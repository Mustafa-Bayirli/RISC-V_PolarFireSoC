// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   common_buffer_0delay.sv
//
//   Purpose:

//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none


module  miv_rv32_common_buffer_behav
//********************************************************************************
// Parameter description

  #(
    parameter BUFF_WIDTH = 32,
    parameter BUFF_SIZE = 2,
    parameter PTR_SIZE = 1
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    input wire                               resetn,
    input wire                               clk,
    
    input wire                               valid_in,
    output wire                              ready_in,
    input wire [BUFF_WIDTH-1:0]              data_in,
    
    output wire [BUFF_WIDTH-1:0]             data_out,
    output wire                              valid_out,    
    input wire                               ready_out
    
 
    
  );

//********************************************************************************
// localparams
  localparam BUFF_MAX = BUFF_SIZE-1;

// Declarations

  reg  [PTR_SIZE-1:0]              buff_wr_ptr;
  reg  [PTR_SIZE-1:0]              buff_rd_ptr;
  wire [PTR_SIZE-1:0]              next_buff_wr_ptr;
  wire [PTR_SIZE-1:0]              next_buff_rd_ptr;
  
  wire [BUFF_SIZE-1:0]             buff_wr_strb;
  wire [BUFF_SIZE-1:0]             buff_rd_strb;
  wire [BUFF_SIZE-1:0]             next_alloc;
  
  reg [BUFF_SIZE-1:0]              buff_valid;
  wire [BUFF_SIZE-1:0]             next_buff_valid;
  reg [BUFF_WIDTH-1:0]             buff_data[BUFF_SIZE-1:0]; 
  
  wire                             rd_data;
  wire                             wr_data;
  
  wire                             full;
  wire                             empty;
  
  reg [(BUFF_SIZE*BUFF_WIDTH)-1:0] data_out_pkd_reg;
  reg [BUFF_SIZE-1:0]              valid_out_pkd_reg;
  
  wire                             next_buff_ready;
  reg                              buff_ready_reg;

  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  assign full     = &buff_valid;
  assign empty    = ~(|buff_valid);
  assign wr_data  = valid_in & buff_ready_reg;
  assign rd_data  = ready_out & valid_out;
  
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_rd_ptr <= {PTR_SIZE{1'b0}};
    else
      if(rd_data)
        buff_rd_ptr <= next_buff_rd_ptr;        
  end 
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_wr_ptr <= {PTR_SIZE{1'b0}};
    else
      if(wr_data)
        buff_wr_ptr <= next_buff_wr_ptr;
  end
  
  assign next_buff_wr_ptr = (buff_wr_ptr == BUFF_MAX) ? {PTR_SIZE{1'b0}} : buff_wr_ptr+1;
  assign next_buff_rd_ptr = (buff_rd_ptr == BUFF_MAX) ? {PTR_SIZE{1'b0}} : buff_rd_ptr+1;
  
  
  
  generate
  genvar gen_buff;
  for(gen_buff = 0; gen_buff<BUFF_SIZE; gen_buff=gen_buff+1)
  begin : gen_buff_loop
  
    assign buff_wr_strb[gen_buff] = wr_data & (buff_wr_ptr == gen_buff[PTR_SIZE-1:0]);
    assign next_alloc[gen_buff] = (buff_wr_ptr == gen_buff[PTR_SIZE-1:0]);
    assign buff_rd_strb[gen_buff] = rd_data & (buff_rd_ptr == gen_buff[PTR_SIZE-1:0]);
  
    // Data not reset
    always @(posedge clk)
    begin    
      begin
        if(buff_wr_strb[gen_buff])
        begin
          buff_data[gen_buff] <= data_in;
        end
      end
    end
  
  
    assign next_buff_valid[gen_buff] = (buff_valid[gen_buff] | buff_wr_strb[gen_buff]) & ~buff_rd_strb[gen_buff];
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        buff_valid[gen_buff]  <=  1'b0;
      else
        buff_valid[gen_buff]  <= next_buff_valid[gen_buff]; 
    end  
    
  end
  endgenerate
  
  assign data_out  = !(|buff_valid) ? data_in : buff_data[buff_rd_ptr];
  assign valid_out = !(|buff_valid) ? valid_in : buff_valid[buff_rd_ptr];
  
  assign next_buff_ready = ~(&next_buff_valid);
  
 
  
  assign ready_in = next_buff_ready;


  
  


endmodule


`default_nettype wire
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   miv_rv32_bcu.sv
//
//   Purpose:
//   Branch Computation Unit for Core
//   Computes all program addresses for branches, trap, reset, and sequential execution
//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module  miv_rv32_bcu
//********************************************************************************
// Parameter description

  #(
    parameter USE_FORMAL = 1,
    parameter USE_SIM = 1
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    
    input wire  logic                         clk,
    input wire  logic                         resetn,
    // controls                
    input wire  t_exu_bcu_operand0_sel        bcu_operand0_mux_sel,             
    input wire  t_exu_bcu_operand1_sel        bcu_operand1_mux_sel,             
    input wire  t_exu_bcu_op_sel              bcu_op_sel,  
//    input wire  logic                         bcu_op_valid,  
    output      logic                         bcu_op_ready,           
      //operands
    input wire  logic [L_XLEN-1:0]            bcu_operand_pc,                 
    input wire  logic                         bcu_operand_pc_valid,  
    input wire  logic [L_XLEN-1:0]            bcu_operand_gpr_rs1,            
    input wire  logic                         bcu_operand_gpr_rs1_valid, 
    input wire  logic [L_XLEN-1:0]            bcu_operand_trap_cause,  
    input wire  logic                         bcu_operand_trap_cause_valid, 
    input wire  logic [L_XLEN-1:0]            bcu_operand_immediate,          
    input wire  logic                         bcu_operand_immediate_valid,     
    input wire  logic [L_XLEN-1:0]            bcu_operand_epc,                
    input wire  logic                         bcu_operand_epc_valid,      
    input wire  logic [L_XLEN-1:0]            bcu_operand_dpc,                
    input wire  logic                         bcu_operand_dpc_valid,    
    input wire  logic [L_XLEN-1:0]            bcu_operand_trap_vec, 
    input wire  logic                         bcu_operand_trap_vec_valid,   
    input wire  logic [L_XLEN-1:0]            bcu_operand_reset_vec, 
    input wire  logic                         bcu_operand_reset_vec_valid,                   
      // result               
    output      logic [L_XLEN-1:0]            bcu_result,
    output      logic                         bcu_result_valid,
    input wire  logic                         bcu_result_ready

  );

//********************************************************************************
// localparams


// Declarations

  logic [L_XLEN-1:0]            bcu_add_result;
  logic [L_XLEN-1:0]            bcu_operand0;      
  logic                         bcu_operand0_valid;
  logic [L_XLEN-1:0]            bcu_operand1;      
  logic                         bcu_operand1_valid;  
  

  
  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  


    // bcu_operand0  
  always @*
  begin
    case(bcu_operand0_mux_sel)
      bcu_operand0_pc :
      begin
        bcu_operand0        = bcu_operand_pc;      
        bcu_operand0_valid  = bcu_operand_pc_valid;
      end
      bcu_operand0_rs1 :
      begin
        bcu_operand0        = bcu_operand_gpr_rs1;      
        bcu_operand0_valid  = bcu_operand_gpr_rs1_valid;
      end
      bcu_operand0_trap_cause :
      begin
        bcu_operand0        = bcu_operand_trap_cause;
        bcu_operand0_valid  = bcu_operand_trap_cause_valid;
      end
      default :
      begin
        bcu_operand0        = {L_XLEN{1'b0}};
        bcu_operand0_valid  = 1'b0;
      end
    endcase
  end
  
    // bcu_operand1
  always @*
  begin
    case(bcu_operand1_mux_sel)
      bcu_operand1_imm :
      begin
        bcu_operand1        = bcu_operand_immediate;      
        bcu_operand1_valid  = bcu_operand_immediate_valid;
      end
      bcu_operand1_epc :
      begin
        bcu_operand1        = bcu_operand_epc;      
        bcu_operand1_valid  = bcu_operand_epc_valid;
      end
      bcu_operand1_dpc :
      begin
        bcu_operand1        = bcu_operand_dpc;      
        bcu_operand1_valid  = bcu_operand_dpc_valid;
      end
      bcu_operand1_exvec :
      begin
        bcu_operand1        = bcu_operand_trap_vec;
        bcu_operand1_valid  = bcu_operand_trap_vec_valid;
      end
      bcu_operand1_resetvec :
      begin
        bcu_operand1        = bcu_operand_reset_vec;
        bcu_operand1_valid  = bcu_operand_reset_vec_valid;
      end
      default :
      begin
        bcu_operand1        = {L_XLEN{1'b0}};
        bcu_operand1_valid  = 1'b0;
      end
    endcase
  end
  

  // BCU

  assign bcu_add_result = (bcu_operand0 + bcu_operand1);
  
  always @*
  begin
    case(bcu_op_sel)
      bcu_op_none :     
      begin
        bcu_result        = bcu_add_result;
        bcu_result_valid  = 1'b0;
      end
      bcu_op_add :
      begin
        bcu_result        = bcu_add_result; //{bcu_add_result[L_XLEN-1:1],1'b0};
        bcu_result_valid  = bcu_operand0_valid & bcu_operand1_valid; // & bcu_op_valid;
      end
      default :
      begin
        bcu_result        = {L_XLEN{1'b0}};
        bcu_result_valid  = 1'b0;
      end
    endcase
  end
  
  // BCU is currently purealy combinational, therefore can accept new operation when result is acceptable
  assign bcu_op_ready = bcu_result_ready;

  



endmodule


`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_hart.sv
//
//   Purpose: core core
//            Contains the main blocks of the core including:
//              - Instruction Fetch Unit
//              - Load Store Unit
//              - Memory Management Unit
//              - Execution Pipeline Unit
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_hart
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH                  = 32,
    parameter D_ADDR_WIDTH                  = 32,
    parameter I_DATA_BYTES                  = 4,
    parameter D_DATA_BYTES                  = 4,
	parameter l_core_cfg_hw_debug           = 0,
    parameter l_core_cfg_num_triggers       = 0,
	parameter l_core_cfg_hw_multiply_divide = 0,
	parameter l_core_cfg_hw_compressed      = 0,
	parameter l_core_cfg_hw_sp_float        = 0,
	parameter l_core_reset_vector           = 32'h6000_0000,
    parameter l_core_static_mtvec_base      = 32'h6000_0034,
    parameter l_core_cfg_static_mtvec_base  = 0,
    parameter l_core_cfg_static_mtvec_mode  = 0,
    parameter l_core_static_mtvec_mode      = 0,
	parameter l_core_num_sys_ext_irqs       = 9,
	parameter l_core_cfg_hw_macc_multiplier = 0,
	parameter l_core_cfg_time_count_width   = 0,
    parameter l_core_cfg_lsu_fwd            = 1'b0,
    parameter l_core_cfg_csr_fwd            = 1'b1,
    parameter l_core_cfg_exu_fwd            = 1'b1,
	parameter l_core_cfg_gpr_type           = 1,
	parameter ECC_ENABLE                    = 0,
	parameter NO_MACC_BLK                   = 0, 
	parameter MI_I_MEM                      = 0,
    parameter l_subsys_cfg_axi_present  = 1,
    parameter l_subsys_cfg_ahb_present  = 0,
    parameter l_subsys_cfg_tcm0_present      = 1,
    parameter l_axi_start_addr         = 32'h6000_0000,
    parameter l_axi_end_addr           = 32'h6000_FFFF,
    parameter l_ahb_start_addr         = 32'h6000_0000,
    parameter l_ahb_end_addr           = 32'h6000_FFFF,
    parameter l_tcm0_start_addr             = 32'h8000_0000,
    parameter l_tcm0_end_addr               = 32'h8000_0FFF
	
   )
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,         
  input  wire logic                                resetn, 
  
  input  wire logic                                core_soft_reset, 
  input  wire logic                                parity_en,   
  output      logic                                gpr_uncorrectable_ecc_error,
  input  wire logic [(L_XLEN*2)-1:0]               time_count, 
  input  wire logic [L_XLEN-1:0]                   hart_id,
  
  
  // Fetch Unit External Memory Interface
 
  output      logic                                ifu_emi_req_valid,
  input wire  logic                                ifu_emi_req_ready,
  output      logic [3:0]                          ifu_emi_req_rd_byte_en, 
  output      logic[I_ADDR_WIDTH-1:0]              ifu_emi_req_addr,  
  output      logic                                ifu_emi_req_addr_p,
  input wire  logic                                ifu_emi_resp_valid,
  output      logic                                ifu_emi_resp_ready,
  input wire  logic [31:0]                         ifu_emi_resp_data,
  input wire  logic [3:0]                          ifu_emi_resp_data_p,
  input wire  logic                                ifu_emi_resp_error,   
  
  output      logic                                icache_flush, 
  output      logic                                ram_init_soft_debug_reset,
  
  
  // Load-Store Unit External Memory Interface

  output      logic                                lsu_emi_req_valid,
  input wire  logic                                lsu_emi_req_ready, 
  output      logic [3:0]                          lsu_emi_req_rd_byte_en,  
  output      logic [3:0]                          lsu_emi_req_wr_byte_en,
  output      logic [31:0]                         lsu_emi_req_addr,
  output      logic                                lsu_emi_req_addr_p,
  output      logic                                lsu_emi_req_fence,
  output      logic                                lsu_emi_req_read,
  output      logic                                lsu_emi_req_write,
  output      logic [31:0]                         lsu_emi_req_wr_data,
  output      logic [3:0]                          lsu_emi_req_wr_data_p,
  input wire  logic                                lsu_emi_resp_valid,
  output      logic                                lsu_emi_resp_ready,
  input wire  logic                                lsu_emi_resp_error,
  input wire  logic [31:0]                         lsu_emi_resp_rd_data,  
  input wire  logic [3:0]                          lsu_emi_resp_rd_data_p,       
  
  // Debug Unit Interface 
  input  wire  logic                               debug_reset,  
  input  wire  logic                               debug_core_reset,
  input  wire  logic                               debug_active,
  input  wire  logic [L_XLEN-1:0]                  debug_csr_gpr_req_wr_data, 
  input  wire  logic                               debug_csr_req_valid,          
  output logic                                     debug_csr_req_ready, 
  input  wire  logic                               debug_csr_req_wr_en, 
  input  wire  logic                               debug_csr_req_rd_en, 
  input  wire logic [11:0]                         debug_csr_req_addr,        
  output logic [L_XLEN-1:0]                        debug_csr_resp_rd_data,   
  output logic                                     debug_csr_resp_valid,
  input  wire  logic                               debug_csr_resp_ready,
  input  wire  logic                               debug_gpr_req_valid,          
  output logic                                     debug_gpr_req_ready, 
  input  wire  logic                               debug_gpr_req_wr_en, 
  input  wire  logic                               debug_gpr_req_rd_en, 
  input  wire logic [5:0]                          debug_gpr_req_addr,     
  output logic [L_XLEN-1:0]                        debug_gpr_resp_rd_data,   
  output logic                                     debug_gpr_resp_valid,
  input  wire  logic                               debug_gpr_resp_ready, 
  input  wire logic                                debug_halt_req,   
  output logic                                     debug_halt_ack, 
  input  wire logic                                debug_resethalt_req,   
  output logic                                     debug_resethalt_ack,  
  input  wire logic                                debug_resume_req,   
  output logic                                     debug_resume_ack,
  output logic                                     debug_mode,
  
  // Interrupt (LIC) Interface     
  
  input wire  logic                                m_sw_irq,
  input wire  logic                                m_timer_irq,
  input wire  logic                                m_external_irq,      
  input wire  logic [9:0]                          sys_ext_irq_src, 
  
  // Direct State Interface
    
  // Formal Trace Interface
  output logic [L_XLEN-1:0]                        formal_trace_instr,
  output logic [L_XLEN-1:0]                        formal_trace_pc,  
  output logic                                     formal_trace_reset_taken, 
  output logic                                     formal_trace_instr_retire,
  
  // Instruction Trace Interface
  output logic                                     trace_valid,
  output logic [L_XLEN-1:0]                        trace_iaddr, 
  output logic [L_XLEN-1:0]                        trace_insn,
  output logic [2:0]							   trace_priv, 
  output logic									   trace_exception,
  output logic									   trace_interrupt,
  output logic [5:0]                               trace_cause,
  output logic [L_XLEN-1:0]                        trace_tval,
  
  
  input wire logic                                 icache_ram_init_done,
  output logic                                     gpr_ram_init_done,
  input wire logic [1:0]                           gpr_ecc_error_injection

  );
   


  
//******************************************************************************
// Declarations
  logic                                ifu_expipe_fetch_en_net;
  logic                                ifu_expipe_req_branch_excpt_req_valid_net;
  logic                                ifu_expipe_req_branch_excpt_req_fenci_net;
  logic                                ifu_expipe_req_fenci_proceed_net;         
  logic                                ifu_expipe_req_branch_excpt_req_ready_net;          
  logic                                ifu_expipe_req_branch_excpt_taken_net;
  logic [I_ADDR_WIDTH-1:0]             ifu_expipe_req_branch_excpt_vaddr_net; 
  logic [1:0]                          ifu_expipe_req_priv_net; 
  logic                                ifu_expipe_req_flush_net;
  logic                                ifu_expipe_resp_valid_net;
  logic                                ifu_expipe_resp_ready_net;
  logic [31:0]                         ifu_expipe_resp_ireg_net;
  logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_ireg_vaddr_net;
  logic                                ifu_expipe_resp_ireg_vaddr_valid_net;
  logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_next_vaddr_net;
  logic                                ifu_expipe_resp_compressed_net;
  logic                                ifu_expipe_resp_access_fault_net;  
  logic                                ifu_expipe_resp_access_mem_error_net;
  logic                                ifu_expipe_resp_access_parity_error_net;
  logic                                ifu_expipe_resp_access_misalign_error_net;
  logic                                ifu_expipe_resp_access_aborted_net;  
  
  logic                                lsu_flush_net;
  logic                                lsu_op_os_net;
  logic                                lsu_load_os_net;
  logic                                lsu_fence_os_net;
  logic                                lsu_expipe_req_valid_net;  
  logic                                lsu_expipe_req_ready_net;  
  logic[D_ADDR_WIDTH-1:0]              lsu_expipe_req_addr_net;
  logic                                lsu_expipe_req_addr_valid_net; 
  logic [31:0]                         lsu_expipe_req_wr_data_net;
  logic                                lsu_expipe_req_wr_data_valid_net;  
  t_lsu_op                             lsu_expipe_req_op_net;   
  logic                                lsu_expipe_resp_valid_net;
  logic                                lsu_expipe_resp_ready_net;       
  logic [31:0]                         lsu_expipe_resp_rd_data_net;
  logic                                lsu_expipe_resp_ld_addr_misalign_net;
  logic                                lsu_expipe_resp_ld_access_fault_net;
  logic                                lsu_expipe_resp_str_amo_addr_misalign_net;
  logic                                lsu_expipe_resp_str_amo_access_fault_net;
  logic                                lsu_expipe_resp_access_mem_error_net;
  logic                                lsu_expipe_resp_access_parity_error_net;
  logic                                lsu_expipe_resp_access_aborted_net;
 
  logic                                ifu_emi_req_valid_int;
  logic                                i_flush;
  //gpr ram init done signal to hold cpu in soft reset while init takes place
  //logic                                gpr_ram_init_done;
  
  logic								   trace_priv_net;
  logic	[4:0]						   trace_cause_net;
  
// Assignments
  assign ifu_emi_req_valid = ifu_emi_req_valid_int;
  assign icache_flush      = i_flush;
  
  assign trace_priv = {trace_priv_net, !trace_priv_net, !trace_priv_net};
  assign trace_cause = {1'b0, trace_cause_net};
  
//******************************************************************************
// Main code

  //--------------------------------------------------------
  // Instruction Fetch Unit
  //--------------------------------------------------------
  
   miv_rv32_fetch_unit
   #(
      .I_ADDR_WIDTH                     (I_ADDR_WIDTH                        ),
      .l_core_reset_vector              (l_core_reset_vector                 ),
	  .MI_I_MEM                         (MI_I_MEM                            )
    )
    u_fetch_unit_0
    (
      .clk                                   (clk                                      ),
      .resetn                                (resetn                                   ),
      .parity_en                             (parity_en                                ),
      .ifu_emi_req_valid                     (ifu_emi_req_valid_int                    ),
      .ifu_emi_req_ready                     (ifu_emi_req_ready                        ),
      .ifu_emi_req_rd_byte_en                (ifu_emi_req_rd_byte_en                   ),
      .ifu_emi_req_addr                      (ifu_emi_req_addr                         ),
      .ifu_emi_req_addr_p                    (ifu_emi_req_addr_p                       ),
      .ifu_emi_resp_valid                    (ifu_emi_resp_valid                       ),
      .ifu_emi_resp_ready                    (ifu_emi_resp_ready                       ),
      .ifu_emi_resp_data                     (ifu_emi_resp_data                        ),     
      .ifu_emi_resp_data_p                   (ifu_emi_resp_data_p                      ),
      .ifu_emi_resp_error                    (ifu_emi_resp_error                       ),
      
      .ifu_expipe_fetch_en                   (ifu_expipe_fetch_en_net                  ),
      .ifu_expipe_req_branch_excpt_req_valid (ifu_expipe_req_branch_excpt_req_valid_net),
      .ifu_expipe_req_branch_excpt_req_fenci (ifu_expipe_req_branch_excpt_req_fenci_net),
      .ifu_expipe_req_fenci_proceed          (ifu_expipe_req_fenci_proceed_net         ),
      .ifu_expipe_req_branch_excpt_req_ready (ifu_expipe_req_branch_excpt_req_ready_net),
      .ifu_expipe_req_branch_excpt_vaddr     (ifu_expipe_req_branch_excpt_vaddr_net    ),
      .ifu_expipe_req_priv                   (ifu_expipe_req_priv_net                  ),
      .ifu_expipe_req_flush                  (ifu_expipe_req_flush_net                 ),
      .ifu_expipe_resp_valid                 (ifu_expipe_resp_valid_net                ),
      .ifu_expipe_resp_ready                 (ifu_expipe_resp_ready_net                ), 
      .ifu_expipe_resp_ireg                  (ifu_expipe_resp_ireg_net                 ),
      .ifu_expipe_resp_ireg_vaddr            (ifu_expipe_resp_ireg_vaddr_net           ),
      .ifu_expipe_resp_ireg_vaddr_valid      (ifu_expipe_resp_ireg_vaddr_valid_net     ),
      .ifu_expipe_resp_next_vaddr            (ifu_expipe_resp_next_vaddr_net           ),
      .ifu_expipe_resp_compressed            (ifu_expipe_resp_compressed_net           ),
      .ifu_expipe_resp_access_fault          (ifu_expipe_resp_access_fault_net         ),
      .ifu_expipe_resp_access_mem_error      (ifu_expipe_resp_access_mem_error_net     ),
      .ifu_expipe_resp_access_parity_error   (ifu_expipe_resp_access_parity_error_net  ),
      .ifu_expipe_resp_access_misalign_error (ifu_expipe_resp_access_misalign_error_net),
      .ifu_expipe_resp_access_aborted        (ifu_expipe_resp_access_aborted_net       )
    );

 
  
//////////////////////////////////////////////////////////////////////////////////////////////
  //--------------------------------------------------------
  // Load-Store Unit
  //--------------------------------------------------------
  
  miv_rv32_lsu
   #(                                               
      .D_ADDR_WIDTH                                 (I_ADDR_WIDTH                             ) 
    )
    u_lsu_0
    (                                               
      .clk                                          (clk                                      ),
      .resetn                                       (resetn                                   ),
      .parity_en                                    (parity_en                                ),
      .lsu_flush                                    (lsu_flush_net                            ),
      .lsu_op_os                                    (lsu_op_os_net                            ),
      .lsu_ld_op_os                                 (lsu_load_os_net                          ),
      .lsu_fence_op_os                              (lsu_fence_os_net                         ),
      .lsu_emi_req_valid                            (lsu_emi_req_valid                        ),
      .lsu_emi_req_ready                            (lsu_emi_req_ready                        ),
      .lsu_emi_req_rd_byte_en                       (lsu_emi_req_rd_byte_en                   ),
      .lsu_emi_req_wr_byte_en                       (lsu_emi_req_wr_byte_en                   ),
      .lsu_emi_req_addr                             (lsu_emi_req_addr                         ),   
      .lsu_emi_req_addr_p                           (lsu_emi_req_addr_p                       ),
      .lsu_emi_req_fence                            (lsu_emi_req_fence                        ),
      .lsu_emi_req_read                             (lsu_emi_req_read                         ),
      .lsu_emi_req_write                            (lsu_emi_req_write                        ),
      .lsu_emi_req_wr_data                          (lsu_emi_req_wr_data                      ),
      .lsu_emi_req_wr_data_p                        (lsu_emi_req_wr_data_p                    ),
      .lsu_emi_resp_valid                           (lsu_emi_resp_valid                       ),
      .lsu_emi_resp_ready                           (lsu_emi_resp_ready                       ),
      .lsu_emi_resp_error                           (lsu_emi_resp_error                       ),
      .lsu_emi_resp_rd_data                         (lsu_emi_resp_rd_data                     ),     
      .lsu_emi_resp_rd_data_p                       (lsu_emi_resp_rd_data_p                   ),
      .lsu_expipe_req_valid                         (lsu_expipe_req_valid_net                 ),
      .lsu_expipe_req_ready                         (lsu_expipe_req_ready_net                 ),
      .lsu_expipe_req_addr                          (lsu_expipe_req_addr_net                  ),
      .lsu_expipe_req_addr_valid                    (lsu_expipe_req_addr_valid_net            ),
      .lsu_expipe_req_wr_data                       (lsu_expipe_req_wr_data_net               ),
      .lsu_expipe_req_wr_data_valid                 (lsu_expipe_req_wr_data_valid_net         ),
      .lsu_expipe_req_op                            (lsu_expipe_req_op_net                    ),
      .lsu_expipe_resp_valid                        (lsu_expipe_resp_valid_net                ),
      .lsu_expipe_resp_ready                        (lsu_expipe_resp_ready_net                ),
      .lsu_expipe_resp_rd_data                      (lsu_expipe_resp_rd_data_net              ),
      .lsu_expipe_resp_ld_addr_misalign             (lsu_expipe_resp_ld_addr_misalign_net     ),
      .lsu_expipe_resp_ld_access_fault              (lsu_expipe_resp_ld_access_fault_net      ),
      .lsu_expipe_resp_str_amo_addr_misalign        (lsu_expipe_resp_str_amo_addr_misalign_net),
      .lsu_expipe_resp_str_amo_access_fault         (lsu_expipe_resp_str_amo_access_fault_net ),
      .lsu_expipe_resp_access_mem_error             (lsu_expipe_resp_access_mem_error_net     ),
      .lsu_expipe_resp_access_parity_error          (lsu_expipe_resp_access_parity_error_net  ),
      .lsu_expipe_resp_access_aborted               (lsu_expipe_resp_access_aborted_net       )
   );      

  
  //--------------------------------------------------------
  // Execution Pipeline Unit
  //--------------------------------------------------------
  
  miv_rv32_expipe
   #(
      .I_ADDR_WIDTH                     (I_ADDR_WIDTH                        ),
      .D_ADDR_WIDTH                     (D_ADDR_WIDTH                        ),
      .I_DATA_BYTES                     (I_DATA_BYTES                        ),
      .D_DATA_BYTES                     (D_DATA_BYTES                        ),
      .l_core_cfg_hw_debug              (l_core_cfg_hw_debug                 ),
      .l_core_cfg_num_triggers          (l_core_cfg_num_triggers             ),
      .l_core_cfg_hw_macc_multiplier    (l_core_cfg_hw_macc_multiplier       ),
      .l_core_cfg_hw_multiply_divide    (l_core_cfg_hw_multiply_divide       ),
      .l_core_cfg_hw_compressed         (l_core_cfg_hw_compressed            ),
	  .l_core_cfg_hw_sp_float           (l_core_cfg_hw_sp_float              ),
      .l_core_reset_vector              (l_core_reset_vector                 ),
      .l_core_static_mtvec_base         (l_core_static_mtvec_base            ),
      .l_core_cfg_static_mtvec_base     (l_core_cfg_static_mtvec_base        ),
      .l_core_cfg_static_mtvec_mode     (l_core_cfg_static_mtvec_mode        ),
      .l_core_static_mtvec_mode         (l_core_static_mtvec_mode            ),
	  .l_core_num_sys_ext_irqs          (l_core_num_sys_ext_irqs             ),
	  .l_core_cfg_time_count_width      (l_core_cfg_time_count_width         ),
      .l_core_cfg_lsu_fwd               (l_core_cfg_lsu_fwd                  ),
      .l_core_cfg_csr_fwd               (l_core_cfg_csr_fwd                  ),
      .l_core_cfg_exu_fwd               (l_core_cfg_exu_fwd                  ),
	  .l_core_cfg_gpr_type              (l_core_cfg_gpr_type                 ),
	  .ECC_ENABLE                       (ECC_ENABLE                          ),
	  .NO_MACC_BLK                      (NO_MACC_BLK                         ),
      .l_subsys_cfg_axi_present          (l_subsys_cfg_axi_present             ),
      .l_subsys_cfg_ahb_present          (l_subsys_cfg_ahb_present             ),
      .l_subsys_cfg_tcm0_present         (l_subsys_cfg_tcm0_present            ),
      .l_axi_start_addr                 (l_axi_start_addr                    ),
      .l_axi_end_addr                   (l_axi_end_addr                      ),
      .l_ahb_start_addr                 (l_ahb_start_addr                    ),
      .l_ahb_end_addr                   (l_ahb_end_addr                      ),
      .l_tcm0_start_addr                (l_tcm0_start_addr                   ),
      .l_tcm0_end_addr                  (l_tcm0_end_addr                     )
    )
    u_expipe_0
    (
      .clk                                   (clk                                      ),
      .resetn                                (resetn                                   ),
      .core_soft_reset                       (core_soft_reset                          ),
      .gpr_uncorrectable_ecc_error           (gpr_uncorrectable_ecc_error              ),
      .time_count                            (time_count                               ),
      .hart_id                               (hart_id                                  ),
      .ifu_expipe_fetch_en                   (ifu_expipe_fetch_en_net                  ),
      .ifu_expipe_req_branch_excpt_req_valid (ifu_expipe_req_branch_excpt_req_valid_net),
      .ifu_expipe_req_branch_excpt_req_fenci (ifu_expipe_req_branch_excpt_req_fenci_net),
      .ifu_expipe_req_fenci_proceed          (ifu_expipe_req_fenci_proceed_net         ),
      .ifu_expipe_req_branch_excpt_req_ready (ifu_expipe_req_branch_excpt_req_ready_net),
      .ifu_expipe_req_branch_excpt_vaddr     (ifu_expipe_req_branch_excpt_vaddr_net    ),
      .ifu_expipe_req_priv                   (ifu_expipe_req_priv_net                  ),
      .ifu_expipe_req_flush                  (ifu_expipe_req_flush_net                 ),
      .ifu_expipe_resp_valid                 (ifu_expipe_resp_valid_net                ),
      .ifu_expipe_resp_ready                 (ifu_expipe_resp_ready_net                ),
      .ifu_expipe_resp_ireg                  (ifu_expipe_resp_ireg_net                 ),
      .ifu_expipe_resp_ireg_vaddr            (ifu_expipe_resp_ireg_vaddr_net           ),      
      .ifu_expipe_resp_ireg_vaddr_valid      (ifu_expipe_resp_ireg_vaddr_valid_net     ),
      .ifu_expipe_resp_next_vaddr            (ifu_expipe_resp_next_vaddr_net           ),
      .ifu_expipe_resp_compressed            (ifu_expipe_resp_compressed_net           ),
      .ifu_expipe_resp_access_fault          (ifu_expipe_resp_access_fault_net         ),
      .ifu_expipe_resp_access_mem_error      (ifu_expipe_resp_access_mem_error_net     ),
      .ifu_expipe_resp_access_parity_error   (ifu_expipe_resp_access_parity_error_net  ),
      .ifu_expipe_resp_access_misalign_error (ifu_expipe_resp_access_misalign_error_net),
      .ifu_expipe_resp_access_aborted        (ifu_expipe_resp_access_aborted_net       ),
      .lsu_flush                             (lsu_flush_net                            ),
      .lsu_op_os                             (lsu_op_os_net                            ),
      .lsu_ld_op_os                          (lsu_load_os_net                          ),
      .lsu_fence_op_os                       (lsu_fence_os_net                         ),
      .lsu_req_valid                         (lsu_expipe_req_valid_net                 ),
      .lsu_req_ready                         (lsu_expipe_req_ready_net                 ),
      .lsu_req_addr                          (lsu_expipe_req_addr_net                  ),
      .lsu_req_addr_valid                    (lsu_expipe_req_addr_valid_net            ),
      .lsu_req_wr_data                       (lsu_expipe_req_wr_data_net               ),
      .lsu_req_wr_data_valid                 (lsu_expipe_req_wr_data_valid_net         ),
      .lsu_req_op                            (lsu_expipe_req_op_net                    ),
      .lsu_resp_valid                        (lsu_expipe_resp_valid_net                ),
      .lsu_resp_ready                        (lsu_expipe_resp_ready_net                ),
      .lsu_resp_rd_data                      (lsu_expipe_resp_rd_data_net              ),
      .lsu_resp_ld_addr_misalign             (lsu_expipe_resp_ld_addr_misalign_net     ),
      .lsu_resp_ld_access_fault              (lsu_expipe_resp_ld_access_fault_net      ),
      .lsu_resp_str_amo_addr_misalign        (lsu_expipe_resp_str_amo_addr_misalign_net),
      .lsu_resp_str_amo_access_fault         (lsu_expipe_resp_str_amo_access_fault_net ),
      .lsu_resp_access_mem_error             (lsu_expipe_resp_access_mem_error_net     ),
      .lsu_resp_access_parity_error          (lsu_expipe_resp_access_parity_error_net  ),
      .lsu_resp_access_aborted               (lsu_expipe_resp_access_aborted_net       ),
      .debug_reset                           (debug_reset                              ),
      .debug_core_reset                      (debug_core_reset                         ),
      .debug_active                          (debug_active                             ),
      .debug_csr_gpr_req_wr_data             (debug_csr_gpr_req_wr_data                ), 
      .debug_csr_req_valid                   (debug_csr_req_valid                      ), 
      .debug_csr_req_ready                   (debug_csr_req_ready                      ), 
      .debug_csr_req_wr_en                   (debug_csr_req_wr_en                      ), 
      .debug_csr_req_rd_en                   (debug_csr_req_rd_en                      ), 
      .debug_csr_req_addr                    (debug_csr_req_addr                       ), 
      .debug_csr_resp_rd_data                (debug_csr_resp_rd_data                   ), 
      .debug_csr_resp_ready                  (debug_csr_resp_ready                     ), 
      .debug_csr_resp_valid                  (debug_csr_resp_valid                     ), 
      .debug_gpr_req_valid                   (debug_gpr_req_valid                      ), 
      .debug_gpr_req_ready                   (debug_gpr_req_ready                      ), 
      .debug_gpr_req_wr_en                   (debug_gpr_req_wr_en                      ), 
      .debug_gpr_req_rd_en                   (debug_gpr_req_rd_en                      ), 
      .debug_gpr_req_addr                    (debug_gpr_req_addr                       ), 
      .debug_gpr_resp_rd_data                (debug_gpr_resp_rd_data                   ), 
      .debug_gpr_resp_ready                  (debug_gpr_resp_ready                     ), 
      .debug_gpr_resp_valid                  (debug_gpr_resp_valid                     ), 
      .debug_halt_req                        (debug_halt_req                           ), 
      .debug_halt_ack                        (debug_halt_ack                           ), 
      .debug_resethalt_req                   (debug_resethalt_req                      ), 
      .debug_resethalt_ack                   (debug_resethalt_ack                      ), 
      .debug_resume_req                      (debug_resume_req                         ),
      .debug_resume_ack                      (debug_resume_ack                         ),
      .debug_mode                            (debug_mode                               ),
      .m_sw_irq                              (m_sw_irq                                 ),
      .m_timer_irq                           (m_timer_irq                              ),
      .m_external_irq                        (m_external_irq                           ),
      .sys_ext_irq_src                       (sys_ext_irq_src                          ),
	  .gpr_ram_init_done                     (gpr_ram_init_done                        ),
	  
	  .formal_trace_instr                    (formal_trace_instr                       ),
      .formal_trace_pc                       (formal_trace_pc                          ),
      .formal_trace_reset_taken              (formal_trace_reset_taken                 ),
      .formal_trace_instr_retire             (formal_trace_instr_retire                ),
	  
	  .trace_valid					         (trace_valid					           ),
      .trace_iaddr                           (trace_iaddr                              ),
	  .trace_insn                            (trace_insn                               ),
      .trace_priv                            (trace_priv_net                           ),
	  .trace_exception                       (trace_exception                          ),
      .trace_interrupt                       (trace_interrupt                          ),
	  .trace_cause					         (trace_cause_net                          ),
	  .trace_tval					         (trace_tval                               ),
	  
	  
	  .i_flush                               (i_flush                                  ),
	  .ram_init_soft_debug_reset             (ram_init_soft_debug_reset                ),
      .icache_ram_init_done                  (icache_ram_init_done                     ),
      .gpr_ecc_error_injection               (gpr_ecc_error_injection                  )	  
    );
      
      
      
 

     

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

`endif

 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_csr_decode.sv
//
//   Purpose:   decoder for csr registers
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module  miv_rv32_csr_decode
//********************************************************************************
// Parameter description
  #(
      parameter CHECK_ILLEGAL          = 0,
	  parameter l_core_cfg_hw_debug    = 0,
	  parameter l_core_cfg_hw_sp_float = 0
  )

//********************************************************************************
// Port description

  (
    //inputs
    input wire logic                clk,
    input wire logic                resetn,
    
    input wire logic                debug_mode,
    input wire logic [11:0]         csr_rd_addr,
    input wire logic                csr_rd_en_valid,   
    input wire logic [11:0]         csr_wr_addr,
    input wire logic                csr_wr_en_valid,
    
    output t_csr_reg_rd_sel         csr_reg_rd_sel,
    output t_csr_reg_wr_sel         csr_reg_wr_sel,
    output logic                    csr_rd_illegal,  
    output logic                    csr_wr_illegal
    
  );
    

                        

//********************************************************************************
// localparams
  

// Declarations



  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  assign csr_reg_rd_sel.mvendorid_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mvendorid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mvendorid_sw_wr_sel = 1'b0;  // read only
  
  assign csr_reg_rd_sel.marchid_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_marchid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.marchid_sw_wr_sel   = 1'b0;  // read only 

  assign csr_reg_rd_sel.mimpid_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_mimpid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mimpid_sw_wr_sel    = 1'b0;  // read only 
  
  assign csr_reg_rd_sel.mhartid_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mhartid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mhartid_sw_wr_sel   = 1'b0;  // read only
    
  // term does not need to check privilege as core only supports machine mode                      
  assign csr_reg_rd_sel.mstatus_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mstatus) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.sstatus_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_sstatus) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.ustatus_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_ustatus) && csr_rd_en_valid;                          
  assign csr_reg_wr_sel.mstatus_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_mstatus) && csr_wr_en_valid; 
  assign csr_reg_wr_sel.sstatus_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_sstatus) && csr_wr_en_valid;  
  assign csr_reg_wr_sel.ustatus_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_ustatus) && csr_wr_en_valid;  
  
  assign csr_reg_rd_sel.misa_sw_rd_sel      = (csr_rd_addr == l_core_csr_addr_misa) && csr_rd_en_valid;
  assign csr_reg_wr_sel.misa_sw_wr_sel      = (csr_wr_addr == l_core_csr_addr_misa) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.medeleg_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_medeleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.medeleg_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_medeleg) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.mideleg_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mideleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.mideleg_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_mideleg) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.mie_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_mie) && csr_rd_en_valid;  
  assign csr_reg_rd_sel.sie_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_sie) && csr_rd_en_valid;  
  assign csr_reg_rd_sel.uie_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_uie) && csr_rd_en_valid;                     
  assign csr_reg_wr_sel.mie_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_mie) && csr_wr_en_valid;
  assign csr_reg_wr_sel.sie_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_sie) && csr_wr_en_valid;
  assign csr_reg_wr_sel.uie_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_uie) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.mip_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_mip) && csr_rd_en_valid;
  assign csr_reg_rd_sel.sip_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_sip) && csr_rd_en_valid;
  assign csr_reg_rd_sel.uip_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_uip) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.ip_sw_rd_sel     = csr_reg_rd_sel.mip_sw_rd_sel | csr_reg_rd_sel.sip_sw_rd_sel | csr_reg_rd_sel.uip_sw_rd_sel;                           
  assign csr_reg_wr_sel.mip_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_mip) && csr_wr_en_valid;
  assign csr_reg_wr_sel.sip_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_sip) && csr_wr_en_valid;
  assign csr_reg_wr_sel.uip_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_uip) && csr_wr_en_valid;  
  assign csr_reg_wr_sel.ip_sw_wr_sel     = 1'b0; 
  
  assign csr_reg_rd_sel.mtvec_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_mtvec) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mtvec_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_mtvec) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mepc_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mepc) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mepc_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_mepc) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mcause_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcause) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mcause_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcause) && csr_wr_en_valid ; 
  
  assign csr_reg_rd_sel.mtval_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_mtval) && csr_rd_en_valid;
  assign csr_reg_wr_sel.mtval_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_mtval) && csr_wr_en_valid;  
  
  assign csr_reg_rd_sel.mcounteren_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcounteren) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mcounteren_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcounteren) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mcounterinhibit_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcounterinhibit) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mcounterinhibit_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcounterinhibit) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mscratch_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mscratch) && csr_rd_en_valid;
  assign csr_reg_wr_sel.mscratch_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mscratch) && csr_wr_en_valid; 
  
  assign csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel = ({csr_rd_addr[11:2],2'b00} == (l_core_csr_addr_pmpcfg0 & 12'hFFC)) && csr_rd_en_valid;
  assign csr_reg_wr_sel.pmpcfg_0_3_sw_wr_sel = ({csr_wr_addr[11:2],2'b00} == (l_core_csr_addr_pmpcfg0 & 12'hFFC)) && csr_wr_en_valid;
  assign csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel = ({csr_rd_addr[11:4],4'b0000} == (l_core_csr_addr_pmpaddr0 & 12'hFF0)) && csr_rd_en_valid;
  assign csr_reg_wr_sel.pmpaddr_0_15_sw_wr_sel = ({csr_wr_addr[11:4],4'b0000} == (l_core_csr_addr_pmpaddr0 & 12'hFF0)) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.sedeleg_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_sedeleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sedeleg_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_sedeleg) && csr_wr_en_valid;
  assign csr_reg_rd_sel.sideleg_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_sideleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sideleg_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_sideleg) && csr_wr_en_valid;
  assign csr_reg_rd_sel.stvec_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_stvec) && csr_rd_en_valid;
  assign csr_reg_wr_sel.stvec_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_stvec) && csr_wr_en_valid;
  assign csr_reg_rd_sel.sepc_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_sepc) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sepc_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_sepc) && csr_wr_en_valid;
  assign csr_reg_rd_sel.scause_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_scause) && csr_rd_en_valid;
  assign csr_reg_wr_sel.scause_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_scause) && csr_wr_en_valid;
  assign csr_reg_rd_sel.stval_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_stval) && csr_rd_en_valid;
  assign csr_reg_wr_sel.stval_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_stval) && csr_wr_en_valid;
  assign csr_reg_rd_sel.scounteren_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_scounteren) && csr_rd_en_valid;
  assign csr_reg_wr_sel.scounteren_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_scounteren) && csr_wr_en_valid;
  assign csr_reg_rd_sel.sscratch_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_sscratch) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sscratch_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_sscratch) && csr_wr_en_valid;
  assign csr_reg_rd_sel.satp_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_satp) && csr_rd_en_valid;
  assign csr_reg_wr_sel.satp_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_satp) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.utvec_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_utvec) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utvec_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_utvec) && csr_wr_en_valid;
  assign csr_reg_rd_sel.uepc_sw_rd_sel     = (csr_rd_addr == l_core_csr_addr_uepc) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uepc_sw_wr_sel     = (csr_wr_addr == l_core_csr_addr_uepc) && csr_wr_en_valid;
  assign csr_reg_rd_sel.ucause_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_ucause) && csr_rd_en_valid;
  assign csr_reg_wr_sel.ucause_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_ucause) && csr_wr_en_valid;
  assign csr_reg_rd_sel.utval_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_utval) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utval_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_utval) && csr_wr_en_valid;
  assign csr_reg_rd_sel.uscratch_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_uscratch) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uscratch_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_uscratch) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.ucycle_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_cycle) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.mcycle_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_mcycle) && csr_rd_en_valid;
  assign csr_reg_wr_sel.ucycle_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_cycle) && csr_wr_en_valid;  // illegal
  assign csr_reg_wr_sel.mcycle_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_mcycle) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.ucycleh_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_cycleh) && csr_rd_en_valid;
  assign csr_reg_rd_sel.mcycleh_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcycleh) && csr_rd_en_valid;
  assign csr_reg_wr_sel.ucycleh_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_cycleh) && csr_wr_en_valid; // illegal
  assign csr_reg_wr_sel.mcycleh_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcycleh) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.utime_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_time) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utime_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_time) && csr_wr_en_valid; 
  assign csr_reg_rd_sel.utimeh_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_timeh) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utimeh_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_timeh) && csr_wr_en_valid;  
  
  assign csr_reg_rd_sel.uinstret_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_instret) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.minstret_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_minstret) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uinstret_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_instret) && csr_wr_en_valid;  // illegal
  assign csr_reg_wr_sel.minstret_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_minstret) && csr_wr_en_valid; 
  assign csr_reg_rd_sel.uinstreth_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_instreth) && csr_rd_en_valid;
  assign csr_reg_rd_sel.minstreth_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_minstreth) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uinstreth_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_instreth) && csr_wr_en_valid; // illegal
  assign csr_reg_wr_sel.minstreth_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_minstreth) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.hpmcounter_3_31_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounter3 & 12'hFE0)) && 
                                                      (csr_rd_addr != l_core_csr_addr_cycle) &&
                                                      (csr_rd_addr != l_core_csr_addr_time) &&
                                                      (csr_rd_addr != l_core_csr_addr_instret) &&
                                                      csr_rd_en_valid;
  assign csr_reg_wr_sel.hpmcounter_3_31_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounter3 & 12'hFE0)) && 
                                                     (csr_wr_addr != l_core_csr_addr_cycle) &&
                                                     (csr_wr_addr != l_core_csr_addr_time) &&
                                                     (csr_wr_addr != l_core_csr_addr_instret) && 
                                                     csr_wr_en_valid;
  assign csr_reg_rd_sel.hpmcounter_3_31h_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounterh3 & 12'hFE0)) && 
                                                       (csr_rd_addr != l_core_csr_addr_cycleh) &&
                                                       (csr_rd_addr != l_core_csr_addr_timeh) &&
                                                       (csr_rd_addr != l_core_csr_addr_instreth) &&
                                                       csr_rd_en_valid;
  assign csr_reg_wr_sel.hpmcounter_3_31h_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounterh3 & 12'hFE0)) && 
                                                      (csr_wr_addr != l_core_csr_addr_cycleh) &&
                                                      (csr_wr_addr != l_core_csr_addr_timeh) &&
                                                      (csr_wr_addr != l_core_csr_addr_instreth) && 
                                                      csr_wr_en_valid;     
  assign csr_reg_rd_sel.mhpmcounter_3_31_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounter3 & 12'hFE0)) && 
                                                      (csr_rd_addr != 12'hB00) &&
                                                      (csr_rd_addr != 12'hB01) &&
                                                      (csr_rd_addr != 12'hB02) &&
                                                      csr_rd_en_valid;
  assign csr_reg_wr_sel.mhpmcounter_3_31_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounter3 & 12'hFE0)) && 
                                                      (csr_wr_addr != 12'hB00) &&
                                                      (csr_wr_addr != 12'hB01) &&
                                                      (csr_wr_addr != 12'hB02) && 
                                                      csr_wr_en_valid;                                    
  assign csr_reg_rd_sel.mhpmcounter_3_31h_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounterh3 & 12'hFE0)) && 
                                                       (csr_rd_addr != 12'hB80) &&
                                                       (csr_rd_addr != 12'hB81) &&
                                                       (csr_rd_addr != 12'hB82) &&
                                                       csr_rd_en_valid;
  assign csr_reg_wr_sel.mhpmcounter_3_31h_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounterh3 & 12'hFE0)) && 
                                                       (csr_wr_addr != 12'hB80) &&
                                                       (csr_wr_addr != 12'hB81) &&
                                                       (csr_wr_addr != 12'hB82) && 
                                                       csr_wr_en_valid;     

  assign csr_reg_rd_sel.hpmevent_3_31_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmevent3 & 12'hFE0)) && 
                                                   (csr_rd_addr != 12'h320) &&
                                                   (csr_rd_addr != 12'h321) &&
                                                   (csr_rd_addr != 12'h322) &&
                                                   csr_rd_en_valid;
  assign csr_reg_wr_sel.hpmevent_3_31_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmevent3 & 12'hFE0)) && 
                                                   (csr_wr_addr != 12'h320) &&
                                                   (csr_wr_addr != 12'h321) &&
                                                   (csr_wr_addr != 12'h322) &&
                                                   csr_wr_en_valid;  
                                                   
                                                   

  assign csr_reg_rd_sel.tselect_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_tselect) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tselect_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_tselect) && csr_wr_en_valid;
  assign csr_reg_rd_sel.tdata1_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_tdata1) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tdata1_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_tdata1) && csr_wr_en_valid;
  assign csr_reg_rd_sel.tdata2_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_tdata2) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tdata2_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_tdata2) && csr_wr_en_valid;      
  assign csr_reg_rd_sel.tdata3_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_tdata3) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tdata3_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_tdata3) && csr_wr_en_valid;  

  generate if(l_core_cfg_hw_debug != 0) 
  begin : gen_debug  
    assign csr_reg_rd_sel.dcsr_debugger_rd_sel       = (csr_rd_addr == l_core_csr_addr_dcsr) & csr_rd_en_valid & debug_mode; 
    assign csr_reg_wr_sel.dcsr_debugger_wr_sel       = (csr_wr_addr == l_core_csr_addr_dcsr) & csr_wr_en_valid & debug_mode; 
    assign csr_reg_rd_sel.dpc_debugger_rd_sel        = (csr_rd_addr == l_core_csr_addr_dpc)  & csr_rd_en_valid & debug_mode;
    assign csr_reg_wr_sel.dpc_debugger_wr_sel        = (csr_wr_addr == l_core_csr_addr_dpc)  & csr_wr_en_valid & debug_mode;
    assign csr_reg_rd_sel.dscratch0_debugger_rd_sel  = (csr_rd_addr == l_core_csr_addr_dscratch0) & csr_rd_en_valid & debug_mode;
    assign csr_reg_wr_sel.dscratch0_debugger_wr_sel  = (csr_wr_addr == l_core_csr_addr_dscratch0) & csr_wr_en_valid & debug_mode;
    assign csr_reg_rd_sel.dscratch1_debugger_rd_sel  = (csr_rd_addr == l_core_csr_addr_dscratch1) & csr_rd_en_valid & debug_mode; 
    assign csr_reg_wr_sel.dscratch1_debugger_wr_sel  = (csr_wr_addr == l_core_csr_addr_dscratch1) & csr_wr_en_valid & debug_mode; 
  end else begin : ngen_debug           
    assign csr_reg_rd_sel.dcsr_debugger_rd_sel       = 1'b0;
    assign csr_reg_wr_sel.dcsr_debugger_wr_sel       = 1'b0;
    assign csr_reg_rd_sel.dpc_debugger_rd_sel        = 1'b0;
    assign csr_reg_wr_sel.dpc_debugger_wr_sel        = 1'b0;
    assign csr_reg_rd_sel.dscratch0_debugger_rd_sel  = 1'b0;
    assign csr_reg_wr_sel.dscratch0_debugger_wr_sel  = 1'b0;
    assign csr_reg_rd_sel.dscratch1_debugger_rd_sel  = 1'b0;
    assign csr_reg_wr_sel.dscratch1_debugger_wr_sel  = 1'b0; 
  end 
  endgenerate    
  
  generate if(l_core_cfg_hw_sp_float != 0) 
  begin : gen_float  
    assign csr_reg_rd_sel.fflags_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_fflags) & csr_rd_en_valid; 
    assign csr_reg_wr_sel.fflags_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_fflags) & csr_wr_en_valid; 
    assign csr_reg_rd_sel.frm_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_frm) & csr_rd_en_valid; 
    assign csr_reg_wr_sel.frm_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_frm) & csr_wr_en_valid; 
    assign csr_reg_rd_sel.fcsr_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_fcsr) & csr_rd_en_valid; 
    assign csr_reg_wr_sel.fcsr_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_fcsr) & csr_wr_en_valid; 
  end else begin : ngen_float              
    assign csr_reg_rd_sel.fflags_sw_rd_sel = 1'b0;
    assign csr_reg_wr_sel.fflags_sw_wr_sel = 1'b0;
    assign csr_reg_rd_sel.frm_sw_rd_sel    = 1'b0;
    assign csr_reg_wr_sel.frm_sw_wr_sel    = 1'b0;
    assign csr_reg_rd_sel.fcsr_sw_rd_sel   = 1'b0; 
    assign csr_reg_wr_sel.fcsr_sw_wr_sel   = 1'b0; 
  end 
  endgenerate   
  
  generate 
  if(CHECK_ILLEGAL) begin :gen_check_illegal  
  
    logic                    rd_legal_csr;
    logic                    rd_legal_csr_debug;
    logic                    rd_legal_csr_float;	
    logic                    illegal_wr_read_only;
    logic                    wr_legal_csr;
    logic                    wr_legal_csr_debug;    
    logic                    wr_legal_csr_float;	
  
  
    assign rd_legal_csr = csr_reg_rd_sel.mvendorid_sw_rd_sel |
                          csr_reg_rd_sel.marchid_sw_rd_sel |                       
                          csr_reg_rd_sel.mimpid_sw_rd_sel |
                          csr_reg_rd_sel.mhartid_sw_rd_sel |
                          csr_reg_rd_sel.mstatus_sw_rd_sel |
                          csr_reg_rd_sel.sstatus_sw_rd_sel |
                          csr_reg_rd_sel.ustatus_sw_rd_sel |
                          csr_reg_rd_sel.misa_sw_rd_sel |
                          csr_reg_rd_sel.medeleg_sw_rd_sel |
                          csr_reg_rd_sel.mideleg_sw_rd_sel |
                          csr_reg_rd_sel.mie_sw_rd_sel |
                          csr_reg_rd_sel.sie_sw_rd_sel |
                          csr_reg_rd_sel.uie_sw_rd_sel |
                          csr_reg_rd_sel.mip_sw_rd_sel |
                          csr_reg_rd_sel.sip_sw_rd_sel |
                          csr_reg_rd_sel.uip_sw_rd_sel |
                          csr_reg_rd_sel.mtvec_sw_rd_sel |
                          csr_reg_rd_sel.mepc_sw_rd_sel |
                          csr_reg_rd_sel.mcause_sw_rd_sel |
                          csr_reg_rd_sel.mtval_sw_rd_sel |
                          csr_reg_rd_sel.mcounterinhibit_sw_rd_sel |
                          csr_reg_rd_sel.mcounteren_sw_rd_sel |
                          csr_reg_rd_sel.mscratch_sw_rd_sel |
                          csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel |
                          csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel |
                          csr_reg_rd_sel.sideleg_sw_rd_sel |
                          csr_reg_rd_sel.sedeleg_sw_rd_sel |
                          csr_reg_rd_sel.stvec_sw_rd_sel |
                          csr_reg_rd_sel.sepc_sw_rd_sel |
                          csr_reg_rd_sel.scause_sw_rd_sel |
                          csr_reg_rd_sel.stval_sw_rd_sel | 
                          csr_reg_rd_sel.scounteren_sw_rd_sel |
                          csr_reg_rd_sel.sscratch_sw_rd_sel |
                          csr_reg_rd_sel.satp_sw_rd_sel |
                          csr_reg_rd_sel.utvec_sw_rd_sel |
                          csr_reg_rd_sel.uepc_sw_rd_sel |
                          csr_reg_rd_sel.ucause_sw_rd_sel |
                          csr_reg_rd_sel.utval_sw_rd_sel | 
                          csr_reg_rd_sel.uscratch_sw_rd_sel |
                          csr_reg_rd_sel.ucycle_sw_rd_sel |
                          csr_reg_rd_sel.ucycleh_sw_rd_sel |
                          csr_reg_rd_sel.mcycle_sw_rd_sel |
                          csr_reg_rd_sel.mcycleh_sw_rd_sel |
                          csr_reg_rd_sel.utime_sw_rd_sel |
                          csr_reg_rd_sel.utimeh_sw_rd_sel |
                          csr_reg_rd_sel.uinstret_sw_rd_sel |
                          csr_reg_rd_sel.uinstreth_sw_rd_sel |
                          csr_reg_rd_sel.minstret_sw_rd_sel |
                          csr_reg_rd_sel.minstreth_sw_rd_sel |                       
                          csr_reg_rd_sel.hpmcounter_3_31_sw_rd_sel |
                          csr_reg_rd_sel.hpmcounter_3_31h_sw_rd_sel |                      
                          csr_reg_rd_sel.mhpmcounter_3_31_sw_rd_sel |
                          csr_reg_rd_sel.mhpmcounter_3_31h_sw_rd_sel |
                          csr_reg_rd_sel.hpmevent_3_31_sw_rd_sel |
                          csr_reg_rd_sel.tselect_sw_rd_sel |
                          csr_reg_rd_sel.tdata1_sw_rd_sel |
                          csr_reg_rd_sel.tdata2_sw_rd_sel |
                          csr_reg_rd_sel.tdata3_sw_rd_sel;    
                          
    assign rd_legal_csr_debug  = rd_legal_csr |
                                 csr_reg_rd_sel.dcsr_debugger_rd_sel |
                                 csr_reg_rd_sel.dpc_debugger_rd_sel |
                                 csr_reg_rd_sel.dscratch0_debugger_rd_sel |
                                 csr_reg_rd_sel.dscratch1_debugger_rd_sel;  
								  
    assign rd_legal_csr_float   = rd_legal_csr |
                                  csr_reg_rd_sel.fflags_sw_rd_sel |
                                  csr_reg_rd_sel.frm_sw_rd_sel |   
                                  csr_reg_rd_sel.fcsr_sw_rd_sel;
                                  
    assign csr_rd_illegal      =  csr_rd_en_valid & (debug_mode ? ~rd_legal_csr_debug : (~rd_legal_csr & ~rd_legal_csr_float)); 
  
    assign illegal_wr_read_only = csr_reg_wr_sel.mvendorid_sw_wr_sel |
                                  csr_reg_wr_sel.marchid_sw_wr_sel |         
                                  csr_reg_wr_sel.mimpid_sw_wr_sel |          
                                  csr_reg_wr_sel.mhartid_sw_wr_sel |         
                                  csr_reg_wr_sel.ucycle_sw_wr_sel |          
                                  csr_reg_wr_sel.ucycleh_sw_wr_sel |         
                                  csr_reg_wr_sel.utime_sw_wr_sel |           
                                  csr_reg_wr_sel.utimeh_sw_wr_sel |          
                                  csr_reg_wr_sel.uinstret_sw_wr_sel |        
                                  csr_reg_wr_sel.uinstreth_sw_wr_sel |       
                                  csr_reg_wr_sel.hpmcounter_3_31_sw_wr_sel | 
                                  csr_reg_wr_sel.hpmcounter_3_31h_sw_wr_sel; 
                           
    assign wr_legal_csr =  csr_reg_wr_sel.mstatus_sw_wr_sel |
                           csr_reg_wr_sel.sstatus_sw_wr_sel |
                           csr_reg_wr_sel.ustatus_sw_wr_sel |
                           csr_reg_wr_sel.misa_sw_wr_sel |
                           csr_reg_wr_sel.medeleg_sw_wr_sel |
                           csr_reg_wr_sel.mideleg_sw_wr_sel |
                           csr_reg_wr_sel.mie_sw_wr_sel |
                           csr_reg_wr_sel.sie_sw_wr_sel |
                           csr_reg_wr_sel.uie_sw_wr_sel |
                           csr_reg_wr_sel.mip_sw_wr_sel |
                           csr_reg_wr_sel.sip_sw_wr_sel |
                           csr_reg_wr_sel.uip_sw_wr_sel |
                           csr_reg_wr_sel.mtvec_sw_wr_sel |
                           csr_reg_wr_sel.mepc_sw_wr_sel |
                           csr_reg_wr_sel.mcause_sw_wr_sel |
                           csr_reg_wr_sel.mtval_sw_wr_sel |
                           csr_reg_wr_sel.mcounterinhibit_sw_wr_sel |
                           csr_reg_wr_sel.mcounteren_sw_wr_sel |
                           csr_reg_wr_sel.mscratch_sw_wr_sel |
                           csr_reg_wr_sel.pmpcfg_0_3_sw_wr_sel |
                           csr_reg_wr_sel.pmpaddr_0_15_sw_wr_sel |
                           csr_reg_wr_sel.sideleg_sw_wr_sel |
                           csr_reg_wr_sel.sedeleg_sw_wr_sel |
                           csr_reg_wr_sel.stvec_sw_wr_sel |
                           csr_reg_wr_sel.sepc_sw_wr_sel |
                           csr_reg_wr_sel.scause_sw_wr_sel |
                           csr_reg_wr_sel.stval_sw_wr_sel | 
                           csr_reg_wr_sel.scounteren_sw_wr_sel |
                           csr_reg_wr_sel.sscratch_sw_wr_sel |
                           csr_reg_wr_sel.satp_sw_wr_sel |
                           csr_reg_wr_sel.utvec_sw_wr_sel |
                           csr_reg_wr_sel.uepc_sw_wr_sel |
                           csr_reg_wr_sel.ucause_sw_wr_sel |
                           csr_reg_wr_sel.utval_sw_wr_sel | 
                           csr_reg_wr_sel.uscratch_sw_wr_sel |
                           csr_reg_wr_sel.mcycle_sw_wr_sel |
                           csr_reg_wr_sel.mcycleh_sw_wr_sel |
                           csr_reg_wr_sel.minstret_sw_wr_sel |
                           csr_reg_wr_sel.minstreth_sw_wr_sel |
                           csr_reg_wr_sel.mhpmcounter_3_31_sw_wr_sel |
                           csr_reg_wr_sel.mhpmcounter_3_31h_sw_wr_sel |
                           csr_reg_wr_sel.hpmevent_3_31_sw_wr_sel |
                           csr_reg_wr_sel.tselect_sw_wr_sel |
                           csr_reg_wr_sel.tdata1_sw_wr_sel |
                           csr_reg_wr_sel.tdata2_sw_wr_sel |
                           csr_reg_wr_sel.tdata3_sw_wr_sel;   
                           
    assign wr_legal_csr_debug   = wr_legal_csr |
                                  csr_reg_wr_sel.dcsr_debugger_wr_sel |
                                  csr_reg_wr_sel.dpc_debugger_wr_sel |
                                  csr_reg_wr_sel.dscratch0_debugger_wr_sel |
                                  csr_reg_wr_sel.dscratch1_debugger_wr_sel;  
								  
    assign wr_legal_csr_float   = wr_legal_csr |
                                  csr_reg_wr_sel.fflags_sw_wr_sel |
                                  csr_reg_wr_sel.frm_sw_wr_sel |   
                                  csr_reg_wr_sel.fcsr_sw_wr_sel;
                         
    // use non-trap masked version as illegal is a term in trap generation                       
    assign csr_wr_illegal = csr_wr_en_valid & (illegal_wr_read_only | ( debug_mode ? ~wr_legal_csr_debug : (~wr_legal_csr & ~wr_legal_csr_float)));
    
  end
  else begin :ngen_check_illegal
  
    assign csr_rd_illegal = 1'b0;
    assign csr_wr_illegal = 1'b0;
  
  end
  endgenerate
  
// properties
`ifdef miv_rv32_RTL_PROPS

  // should only be up to one read request
  assert_csr_priv_rd_sel_onehot0 : assert property (@(posedge clk) disable iff (~resetn)
                         csr_rd_en_valid |-> $onehot0({csr_reg_rd_sel.mvendorid_sw_rd_sel,
                                                      csr_reg_rd_sel.marchid_sw_rd_sel,     
                                                      csr_reg_rd_sel.mimpid_sw_rd_sel,
                                                      csr_reg_rd_sel.mhartid_sw_rd_sel,
                                                      csr_reg_rd_sel.mstatus_sw_rd_sel,
                                                      csr_reg_rd_sel.sstatus_sw_rd_sel,
                                                      csr_reg_rd_sel.ustatus_sw_rd_sel,
                                                      csr_reg_rd_sel.misa_sw_rd_sel,
                                                      csr_reg_rd_sel.medeleg_sw_rd_sel,
                                                      csr_reg_rd_sel.mideleg_sw_rd_sel,
                                                      csr_reg_rd_sel.mie_sw_rd_sel,
                                                      csr_reg_rd_sel.sie_sw_rd_sel,
                                                      csr_reg_rd_sel.uie_sw_rd_sel,
                                                      csr_reg_rd_sel.mip_sw_rd_sel,
                                                      csr_reg_rd_sel.sip_sw_rd_sel,
                                                      csr_reg_rd_sel.uip_sw_rd_sel,
                                                      csr_reg_rd_sel.mtvec_sw_rd_sel,
                                                      csr_reg_rd_sel.mepc_sw_rd_sel,
                                                      csr_reg_rd_sel.mcause_sw_rd_sel,
                                                      csr_reg_rd_sel.mtval_sw_rd_sel,
                                                      csr_reg_rd_sel.mcounteren_sw_rd_sel,
                                                      csr_reg_rd_sel.mcounterinhibit_sw_rd_sel,
                                                      csr_reg_rd_sel.mscratch_sw_rd_sel,
                                                      csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel,
                                                      csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel,
                                                      csr_reg_rd_sel.sideleg_sw_rd_sel ,
                                                      csr_reg_rd_sel.sedeleg_sw_rd_sel ,
                                                      csr_reg_rd_sel.stvec_sw_rd_sel ,
                                                      csr_reg_rd_sel.sepc_sw_rd_sel ,
                                                      csr_reg_rd_sel.scause_sw_rd_sel ,
                                                      csr_reg_rd_sel.stval_sw_rd_sel , 
                                                      csr_reg_rd_sel.scounteren_sw_rd_sel ,
                                                      csr_reg_rd_sel.sscratch_sw_rd_sel ,
                                                      csr_reg_rd_sel.satp_sw_rd_sel ,
                                                      csr_reg_rd_sel.utvec_sw_rd_sel ,
                                                      csr_reg_rd_sel.uepc_sw_rd_sel ,
                                                      csr_reg_rd_sel.ucause_sw_rd_sel ,
                                                      csr_reg_rd_sel.utval_sw_rd_sel , 
                                                      csr_reg_rd_sel.uscratch_sw_rd_sel ,
                                                      csr_reg_rd_sel.ucycle_sw_rd_sel ,
                                                      csr_reg_rd_sel.ucycleh_sw_rd_sel ,
                                                      csr_reg_rd_sel.mcycle_sw_rd_sel ,
                                                      csr_reg_rd_sel.mcycleh_sw_rd_sel ,
                                                      csr_reg_rd_sel.utime_sw_rd_sel ,
                                                      csr_reg_rd_sel.utimeh_sw_rd_sel ,
                                                      csr_reg_rd_sel.uinstret_sw_rd_sel ,
                                                      csr_reg_rd_sel.uinstreth_sw_rd_sel ,
                                                      csr_reg_rd_sel.minstret_sw_rd_sel ,
                                                      csr_reg_rd_sel.minstreth_sw_rd_sel ,
                                                      csr_reg_rd_sel.hpmcounter_3_31_sw_rd_sel ,
                                                      csr_reg_rd_sel.hpmcounter_3_31h_sw_rd_sel ,
                                                      csr_reg_rd_sel.mhpmcounter_3_31_sw_rd_sel ,
                                                      csr_reg_rd_sel.mhpmcounter_3_31h_sw_rd_sel ,
                                                      csr_reg_rd_sel.hpmevent_3_31_sw_rd_sel,
                                                      csr_reg_rd_sel.tselect_sw_rd_sel,
                                                      csr_reg_rd_sel.tdata1_sw_rd_sel,
                                                      csr_reg_rd_sel.tdata2_sw_rd_sel,
                                                      csr_reg_rd_sel.tdata3_sw_rd_sel,
                                                      csr_reg_rd_sel.fflags_sw_rd_sel,
                                                      csr_reg_rd_sel.frm_sw_rd_sel,   
                                                      csr_reg_rd_sel.fcsr_sw_rd_sel  
													  })); 
  
  // should only be up to one write request
  assert_csr_priv_wr_sel_onehot0 : assert property (@(posedge clk) disable iff (~resetn)
                         csr_wr_en_valid |-> $onehot0({csr_reg_wr_sel.mvendorid_sw_wr_sel,
                                                      csr_reg_wr_sel.marchid_sw_wr_sel,     
                                                      csr_reg_wr_sel.mimpid_sw_wr_sel,
                                                      csr_reg_wr_sel.mhartid_sw_wr_sel,
                                                      csr_reg_wr_sel.mstatus_sw_wr_sel,
                                                      csr_reg_wr_sel.sstatus_sw_wr_sel,
                                                      csr_reg_wr_sel.ustatus_sw_wr_sel,
                                                      csr_reg_wr_sel.misa_sw_wr_sel,
                                                      csr_reg_wr_sel.medeleg_sw_wr_sel,
                                                      csr_reg_wr_sel.mideleg_sw_wr_sel,
                                                      csr_reg_wr_sel.mie_sw_wr_sel,
                                                      csr_reg_wr_sel.sie_sw_wr_sel,
                                                      csr_reg_wr_sel.uie_sw_wr_sel,
                                                      csr_reg_wr_sel.mip_sw_wr_sel,
                                                      csr_reg_wr_sel.sip_sw_wr_sel,
                                                      csr_reg_wr_sel.uip_sw_wr_sel,
                                                      csr_reg_wr_sel.mtvec_sw_wr_sel,
                                                      csr_reg_wr_sel.mepc_sw_wr_sel,
                                                      csr_reg_wr_sel.mcause_sw_wr_sel,
                                                      csr_reg_wr_sel.mtval_sw_wr_sel,
                                                      csr_reg_wr_sel.mcounteren_sw_wr_sel,
                                                      csr_reg_wr_sel.mcounterinhibit_sw_wr_sel,
                                                      csr_reg_wr_sel.mscratch_sw_wr_sel,
                                                      csr_reg_wr_sel.pmpcfg_0_3_sw_wr_sel,
                                                      csr_reg_wr_sel.pmpaddr_0_15_sw_wr_sel ,
                                                      csr_reg_wr_sel.sideleg_sw_wr_sel ,
                                                      csr_reg_wr_sel.sedeleg_sw_wr_sel ,
                                                      csr_reg_wr_sel.stvec_sw_wr_sel ,
                                                      csr_reg_wr_sel.sepc_sw_wr_sel ,
                                                      csr_reg_wr_sel.scause_sw_wr_sel ,
                                                      csr_reg_wr_sel.stval_sw_wr_sel , 
                                                      csr_reg_wr_sel.scounteren_sw_wr_sel ,
                                                      csr_reg_wr_sel.sscratch_sw_wr_sel ,
                                                      csr_reg_wr_sel.satp_sw_wr_sel,
                                                      csr_reg_wr_sel.utvec_sw_wr_sel ,
                                                      csr_reg_wr_sel.uepc_sw_wr_sel ,
                                                      csr_reg_wr_sel.ucause_sw_wr_sel ,
                                                      csr_reg_wr_sel.utval_sw_wr_sel , 
                                                      csr_reg_wr_sel.uscratch_sw_wr_sel ,
                                                      csr_reg_wr_sel.ucycle_sw_wr_sel ,
                                                      csr_reg_wr_sel.ucycleh_sw_wr_sel ,
                                                      csr_reg_wr_sel.mcycle_sw_wr_sel ,
                                                      csr_reg_wr_sel.mcycleh_sw_wr_sel ,
                                                      csr_reg_wr_sel.utime_sw_wr_sel ,
                                                      csr_reg_wr_sel.utimeh_sw_wr_sel ,
                                                      csr_reg_wr_sel.uinstret_sw_wr_sel ,
                                                      csr_reg_wr_sel.uinstreth_sw_wr_sel ,
                                                      csr_reg_wr_sel.minstret_sw_wr_sel ,
                                                      csr_reg_wr_sel.minstreth_sw_wr_sel ,
                                                      csr_reg_wr_sel.hpmcounter_3_31_sw_wr_sel ,
                                                      csr_reg_wr_sel.hpmcounter_3_31h_sw_wr_sel ,
                                                      csr_reg_wr_sel.mhpmcounter_3_31_sw_wr_sel ,
                                                      csr_reg_wr_sel.mhpmcounter_3_31h_sw_wr_sel ,
                                                      csr_reg_wr_sel.hpmevent_3_31_sw_wr_sel,
                                                      csr_reg_wr_sel.tselect_sw_wr_sel,
                                                      csr_reg_wr_sel.tdata1_sw_wr_sel,
                                                      csr_reg_wr_sel.tdata2_sw_wr_sel,
                                                      csr_reg_wr_sel.tdata3_sw_wr_sel,
                                                      csr_reg_wr_sel.fflags_sw_wr_sel,
                                                      csr_reg_wr_sel.frm_sw_wr_sel,   
                                                      csr_reg_wr_sel.fcsr_sw_wr_sel })); 
                                                     
`endif                                                      
                                                                                                          
                                                                                                                               
endmodule


`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
// v1.1 HW trigger re-enabled, DPC updated for debug entry on HW trigger
// see assign implicit_wr_dpc_pc_wr_data  = trigger_debug_enter_taken ? excpt_trigger_dpc : // <CL> Update dpc on trigger_debug_enter_taken
// HW Trigger re-enabled (tselect)
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_csr_privarch.sv
//
//   Purpose: Core CSRs and privileged state
//
//   Author: 
//
//   Version: 1.1
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_csr_privarch
  //****************************************************************************
  // Parameter description
  #(parameter I_ADDR_WIDTH                         = 16,
	parameter l_core_cfg_hw_debug                  = 0,
    parameter l_core_cfg_num_triggers              = 0,
    parameter l_core_cfg_trigger_bus_width         = 0,
    parameter l_core_cfg_hw_multiply_divide        = 0,
    parameter l_core_cfg_hw_compressed             = 0,
	parameter l_core_cfg_hw_sp_float               = 0,
    parameter l_core_reset_vector                  = 32'h6000_0000,
    parameter l_core_static_mtvec_base             = 32'h6000_0034,
    parameter l_core_cfg_static_mtvec_base         = 0,
    parameter l_core_cfg_static_mtvec_mode         = 0,
    parameter l_core_static_mtvec_mode             = 0,
	parameter l_core_num_sys_ext_irqs              = 9,
	parameter l_core_cfg_time_count_width          = 0,
    parameter l_core_cfg_gpr_ecc_uncorrectable_irq = 0,
    parameter l_core_cfg_gpr_ecc_correctable_irq   = 0,
    parameter l_subsys_cfg_axi_present         = 1,
    parameter l_subsys_cfg_ahb_present         = 0,
    parameter l_subsys_cfg_tcm0_present             = 1,
    parameter l_axi_start_addr                = 32'h6000_0000,
    parameter l_axi_end_addr                  = 32'h6000_FFFF,
    parameter l_ahb_start_addr                = 32'h6000_0000,
    parameter l_ahb_end_addr                  = 32'h6000_FFFF,
    parameter l_tcm0_start_addr                    = 32'h8000_0000,
    parameter l_tcm0_end_addr                      = 32'h8000_0FFF
   )


  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                              clk,
  input  wire logic                              resetn,                            
  input  wire logic                              soft_reset, 
  input  wire logic                              debug_soft_reset,   
  input  wire logic                              debug_reset,   
// hart configuration
  input  wire logic [L_XLEN-1:0]                 hart_id, 
// instruction (pipeline) status 
  input  wire logic                              cycle_executed,
  input  wire logic [(L_XLEN*2)-1:0]             time_count, 
  input  wire logic                              instr_retired, 
  
  input  wire logic                              instr_wfi, 
  
  input  wire logic                              instr_completing_retr,
  input  wire logic                              instr_valid_retr, 
  input  wire logic                              instr_lsu_op_retr, 
  input  wire logic                              lsu_op_os,
  output logic                                   wfi_waiting, 
  output logic                                   irq_stall_lsu_req,  
  output logic                                   irq_abort_lsu_req, 
  input  wire logic                              flush,
// GPR/immediate data path for sw writes  
  input wire  logic [L_XLEN-1:0]                 csr_op_gpr_imm,            
  input wire  logic                              csr_op_gpr_imm_valid, 
  output logic [L_XLEN-1:0]                      csr_op_rd_data,   
  output logic                                   csr_op_rd_data_valid,               
  output logic                                   csr_op_ready, 
// control path for csr operations
  input wire  t_csr_alu_wr_op_sel                csr_alu_wr_op_sel,  
  input wire  t_csr_alu_rd_op_sel                csr_alu_rd_op_sel,           
  input  wire logic [11:0]                       csr_op_addr,
  input  wire logic                              csr_op_addr_valid,   
// implicit read/write signals
  input  wire logic                              ext_msip,
  input  wire logic                              ext_mtip,
  input  wire logic                              ext_meip,    
  input  wire logic [9:0]                        sys_ext_irq_src,              
  input  wire logic                              gpr_uncorrectable_ecc_irq_src,
  input  wire logic                              gpr_correctable_ecc_irq_src,  
  input  wire logic [L_XLEN-1:0]                 curr_pc,    
  input  wire logic [L_XLEN-1:0]                 curr_instr_enc,
  input  wire logic [L_XLEN-1:0]                 curr_ld_addr,  
  input  wire logic [L_XLEN-1:0]                 curr_str_addr,          
  input  wire logic                              excpt_i_addr_misalign,     
  input  wire logic                              excpt_i_access_fault,      
  input  wire logic                              excpt_illegal_instr,       
  input  wire logic                              excpt_breakpoint, 
  input  wire logic [l_core_cfg_trigger_bus_width-1:0]      excpt_trigger,             
  input  wire logic                              excpt_ld_addr_misalign,         
  input  wire logic                              excpt_ld_access_fault,          
  input  wire logic                              excpt_str_amo_addr_misalign,    
  input  wire logic                              excpt_str_amo_access_fault,     
  input  wire logic                              excpt_m_env_call,               
  input  wire logic                              excpt_s_env_call,               
  input  wire logic                              excpt_u_env_call,
  input  wire logic                              excpt_bus_error_i,          
  input  wire logic                              excpt_parity_error_i,       
  input  wire logic                              excpt_bus_error_d,          
  input  wire logic                              excpt_parity_error_d,  
  output logic                                   trap_taken,                     
  input  wire logic                              trap_return,  
  input  wire logic [1:0]                        extension_context_state,    
// debug 
  input  wire  logic [L_XLEN-1:0]                debug_csr_op_wr_data,
  input  wire  logic                             debug_csr_wr_en, 
  input  wire  logic                             debug_csr_rd_en, 
  input  wire logic [11:0]                       debug_csr_op_addr,
  output logic [L_XLEN-1:0]                      debug_csr_op_rd_data,
  output logic                                   debug_csr_op_rd_data_valid, 
   
  input  wire  logic                             debug_active,
  input  wire logic                              debug_halt_req,   
  output logic                                   debug_halt_ack,  
  input  wire  logic                             debug_resethalt_req,
  output logic                                   debug_resethalt_ack,
  input  wire logic                              debug_resume_req,   
  output logic                                   debug_resume_ack,
  output logic                                   debug_mode_enter_req,      
  input  wire  logic                             debug_instr_debug_enter_req,
  output logic                                   debug_mode_enter, 
  output logic                                   debug_mode_retire_mask,
  output logic                                   debug_mode_exit,   
// CSR Priv state values
  output logic [L_XLEN-1:0]                      csr_priv_misa,  
  output logic [4:0]                             csr_priv_cause_excpt_code,
  output logic                                   csr_priv_mtvec_excpt_vectored,
  output logic [L_XLEN-1:0]                      csr_priv_mtvec_excpt_vec,
  output logic [L_XLEN-1:0] 					 csr_priv_mtval,
  output logic [L_XLEN-1:0]                      csr_priv_epc,   
  output logic [L_XLEN-1:0]                      csr_priv_dpc,   
  output logic                                   csr_priv_soft_reset_taken,
  output logic                                   csr_priv_interrupt_taken,  
  output logic [1:0]                             csr_priv_priv_mode,
  output logic                                   csr_priv_debug_mode,
// trigger/debug inputs
  input wire  logic [31:0]                       trigger_instruction_opcode,    
  input wire  logic [31:0]                       trigger_instruction_address,  
  input wire  logic                              trigger_instruction_valid,
  input wire  logic                              step_instruction_valid,
  output logic [l_core_cfg_trigger_bus_width-1:0]           trigger_req,
// soft/debug reset output signal for triggering gpr ram init
  output logic                                   ram_init_soft_debug_reset,
//fpu flags
  input wire logic[4:0]                          fpu_flags,
  input wire                                     fpu_flags_valid,
  output logic[2:0]                              fpu_frm                         
);  

  
//******************************************************************************
// Declarations

  logic                         soft_reset_taken_retr;
  logic                         soft_reset_pending;
  logic                         next_soft_reset_pending;
  logic                         debug_reset_taken_retr;
  logic                         debug_active_retr;
  logic                         interrupt_taken;  
  logic                         exception_taken;
  logic                         excpt_ebreak;
  logic                         excpt_trigger_break_taken;
  logic                         excpt_trigger_break_taken_and_debug;
  logic [31:0]                  excpt_trigger_dpc;
  logic                         excpt_trigger_debug_taken;
  logic [4:0]                   cause_excpt_code;
  logic [4:0]                   cause_excpt_code_irq;
  logic [4:0]                   cause_excpt_code_excpt;
  logic [L_XLEN-1:0]            trap_val;
  logic                         irq_m_swi;
  logic                         locally_enabled_irq_captured;
  logic                         base_irq_src_ext; 
  logic                         base_irq_src_timer;
  logic                         base_irq_src_sw;
  logic                         base_irq_p_ext;
  logic                         base_irq_p_timer;    
  logic                         base_irq_p_sw; 
  logic [9:0]                   sys_ext_irq_p;              
  logic                         gpr_correctable_ecc_irq_p;  
  logic                         gpr_uncorrectable_ecc_irq_p;
  logic                         instret_count_irq_p;
  logic                         cycle_count_irq_p;
  logic                         hpm_count_irq_p;
  logic                         instret_count_irq_src;
  logic                         cycle_count_irq_src;  
  logic                         hpm_count_irq_src;    
  
  logic                         trap_taken_internal;
  logic                         valid_instr_completing;
  t_csr_reg_rd_sel              csr_reg_rd_sel;
  t_csr_reg_wr_sel              csr_reg_wr_sel;
  logic [L_XLEN-1:0]            mvendorid;
  logic [L_XLEN-1:0]            mvendorid_rd_data;  
  logic [L_XLEN-1:0]            marchid;
  logic [L_XLEN-1:0]            marchid_rd_data;  
  logic [L_XLEN-1:0]            mimpid;
  logic [L_XLEN-1:0]            mimpid_rd_data;  
  logic [L_XLEN-1:0]            mhartid;
  logic [L_XLEN-1:0]            mhartid_rd_data;  
  logic [L_XLEN-1:0]            mstatus;
  logic [L_XLEN-1:0]            mstatus_rd_data;
  logic [L_XLEN-1:0]            sstatus;
  logic [L_XLEN-1:0]            sstatus_rd_data;
  logic [L_XLEN-1:0]            ustatus;
  logic [L_XLEN-1:0]            ustatus_rd_data;  
  logic                         status_uie;
  logic                         status_sie;
  logic                         status_mie;
  logic                         status_ie;
  logic                         machine_init_wr_status_mie_wr_en;  
  logic                         machine_init_wr_status_mie_wr_data;
  logic                         machine_implicit_wr_status_mie_wr_en;
  logic                         machine_implicit_wr_status_mie_wr_data;
  logic                         machine_sw_wr_status_mie_wr_en;
  logic                         machine_sw_wr_status_mie_wr_data;
  logic                         status_upie; 
  logic                         status_spie; 
  logic                         status_mpie;
  logic                         machine_implicit_wr_status_mpie_wr_en;
  logic                         machine_implicit_wr_status_mpie_wr_data;
  logic                         machine_sw_wr_status_mpie_wr_en;
  logic                         machine_sw_wr_status_mpie_wr_data; 
  logic                         status_spp;
  logic [1:0]                   status_mpp;
  logic [1:0]                   status_fs;
  logic [1:0]                   status_xs;
  logic                         status_mprv;
  logic                         status_sum;
  logic                         status_mxr;
  logic                         status_tvm;
  logic                         status_tw;
  logic                         status_tsr;
  logic                         status_sd;  
  logic [L_XLEN-1:0]            misa;
  logic [L_XLEN-1:0]            misa_rd_data;
  logic                         misa_ext_a;
  logic                         misa_ext_b;
  logic                         misa_ext_c;
  logic                         misa_ext_d;
  logic                         misa_ext_e;
  logic                         misa_ext_f;
  logic                         misa_ext_g;
  logic                         misa_ext_h;
  logic                         misa_ext_i;
  logic                         misa_ext_j;
  logic                         misa_ext_k;
  logic                         misa_ext_l;
  logic                         misa_ext_m;
  logic                         misa_ext_n;
  logic                         misa_ext_o;
  logic                         misa_ext_p;
  logic                         misa_ext_q;
  logic                         misa_ext_r;
  logic                         misa_ext_s;
  logic                         misa_ext_t;
  logic                         misa_ext_u;
  logic                         misa_ext_v;
  logic                         misa_ext_w;
  logic                         misa_ext_x;
  logic                         misa_ext_y;
  logic                         misa_ext_z;
  logic [1:0]                   misa_ext_mxl; 
  logic [L_XLEN-1:0]            mideleg;
  logic [L_XLEN-1:0]            mideleg_rd_data;
  logic [L_XLEN-1:0]            medeleg;
  logic [L_XLEN-1:0]            medeleg_rd_data;  
  logic [L_XLEN-1:0]            mie;
  logic [L_XLEN-1:0]            mie_rd_data;
  logic [L_XLEN-1:0]            sie;
  logic [L_XLEN-1:0]            sie_rd_data;
  logic [L_XLEN-1:0]            uie;
  logic [L_XLEN-1:0]            ie;
  logic [L_XLEN-1:0]            uie_rd_data;
  logic                         ie_usie;
  logic                         ie_ssie;
  logic                         ie_msie;
  logic                         machine_implicit_wr_ie_msie_wr_en;
  logic                         machine_implicit_wr_ie_msie_wr_data;
  logic                         machine_sw_wr_ie_msie_wr_en;
  logic                         machine_sw_wr_ie_msie_wr_data;
  logic                         ie_utie;
  logic                         ie_stie;
  logic                         ie_mtie;
  logic                         machine_implicit_wr_ie_mtie_wr_en;
  logic                         machine_implicit_wr_ie_mtie_wr_data;
  logic                         machine_sw_wr_ie_mtie_wr_en;
  logic                         machine_sw_wr_ie_mtie_wr_data;
  logic                         ie_ueie;
  logic                         ie_seie;
  logic                         ie_meie;
  logic                         machine_implicit_wr_ie_meie_wr_en;
  logic                         machine_implicit_wr_ie_meie_wr_data;
  logic                         machine_sw_wr_ie_meie_wr_en;
  logic                         machine_sw_wr_ie_meie_wr_data;
  logic [9:0]                   ie_mextsysie;
  logic                         ie_gpr_ecc_uncorr;
  logic                         ie_gpr_ecc_corr;
  logic                         ie_instret_cnt;
  logic                         ie_cycle_cnt;
  logic                         ie_hpm_cnt;
  logic [L_XLEN-1:0]            mip;
  logic [L_XLEN-1:0]            mip_rd_data; 
  logic [L_XLEN-1:0]            sip;
  logic [L_XLEN-1:0]            sip_rd_data;
  logic [L_XLEN-1:0]            uip;
  logic [L_XLEN-1:0]            uip_rd_data;
  logic                         ip_usip;
  logic                         ip_ssip;
  logic                         ip_msip;
  logic                         ip_utip;
  logic                         ip_stip;
  logic                         ip_mtip;
  logic                         ip_ueip;
  logic                         ip_seip;
  logic                         ip_meip;
  logic                         gpr_uncorrectable_ecc_irq_clr;
  logic                         gpr_correctable_ecc_irq_clr;
  logic                         instret_count_irq_clr;
  logic                         cycle_count_irq_clr;
  logic                         hpm_count_irq_clr;
  
    
  logic [L_XLEN-1:0]            mtvec;
  logic [L_XLEN-1:0]            mtvec_rd_data; 
  logic [1:0]                   mtvec_mode; 
  logic                         machine_implicit_wr_mtvec_mode_wr_en;
  logic [1:0]                   machine_implicit_wr_mtvec_mode_wr_data;
  logic                         machine_sw_wr_mtvec_mode_wr_en;
  logic [1:0]                   machine_sw_wr_mtvec_mode_wr_data;
  logic [L_XLEN-1:2]            mtvec_base_reg;   
  logic                         machine_implicit_wr_mtvec_base_wr_en;
  logic [L_XLEN-1:2]            machine_implicit_wr_mtvec_base_wr_data;
  logic                         machine_sw_wr_mtvec_base_wr_en;
  logic [L_XLEN-1:2]            machine_sw_wr_mtvec_base_wr_data;
  logic                         mtvec_warl_wr_en;
  logic [L_XLEN-1:0]            mtvec_base; 
  
  logic [L_XLEN-1:0]            mepc;
  logic [L_XLEN-1:0]            mepc_rd_data;  
  logic [L_XLEN-1:1]            mepc_epc; 
  logic                         machine_implicit_wr_mepc_epc_wr_en;
  logic [L_XLEN-1:1]            machine_implicit_wr_mepc_epc_wr_data;
  logic                         machine_sw_wr_mepc_epc_wr_en;
  logic [L_XLEN-1:0]            machine_sw_wr_mepc_epc_wr_data;
  
  logic [L_XLEN-1:0]            mcause;
  logic [L_XLEN-1:0]            mcause_rd_data;
  logic                         mcause_sw_rd_sel;
  logic                         mcause_sw_wr_sel;  
  logic [4:0]                   mcause_excpt_code; 
  logic                         machine_init_wr_mcause_excpt_code_wr_en;
  logic [4:0]                   machine_init_wr_mcause_excpt_code_wr_data;
  logic                         machine_implicit_wr_mcause_excpt_code_wr_en;
  logic [4:0]                   machine_implicit_wr_mcause_excpt_code_wr_data;
  logic                         machine_sw_wr_mcause_excpt_code_wr_en;
  logic [4:0]                   machine_sw_wr_mcause_excpt_code_wr_data;
  logic                         mcause_interrupt; 
  logic                         machine_init_wr_mcause_interrupt_wr_en;
  logic                         machine_init_wr_mcause_interrupt_wr_data;
  logic                         machine_implicit_wr_mcause_interrupt_wr_en;
  logic                         machine_implicit_wr_mcause_interrupt_wr_data;
  logic                         machine_sw_wr_mcause_interrupt_wr_en;
  logic                         machine_sw_wr_mcause_interrupt_wr_data;  
  logic [L_XLEN-1:0]            mtval;
  logic [L_XLEN-1:0]            mtval_rd_data;  
  logic [L_XLEN-1:0]            mtval_tval; 
  logic                         machine_implicit_wr_mtval_tval_wr_en;
  logic [L_XLEN-1:0]            machine_implicit_wr_mtval_tval_wr_data;
  logic                         machine_sw_wr_mtval_tval_wr_en;
  logic [L_XLEN-1:0]            machine_sw_wr_mtval_tval_wr_data;  
  logic [L_XLEN-1:0]            mcounteren;
  logic [L_XLEN-1:0]            mcounteren_rd_data;
  logic                         mcounteren_cycle_count_en;
  logic                         mcounteren_timer_count_en;
  logic                         mcounteren_instret_count_en;
  logic [28:0]                  mcounteren_hpm_count_en; 
  logic [L_XLEN-1:0]            mcounterinhibit;
  logic [L_XLEN-1:0]            mcounterinhibit_rd_data; 
  logic                         mcounterinhibit_cycle_count_inh; 
  logic                         mcounterinhibit_instret_count_inh;     
  logic [28:0]                  mcounterinhibit_hpm_count_inh;   
  logic [L_XLEN-1:0]            mscratch;
  logic [L_XLEN-1:0]            mscratch_rd_data;
  logic [L_XLEN-1:0]            mscratch_scratch; 
  logic                         machine_sw_wr_mscratch_scratch_wr_en;
  logic [L_XLEN-1:0]            machine_sw_wr_mscratch_scratch_wr_data; 
  logic [L_XLEN-1:0]            pmpcfg_0_3;
  logic [L_XLEN-1:0]            pmpcfg_0_3_rd_data;
  logic [L_XLEN-1:0]            pmpaddr_0_15;
  logic [L_XLEN-1:0]            pmpaddr_0_15_rd_data;  
  logic [L_XLEN-1:0]            sideleg;
  logic [L_XLEN-1:0]            sideleg_rd_data; 
  logic [L_XLEN-1:0]            sedeleg;
  logic [L_XLEN-1:0]            sedeleg_rd_data;
  logic [L_XLEN-1:0]            stvec;
  logic [L_XLEN-1:0]            stvec_rd_data;
  logic [L_XLEN-1:0]            sepc;
  logic [L_XLEN-1:0]            sepc_rd_data;
  logic [L_XLEN-1:0]            scause;
  logic [L_XLEN-1:0]            scause_rd_data;
  logic [L_XLEN-1:0]            stval;
  logic [L_XLEN-1:0]            stval_rd_data;
  logic [L_XLEN-1:0]            scounteren;
  logic [L_XLEN-1:0]            scounteren_rd_data;
  logic [L_XLEN-1:0]            sscratch;
  logic [L_XLEN-1:0]            sscratch_rd_data;
  logic [L_XLEN-1:0]            satp;
  logic [L_XLEN-1:0]            satp_rd_data; 
  logic [L_XLEN-1:0]            utvec;
  logic [L_XLEN-1:0]            utvec_rd_data;
  logic [L_XLEN-1:0]            uepc;
  logic [L_XLEN-1:0]            uepc_rd_data;
  logic [L_XLEN-1:0]            ucause;
  logic [L_XLEN-1:0]            ucause_rd_data;
  logic [L_XLEN-1:0]            utval;
  logic [L_XLEN-1:0]            utval_rd_data;
  logic [L_XLEN-1:0]            uscratch;
  logic [L_XLEN-1:0]            uscratch_rd_data;  
//  logic [l_core_cfg_cycle_count_width-1:0]   cycle_count_reg;
  logic [(L_XLEN*2)-1:0]                          cycle_count;           
  logic [L_XLEN-1:0]                              ucycle_rd_data;    
  logic [L_XLEN-1:0]                              mcycle_rd_data;              
  logic [L_XLEN-1:0]                              ucycleh_rd_data;    
  logic [L_XLEN-1:0]                              mcycleh_rd_data; 
  logic [L_XLEN-1:0]                              utime;
  logic [L_XLEN-1:0]                              utime_rd_data; 
  logic [L_XLEN-1:0]                              utimeh;
  logic [L_XLEN-1:0]                              utimeh_rd_data;
//  logic [l_core_cfg_instret_count_width-1:0] instret_count_reg;
  logic [(L_XLEN*2)-1:0]                          instret_count;
  logic [L_XLEN-1:0]                              uinstret_rd_data;
  logic [L_XLEN-1:0]                              minstret_rd_data;
  logic [L_XLEN-1:0]                              uinstreth_rd_data;
  logic [L_XLEN-1:0]                              minstreth_rd_data;
  logic [L_XLEN-1:0]                              hpmcounter_3_31_rd_data;
  logic [L_XLEN-1:0]                              hpmcounter_3_31h_rd_data;
  logic [L_XLEN-1:0]                              mhpmcounter_3_31_rd_data;
  logic [L_XLEN-1:0]                              mhpmcounter_3_31h_rd_data; 
  logic [L_XLEN-1:0]                              hpmevent_3_31_rd_data; 
   
  logic [L_XLEN-1:0]                              tselect;
  logic [L_XLEN-1:0]                              tselect_rd_data;
  logic [L_XLEN-1:0]                              tdata1;
  logic [L_XLEN-1:0]                              tdata1_rd_data;
  logic [L_XLEN-1:0]                              tdata2;
  logic [L_XLEN-1:0]                              tdata2_rd_data;
  logic [L_XLEN-1:0]                              tdata3;
  logic [L_XLEN-1:0]                              tdata3_rd_data;          
  
  logic                                           sw_csr_wr_valid_qual;
  logic                                           sw_csr_rd_valid_qual;
  logic                                           sw_rd_en_valid;
  logic [11:0]                                    csr_op_addr_sig;
  
  logic [1:0]                                     priv_mode;       
  
  logic                                           ext_msip_retime;
  logic                                           ext_mtip_retime;
  logic                                           ext_meip_retime;
  
      
  logic [L_XLEN-1:0]                              csr_op_wr_data; 
  logic                                           csr_op_wr_data_valid;  
  logic                                           csr_op_wr_valid;   
  logic                                           csr_op_rd_valid;    
  logic                                           csr_alu_wr_op_ready; 
  
  logic [L_XLEN-1:0]                              exu_csr_op_wr_data; 
  logic                                           exu_csr_op_wr_data_valid;  
  logic                                           exu_csr_op_wr_valid;    
  logic                                           exu_csr_alu_wr_op_ready; 
  
  logic                                           set_wfi_waiting;
  logic                                           clr_wfi_waiting;
  logic                                           wfi_waiting_reg;
  
  logic                                           debugger_rd_en_valid;
  logic                                           debugger_wr_en_valid;
  logic                                           debug_mode;   
  logic                                           debug_enter_taken; 
  logic                                           debug_exit_taken; 

  logic [L_XLEN-1:0]                              dcsr;
  logic [L_XLEN-1:0]                              dcsr_rd_data;
  logic [3:0]                                     dcsr_xdebugver;
  logic                                           dcsr_ebreakm;
  logic                                           dcsr_ebreaks;
  logic                                           dcsr_ebreaku;
  logic                                           dcsr_stepie;
  logic                                           dcsr_stopcount;
  logic                                           dcsr_stoptime;
  logic [2:0]                                     dcsr_cause;
  logic                                           dcsr_mprven;
  logic                                           dcsr_nmip;
  logic                                           dcsr_step;
  logic [1:0]                                     dcsr_prv;
  logic [I_ADDR_WIDTH-1:0]                        dpc_reg;
  logic [L_XLEN-1:0]                              dpc;
  logic [L_XLEN-1:0]                              dpc_rd_data;
  logic [L_XLEN-1:0]                              dscratch0;
  logic [L_XLEN-1:0]                              dscratch0_rd_data;  
  logic [L_XLEN-1:0]                              dscratch1;  
  logic [L_XLEN-1:0]                              dscratch1_rd_data; 
  logic                                           step_debug_enter_taken;  
  logic                                           haltreq_debug_enter_taken;    
  logic                                           resethaltreq_debug_enter_taken; 
  logic                                           trigger_debug_enter_taken; 
  logic                                           ebreak_debug_enter_taken; 
  
//******************************************************************************
// Main code

  

// CSR write path operations
//------------------------------------
  
  always @*
  begin
    case(csr_alu_wr_op_sel)
      csr_alu_wr_op_swap :
      begin
        exu_csr_op_wr_data        = csr_op_gpr_imm ;
        exu_csr_op_wr_data_valid  = csr_op_gpr_imm_valid;
        exu_csr_op_wr_valid       = 1'b1;
        exu_csr_alu_wr_op_ready   = csr_op_gpr_imm_valid;
      end
      
      csr_alu_wr_op_set :
      begin
        exu_csr_op_wr_data        = csr_op_rd_data | csr_op_gpr_imm;
        exu_csr_op_wr_data_valid  = csr_op_gpr_imm_valid;
        exu_csr_op_wr_valid       = 1'b1;
        exu_csr_alu_wr_op_ready   = csr_op_gpr_imm_valid;
      end
      
      csr_alu_wr_op_clr :
      begin
        exu_csr_op_wr_data        = csr_op_rd_data & ~csr_op_gpr_imm;
        exu_csr_op_wr_data_valid  = csr_op_gpr_imm_valid;
        exu_csr_op_wr_valid       = 1'b1;
        exu_csr_alu_wr_op_ready   = csr_op_gpr_imm_valid;
      end


      csr_alu_wr_op_none :
      begin
        exu_csr_op_wr_data        = {L_XLEN{1'b0}};
        exu_csr_op_wr_data_valid  = 1'b0;
        exu_csr_op_wr_valid       = 1'b0;
        exu_csr_alu_wr_op_ready   = 1'b1;
      end
      
      default :
      begin
        exu_csr_op_wr_data        = {L_XLEN{1'b0}};
        exu_csr_op_wr_data_valid  = 1'b0;
        exu_csr_op_wr_valid       = 1'b0;
        exu_csr_alu_wr_op_ready   = 1'b0;
      end
    endcase
  end
  
  assign csr_op_wr_data        = debug_mode ? debug_csr_op_wr_data  : exu_csr_op_wr_data;      
  assign csr_op_wr_data_valid  = debug_mode ? debug_csr_wr_en       : exu_csr_op_wr_data_valid;
  assign csr_op_wr_valid       = debug_mode ? debug_csr_wr_en       : (exu_csr_op_wr_valid  & ~flush);     
  assign csr_alu_wr_op_ready   = debug_mode ? 1'b1                  : exu_csr_alu_wr_op_ready; 
  
  assign csr_op_rd_valid       = debug_mode ? debug_csr_rd_en       : (csr_alu_rd_op_sel != csr_alu_rd_op_none);
  assign csr_op_addr_sig       = debug_mode ? debug_csr_op_addr     : csr_op_addr;

// intermediate computations
//------------------------------------
  
  // when dcsr_ebreakm = 0 take exception as per priv spec, when = 1 enter debug as defined in debug spec, unless debug not active
  assign excpt_ebreak = excpt_breakpoint & ((~dcsr_ebreakm) | (~debug_active_retr));  

  assign valid_instr_completing = instr_completing_retr & instr_valid_retr;       

  // Mask exception generation when entering debug mode since the instruction is not retired, hence precise exceptions associated
  // with it not generated. 
  // A trigger break that causes a trap and enters debug mode (from seperate triggers), should not generate a trap externally, howevever
  // if both are allowed simultaneously (l_cfg_core_trigger_both = 1), as optionally defined by the debug spec, a trap should be generated internally
  // such that the implicit updates associated with a trap are performed; then when exitingdebug, the trap will appear to also have executed.
  
  assign exception_taken = valid_instr_completing & 
                           ~(debug_enter_taken | debug_mode) &
                            ((|{excpt_i_addr_misalign,        
                                excpt_i_access_fault,        
                                excpt_illegal_instr,         
                                excpt_ebreak, 
                                excpt_trigger_break_taken,           
                                excpt_ld_addr_misalign,      
                                excpt_ld_access_fault,       
                                excpt_str_amo_addr_misalign, 
                                excpt_str_amo_access_fault,  
                                excpt_m_env_call,            
                                excpt_s_env_call,            
                                excpt_u_env_call,
                                excpt_bus_error_i,   
                                excpt_parity_error_i,
                                excpt_bus_error_d,   
                                excpt_parity_error_d}) | 
                               excpt_trigger_break_taken_and_debug) ;                   
 
  // interrupts                                     
  assign base_irq_src_ext    = ext_meip; 
  assign base_irq_src_timer  = ext_mtip;
  assign base_irq_src_sw     = ext_msip;                              
                                      
  miv_rv32_priv_irq  #( .l_core_num_sys_ext_irqs              (l_core_num_sys_ext_irqs              ),
                         .l_core_cfg_gpr_ecc_uncorrectable_irq (l_core_cfg_gpr_ecc_uncorrectable_irq ),
                         .l_core_cfg_gpr_ecc_correctable_irq   (l_core_cfg_gpr_ecc_correctable_irq   )  
  )
  u_miv_rv32_priv_irq_0
  (
    .clk                            (clk                           ),
    .resetn                         (resetn                        ), 
    .debug_mode                     (debug_mode                    ),
    .lsu_op_os                      (lsu_op_os                     ),
    .instr_completing_retr          (instr_completing_retr         ),
    .instr_valid_retr               (instr_valid_retr              ),
    .instr_lsu_op_retr              (instr_lsu_op_retr             ),
    .ie                             (ie                            ),
    .global_enable                  (status_ie                     ),
    .dcsr_stepie                    (dcsr_stepie                   ),
    .dcsr_step                      (dcsr_step                     ),
    .ip_read                        (csr_reg_rd_sel.ip_sw_rd_sel   ),
                                    
    .base_irq_src_ext               (base_irq_src_ext              ),
    .base_irq_src_timer             (base_irq_src_timer            ),
    .base_irq_src_sw                (base_irq_src_sw               ),
    .sys_ext_irq_src                (sys_ext_irq_src               ),
    .gpr_uncorrectable_ecc_irq_src  (gpr_uncorrectable_ecc_irq_src ),
    .gpr_uncorrectable_ecc_irq_clr  (gpr_uncorrectable_ecc_irq_clr ),
    .gpr_correctable_ecc_irq_src    (gpr_correctable_ecc_irq_src   ),
    .gpr_correctable_ecc_irq_clr    (gpr_correctable_ecc_irq_clr   ),
    .instret_count_irq_src          (instret_count_irq_src         ),
    .instret_count_irq_clr          (instret_count_irq_clr         ),
    .cycle_count_irq_src            (cycle_count_irq_src           ),
    .cycle_count_irq_clr            (cycle_count_irq_clr           ),
    .hpm_count_irq_src              (hpm_count_irq_src             ),
    .hpm_count_irq_clr              (hpm_count_irq_clr             ),
                                    
    .irq_stall_lsu_req              (irq_stall_lsu_req             ),
    .irq_abort_lsu_req              (irq_abort_lsu_req             ),
    .locally_enabled_irq_captured   (locally_enabled_irq_captured  ),
    .irq_taken                      (interrupt_taken               ),
    .base_ip_ext                    (base_irq_p_ext                ),    
    .base_ip_timer                  (base_irq_p_timer              ),
    .base_ip_sw                     (base_irq_p_sw                 ), 
    .sys_ext_ip                     (sys_ext_irq_p                 ), 
    .gpr_correctable_ecc_ip         (gpr_correctable_ecc_irq_p     ), 
    .gpr_uncorrectable_ecc_ip       (gpr_uncorrectable_ecc_irq_p   ), 
    .instret_count_ip               (instret_count_irq_p           ),
    .cycle_count_ip                 (cycle_count_irq_p             ),
    .hpm_count_ip                   (hpm_count_irq_p               ),
    .cause_excpt_code_irq           (cause_excpt_code_irq          )
  ); 
  
  assign trap_taken_internal = exception_taken | interrupt_taken; 
  assign trap_taken          = trap_taken_internal & ~(debug_enter_taken | debug_mode);                                 
                                                
  // priority/encoding defined by priv spec                                                
  assign cause_excpt_code_excpt = excpt_trigger_break_taken ? 5'd3 :  
                                    excpt_i_access_fault ? 5'd1 : 
                                      excpt_illegal_instr ? 5'd2 : 
                                        excpt_i_addr_misalign ? 5'd0 :  
                                          excpt_m_env_call ? 5'd11 : 
                                            excpt_ebreak ? 5'd3 :
                                              excpt_str_amo_addr_misalign ? 5'd6 :
                                                excpt_ld_addr_misalign ? 5'd4 : 
                                                  excpt_str_amo_access_fault ? 5'd7 :
                                                    excpt_ld_access_fault ? 5'd5 : 
                                                      excpt_bus_error_i ? 5'd24 :    
                                                        excpt_parity_error_i ? 5'd25 :
                                                          excpt_bus_error_d ? 5'd26 :   
                                                            excpt_parity_error_d ? 5'd27 : 5'd0;                                             
                                                  
                                                           
  assign cause_excpt_code = interrupt_taken ? cause_excpt_code_irq : cause_excpt_code_excpt;
  
  assign trap_val = interrupt_taken ? 32'd0 :
                      excpt_trigger_break_taken ? curr_pc : 
                        excpt_i_access_fault ? curr_pc :
                          excpt_illegal_instr ? curr_instr_enc :  
                            excpt_i_addr_misalign ? curr_pc : 
                              excpt_m_env_call ? 32'd0 :
                                excpt_ebreak ? curr_pc :
                                  excpt_str_amo_addr_misalign ? curr_str_addr :
                                    excpt_ld_addr_misalign ? curr_ld_addr :
                                      excpt_str_amo_access_fault ? curr_str_addr : 
                                        excpt_ld_access_fault ? curr_ld_addr : 
                                          excpt_bus_error_i ? curr_pc :   
                                            excpt_parity_error_i ? curr_pc :
                                              excpt_bus_error_d ? curr_ld_addr :   
                                                excpt_parity_error_d ? curr_ld_addr : 32'd0; 
  
  //--------------------------------------------------------
  // Reset handling
  //--------------------------------------------------------   
  // Need to ensure soft_reset occurs (soft_reset_taken_retr asserted) only when an instruction is completing
  // to ensure reset handling instruction is inserted without anything outstanding in the retr stage
  // stage.
  // Reset must take priority over new instructions and must happen if no instructions in flight
  // need to mask when debug entry is pending so that debug mode can be entered as soft_rest will prevent it doing so if held asserted 
  // as may be the case when debugger is requesting debug mode entry straight out of reset
  
  assign next_soft_reset_pending = (soft_reset_pending & ~soft_reset_taken_retr) | (soft_reset | debug_soft_reset);
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      soft_reset_pending <= 1'b0;
    else
      soft_reset_pending <= next_soft_reset_pending;
  end
  
  assign soft_reset_taken_retr = soft_reset_pending & (instr_completing_retr | ~instr_valid_retr) & ~debug_mode_enter_req;  
  
  assign ram_init_soft_debug_reset = next_soft_reset_pending;
 

// piveleged mode bits
//------------------------------------

  assign priv_mode = l_core_mode_machine ; // Only Machine mode supported by core
  

// CSR registers
//------------------------------------
 
  assign sw_csr_wr_valid_qual = csr_op_wr_valid & csr_op_wr_data_valid & csr_op_addr_valid;
  assign sw_csr_rd_valid_qual = csr_op_rd_valid & csr_op_addr_valid;  
  
    miv_rv32_csr_decode
    #(
      .CHECK_ILLEGAL         (0),  // illegal checks performed in DE stage
	  .l_core_cfg_hw_debug   (l_core_cfg_hw_debug),
	  .l_core_cfg_hw_sp_float (l_core_cfg_hw_sp_float)
    )
    u_miv_rv32_csr_decode_0
    (
      .clk                         (clk                 ),
      .resetn                      (resetn              ),
      .debug_mode                  (debug_mode          ),
      .csr_rd_addr                 (csr_op_addr_sig     ),
      .csr_rd_en_valid             (sw_csr_rd_valid_qual),
      .csr_wr_addr                 (csr_op_addr_sig     ),
      .csr_wr_en_valid             (sw_csr_wr_valid_qual),
      .csr_reg_rd_sel              (csr_reg_rd_sel      ),
      .csr_reg_wr_sel              (csr_reg_wr_sel      ),
      .csr_rd_illegal              (                    ),  // open, illegal checks performed in DE stage
      .csr_wr_illegal              (                    )   // open, illegal checks performed in DE stage   
    );   
	
	
//assign csr_reg_rd_sel.fcsr_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_fcsr) & csr_rd_en_valid; 
//assign csr_reg_wr_sel.fcsr_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_fcsr) & csr_wr_en_valid; 
	
logic [L_XLEN-1:0] fcsr_rd_data;
logic [L_XLEN-1:0] fcsr;

logic [L_XLEN-1:0] fflags_rd_data;
logic [4:0]        fflags;
logic [4:0]        fflags_flags;
logic [4:0]        machine_implicit_wr_fflags_flags_wr_data;
logic [4:0]        machine_sw_wr_fflags_flags_wr_data;      
logic              machine_implicit_wr_fflags_flags_wr_en ; 
logic              machine_sw_wr_fflags_flags_wr_en;       
	
logic [L_XLEN-1:0] frm_rd_data;
logic [2:0]        frm_frm;
logic [2:0]        machine_implicit_wr_frm_frm_wr_data;
logic [2:0]        machine_sw_wr_frm_frm_wr_data;      
logic              machine_implicit_wr_frm_frm_wr_en ; 
logic              machine_sw_wr_frm_frm_wr_en;     


// User Floating Point CSRs 
//+++++++++++++++++++++++++++ 
//fcsr
//  fcsr
  assign fcsr         = {24'b0, frm_frm, fflags_flags}; 
  assign fcsr_rd_data = fcsr & {L_XLEN{csr_reg_rd_sel.fcsr_sw_rd_sel}};  
  
//fflags	
//  fflags
  assign machine_implicit_wr_fflags_flags_wr_en   = fpu_flags_valid; 
  assign machine_implicit_wr_fflags_flags_wr_data = fpu_flags; 
  assign machine_sw_wr_fflags_flags_wr_en         = (csr_reg_wr_sel.fflags_sw_wr_sel) | (csr_reg_wr_sel.fcsr_sw_wr_sel);
  assign machine_sw_wr_fflags_flags_wr_data       = csr_op_wr_data[4:0]; 

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (5),  
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_fflags_flags
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({5{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_fflags_flags_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_fflags_flags_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_fflags_flags_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_fflags_flags_wr_data),
      .state_val                   (fflags_flags)
    );

  assign fflags           = fflags_flags; 
  assign fflags_rd_data   = {{L_XLEN-5{1'b0}}, fflags} & {L_XLEN{csr_reg_rd_sel.fflags_sw_rd_sel}};  
  
//frm	
//  frm
  assign machine_implicit_wr_frm_frm_wr_en   = 1'b0;       
  assign machine_implicit_wr_frm_frm_wr_data = 3'b0;
  assign machine_sw_wr_frm_frm_wr_en         = (csr_reg_wr_sel.frm_sw_wr_sel) | (csr_reg_wr_sel.fcsr_sw_wr_sel);
  assign machine_sw_wr_frm_frm_wr_data       = (csr_reg_wr_sel.fcsr_sw_wr_sel) ? csr_op_wr_data[7:5]: csr_op_wr_data[2:0];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (3),  
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_frm_frm
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({3{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_frm_frm_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_frm_frm_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_frm_frm_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_frm_frm_wr_data),
      .state_val                   (frm_frm)
    );

  assign fpu_frm       = frm_frm; 
  assign frm_rd_data   = {{L_XLEN-3{1'b0}}, fpu_frm} & {L_XLEN{csr_reg_rd_sel.frm_sw_rd_sel}};  
// Machine Mode CSRs
//++++++++++++++++++ 

//mvendorid	
//  mvendorid
  

  assign mvendorid = l_core_vendorid;
  assign mvendorid_rd_data = mvendorid & {L_XLEN{csr_reg_rd_sel.mvendorid_sw_rd_sel}};
  
//marchid	
//  marchid


  assign marchid = l_core_marchid;
  assign marchid_rd_data = marchid & {L_XLEN{csr_reg_rd_sel.marchid_sw_rd_sel}};
	
//mimpid	
//  mimpid

  assign mimpid = l_core_mimpid;
  assign mimpid_rd_data = mimpid & {L_XLEN{csr_reg_rd_sel.mimpid_sw_rd_sel}};
	
//mhartid	
// mhartid

  assign mhartid = hart_id;  // read only
  assign mhartid_rd_data = mhartid & {L_XLEN{csr_reg_rd_sel.mhartid_sw_rd_sel}};
	    
//status  
                                                    
//  status_uie
  assign status_uie = 1'b0;         // no user mode in core
//  status_sie
  assign status_sie = 1'b0;         // no supervisor mode in core
//  status_mie
  assign machine_init_wr_status_mie_wr_en       = soft_reset_taken_retr;
  assign machine_init_wr_status_mie_wr_data     = 1'b0;
  assign machine_implicit_wr_status_mie_wr_en   = (priv_mode == l_core_mode_machine ) && (trap_taken_internal || trap_return);
  assign machine_implicit_wr_status_mie_wr_data = trap_taken_internal ? 1'b0 :status_mpie;
  assign machine_sw_wr_status_mie_wr_en         = csr_reg_wr_sel.mstatus_sw_wr_sel;
  assign machine_sw_wr_status_mie_wr_data       = csr_op_wr_data[3];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_status_mie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_status_mie_wr_en),
      .init_wr_data                (machine_init_wr_status_mie_wr_data),
      .machine_implicit_wr_en      (machine_implicit_wr_status_mie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_status_mie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_status_mie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_status_mie_wr_data),
      .state_val                   (status_mie)
    );   
    
  assign status_ie =  ((priv_mode == l_core_mode_machine) & status_mie) |
                      ((priv_mode == l_core_mode_supervisor) & status_sie) |
                      ((priv_mode == l_core_mode_user) & status_uie);
    
//  status_upie  
  assign status_upie = 1'b0;        // no user mode in core
//  status_spie
  assign status_spie = 1'b0;        // no supervisor mode in core
//  status_mpie
  assign machine_implicit_wr_status_mpie_wr_en   = (priv_mode == l_core_mode_machine ) && (trap_taken_internal || trap_return);
  assign machine_implicit_wr_status_mpie_wr_data = trap_taken_internal ? status_mie :1'b1;
  assign machine_sw_wr_status_mpie_wr_en         = csr_reg_wr_sel.mstatus_sw_wr_sel;
  assign machine_sw_wr_status_mpie_wr_data       = csr_op_wr_data[7];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_status_mpie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_status_mpie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_status_mpie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_status_mpie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_status_mpie_wr_data),
      .state_val                   (status_mpie)
    );
    
//  status_spp
  assign status_spp = 1'b0;            // no supervisor mode in core
//  status_mpp
  assign status_mpp = l_core_mode_machine ;   // Previous mode can only be machine mode in core 
//  status_fs
 assign status_fs = 2'b00;              // no supervisor mode in core
//  status_xs
  assign status_xs = extension_context_state;
//  status_mprv
  assign status_mprv = 1'b0;            // no supervisor mode in core
//  status_sum
  assign status_sum = 1'b0;             // no supervisor mode in core
//  status_mxr
  assign status_mxr = 1'b0;             // no supervisor mode in core
//  status_tvm
  assign status_tvm = 1'b0;             // no supervisor mode in core
//  status_tw
  assign status_tw = 1'b0;              // no supervisor mode in core
//  status_tsr
  assign status_tsr = 1'b0;             // no supervisor mode in core
//  status_sd
  assign status_sd = |{status_fs,status_xs};


  assign mstatus = {status_sd,
                    8'b0000_0000,
                    status_tsr,
                    status_tw,
                    status_tvm,
                    status_mxr,
                    status_sum,
                    status_mprv,
                    status_xs,
                    status_fs,
                    status_mpp,
                    2'b00,
                    status_spp,
                    status_mpie,
                    1'b0,
                    status_spie,
                    status_upie,
                    status_mie,
                    1'b0,
                    status_sie,
                    status_uie};
                   
  assign mstatus_rd_data = mstatus & {L_XLEN{csr_reg_rd_sel.mstatus_sw_rd_sel}}; 
  
  assign sstatus = {status_sd,       
                    8'b0000_0000,    
                    1'b0,            
                    1'b0,            
                    1'b0,            
                    status_mxr,      
                    status_sum,      
                    1'b0,            
                    status_xs,       
                    status_fs,       
                    2'b00,           
                    2'b00,           
                    1'b0,            
                    1'b0,            
                    1'b0,            
                    status_spie,     
                    status_upie,     
                    1'b0,            
                    1'b0,            
                    status_sie,      
                    status_uie};      
                                      
                   
  assign sstatus_rd_data = sstatus & {L_XLEN{csr_reg_rd_sel.sstatus_sw_rd_sel}};    
  
  assign ustatus = {1'b0,
                    8'b0000_0000,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    2'b0,
                    2'b0,
                    2'b00,
                    2'b00,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    status_upie,
                    1'b0,
                    1'b0,
                    1'b0,
                    status_uie};
                   
  assign ustatus_rd_data = ustatus & {L_XLEN{csr_reg_rd_sel.ustatus_sw_rd_sel}};              
	
//misa	
  
// All ISA config is static in core
//  misa_ext_a
  assign misa_ext_a = l_core_cfg_hw_atomics;
//  misa_ext_b
  assign misa_ext_b = 1'b0;
//  misa_ext_c
  assign misa_ext_c = l_core_cfg_hw_compressed;
//  misa_ext_d  
  assign misa_ext_d = 1'b0;
//  misa_ext_e
  assign misa_ext_e = 1'b0;
//  misa_ext_f
  assign misa_ext_f = l_core_cfg_hw_sp_float;
//  misa_ext_g
  assign misa_ext_g = 1'b0;
//  misa_ext_h
  assign misa_ext_h = 1'b0;
//  misa_ext_i
  assign misa_ext_i = 1'b1;
//  misa_ext_j
  assign misa_ext_j = 1'b0;
//  misa_ext_k
  assign misa_ext_k = 1'b0;
//  misa_ext_l
  assign misa_ext_l = 1'b0;
//  misa_ext_m
  assign misa_ext_m = l_core_cfg_hw_multiply_divide;
//  misa_ext_n
  assign misa_ext_n = 1'b0;
//  misa_ext_o
  assign misa_ext_o = 1'b0;
//  misa_ext_p
  assign misa_ext_p = 1'b0;
//  misa_ext_q
  assign misa_ext_q = 1'b0;
//  misa_ext_r
  assign misa_ext_r = 1'b0;
//  misa_ext_s
  assign misa_ext_s = 1'b0;
//  misa_ext_t
  assign misa_ext_t = 1'b0;
//  misa_ext_u
  assign misa_ext_u = 1'b0;
//  misa_ext_v
  assign misa_ext_v = 1'b0;
//  misa_ext_w
  assign misa_ext_w = 1'b0;
//  misa_ext_x
  assign misa_ext_x = 1'b0;
//  misa_ext_y
  assign misa_ext_y = 1'b0;
//  misa_ext_z
  assign misa_ext_z = 1'b1; // ZCisr supported
//  misa_mxl
  assign misa_ext_mxl = 2'd1; // 32-bit only

  assign misa = {misa_ext_mxl, 
                 4'b0000,
                 misa_ext_z, misa_ext_y, misa_ext_x, misa_ext_w, misa_ext_v, misa_ext_u, 
                 misa_ext_t, misa_ext_s, misa_ext_r, misa_ext_q, misa_ext_p, misa_ext_o, misa_ext_n, 
                 misa_ext_m, misa_ext_l, misa_ext_k, misa_ext_j, misa_ext_i, misa_ext_h, misa_ext_g, 
                 misa_ext_f, misa_ext_e, misa_ext_d, misa_ext_c, misa_ext_b, misa_ext_a};
                 
  assign misa_rd_data = misa & {L_XLEN{csr_reg_rd_sel.misa_sw_rd_sel}};
	
//medeleg	
// medeleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign medeleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign medeleg_rd_data   = medeleg & {L_XLEN{csr_reg_rd_sel.medeleg_sw_rd_sel}};
  
//mideleg	
// mideleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign mideleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign mideleg_rd_data   = mideleg & {L_XLEN{csr_reg_rd_sel.mideleg_sw_rd_sel}};
	
//ie	

//  ie_usie
  assign ie_usie = 1'b0;
//  ie_ssie
  assign ie_ssie = 1'b0;
//  ie_msie
  assign machine_implicit_wr_ie_msie_wr_en   = 1'b0;
  assign machine_implicit_wr_ie_msie_wr_data = 1'b0;
  assign machine_sw_wr_ie_msie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
  assign machine_sw_wr_ie_msie_wr_data       = csr_op_wr_data[3];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_msie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_msie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_msie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_msie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_msie_wr_data),
      .state_val                   (ie_msie)
    );
//  ie_utie
  assign ie_utie = 1'b0;
//  ie_stie
  assign ie_stie = 1'b0;
//  ie_mtie
  assign machine_implicit_wr_ie_mtie_wr_en   = 1'b0;
  assign machine_implicit_wr_ie_mtie_wr_data = 1'b0;
  assign machine_sw_wr_ie_mtie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
  assign machine_sw_wr_ie_mtie_wr_data       = csr_op_wr_data[7];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_mtie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_mtie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_mtie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_mtie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_mtie_wr_data),
      .state_val                   (ie_mtie)
    );

//  ie_ueie
  assign ie_ueie = 1'b0;
//  ie_seie
  assign ie_seie = 1'b0;
//  ie_meie
  assign machine_implicit_wr_ie_meie_wr_en   = 1'b0;
  assign machine_implicit_wr_ie_meie_wr_data = 1'b0;
  assign machine_sw_wr_ie_meie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
  assign machine_sw_wr_ie_meie_wr_data       = csr_op_wr_data[11];

  miv_rv32_csr_gpr_state_reg
  #(
    .WIDTH               (1),
    .FIELD_RESET_EN      (0),
    .FIELD_RESET_VAL     (0)
  )
  u_csr_gpr_state_reg_ie_meie
  (
    .clk                         (clk),
    .resetn                      (resetn),
    .init_wr_en                  (1'b0),
    .init_wr_data                (1'b0),
    .machine_implicit_wr_en      (machine_implicit_wr_ie_meie_wr_en),
    .machine_implicit_wr_data    (machine_implicit_wr_ie_meie_wr_data),
    .machine_sw_wr_en            (machine_sw_wr_ie_meie_wr_en),
    .machine_sw_wr_data          (machine_sw_wr_ie_meie_wr_data),
    .state_val                   (ie_meie)
  );
    
  genvar i_ext_sys_irq;
  generate  
  for (i_ext_sys_irq = 0; i_ext_sys_irq < 10; i_ext_sys_irq++) begin : gen_ext_sys_irq
  
    if(i_ext_sys_irq < l_core_num_sys_ext_irqs) begin : gen_ext_sys_irq_bit
    
      logic machine_implicit_wr_ie_mextsysie_wr_en;  
      logic machine_implicit_wr_ie_mextsysie_wr_data;
      logic machine_sw_wr_ie_mextsysie_wr_en;        
      logic machine_sw_wr_ie_mextsysie_wr_data;      
    
      assign machine_implicit_wr_ie_mextsysie_wr_en   = 1'b0;
      assign machine_implicit_wr_ie_mextsysie_wr_data = 1'b0;
      assign machine_sw_wr_ie_mextsysie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
      assign machine_sw_wr_ie_mextsysie_wr_data       = csr_op_wr_data[22+i_ext_sys_irq];
    
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_ie_mextsysie
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                (1'b0),
        .machine_implicit_wr_en      (machine_implicit_wr_ie_mextsysie_wr_en),
        .machine_implicit_wr_data    (machine_implicit_wr_ie_mextsysie_wr_data),
        .machine_sw_wr_en            (machine_sw_wr_ie_mextsysie_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_ie_mextsysie_wr_data),
        .state_val                   (ie_mextsysie[i_ext_sys_irq])
      );
     
    end
    else begin : ngen_ext_sys_irq_bit
      
        assign ie_mextsysie[i_ext_sys_irq] = 1'b0;
  
    end
  end
  endgenerate
  
  generate if(l_core_cfg_gpr_ecc_uncorrectable_irq) begin : gen_ecc_uncorrectable_irq
  
    logic machine_implicit_wr_ie_gpr_ecc_uncorr_wr_en;  
    logic machine_implicit_wr_ie_gpr_ecc_uncorr_wr_data;
    logic machine_sw_wr_ie_gpr_ecc_uncorr_wr_en;        
    logic machine_sw_wr_ie_gpr_ecc_uncorr_wr_data;      
    
    assign machine_implicit_wr_ie_gpr_ecc_uncorr_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_gpr_ecc_uncorr_wr_data = 1'b0;
    assign machine_sw_wr_ie_gpr_ecc_uncorr_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_gpr_ecc_uncorr_wr_data       = csr_op_wr_data[16];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_gpr_ecc_uncorr
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_gpr_ecc_uncorr_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_gpr_ecc_uncorr_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_gpr_ecc_uncorr_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_gpr_ecc_uncorr_wr_data),
      .state_val                   (ie_gpr_ecc_uncorr)
    );  
   
  end
  else begin : ngen_ecc_uncorrectable_irq
    
      assign ie_gpr_ecc_uncorr = 1'b0;
  
  end
  endgenerate

  generate if(l_core_cfg_gpr_ecc_correctable_irq) begin : gen_ecc_correctable_irq
  
    logic machine_implicit_wr_ie_gpr_ecc_corr_wr_en;  
    logic machine_implicit_wr_ie_gpr_ecc_corr_wr_data;
    logic machine_sw_wr_ie_gpr_ecc_corr_wr_en;        
    logic machine_sw_wr_ie_gpr_ecc_corr_wr_data;      
    
    assign machine_implicit_wr_ie_gpr_ecc_corr_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_gpr_ecc_corr_wr_data = 1'b0;
    assign machine_sw_wr_ie_gpr_ecc_corr_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_gpr_ecc_corr_wr_data       = csr_op_wr_data[17];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_gpr_ecc_corr
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_gpr_ecc_corr_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_gpr_ecc_corr_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_gpr_ecc_corr_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_gpr_ecc_corr_wr_data),
      .state_val                   (ie_gpr_ecc_corr)
    );  
   
  end
  else begin : ngen_ecc_correctable_irq
    
      assign ie_gpr_ecc_corr = 1'b0;
  
  end
  endgenerate
  
  generate if(l_core_cfg_instret_count_irq) begin : gen_instret_count_irq
  
    logic machine_implicit_wr_ie_instret_cnt_wr_en;  
    logic machine_implicit_wr_ie_instret_cnt_wr_data;
    logic machine_sw_wr_ie_instret_cnt_wr_en;        
    logic machine_sw_wr_ie_instret_cnt_wr_data;      
    
    assign machine_implicit_wr_ie_instret_cnt_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_instret_cnt_wr_data = 1'b0;
    assign machine_sw_wr_ie_instret_cnt_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_instret_cnt_wr_data       = csr_op_wr_data[18];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_instret_cnt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_instret_cnt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_instret_cnt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_instret_cnt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_instret_cnt_wr_data),
      .state_val                   (ie_instret_cnt)
    );  
   
  end
  else begin : ngen_instret_count_irq
    
      assign ie_instret_cnt = 1'b0;
  
  end
  endgenerate
  
  generate if(l_core_cfg_cycle_count_irq) begin : gen_cycle_count_irq
  
    logic machine_implicit_wr_ie_cycle_cnt_wr_en;  
    logic machine_implicit_wr_ie_cycle_cnt_wr_data;
    logic machine_sw_wr_ie_cycle_cnt_wr_en;        
    logic machine_sw_wr_ie_cycle_cnt_wr_data;      
    
    assign machine_implicit_wr_ie_cycle_cnt_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_cycle_cnt_wr_data = 1'b0;
    assign machine_sw_wr_ie_cycle_cnt_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_cycle_cnt_wr_data       = csr_op_wr_data[19];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_cycle_cnt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_cycle_cnt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_cycle_cnt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_cycle_cnt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_cycle_cnt_wr_data),
      .state_val                   (ie_cycle_cnt)
    );  
   
  end
  else begin : ngen_cycle_count_irq
    
      assign ie_cycle_cnt = 1'b0;
  
  end
  endgenerate
  
  generate if(l_core_cfg_hpm_count_irq) begin : gen_hpm_count_irq
  
    logic machine_implicit_wr_ie_hpm_cnt_wr_en;  
    logic machine_implicit_wr_ie_hpm_cnt_wr_data;
    logic machine_sw_wr_ie_hpm_cnt_wr_en;        
    logic machine_sw_wr_ie_hpm_cnt_wr_data;      
    
    assign machine_implicit_wr_ie_hpm_cnt_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_hpm_cnt_wr_data = 1'b0;
    assign machine_sw_wr_ie_hpm_cnt_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_hpm_cnt_wr_data       = csr_op_wr_data[20];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_hpm_cnt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_hpm_cnt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_hpm_cnt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_hpm_cnt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_hpm_cnt_wr_data),
      .state_val                   (ie_hpm_cnt)
    );  
   
  end
  else begin : ngen_hpm_count_irq
    
      assign ie_hpm_cnt = 1'b0;
  
  end
  endgenerate
  
  assign mie = {ie_mextsysie,
                {1{1'b0}},
                ie_hpm_cnt,
                ie_cycle_cnt,
                ie_instret_cnt,
                ie_gpr_ecc_corr,
                ie_gpr_ecc_uncorr,
                {4{1'b0}},
                ie_meie,
                1'b0,
                ie_seie,
                ie_ueie,
                ie_mtie,
                1'b0,
                ie_stie,
                ie_utie,
                ie_msie,
                1'b0,
                ie_ssie,
                ie_usie};
                   
  assign mie_rd_data = mie & {L_XLEN{csr_reg_rd_sel.mie_sw_rd_sel}};  
  
  assign sie = {{20{1'b0}},
                1'b0,
                1'b0,
                ie_seie,
                ie_ueie,
                1'b0,
                1'b0,
                ie_stie,
                ie_utie,
                1'b0,
                1'b0,
                ie_ssie,
                ie_usie};
                   
  assign sie_rd_data = sie & {L_XLEN{csr_reg_rd_sel.sie_sw_rd_sel}};
  
  assign uie = {{20{1'b0}},
                1'b0,
                1'b0,
                1'b0,
                ie_ueie,
                1'b0,
                1'b0,
                1'b0,
                ie_utie,
                1'b0,
                1'b0,
                1'b0,
                ie_usie};
                   
  assign uie_rd_data = uie & {L_XLEN{csr_reg_rd_sel.uie_sw_rd_sel}};
  
  assign ie = ({L_XLEN{(priv_mode == l_core_mode_machine)}} & mie) |
              ({L_XLEN{(priv_mode == l_core_mode_supervisor)}} & sie) |
              ({L_XLEN{(priv_mode == l_core_mode_user)}} & uie);
	
//ip	

  // sticky pending bits are cleared by writing 1 to corresponding IP bit
  // Note this action can only be performed in machine mode by writing to the mip alias for ip.
  
  assign gpr_uncorrectable_ecc_irq_clr  = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[16];
  assign gpr_correctable_ecc_irq_clr    = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[17];
  assign instret_count_irq_clr          = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[18];
  assign cycle_count_irq_clr            = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[19];
  assign hpm_count_irq_clr              = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[20];
  
  
//  ip_usip
  assign ip_usip = 1'b0;
//  ip_ssip
  assign ip_ssip = 1'b0;
//  ip_msip
  assign ip_msip = base_irq_p_sw;
//  ip_utip
  assign ip_utip = 1'b0;
//  ip_stip
  assign ip_stip = 1'b0;
//  ip_mtip
  assign ip_mtip = base_irq_p_timer;
//  ip_ueip
  assign ip_ueip = 1'b0;
//  ip_seip
  assign ip_seip = 1'b0;
//  ip_meip
  assign ip_meip = base_irq_p_ext;

  assign mip = {sys_ext_irq_p,
                {1{1'b0}},
                hpm_count_irq_p, 
                cycle_count_irq_p,
                instret_count_irq_p,
                gpr_correctable_ecc_irq_p,
                gpr_uncorrectable_ecc_irq_p,
                {4{1'b0}},
                ip_meip,
                1'b0,
                ip_seip,
                ip_ueip,
                ip_mtip,
                1'b0,
                ip_stip,
                ip_utip,
                ip_msip,
                1'b0,
                ip_ssip,
                ip_usip};
                   
  assign mip_rd_data = mip & {L_XLEN{csr_reg_rd_sel.mip_sw_rd_sel}}; 
  
  assign sip = {{20{1'b0}},
               1'b0,
               1'b0,
               ip_seip,
               ip_ueip,
               1'b0,
               1'b0,
               ip_stip,
               ip_utip,
               1'b0,
               1'b0,
               ip_ssip,
               ip_usip};
                   
  assign sip_rd_data = sip & {L_XLEN{csr_reg_rd_sel.sip_sw_rd_sel}}; 
  
  assign uip = {{20{1'b0}},
               1'b0,
               1'b0,
               1'b0,
               ip_ueip,
               1'b0,
               1'b0,
               1'b0,
               ip_utip,
               1'b0,
               1'b0,
               1'b0,
               ip_usip};
                   
  assign uip_rd_data = uip & {L_XLEN{csr_reg_rd_sel.uip_sw_rd_sel}}; 
	
//mtvec	

//  mtvec_mode
  assign machine_implicit_wr_mtvec_mode_wr_en   = 1'b0;
  assign machine_implicit_wr_mtvec_mode_wr_data = 2'b00;
  assign machine_sw_wr_mtvec_mode_wr_en         = csr_reg_wr_sel.mtvec_sw_wr_sel;
  assign machine_sw_wr_mtvec_mode_wr_data       = csr_op_wr_data[1:0];

  generate if(l_core_cfg_static_mtvec_mode) 
  begin : gen_mtvec_mode_read_only
  
    assign mtvec_mode = l_core_static_mtvec_mode;
  end
  else begin : gen_mtvec_mode_writable
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (2),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mtvec_mode
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({2{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mtvec_mode_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mtvec_mode_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mtvec_mode_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mtvec_mode_wr_data),
      .state_val                   (mtvec_mode)
    );
    
  end
  endgenerate
  
//	mtvec_base

  assign machine_implicit_wr_mtvec_base_wr_en   = 1'b0;
  assign machine_implicit_wr_mtvec_base_wr_data = {30{1'd0}};
  assign machine_sw_wr_mtvec_base_wr_en         = (mtvec_warl_wr_en) ? 1'b1 : 1'b0;  // SAR_125515
  assign machine_sw_wr_mtvec_base_wr_data       = csr_op_wr_data[31:2];

  assign mtvec_warl_wr_en                       = (csr_reg_wr_sel.mtvec_sw_wr_sel & (((l_subsys_cfg_axi_present) & (machine_sw_wr_mtvec_base_wr_data[31:12] >= l_axi_start_addr[31:12]) &  
                                                                                                                  (machine_sw_wr_mtvec_base_wr_data[31:12] <= l_axi_end_addr[31:12])) |
                                                                                     ((l_subsys_cfg_ahb_present) & (machine_sw_wr_mtvec_base_wr_data[31:12] >= l_ahb_start_addr[31:12]) &  
                                                                                                                  (machine_sw_wr_mtvec_base_wr_data[31:12] <= l_ahb_end_addr[31:12])) |
                                                                                         ((l_subsys_cfg_tcm0_present) & (machine_sw_wr_mtvec_base_wr_data[31:12] >= l_tcm0_start_addr[31:12]) &  
                                                                                                                       (machine_sw_wr_mtvec_base_wr_data[31:12] <= l_tcm0_end_addr[31:12]))));

  generate if(l_core_cfg_static_mtvec_base) 
  begin : gen_mtvec_base_read_only
  
    assign mtvec_base_reg = l_core_static_mtvec_base[31:2];
  end
  else begin : gen_mtvec_base_writable

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (30),  
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (l_core_static_mtvec_base[31:2])  // SAR_125515
    )
    u_csr_gpr_state_reg_mtvec_base
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({30{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mtvec_base_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mtvec_base_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mtvec_base_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mtvec_base_wr_data),
      .state_val                   (mtvec_base_reg)
    );
    
    
  end
  endgenerate

  assign mtvec_base      = {mtvec_base_reg,2'b00}; 
  assign mtvec           = {mtvec_base_reg,mtvec_mode}; 
  assign mtvec_rd_data   = mtvec & {L_XLEN{csr_reg_rd_sel.mtvec_sw_rd_sel}};
  
  assign csr_priv_mtvec_excpt_vectored = (mtvec_mode == 2'd1);
  assign csr_priv_mtvec_excpt_vec      = mtvec_base;
	
//mepc	
//  mepc_epc
  assign machine_implicit_wr_mepc_epc_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mepc_epc_wr_data = curr_pc[L_XLEN-1:1];
  assign machine_sw_wr_mepc_epc_wr_en         = csr_reg_wr_sel.mepc_sw_wr_sel;
  assign machine_sw_wr_mepc_epc_wr_data       = csr_op_wr_data;

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (31),  
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mepc_epc
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({31{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mepc_epc_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mepc_epc_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mepc_epc_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mepc_epc_wr_data[L_XLEN-1:1]),
      .state_val                   (mepc_epc)
    );

  assign mepc           = {mepc_epc,1'b0}; 
  assign mepc_rd_data   = mepc & {L_XLEN{csr_reg_rd_sel.mepc_sw_rd_sel}};
	
//mcause	

//  mcause_excpt_code
  assign machine_init_wr_mcause_excpt_code_wr_en       = soft_reset_taken_retr;  // async reset handled seperately
  assign machine_init_wr_mcause_excpt_code_wr_data     = l_core_mcause_code_reset_state;
  assign machine_implicit_wr_mcause_excpt_code_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mcause_excpt_code_wr_data = cause_excpt_code;
  assign machine_sw_wr_mcause_excpt_code_wr_en         = csr_reg_wr_sel.mcause_sw_wr_sel;
  assign machine_sw_wr_mcause_excpt_code_wr_data       = csr_op_wr_data[4:0];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (5),  // 
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (l_core_mcause_code_reset_state)
    )
    u_csr_gpr_state_reg_mcause_excpt_code
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_mcause_excpt_code_wr_en),
      .init_wr_data                (machine_init_wr_mcause_excpt_code_wr_data),
      .machine_implicit_wr_en      (machine_implicit_wr_mcause_excpt_code_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mcause_excpt_code_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mcause_excpt_code_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mcause_excpt_code_wr_data),
      .state_val                   (mcause_excpt_code)
    );
//  mcause_interrupt
  assign machine_init_wr_mcause_interrupt_wr_en       = soft_reset_taken_retr;  // async reset handled seperately
  assign machine_init_wr_mcause_interrupt_wr_data     = l_core_mcause_interrupt_reset_state;
  assign machine_implicit_wr_mcause_interrupt_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mcause_interrupt_wr_data = interrupt_taken;
  assign machine_sw_wr_mcause_interrupt_wr_en         = csr_reg_wr_sel.mcause_sw_wr_sel;
  assign machine_sw_wr_mcause_interrupt_wr_data       = csr_op_wr_data[31];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),  // 
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mcause_interrupt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_mcause_interrupt_wr_en),
      .init_wr_data                (machine_init_wr_mcause_interrupt_wr_data),
      .machine_implicit_wr_en      (machine_implicit_wr_mcause_interrupt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mcause_interrupt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mcause_interrupt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mcause_interrupt_wr_data),
      .state_val                   (mcause_interrupt)
    );

  assign mcause           = {mcause_interrupt, {26{1'b0}}, mcause_excpt_code}; 
  assign mcause_rd_data   = mcause & {L_XLEN{csr_reg_rd_sel.mcause_sw_rd_sel}};
	

//  mtval
//  mtval_tval
  assign machine_implicit_wr_mtval_tval_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mtval_tval_wr_data = trap_val;
  assign machine_sw_wr_mtval_tval_wr_en         = csr_reg_wr_sel.mtval_sw_wr_sel;
  assign machine_sw_wr_mtval_tval_wr_data       = csr_op_wr_data;

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (32),  
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mtval_tval
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({32{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mtval_tval_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mtval_tval_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mtval_tval_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mtval_tval_wr_data),
      .state_val                   (mtval_tval)
    );

  assign mtval           = mtval_tval;
  assign csr_priv_mtval  = mtval_tval; 
  assign mtval_rd_data   = mtval & {L_XLEN{csr_reg_rd_sel.mtval_sw_rd_sel}};

//mcounteren	
// Mcounteren is implemented as read-only and always reads 0 for mcounteren_cycle_count_en, mcounteren_timer_count_en, mcounteren_instret_count_en, mcounteren_hpm_count_en
// as there is no supervisor mode in core 

//  mcounteren_cycle_count_en
  assign mcounteren_cycle_count_en = 1'b0;
//	mcounteren_timer_count_en
  assign mcounteren_timer_count_en = 1'b0;
//	mcounteren_timer_count_en
  assign mcounteren_instret_count_en = 1'b0;
//	mcounteren_timer_count_en
  assign mcounteren_hpm_count_en = {29{1'b0}};

  assign mcounteren           = {mcounteren_hpm_count_en,mcounteren_instret_count_en,mcounteren_timer_count_en,mcounteren_cycle_count_en}; 
  assign mcounteren_rd_data   = mcounteren & {L_XLEN{csr_reg_rd_sel.mcounteren_sw_rd_sel}};

//mcounterinhibit	
//  mcounterinhibit_cycle_count_inh
  generate if(l_core_cfg_cycle_count_width > 0) 
  begin : gen_cycle_count_inh
  
    
    logic  machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_en;
    logic  machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_data;

    assign machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_en         = csr_reg_wr_sel.mcounterinhibit_sw_wr_sel;
    assign machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_data       = csr_op_wr_data[0];

      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_mcounterinhibit_cycle_count_inh
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                (1'b0),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_data),
        .state_val                   (mcounterinhibit_cycle_count_inh)
      );
  end 
  else begin : ngen_cycle_count_inh
    assign mcounterinhibit_cycle_count_inh = 1'b0;
  end
  endgenerate
  
//  mcounterinhibit_instret_count_inh
  generate if(l_core_cfg_instret_count_width > 0) 
  begin : gen_instret_count_inh
    
    logic machine_sw_wr_mcounterinhibit_instret_count_inh_wr_en;
    logic machine_sw_wr_mcounterinhibit_instret_count_inh_wr_data;
  
    assign machine_sw_wr_mcounterinhibit_instret_count_inh_wr_en         = csr_reg_wr_sel.mcounterinhibit_sw_wr_sel;
    assign machine_sw_wr_mcounterinhibit_instret_count_inh_wr_data       = csr_op_wr_data[2];

      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_mcounterinhibit_instret_count_inh
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                (1'b0),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_mcounterinhibit_instret_count_inh_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_mcounterinhibit_instret_count_inh_wr_data),
        .state_val                   (mcounterinhibit_instret_count_inh)
      );
  end 
  else begin : ngen_instret_count_inh
    assign mcounterinhibit_instret_count_inh = 1'b0;
  end
  endgenerate
  
//  mcounterinhibit_hpm_count_inh
  generate if(l_core_cfg_num_hpm_counters > 0) 
  begin : gen_hpm_count_inh
  
  
  logic                                          machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_en;
  logic [l_core_cfg_num_hpm_counters-1:0]   machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_data;
  logic [l_core_cfg_num_hpm_counters-1:0]   mcounterinhibit_hpm_count_inh_reg; 
  

    assign machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_en         = csr_reg_wr_sel.mcounterinhibit_sw_wr_sel;
    assign machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_data       = csr_op_wr_data[l_core_cfg_num_hpm_counters-1:0];

      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (l_core_cfg_num_hpm_counters),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_mcounterinhibit_hpm_count_inh
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                ({l_core_cfg_num_hpm_counters{1'b0}}),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    ({l_core_cfg_num_hpm_counters{1'b0}}),
        .machine_sw_wr_en            (machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_data),
        .state_val                   (mcounterinhibit_hpm_count_inh_reg)
      );
      
      if(l_core_cfg_num_hpm_counters >= 29) // should not be greater than 29!
      begin : gen_assign_hpm_count_inh_eq29
        assign mcounterinhibit_hpm_count_inh = mcounterinhibit_hpm_count_inh_reg;
      end
      else begin : gen_assign_hpm_count_inh_lt29
        assign mcounterinhibit_hpm_count_inh = {{(29-l_core_cfg_num_hpm_counters){1'b0}}, mcounterinhibit_hpm_count_inh_reg};
      end

  end 
  else begin : ngen_hpm_count_inh
    assign mcounterinhibit_hpm_count_inh = {29{1'b0}};
  end
  endgenerate

  assign mcounterinhibit           = {mcounterinhibit_hpm_count_inh, 
                                      mcounterinhibit_instret_count_inh, 
                                      1'b0, 
                                      mcounterinhibit_cycle_count_inh}; 
  assign mcounterinhibit_rd_data   = mcounterinhibit & {L_XLEN{csr_reg_rd_sel.mcounterinhibit_sw_rd_sel}};
  
  	
//mscratch	
//  mscratch_scratch
  assign machine_sw_wr_mscratch_scratch_wr_en         = csr_reg_wr_sel.mscratch_sw_wr_sel;
  assign machine_sw_wr_mscratch_scratch_wr_data       = csr_op_wr_data;

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (32),  
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mscratch_scratch
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({32{1'b0}}),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    ({32{1'b0}}),
      .machine_sw_wr_en            (machine_sw_wr_mscratch_scratch_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mscratch_scratch_wr_data),
      .state_val                   (mscratch_scratch)
    );

  assign mscratch           = mscratch_scratch; 
  assign mscratch_rd_data   = mscratch & {L_XLEN{csr_reg_rd_sel.mscratch_sw_rd_sel}};
  
//pmpcfg
// Core does not currently support memory protection, so pmp registers unused, group together
// however csrs are legally addressable

  assign pmpcfg_0_3           = {L_XLEN{1'b0}}; 
  assign pmpcfg_0_3_rd_data   = pmpcfg_0_3 & {L_XLEN{csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel}};
  
//pmpaddr
// Core does not currently support memory protection, so pmp registers unused, group together
// however csrs are legally addressable
  assign pmpaddr_0_15           = {L_XLEN{1'b0}}; 
  assign pmpaddr_0_15_rd_data   = pmpaddr_0_15 & {L_XLEN{csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel}};

// Supervisor Mode CSRs
//+++++++++++++++++++++  

// sedeleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign sedeleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sedeleg_rd_data   = sedeleg & {L_XLEN{csr_reg_rd_sel.sedeleg_sw_rd_sel}};
  
//sideleg	
// sideleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign sideleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sideleg_rd_data   = sideleg & {L_XLEN{csr_reg_rd_sel.sideleg_sw_rd_sel}};
  
//stvec	
// stvec not implemented on core as it is machine only
// however csr is legally addressable 
  assign stvec           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign stvec_rd_data   = stvec & {L_XLEN{csr_reg_rd_sel.stvec_sw_rd_sel}};
  
//sepc	
// sepc not implemented on core as it is machine only
// however csr is legally addressable 
  assign sepc           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sepc_rd_data   = sepc & {L_XLEN{csr_reg_rd_sel.sepc_sw_rd_sel}};
  
//scause	
// scause not implemented on core as it is machine only
// however csr is legally addressable 
  assign scause           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign scause_rd_data   = scause & {L_XLEN{csr_reg_rd_sel.scause_sw_rd_sel}};
  
//stval	
// stval not implemented on core as it is machine only
// however csr is legally addressable 
  assign stval           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign stval_rd_data   = stval & {L_XLEN{csr_reg_rd_sel.stval_sw_rd_sel}};
  
//scounteren	
// scounteren not implemented on core as it is machine only
// however csr is legally addressable 
  assign scounteren           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign scounteren_rd_data   = scounteren & {L_XLEN{csr_reg_rd_sel.scounteren_sw_rd_sel}};
  
//sscratch	
// sscratch not implemented on core as it is machine only
// however csr is legally addressable 
  assign sscratch           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sscratch_rd_data   = sscratch & {L_XLEN{csr_reg_rd_sel.sscratch_sw_rd_sel}};
  
//satp	
// satp not implemented on core as it is machine only
// however csr is legally addressable 
  assign satp           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign satp_rd_data   = satp & {L_XLEN{csr_reg_rd_sel.satp_sw_rd_sel}};

// User Mode CSRs
//+++++++++++++++++++++ 
 
//utvec	
// utvec not implemented on core as it is machine only
// however csr is legally addressable 
  assign utvec           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign utvec_rd_data   = utvec & {L_XLEN{csr_reg_rd_sel.utvec_sw_rd_sel}};
  
//uepc	
// uepc not implemented on core as it is machine only
// however csr is legally addressable 
  assign uepc           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign uepc_rd_data   = uepc & {L_XLEN{csr_reg_rd_sel.uepc_sw_rd_sel}};
  
//ucause	
// ucause not implemented on core as it is machine only
// however csr is legally addressable 
  assign ucause           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign ucause_rd_data   = ucause & {L_XLEN{csr_reg_rd_sel.ucause_sw_rd_sel}};
  
//utval	
// utval not implemented on core as it is machine only
// however csr is legally addressable 
  assign utval           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign utval_rd_data   = utval & {L_XLEN{csr_reg_rd_sel.utval_sw_rd_sel}};
  
//uscratch	
// uscratch not implemented on core as it is machine only
// however csr is legally addressable
  assign uscratch           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign uscratch_rd_data   = uscratch & {L_XLEN{csr_reg_rd_sel.uscratch_sw_rd_sel}};
  
// cycle
// (up-to) 64-bit cycle counter
  generate if(l_core_cfg_cycle_count_width > 0) 
  begin : gen_cycle_count
  
    logic [l_core_cfg_cycle_count_width-1:0] next_count_inc;  
    assign next_count_inc = ~(debug_mode & dcsr_stopcount) ? (cycle_count[l_core_cfg_cycle_count_width-1:0] + 'd1) : 
                                                              cycle_count[l_core_cfg_cycle_count_width-1:0];    
    
    // cycle_count_lo
    if(l_core_cfg_cycle_count_width >= L_XLEN) 
    begin : gen_cycle_count_lo_gte_xlen
    
      logic [L_XLEN-1:0]                            cycle_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(csr_reg_wr_sel.mcycle_sw_wr_sel)
          cycle_count_reg_lo = csr_op_wr_data;
        else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
          cycle_count_reg_lo = next_count_inc[L_XLEN-1:0];
      end 
      
      assign cycle_count[L_XLEN-1:0] = cycle_count_reg_lo;
    
    end else begin :gen_cycle_count_lo_lt_xlen 
    
      logic [l_core_cfg_cycle_count_width-1:0]  cycle_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(csr_reg_wr_sel.mcycle_sw_wr_sel)
          cycle_count_reg_lo = csr_op_wr_data[l_core_cfg_cycle_count_width-1:0];
        else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
          cycle_count_reg_lo = next_count_inc[l_core_cfg_cycle_count_width-1:0];
      end 
      
      assign cycle_count[L_XLEN-1:0] = {{(L_XLEN-l_core_cfg_cycle_count_width){1'b0}},cycle_count_reg_lo}; 
    
    end
    
    // cycle_count_hi
    
    if(l_core_cfg_cycle_count_width > L_XLEN) 
    begin : gen_cycle_count_hi_gt_xlen
    
    
    
      if(l_core_cfg_cycle_count_width == L_XLEN*2) 
      begin : gen_cycle_count_hi_eq_2xlen
      
        logic [L_XLEN-1:0]    cycle_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width{1'b0}};
          else if(soft_reset_taken_retr)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width{1'b0}};
          else if(csr_reg_wr_sel.mcycleh_sw_wr_sel)
            cycle_count_reg_hi = csr_op_wr_data;
          else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
            cycle_count_reg_hi = next_count_inc[L_XLEN+:L_XLEN];
        end 
        
        assign cycle_count[L_XLEN+:L_XLEN] = cycle_count_reg_hi;
    
      end else begin :gen_cycle_count_hi_lt_xlen 
      
        logic [l_core_cfg_cycle_count_width-L_XLEN-1:0]    cycle_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width-L_XLEN{1'b0}};
          else if(soft_reset_taken_retr)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width-L_XLEN{1'b0}};
          else if(csr_reg_wr_sel.mcycleh_sw_wr_sel)
            cycle_count_reg_hi = csr_op_wr_data[l_core_cfg_cycle_count_width-L_XLEN-1:0];
          else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
            cycle_count_reg_hi = next_count_inc[l_core_cfg_cycle_count_width-L_XLEN-1:0];
        end 
        
        assign cycle_count[L_XLEN+:L_XLEN] = {{((L_XLEN*2)-l_core_cfg_cycle_count_width){1'b0}},cycle_count_reg_hi}; 
    
      end
       
    end
    else begin :gen_cycle_count_hi_lte_xlen
      assign cycle_count[L_XLEN+:L_XLEN] = {L_XLEN{1'b0}};
    end
    
    assign cycle_count_irq_src = cycle_count[l_core_cfg_instret_count_width-1];

  end
  else begin : ngen_cycle_count 

    assign cycle_count          = {(L_XLEN*2){1'b0}}; 
    assign cycle_count_irq_src  = 1'b0; 

  end
  endgenerate


  assign ucycle_rd_data    = cycle_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.ucycle_sw_rd_sel}};
  assign mcycle_rd_data    = cycle_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.mcycle_sw_rd_sel}};


  assign ucycleh_rd_data    = cycle_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.ucycleh_sw_rd_sel}};
  assign mcycleh_rd_data    = cycle_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.mcycleh_sw_rd_sel}};
  
// time
// 64-bit time counter
// timer is external to core such that it can be shared across multiple cores
// ISA requires time to read 0 if not implemented


  generate if(l_core_cfg_time_count_width > 0) 
  begin : gen_time_ext
    assign utime  = time_count[0+:L_XLEN]; 
    assign utimeh = time_count[L_XLEN+:L_XLEN];
  end
  else begin : ngen_time_ext
    assign utime  = {L_XLEN{1'b0}};
    assign utimeh = {L_XLEN{1'b0}};
  end
  endgenerate

  assign utime_rd_data   = utime & {L_XLEN{csr_reg_rd_sel.utime_sw_rd_sel}};
  assign utimeh_rd_data   = utimeh & {L_XLEN{csr_reg_rd_sel.utimeh_sw_rd_sel}};
  
// instret
// (up-to) 64-bit instret counter
  generate if(l_core_cfg_instret_count_width > 0) 
  begin : gen_instret_count
  
    logic [l_core_cfg_instret_count_width-1:0] next_count_inc;  
    assign next_count_inc = ~(debug_mode & dcsr_stopcount) ? (instret_count[l_core_cfg_instret_count_width-1:0] + 'd1) :
                                                              instret_count[l_core_cfg_instret_count_width-1:0];    
    
    // instret_count_lo
    if(l_core_cfg_instret_count_width >= L_XLEN) 
    begin : gen_instret_count_lo_gte_xlen
    
      logic [L_XLEN-1:0]                            instret_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(csr_reg_wr_sel.minstret_sw_wr_sel)
          instret_count_reg_lo = csr_op_wr_data;
        else if(instr_retired && !mcounterinhibit_instret_count_inh)
          instret_count_reg_lo = next_count_inc[L_XLEN-1:0];
      end 
      
      assign instret_count[L_XLEN-1:0] = instret_count_reg_lo;
    
    end else begin :gen_instret_count_lo_lt_xlen 
    
      logic [l_core_cfg_instret_count_width-1:0]  instret_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(csr_reg_wr_sel.minstret_sw_wr_sel)
          instret_count_reg_lo = csr_op_wr_data[l_core_cfg_instret_count_width-1:0];
        else if(instr_retired && !mcounterinhibit_instret_count_inh)
          instret_count_reg_lo = next_count_inc[l_core_cfg_instret_count_width-1:0];
      end 
      
      assign instret_count[L_XLEN-1:0] = {{(L_XLEN-l_core_cfg_instret_count_width){1'b0}},instret_count_reg_lo}; 
    
    end
    
    // instret_count_hi
    
    if(l_core_cfg_instret_count_width > L_XLEN) 
    begin : gen_instret_count_hi_gt_xlen
    
    
    
      if(l_core_cfg_instret_count_width == L_XLEN*2) 
      begin : gen_instret_count_hi_eq_2xlen
      
        logic [L_XLEN-1:0]    instret_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            instret_count_reg_hi = {l_core_cfg_instret_count_width{1'b0}};
          else if(soft_reset_taken_retr)
            instret_count_reg_hi = {l_core_cfg_instret_count_width{1'b0}};
          else if(csr_reg_wr_sel.minstreth_sw_wr_sel)
            instret_count_reg_hi = csr_op_wr_data;
          else if(instr_retired && !mcounterinhibit_instret_count_inh)
            instret_count_reg_hi = next_count_inc[L_XLEN+:L_XLEN];
        end 
        
        assign instret_count[L_XLEN+:L_XLEN] = instret_count_reg_hi;
    
      end else begin :gen_instret_count_hi_lt_xlen 
      
        logic [l_core_cfg_instret_count_width-L_XLEN-1:0]    instret_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            instret_count_reg_hi = {l_core_cfg_instret_count_width-L_XLEN{1'b0}};
          else if(soft_reset_taken_retr)
            instret_count_reg_hi = {l_core_cfg_instret_count_width-L_XLEN{1'b0}};
          else if(csr_reg_wr_sel.minstreth_sw_wr_sel)
            instret_count_reg_hi = csr_op_wr_data[l_core_cfg_instret_count_width-L_XLEN-1:0];
          else if(instr_retired && !mcounterinhibit_instret_count_inh)
            instret_count_reg_hi = next_count_inc[l_core_cfg_instret_count_width-L_XLEN-1:0];
        end 
        
        assign instret_count[L_XLEN+:L_XLEN] = {{((L_XLEN*2)-l_core_cfg_instret_count_width){1'b0}},instret_count_reg_hi}; 
    
      end
       
    end
    else begin :gen_instret_count_hi_lte_xlen
      assign instret_count[L_XLEN+:L_XLEN] = {L_XLEN{1'b0}};
    end
    
    // generate interrupt when msb bit is set
    // this allows the instruction retired counter to have less bits than 64 to reduce area, and allow software to handle wrapping
    assign instret_count_irq_src = instret_count[l_core_cfg_instret_count_width-1];

  end
  else begin : ngen_instret_count 

    assign instret_count          = {(L_XLEN*2){1'b0}}; 
    assign instret_count_irq_src  = 1'b0;

  end
  endgenerate


  assign uinstret_rd_data    = instret_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.uinstret_sw_rd_sel}};
  assign minstret_rd_data    = instret_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.minstret_sw_rd_sel}};
  assign uinstreth_rd_data    = instret_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.uinstreth_sw_rd_sel}};
  assign minstreth_rd_data    = instret_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.minstreth_sw_rd_sel}};
  
//hpmcounter
// Core does not currently support hardware performance monitors
// however csrs are legally addressable
  assign hpmcounter_3_31_rd_data   = {L_XLEN{1'b0}};
  assign mhpmcounter_3_31_rd_data  = {L_XLEN{1'b0}};
  assign hpmcounter_3_31h_rd_data  = {L_XLEN{1'b0}};
  assign mhpmcounter_3_31h_rd_data = {L_XLEN{1'b0}};
  assign hpmevent_3_31_rd_data     = {L_XLEN{1'b0}}; 
  
  assign hpm_count_irq_src         = 1'b0;
  
// Debug and Trace CSRs
//++++++++++++++++++++++++++  

// Trace/trigger registers
// When implemented Core only supports address (execution) triggers)
// The number of triggers is defined by l_core_cfg_num_triggers
// When implemented trigger registers are accessible from debug mode or machine mode
// tselect is an index into the indirectly accessed tdata1 and tdata2 registers; 
// tdata3 is not used by core and always reads 0


// tselect 
  // can always write tselect when addressed as always in machine or debug mode

 
 generate if(l_core_cfg_num_triggers > 0) 
  begin : gen_tselect
  
    logic                                             machine_sw_wr_tselect_wr_en;    
    logic [l_core_cfg_trigger_select_width-1:0]  machine_sw_wr_tselect_wr_data;  
    logic                                             machine_init_wr_tselect_wr_en;  
    logic [l_core_cfg_trigger_select_width-1:0]  machine_init_wr_tselect_wr_data;
    logic [l_core_cfg_trigger_select_width-1:0]  tselect_reg; 
  
    assign machine_sw_wr_tselect_wr_en      = csr_reg_wr_sel.tselect_sw_wr_sel; 
    assign machine_sw_wr_tselect_wr_data    = csr_op_wr_data[l_core_cfg_trigger_select_width-1:0];
    assign machine_init_wr_tselect_wr_en    = soft_reset_taken_retr; //debug_reset_taken_retr | 
    assign machine_init_wr_tselect_wr_data  = {l_core_cfg_trigger_select_width{1'b0}};
    
    assign tselect_reg = 1'b0; // single HW Breakpoint operation

/*  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (l_core_cfg_trigger_select_width),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_tselect
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_tselect_wr_en),
      .init_wr_data                (machine_init_wr_tselect_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    ({l_core_cfg_trigger_select_width{1'b0}}),
      .machine_sw_wr_en            (machine_sw_wr_tselect_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_tselect_wr_data),
      .state_val                   (tselect_reg)
    );
*/
    if(l_core_cfg_trigger_select_width < L_XLEN)
    begin : gen_partial_assign_tselect
      assign tselect           = {{(L_XLEN-l_core_cfg_trigger_select_width){1'b0}}, tselect_reg};
    end
    else begin : gen_full_assign_tselect
      assign tselect           = tselect_reg;
    end // end generate gen_full_assign_tselect
      
  end
  else begin : ngen_tselect
  
    assign tselect           = {L_XLEN{1'b0}};

  end
  endgenerate
  
  assign tselect_rd_data   = tselect & {L_XLEN{csr_reg_rd_sel.tselect_sw_rd_sel}};
  
  
// tdata<n> registers are implemented per-trigger, selected by tselect

   // tdata1, tdata 2

  genvar i_trig_tdata1_2;
  generate if(l_core_cfg_num_triggers > 0) 
  begin : gen_tdata1_2
  
    logic [L_XLEN-1:0]                                tdata1_mcontrol [l_core_cfg_num_triggers-1:0];
    logic [L_XLEN-1:0]                                tdata1_mcontrol_rd_data [l_core_cfg_num_triggers-1:0];
    logic                                             tdata1_mcontrol_sw_rd_sel [l_core_cfg_num_triggers-1:0];
    logic                                             tdata1_mcontrol_sw_wr_sel [l_core_cfg_num_triggers-1:0];
    logic [L_XLEN-1:0]                                tdata1_reg [l_core_cfg_num_triggers-1:0];
    
    logic [l_core_cfg_num_triggers-1:0]          trigger_match; 
    logic [l_core_cfg_num_triggers-1:0]          trigger_hit;
    logic [l_core_cfg_num_triggers-1:0]          per_trigger_excpt;
    logic [l_core_cfg_num_triggers-1:0]          per_trigger_debug;
    

    
    logic [L_XLEN-1:0]                                tdata2_reg [l_core_cfg_num_triggers-1:0];
   
    for(i_trig_tdata1_2 = 0; i_trig_tdata1_2 < l_core_cfg_num_triggers; i_trig_tdata1_2++)
    begin : gen_per_trig_tdata1 
    
      logic [3:0] tdata1_type;
      logic       tdata1_dmode;
      logic       machine_init_wr_tdata1_dmode_wr_en;
      logic       machine_init_wr_tdata1_dmode_wr_data;
      logic       machine_sw_wr_tdata1_dmode_wr_en;
      logic       machine_sw_wr_tdata1_dmode_wr_data;
      logic [5:0] tdata1_mcontrol_maskmax;
      logic       tdata1_mcontrol_hit;
      logic       machine_init_wr_tdata1_mcontrol_hit_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_hit_wr_data;
      logic       machine_implicit_wr_tdata1_mcontrol_hit_wr_en;
      logic       machine_implicit_wr_tdata1_mcontrol_hit_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_hit_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_hit_wr_data;
      logic       tdata1_mcontrol_select;
      logic       machine_init_wr_tdata1_mcontrol_select_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_select_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_select_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_select_wr_data;
      logic       tdata1_mcontrol_timing;
      logic [1:0] tdata1_mcontrol_sizelo;
      logic [3:0] tdata1_mcontrol_action; 
      logic       tdata1_mcontrol_action_reg;
      logic       machine_init_wr_tdata1_mcontrol_action_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_action_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_action_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_action_wr_data;
      logic       tdata1_mcontrol_chain;
      logic [3:0] tdata1_mcontrol_match;
      logic       tdata1_mcontrol_m;
      logic       machine_init_wr_tdata1_mcontrol_m_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_m_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_m_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_m_wr_data;
      logic       tdata1_mcontrol_s;
      logic       tdata1_mcontrol_u;
      logic       tdata1_mcontrol_execute;
      logic       machine_init_wr_tdata1_mcontrol_execute_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_execute_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_execute_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_execute_wr_data;
      logic       tdata1_mcontrol_store;
      logic       tdata1_mcontrol_load;
      
      logic               machine_init_wr_tdata2_match_data_wr_en;
      logic [L_XLEN-1:0]  machine_init_wr_tdata2_match_data_wr_data;
      logic               machine_sw_wr_tdata2_match_data_wr_en;
      logic [L_XLEN-1:0]  machine_sw_wr_tdata2_match_data_wr_data;
      
      logic [L_XLEN-1:0]  tdata2_match_data;
      
      logic [L_XLEN-1:0]  curr_match_data;
      logic               trigger_opcode_match;
      logic               trigger_iaddr_match;
      
      
      // tdata1_type[3:0]
      // Supports only type 2 (instruction address/opcode trigger)
      assign tdata1_type = 4'd2;

      // tdata1_dmode 
      // 0: Both Debug and M-mode can write the tdata
      // registers at the selected tselect.
      // 1: Only Debug Mode can write the tdata registers at the selected tselect. Writes from other
      // modes are ignored.
      // This bit is only writable from Debug Mode.
      
      assign tdata1_dmode = 1'b1; // Debug only triggers
/*      
      assign machine_init_wr_tdata1_dmode_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata1_dmode_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_dmode_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                      (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) & 
                                                      debug_mode;
      assign machine_sw_wr_tdata1_dmode_wr_data     = csr_op_wr_data[27];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_dmode
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_dmode_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_dmode_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_dmode_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_dmode_wr_data),
        .state_val                   (tdata1_dmode)
      );  
*/
      // tdata1_mcontrol_maskmax[5:0]
      // maskmax is always 0 for core 
      assign tdata1_mcontrol_maskmax = 6'd0;

      // tdata1_mcontrol_hit
      // indicates the trigger hit on the match
      
      assign trigger_hit[i_trig_tdata1_2]                     = excpt_trigger[i_trig_tdata1_2] & ~debug_mode;
      
      assign machine_init_wr_tdata1_mcontrol_hit_wr_en        = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata1_mcontrol_hit_wr_data      = 1'b0;
      assign machine_implicit_wr_tdata1_mcontrol_hit_wr_en    = trigger_hit[i_trig_tdata1_2];
      assign machine_implicit_wr_tdata1_mcontrol_hit_wr_data  = 1'b1;
      assign machine_sw_wr_tdata1_mcontrol_hit_wr_en          = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_hit_wr_data        = csr_op_wr_data[20];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_hit
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_hit_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_hit_wr_data),
        .machine_implicit_wr_en      (machine_implicit_wr_tdata1_mcontrol_hit_wr_en),
        .machine_implicit_wr_data    (machine_implicit_wr_tdata1_mcontrol_hit_wr_data),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_hit_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_hit_wr_data),
        .state_val                   (tdata1_mcontrol_hit)
      );  

      // tdata1_mcontrol_select
      // 0: Perform a match on the virtual address.
      // 1: Perform a match on the data value loaded or stored, or the instruction executed. 
      //    Core only supports instruction match, so this will be a match on the opcode
      
      assign tdata1_mcontrol_select = 1'b0; // address match only supported
/*      
      assign machine_init_wr_tdata1_mcontrol_select_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr; // REVISIT should this use reset aligned to ex stage rather than retr?
      assign machine_init_wr_tdata1_mcontrol_select_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_select_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_select_wr_data     = csr_op_wr_data[19];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_select
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_select_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_select_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_select_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_select_wr_data),
        .state_val                   (tdata1_mcontrol_select)
      );  
*/

      // tdata1_mcontrol_timing 
      // Always 0 for Core as it follows the recommendation in the debug specification  
      // to perform address triggers just before the instruction is (or would have been) executed
      assign tdata1_mcontrol_timing  = 1'b0;


      // tdata1_mcontrol_sizelo [1:0]
      // Always 0 for Core as it only performs instruction/opcode matches of any size
      // Compressed opcode matches will automatically only match the bottom 16 bits of tdata2, ignoring the upper bits
      assign tdata1_mcontrol_sizelo  = 2'b00;

      // tdata1_mcontrol_action [3:0]
      // May only be 0 or 1, bits [3:1] will always be 0 in Core
      // 0 Raise a breakpoint exception. (Used when software wants to use the trigger module without an external debugger attached.)
      // 1 Enter Debug Mode. (Only supported when the triggers dmode is 1.)
      
      assign tdata1_mcontrol_action = 4'b0001; // debug entry only supported
/*      
      assign machine_init_wr_tdata1_mcontrol_action_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata1_mcontrol_action_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_action_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_action_wr_data     = csr_op_wr_data[12];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_action
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_action_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_action_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_action_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_action_wr_data),
        .state_val                   (tdata1_mcontrol_action_reg)
      );  
      
      assign tdata1_mcontrol_action = {3'b000,tdata1_mcontrol_action_reg};
*/
      // tdata1_mcontrol_chain
      // Always 0 in Core as it does not supported chained matches 
      assign tdata1_mcontrol_chain = 1'b0;

      // tdata1_mcontrol_match [3:0]
      // Always 0 in Core . Exact match only 
      assign tdata1_mcontrol_match = 4'd0;

      // tdata1_mcontrol_m 
      // When set, enable this trigger in M-mode.
      assign tdata1_mcontrol_m = 1'b1;

/*      
      assign machine_init_wr_tdata1_mcontrol_m_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr; // REVISIT should this be reset aligned to ex rather than retr?
      assign machine_init_wr_tdata1_mcontrol_m_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_m_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                           (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                           ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_m_wr_data     = csr_op_wr_data[6];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_m
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_m_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_m_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_m_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_m_wr_data),
        .state_val                   (tdata1_mcontrol_m)
      );  
*/
      // tdata1_mcontrol_s 
      // When set, enable this trigger in S-mode.
      // Always 0 in core as Supervisor mode does not exist
      assign tdata1_mcontrol_s = 1'b0;

      // tdata1_mcontrol_u 
      // When set, enable this trigger in U-mode.
      // Always 0 in core as User mode does not exixt
      assign tdata1_mcontrol_u = 1'b0;

      // tdata1_mcontrol_execute 
      // When set, the trigger fires on the virtual address or opcode of an instruction that is executed.
      
      assign machine_init_wr_tdata1_mcontrol_execute_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr; // REVISIT should this be reset aligned to ex stage rather than retr?
      assign machine_init_wr_tdata1_mcontrol_execute_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_execute_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_execute_wr_data     = csr_op_wr_data[6];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_execute
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_execute_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_execute_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_execute_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_execute_wr_data),
        .state_val                   (tdata1_mcontrol_execute)
      );  

      // tdata1_mcontrol_store
      // Always 0 for Core as it only supports instruction matching 
      assign tdata1_mcontrol_store = 1'b0;

      // tdata1_mcontrol_load
      // Always 0 for Core as it only supports instruction matching 
      assign tdata1_mcontrol_load = 1'b0;
      
      assign tdata1_reg[i_trig_tdata1_2]          = {tdata1_type,
                                                     tdata1_dmode,
                                                     tdata1_mcontrol_maskmax,
                                                     tdata1_mcontrol_hit,
                                                     tdata1_mcontrol_select,
                                                     tdata1_mcontrol_timing,
                                                     tdata1_mcontrol_sizelo,
                                                     tdata1_mcontrol_action,
                                                     tdata1_mcontrol_chain,
                                                     tdata1_mcontrol_match,
                                                     tdata1_mcontrol_m,
                                                     1'b0,
                                                     tdata1_mcontrol_s,
                                                     tdata1_mcontrol_u,
                                                     tdata1_mcontrol_execute,
                                                     tdata1_mcontrol_store,
                                                     tdata1_mcontrol_load};
                                                   
      //tdata2
      
      assign machine_init_wr_tdata2_match_data_wr_en        = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata2_match_data_wr_data      = {L_XLEN{1'b0}};
      assign machine_sw_wr_tdata2_match_data_wr_en          = csr_reg_wr_sel.tdata2_sw_wr_sel & 
                                                              (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                              ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata2_match_data_wr_data        = csr_op_wr_data[L_XLEN-1:0];
        
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (L_XLEN),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     ({L_XLEN{1'b0}})
      )
      u_tdata2_match_data
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata2_match_data_wr_en),
        .init_wr_data                (machine_init_wr_tdata2_match_data_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    ({L_XLEN{1'b0}}),
        .machine_sw_wr_en            (machine_sw_wr_tdata2_match_data_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata2_match_data_wr_data),
        .state_val                   (tdata2_match_data)
      );  
    
      assign tdata2_reg[i_trig_tdata1_2]  = tdata2_match_data;
      
      // for each trigger, check if enabled and matches
                                                   
      assign curr_match_data                      = tdata2_reg[i_trig_tdata1_2];
      
      assign trigger_opcode_match                 = 1'b0;
      
//      assign trigger_opcode_match                 = ((curr_match_data[1:0] == 2'b11) ? (trigger_instruction_opcode == curr_match_data) :                // uncompressed match
//                                                                                       (trigger_instruction_opcode[15:0] == curr_match_data[15:0])) &   // compressed match
//                                                    trigger_instruction_valid;
                                                    
      assign trigger_iaddr_match                  = (trigger_instruction_address == curr_match_data[I_ADDR_WIDTH-1:0]) &  
                                                    trigger_instruction_valid;                                             
                                          
      assign trigger_match[i_trig_tdata1_2]       = ((tdata1_mcontrol_select == 1'b0) ? trigger_iaddr_match : trigger_opcode_match) &
                                                    tdata1_mcontrol_m &
                                                    tdata1_mcontrol_execute;     
      
      assign per_trigger_excpt[i_trig_tdata1_2]  = 1'b0;
      
//      assign per_trigger_excpt[i_trig_tdata1_2]  = trigger_hit[i_trig_tdata1_2] & ~tdata1_mcontrol_action[i_trig_tdata1_2]; 
      assign per_trigger_debug[i_trig_tdata1_2]  = trigger_hit[i_trig_tdata1_2] & tdata1_mcontrol_action[i_trig_tdata1_2]; 
       
      assign trigger_req[i_trig_tdata1_2]        = trigger_match[i_trig_tdata1_2];
                            
                                                 
    end // for-generate gen_per_trig_tdata1
    
    // mux per-trigger tdata1 registers based on tselect 
    
    assign tdata1 = tdata1_reg[tselect[l_core_cfg_trigger_select_width-1:0]];    
    assign tdata2 = tdata2_reg[tselect[l_core_cfg_trigger_select_width-1:0]]; 
    
    // as per debug spec, if separate triggers generate trap (breakpoint exception) and enter debug mode simulataneously
    // allowable behaviour is to do both (in n defined order), or just enter debug mode (with hit still updated, but no trap)
    // In Core l_cfg_core_trigger_both = 1 allows both debug enter and trap to be generated simultaneously
    // In this mode trap generation and the register updating side effects will occur as usual, with debug mode also entered
    // To make it appear as if a trap was executed DPC will be updated with the exception vector rather than the current program counter
    // When debug mode is exited, execution will resume at the trap vector.
    // In Core l_cfg_core_trigger_both = 0 prevents simultaneous generation and will only allow debug mode to be entered but 
    // any trap generation will be supressed 
    // In this case DPC will be loaded with the current PC as this would be the next instruction to execute (but it is suppressed from
    // updating state by debug enter)
    
    assign excpt_trigger_debug_taken = |per_trigger_debug;
    
    
    if(l_cfg_core_trigger_both) begin : gen_trigger_break_both
      assign excpt_trigger_break_taken           = (|per_trigger_excpt);
      assign excpt_trigger_dpc                   = curr_pc;
      assign excpt_trigger_break_taken_and_debug = excpt_trigger_break_taken; 
    end
    else begin : ngen_trigger_break_debug_pri
      assign excpt_trigger_break_taken           = (|per_trigger_excpt) & ~excpt_trigger_debug_taken;
      assign excpt_trigger_dpc                   = excpt_trigger_break_taken ? mtvec_base : curr_pc;
      assign excpt_trigger_break_taken_and_debug = 1'b0;
    end
    // endgenerate if l_cfg_core_trigger_both        
    
    
  end // if-generate gen_tdata1_2
  else begin : ngen_tdata1_2
    
    assign tdata1                              = {L_XLEN{1'b0}};
    assign tdata2                              = {L_XLEN{1'b0}}; 
    assign excpt_trigger_break_taken           = 1'b0; 
    assign excpt_trigger_debug_taken           = 1'b0;
    assign trigger_req[0]                      = 1'b0;
    assign excpt_trigger_break_taken_and_debug = 1'b0;
    
  end
  endgenerate
  
  assign tdata1_rd_data   = tdata1 & {L_XLEN{csr_reg_rd_sel.tdata1_sw_rd_sel}};
  assign tdata2_rd_data   = tdata2 & {L_XLEN{csr_reg_rd_sel.tdata2_sw_rd_sel}};                                                  

  
// tdata3 not implemented on core, but still legally addressable
  assign tdata3           = {L_XLEN{1'b0}}; 
  assign tdata3_rd_data   = tdata3 & {L_XLEN{csr_reg_rd_sel.tdata3_sw_rd_sel}}; 
  
// tinfo
// Not implemented as type is read-only. 
// Attempted accesses to this register will cause an illegal instruction exception 

// tcontrol
// Not implemented 
// Attempted accesses to this register will cause an illegal instruction exception 

// mcontext
// Not implemented 
// Attempted accesses to this register will cause an illegal instruction exception 

// scontext
// Not implemented 
// Attempted accesses to this register will cause an illegal instruction exception 

// Debug registers
//----------------
  
  generate if(l_core_cfg_hw_debug != 0) 
  begin : gen_debug
  
    logic                             next_debug_reset_pending; 
    logic                             debug_reset_pending;
    logic                             debugger_wr_dcsr_ebreakm_wr_en;    
    logic                             debugger_wr_dcsr_ebreakm_wr_data;  
    logic                             init_wr_dcsr_ebreakm_en;  
    logic                             init_wr_dcsr_ebreakm_wr_data;    
    logic                             debugger_wr_dcsr_stepie_wr_en;    
    logic                             debugger_wr_dcsr_stepie_wr_data;  
    logic                             init_wr_dcsr_stepie_en;  
    logic                             init_wr_dcsr_stepie_wr_data;
    logic                             debugger_wr_dcsr_stopcount_wr_en;    
    logic                             debugger_wr_dcsr_stopcount_wr_data;  
    logic                             init_wr_dcsr_stopcount_en;  
    logic                             init_wr_dcsr_stopcount_wr_data;
    logic                             debugger_wr_dcsr_stoptime_wr_en;    
    logic                             debugger_wr_dcsr_stoptime_wr_data;  
    logic                             init_wr_dcsr_stoptime_en;  
    logic                             init_wr_dcsr_stoptime_wr_data;
    logic                             init_wr_dcsr_cause_en;  
    logic [2:0]                       init_wr_dcsr_cause_wr_data;  
    logic                             implicit_wr_dcsr_cause_en;  
    logic [2:0]                       implicit_wr_dcsr_cause_wr_data;
    logic                             debugger_wr_dcsr_step_wr_en;    
    logic                             debugger_wr_dcsr_step_wr_data;  
    logic                             init_wr_dcsr_step_en;  
    logic                             init_wr_dcsr_step_wr_data;
    logic                             debugger_wr_dpc_pc_wr_en;    
    logic [I_ADDR_WIDTH-1:0]          debugger_wr_dpc_pc_wr_data;  
    logic                             init_wr_dpc_pc_en;  
    logic [I_ADDR_WIDTH-1:0]          init_wr_dpc_pc_wr_data; 
    logic                             implicit_wr_dpc_pc_en;  
    logic [I_ADDR_WIDTH-1:0]          implicit_wr_dpc_pc_wr_data; 
    logic                             trigger_debug_enter_pending; 
    logic                             set_trigger_debug_enter_pending;
    logic                             clr_trigger_debug_enter_pending; 
    logic                             ebreak_debug_enter_req;
    logic                             trigger_debug_enter_req;     
    logic                             set_haltreq_debug_enter_pending;
    logic                             clr_haltreq_debug_enter_pending;
    logic                             haltreq_debug_enter_pending;
    logic                             set_resethaltreq_debug_enter_pending;
    logic                             clr_resethaltreq_debug_enter_pending;
    logic                             resethaltreq_debug_enter_pending;    
    logic                             set_step_debug_enter_pending;
    logic                             clr_step_debug_enter_pending;
    logic                             step_debug_enter_pending;
    
    
  // Need to ensure debug_reset occurs (debug_reset_taken_retr asserted) only when an instruction is completing
  // to ensure reset handling instruction is inserted without anything outstanding in the retr stage
  // stage.
  // Reset must take priority over new instructions and must happen if no instructions in flight
  
  assign next_debug_reset_pending = (debug_reset_pending & ~debug_reset_taken_retr) | debug_reset;
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      debug_reset_pending <= 1'b0;
    else
      debug_reset_pending <= next_debug_reset_pending;
  end
  
  assign debug_reset_taken_retr = debug_reset_pending & (instr_completing_retr | ~instr_valid_retr) & ~debug_mode_enter_req;    
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      debug_active_retr  <= 1'b0;
    else
      if((instr_completing_retr | ~instr_valid_retr) & ~debug_mode_enter_req)
        debug_active_retr <= debug_active;
  end

    
    // DCSR
    //xdebugver [3:0]
    // read only, fixed at 4'd4 when debug implemented      
    assign dcsr_xdebugver = 4'd4;

    //ebreakm     
    assign debugger_wr_dcsr_ebreakm_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_ebreakm_wr_data  = csr_op_wr_data[15];
    assign init_wr_dcsr_ebreakm_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_ebreakm_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_ebreakm
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_ebreakm_en),
      .init_wr_data                (init_wr_dcsr_ebreakm_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_ebreakm_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_ebreakm_wr_data),
      .state_val                   (dcsr_ebreakm)
    );
    
    //ebreaks
    assign dcsr_ebreaks = 1'b0;

    //ebreaku
    assign dcsr_ebreaku = 1'b0;
    
    //stepie   
    assign debugger_wr_dcsr_stepie_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_stepie_wr_data  = csr_op_wr_data[11];
    assign init_wr_dcsr_stepie_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_stepie_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_stepie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_stepie_en),
      .init_wr_data                (init_wr_dcsr_stepie_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_stepie_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_stepie_wr_data),
      .state_val                   (dcsr_stepie)
    );
    
    //stopcount   
    assign debugger_wr_dcsr_stopcount_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_stopcount_wr_data  = csr_op_wr_data[10];
    assign init_wr_dcsr_stopcount_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_stopcount_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_stopcount
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_stopcount_en),
      .init_wr_data                (init_wr_dcsr_stopcount_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_stopcount_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_stopcount_wr_data),
      .state_val                   (dcsr_stopcount)
    );
    
    //stoptime   
    assign debugger_wr_dcsr_stoptime_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_stoptime_wr_data  = csr_op_wr_data[9];
    assign init_wr_dcsr_stoptime_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_stoptime_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_stoptime
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_stoptime_en),
      .init_wr_data                (init_wr_dcsr_stoptime_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_stoptime_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_stoptime_wr_data),
      .state_val                   (dcsr_stoptime)
    );
    
    //cause   
    // Note , Not writeable by debugger
    assign init_wr_dcsr_cause_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_cause_wr_data      = 3'b000;
    assign implicit_wr_dcsr_cause_en       = debug_enter_taken;
    assign implicit_wr_dcsr_cause_wr_data  = trigger_debug_enter_taken ? 3'd2 :
                                               ebreak_debug_enter_taken ? 3'd1 :
                                                 resethaltreq_debug_enter_taken ? 3'd5 :
                                                    haltreq_debug_enter_taken ? 3'd3 :
                                                      step_debug_enter_taken ? 3'd4 : 3'd0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (3),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_cause
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_cause_en),
      .init_wr_data                (init_wr_dcsr_cause_wr_data),
      .machine_implicit_wr_en      (implicit_wr_dcsr_cause_en),
      .machine_implicit_wr_data    (implicit_wr_dcsr_cause_wr_data),
      .machine_sw_wr_en            (1'b0),
      .machine_sw_wr_data          (3'b000),
      .state_val                   (dcsr_cause)
    );

    //mprven    
    assign dcsr_mprven  = 1'b0;
    
    //nmip
    assign dcsr_nmip = 1'b0; // REVISIT does soft reset count as this?

    //step   
    assign debugger_wr_dcsr_step_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_step_wr_data  = csr_op_wr_data[2];
    assign init_wr_dcsr_step_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_step_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_step
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_step_en),
      .init_wr_data                (init_wr_dcsr_step_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_step_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_step_wr_data),
      .state_val                   (dcsr_step)
    );
    
    // prv
    assign dcsr_prv = 2'd3; // Core can only ever be in machine mode when debug entered
    
    //DPC
    
    //pc   
    assign debugger_wr_dpc_pc_wr_en    = csr_reg_wr_sel.dpc_debugger_wr_sel; 
    assign debugger_wr_dpc_pc_wr_data  = csr_op_wr_data[I_ADDR_WIDTH-1:0];
    assign init_wr_dpc_pc_en           = soft_reset_taken_retr;
    assign init_wr_dpc_pc_wr_data      = l_core_reset_vector;
    assign implicit_wr_dpc_pc_en       = debug_enter_taken & ~debug_mode;  // don't update dpc if already in debug mode as the next instruction is already in dpc
    assign implicit_wr_dpc_pc_wr_data  = trigger_debug_enter_taken ? excpt_trigger_dpc : // <CL> Update dpc on trigger_debug_enter_taken
                                          ebreak_debug_enter_taken ? excpt_trigger_dpc :  // trigger is handled as ebreak 
                                           resethaltreq_debug_enter_taken ? l_core_reset_vector : 
                                              haltreq_debug_enter_taken ? curr_pc :                           
                                                step_debug_enter_taken ? curr_pc : dpc_reg; 
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (I_ADDR_WIDTH),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (l_core_reset_vector)
    )
    u_csr_gpr_state_reg_dpc_pc
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dpc_pc_en),
      .init_wr_data                (init_wr_dpc_pc_wr_data),
      .machine_implicit_wr_en      (implicit_wr_dpc_pc_en),
      .machine_implicit_wr_data    (implicit_wr_dpc_pc_wr_data),
      .machine_sw_wr_en            (debugger_wr_dpc_pc_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dpc_pc_wr_data),
      .state_val                   (dpc_reg)
    );
    

  // debug state entry/exit
    
  // step 
  // When step is enabled and not in debug mode, execute an instruction then enter debug mode
  // 
  // Step can only be enabled when in debug mode, therefore the pipline will already be flushed on exiting debug mode (resume request) to perform the step
  // by branching to DPC (debug exit branch pseudo instruction branching to the instruction to execute)
  // Step can only be disabled when in debug mode, therefore resumption is a normal resume request causing debug exit branch to execute  
  
    assign set_step_debug_enter_pending = dcsr_step & ~debug_mode & step_instruction_valid;
    assign clr_step_debug_enter_pending = step_debug_enter_taken | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        step_debug_enter_pending <= 1'b0;
      else
        if(set_step_debug_enter_pending | clr_step_debug_enter_pending)
          step_debug_enter_pending <= set_step_debug_enter_pending & ~clr_step_debug_enter_pending;
    end
    
    assign step_debug_enter_taken  = step_debug_enter_pending & debug_instr_debug_enter_req;
  
 
    
  // trigger/ebreak
  // enter debug mode when dcsr_ebreakm = 1 and the debugger is attached (debug_active_retr = 1), else raise ebreak exception
  // enter debug mode when trigger taken and the debugger is attached (debug_active_retr = 1), else raise ebreak exception
  
    // pending keeps track of any triggers in the pipeline pending and not yet taken.
    // Trigger may cause a debug-entry, or may cause an exception, but still use to generate debug entry req
    // because even if exception, rather than debug taken by the time the request reaches the retr stage,
    // would still have had to flush the pipeline (which happens for trap or debug entry)

    assign set_trigger_debug_enter_pending = |trigger_req; 
    assign clr_trigger_debug_enter_pending = flush | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        trigger_debug_enter_pending <= 1'b0;
      else
        if(set_trigger_debug_enter_pending | clr_trigger_debug_enter_pending)
          trigger_debug_enter_pending <= set_trigger_debug_enter_pending & ~clr_trigger_debug_enter_pending;
    end
    
    assign ebreak_debug_enter_req     = (excpt_breakpoint & dcsr_ebreakm) & debug_active_retr;
    assign ebreak_debug_enter_taken   = ebreak_debug_enter_req & instr_valid_retr; 
        
    assign trigger_debug_enter_req     = excpt_trigger_debug_taken & debug_active_retr;
    assign trigger_debug_enter_taken    = trigger_debug_enter_req & instr_valid_retr;
  
  // haltreq (from debug module)
  
  // When a halt is requested, the instruction at the DE stage is marked as a debug request, which will suppress any architectural state updates
  // associated with thre marked instruction. All subsequent instructions will be marked, which will prevent any following load-store 
  // instructions being launched in the EX phase
  // when the marked instruction reaches the retr stage, halt_debug_taken will be asserted which will suppress any instructions state updates, and
  // (so this instruction will appear to have not executed at all) and enter debug mode     
  
    assign set_haltreq_debug_enter_pending = debug_halt_req; 
    assign clr_haltreq_debug_enter_pending = haltreq_debug_enter_taken | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        haltreq_debug_enter_pending <= 1'b0;
      else
        if(set_haltreq_debug_enter_pending | clr_haltreq_debug_enter_pending)
          haltreq_debug_enter_pending <= set_haltreq_debug_enter_pending & ~clr_haltreq_debug_enter_pending;
    end

    assign haltreq_debug_enter_taken  = (haltreq_debug_enter_pending & debug_instr_debug_enter_req) | 
                                        (debug_mode & debug_halt_req);
    assign debug_halt_ack             = haltreq_debug_enter_taken |
                                        (debug_halt_req & debug_enter_taken); // take care of corner case when enter debug due to other cause
                                                                              // at same time as req 

  // resethaltreq 
  
  // When a resethalt is requested and reset is assrted, the normal reset mechanism will cause the pipeline to be flushed, and a branch to reset pseudo instruction
  // (branch to reset vector) inserted into the DE stage, this will also cause resetable architectural state to be reset.
  // The debug enter pending will occur immediatel yafter this which using the normal debug entry mechanism, will cause all subsequent instruction (or inserted debug nops)
  // to be marked as debug entry and supressed. Note that the reset branch will cause instructions behind it to be flushed, but the debug entry pending will
  // persist until it reaches the retire stage at which point debug mode will be entered and resethalt_ack asserted
     
  
    assign set_resethaltreq_debug_enter_pending = debug_resethalt_req & soft_reset_taken_retr; 
    assign clr_resethaltreq_debug_enter_pending = resethaltreq_debug_enter_taken | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        resethaltreq_debug_enter_pending <= 1'b0;
      else
        if(set_resethaltreq_debug_enter_pending | clr_resethaltreq_debug_enter_pending)
          resethaltreq_debug_enter_pending <= set_resethaltreq_debug_enter_pending & ~clr_resethaltreq_debug_enter_pending;
    end

    assign resethaltreq_debug_enter_taken  = resethaltreq_debug_enter_pending & debug_instr_debug_enter_req;
                                             
    assign debug_resethalt_ack            = resethaltreq_debug_enter_taken |
                                             (debug_resethalt_req & debug_enter_taken); // take care of corner case when enter debug due to other cause
                                                                                             // at same time as req

    // request to the start of the pipeline to mark debug entry request
    assign debug_mode_enter_req       = resethaltreq_debug_enter_pending | haltreq_debug_enter_pending | step_debug_enter_pending | trigger_debug_enter_pending; 
    
    assign debug_enter_taken          = ebreak_debug_enter_taken | 
                                        trigger_debug_enter_taken | 
                                        resethaltreq_debug_enter_taken |
                                        haltreq_debug_enter_taken | 
                                        step_debug_enter_taken;
                                        
    assign debug_exit_taken           = debug_mode & (debug_resume_req | debug_reset_taken_retr | soft_reset_taken_retr);           
    assign debug_resume_ack           = debug_exit_taken & ~debug_reset_taken_retr;              
    
    // instructions should not retire when debug mode is entered, except when entry is caused by an ebreak instruction
    // entry due to an ebreak instruction should not be masked. Not ebreak is higher priority than haltreq or step
    assign debug_mode_retire_mask     = trigger_debug_enter_taken | 
                                        (resethaltreq_debug_enter_taken & ~ebreak_debug_enter_taken) |
                                        (haltreq_debug_enter_taken & ~ebreak_debug_enter_taken) |
                                        (step_debug_enter_taken  & ~ebreak_debug_enter_taken);    
                              
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        debug_mode  <= 1'b0;
      else
        if(debug_enter_taken | debug_exit_taken)
          debug_mode  <= debug_enter_taken & ~debug_exit_taken;
    end
      
  end  // end if-generate gen_debug
  else begin : ngen_debug
  
    assign debug_reset_taken_retr     = 1'b0;
    assign debug_active_retr          = 1'b0;
  
    // DCSR
    assign dcsr_xdebugver =  4'd0;
    assign dcsr_ebreakm   =  1'b0;
    assign dcsr_ebreaks   =  1'b0;
    assign dcsr_ebreaku   =  1'b0;
    assign dcsr_stepie    =  1'b0;
    assign dcsr_stopcount =  1'b0;
    assign dcsr_stoptime  =  1'b0;
    assign dcsr_cause     =  3'd0;
    assign dcsr_mprven    =  1'b0;
    assign dcsr_nmip      =  1'b0;
    assign dcsr_step      =  1'b0;
    assign dcsr_prv       =  2'd3;
    
    // DPC
    assign dpc_reg = {I_ADDR_WIDTH{1'b0}};
    
    assign debug_mode             = 1'b0;
    assign debug_halt_ack         = 1'b0;
    assign debug_resethalt_ack    = 1'b0;
    assign debug_resume_ack       = 1'b0;
    assign debug_enter_taken      = 1'b0;  
    assign debug_mode_retire_mask = 1'b0;   
    assign debug_exit_taken       = 1'b0; 
    assign debug_mode_enter_req   = 1'b0;
    
    assign step_debug_enter_taken = 1'b0;   
    assign resethaltreq_debug_enter_taken = 1'b0;    
    assign haltreq_debug_enter_taken = 1'b0; 
    assign trigger_debug_enter_taken = 1'b0; 
    assign ebreak_debug_enter_taken = 1'b0;  
    
        
  end
  endgenerate
     
  
  assign debug_mode_enter       = debug_enter_taken;                          
  assign debug_mode_exit        = debug_exit_taken;  
  
  assign dcsr = {dcsr_xdebugver,
                 {12{1'b0}},
                 dcsr_ebreakm, 
                 1'b0, 
                 dcsr_ebreaks,  
                 dcsr_ebreaku,  
                 dcsr_stepie,   
                 dcsr_stopcount,
                 dcsr_stoptime, 
                 dcsr_cause,  
                 1'b0,  
                 dcsr_mprven,   
                 dcsr_nmip,     
                 dcsr_step,     
                 dcsr_prv};                      
  
  assign dcsr_rd_data   = dcsr & {L_XLEN{csr_reg_rd_sel.dcsr_debugger_rd_sel}};
  
  generate if(I_ADDR_WIDTH < L_XLEN) begin : gen_assign_partial_addr_dpc
    assign dpc = {{(L_XLEN-I_ADDR_WIDTH){1'b0}},dpc_reg};
  end
  else begin : gen_assign_full_addr_dpc 
    assign dpc = dpc_reg[I_ADDR_WIDTH-1:0];
  end // end if-generate
  endgenerate
  
  assign dpc_rd_data   = dpc & {L_XLEN{csr_reg_rd_sel.dpc_debugger_rd_sel}};

 // DSCRATCH0  
  assign dscratch0 = {L_XLEN{1'b0}};
  assign dscratch0_rd_data = dscratch0 & {L_XLEN{csr_reg_rd_sel.dscratch0_debugger_rd_sel}};
  
 // DSCRATCH1  
  assign dscratch1 = {L_XLEN{1'b0}};
  assign dscratch1_rd_data = dscratch1 & {L_XLEN{csr_reg_rd_sel.dscratch1_debugger_rd_sel}};

// read mux
// ---------
// read data from each register already masked with rd_enable so just need to "or"
	
  assign csr_op_rd_data = fcsr_rd_data |
                          frm_rd_data |
                          fflags_rd_data |
                          mvendorid_rd_data |
                          marchid_rd_data |                         
                          mimpid_rd_data |
                          mhartid_rd_data |
                          mstatus_rd_data |
                          sstatus_rd_data |
                          ustatus_rd_data |
                          misa_rd_data |
                          medeleg_rd_data |
                          mideleg_rd_data |
                          mie_rd_data |
                          sie_rd_data |
                          uie_rd_data |
                          mip_rd_data |
                          sip_rd_data |
                          uip_rd_data |
                          mtvec_rd_data |
                          mepc_rd_data |
                          mcause_rd_data |
                          mtval_rd_data |
                          mcounteren_rd_data |
                          mcounterinhibit_rd_data |
                          mscratch_rd_data |
                          pmpcfg_0_3_rd_data |
                          pmpaddr_0_15_rd_data |
                          sideleg_rd_data |
                          sedeleg_rd_data |
                          stvec_rd_data |
                          sepc_rd_data |
                          scause_rd_data |
                          stval_rd_data | 
                          scounteren_rd_data |
                          sscratch_rd_data |
                          satp_rd_data |
                          utvec_rd_data |
                          uepc_rd_data |
                          ucause_rd_data |
                          utval_rd_data | 
                          uscratch_rd_data |
                          ucycle_rd_data |
                          ucycleh_rd_data |
                          mcycle_rd_data |
                          mcycleh_rd_data |
                          utime_rd_data |
                          utimeh_rd_data |
                          uinstret_rd_data |
                          uinstreth_rd_data |
                          minstret_rd_data |
                          minstreth_rd_data |
                          hpmcounter_3_31_rd_data |
                          hpmcounter_3_31h_rd_data |
                          mhpmcounter_3_31_rd_data |
                          mhpmcounter_3_31h_rd_data |
                          hpmevent_3_31_rd_data |
                          tselect_rd_data |
                          tdata1_rd_data |
                          tdata2_rd_data |
                          tdata3_rd_data |
                          dcsr_rd_data |
                          dpc_rd_data |
                          dscratch0_rd_data |
                          dscratch1_rd_data;
                          
  assign debug_csr_op_rd_data = csr_op_rd_data;  
  assign debug_csr_op_rd_data_valid = debug_mode & csr_op_rd_valid;                            
  assign csr_op_rd_data_valid = 1'b1;                                             
  
  // csr write hazard detetction  
                             
  // op ready when external operands are valid for write, or always for read only
  assign csr_op_ready = csr_alu_wr_op_ready; 
  
  // assign CSR regsister/privileged state/intermediate values used elsewhere
    assign csr_priv_misa              = misa;  
    assign csr_priv_cause_excpt_code  = mcause_excpt_code;
    assign csr_priv_soft_reset_taken  = soft_reset_taken_retr; 
    assign csr_priv_interrupt_taken   = interrupt_taken;   
    assign csr_priv_priv_mode         = priv_mode;
    assign csr_priv_debug_mode        = debug_mode;  
    assign csr_priv_epc               = mepc;  
    assign csr_priv_dpc               = dpc;     
                             
// Wait for interrupt handling
// When a wait for interrupt instruction is retired, if no unmasked interrupts are pending (masked in ie, global ie ignored) then wfi_waiting will be asserted 
// causing the pipeline to stall until an unmasked interrupt is received. 
// If no interrupts are enabled in ie when the wfi instruction is retired, execution will continue without asserting wfi_waiting.
// If debug mode is entered (ebreak executed, triggered, hakltreq set, or stepped) whilst the wfi instruction is retired or wfi_waiting is asserted, wfi_waiting 
// will be deasserted.
// If soft reset is asserted, wfi_waiting will be deasserted
// Clear WFI when an interrupt source is captured for a locally enabled interrupt. Use this insted of local enable & pending, because pending is only asserted
// when it is safe to commit an interrupt - this includes the instr_valid_retr term because it is necessary to have a valid PC in the retr stage to put in mepc 
// when the interrupt is taken. This may not be present when waifting for an interrupt, therefore pending cannot be set. This is necessary because the interrupt
// should not be taken until the pc for the next instruction is present as defined in section 3.2.3 of the RISC-V architecture

  assign set_wfi_waiting = (instr_wfi & instr_valid_retr & (|mie)); 
  assign clr_wfi_waiting = soft_reset_taken_retr | debug_enter_taken | locally_enabled_irq_captured; //(|(mip & mie));
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      wfi_waiting_reg <= 1'b0;
    else
      if(set_wfi_waiting | clr_wfi_waiting)
        wfi_waiting_reg <= set_wfi_waiting & ~clr_wfi_waiting;
  end   
  
  assign wfi_waiting =   wfi_waiting_reg | set_wfi_waiting; // & ~clr_wfi_waiting);                           

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  // hart id must be static
  assert_csr_priv_hartid_static : assert property (@(posedge clk) disable iff (~resetn)
                                                   $stable(hart_id));
  
  // A WFI instruction will always complete straight away
  assert_csr_priv_wfi_retire_immediately : assert property (@(posedge clk) disable iff (~resetn)
                                                            (instr_valid_retr & instr_wfi & ~debug_enter_taken) |-> instr_retired);
                                                            
  // can never be in debug mode when debug_active_retr is not asserted
  assert_csr_priv_never_debug_when_not_active : assert property (@(posedge clk) disable iff (~resetn)
                                                            debug_mode |-> debug_active_retr);
                                                            
  // If waiting for an interrupt, will eventually resume
  assert_csr_priv_wfi_eventually_resume : assert property (@(posedge clk) disable iff (~resetn)
                                                            wfi_waiting |-> ##[0:$] clr_wfi_waiting);                                                            


  cover_csr_priv_wfi_taken_wait: cover property (@(posedge clk) disable iff (~resetn)    
                                                      (!(soft_reset_taken_retr | debug_enter_taken)) throughout((set_wfi_waiting & ~clr_wfi_waiting) ##1
                                                                                                                (~set_wfi_waiting & ~clr_wfi_waiting)));                                                            
                                                            
  cover_csr_priv_wfi_taken_wait_exit: cover property (@(posedge clk) disable iff (~resetn)    
                                                      (!(soft_reset_taken_retr | debug_enter_taken)) throughout((set_wfi_waiting & ~clr_wfi_waiting) ##1
                                                                                                                (~set_wfi_waiting & ~clr_wfi_waiting) ##[1:$]
                                                                                                             (~set_wfi_waiting & clr_wfi_waiting)));
  
  // Exception properties
  
  cover_csr_priv_excpt_i_addr_misalign_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_i_addr_misalign);      
                                              
  cover_csr_priv_excpt_i_access_fault_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_i_access_fault);  
                                              
  cover_csr_priv_excpt_illegal_instr_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_illegal_instr);    
                                              
  cover_csr_priv_excpt_ebreak_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_ebreak);
                                              
  cover_csr_priv_excpt_trigger_break_taken_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_trigger_break_taken);                                                                                                                                                                                           

  cover_csr_priv_excpt_ld_addr_misalign_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_ld_addr_misalign);  
                                              
  cover_csr_priv_excpt_ld_access_fault_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_ld_access_fault); 
                                                                                            
  cover_csr_priv_excpt_str_amo_addr_misalign_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_str_amo_addr_misalign);  
                                              
  cover_csr_priv_excpt_str_amo_access_fault_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_str_amo_access_fault);    
                                              
  cover_csr_priv_excpt_m_env_callt_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_m_env_call);  
                                              
  cover_csr_priv_excpt_s_env_callt_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_s_env_call); 
                                              
  cover_csr_priv_excpt_u_env_callt_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_u_env_call);   
                                              
  cover_csr_priv_excpt_bus_error_i_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_bus_error_i);
                                              
  cover_csr_priv_excpt_parity_error_i_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_parity_error_i);                                                                                                                                                                                                                                                                                                                           
                                                     
  cover_csr_priv_excpt_bus_error_d_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_bus_error_d);
                                              
  cover_csr_priv_excpt_parity_error_d_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_parity_error_d); 
  
  
  // covers
  //-------
  genvar i_cover_step_seq;
  generate if(l_core_cfg_hw_debug != 0) 
  begin : gen_debug_covers
  
    // step
  
    sequence seq_csr_priv_step_exec;
      (step_debug_enter_taken ##[1:$] debug_exit_taken ##[1:$] instr_retired);
    endsequence
  
   // sequence seq_csr_priv_step_repeat_exec(cycles);
   //   seq_csr_priv_step_exec[->cycles];
   // endsequence
  
    // enter debug mode when stepping
  
    cover_csr_priv_debug_enter_step: cover property (@(posedge clk) disable iff (~resetn)
                                                      step_debug_enter_taken);

    // enter debug after step, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_step: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(instr_retired ##[1:$] 
                                                                                                                                   step_debug_enter_taken ##[1:$] 
                                                                                                                                   debug_exit_taken ##[1:$] 
                                                                                                                                   instr_retired));
 
    // perform multiple steps
  
    cover_csr_priv_debug_step: cover property (@(posedge clk) disable iff (~resetn)
                                                 ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(seq_csr_priv_step_exec ##[1:$] 
                                                                                                                               seq_csr_priv_step_exec ##[1:$]
                                                                                                                               seq_csr_priv_step_exec));
                                                 
                                                 
  // if step mode is enabled, cannot have 2 instructions executed consequitively without entering debug mode in between
  logic [1:0]   prop_next_step_instr_count;
  logic [1:0]   prop_step_instr_count;  
  
  assign prop_next_step_instr_count = debug_enter_taken ? 2'd0 : (instr_retired & dcsr_step) ? prop_step_instr_count + 2'd1 : prop_step_instr_count;
    
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_step_instr_count <= 2'd0;
    else
      prop_step_instr_count <= prop_next_step_instr_count;
  end
  
  
  
  
  // debug prioperties
    
    
    
    assert_csr_priv_debug_step_must_debug_after_retire: assert property (@(posedge clk) disable iff (~resetn)
                                                                         prop_step_instr_count < 2'd2);
    
  
    // trigger   
    cover_csr_priv_debug_enter_trigger: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] trigger_debug_enter_taken);

    // enter debug after trigger, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_trigger: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(instr_retired[->2:$] ##[1:$]
                                                                                    trigger_debug_enter_taken ##[1:$] 
                                                                                    debug_exit_taken ##[1:$] 
                                                                                    instr_retired));
  
    // halt request
    cover_csr_priv_debug_enter_haltreq: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] haltreq_debug_enter_taken);

    // enter debug after haltreq, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_haltreq: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(instr_retired[->2:$] ##[1:$]
                                                                                                                  haltreq_debug_enter_taken ##[1:$] 
                                                                                                                  debug_exit_taken ##[1:$] 
                                                                                                                  instr_retired));
                                                                                                                  
    assert_csr_priv_debug_haltreq_must_debug: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_halt_req |-> ##[1:$]  debug_mode);
                                                               
                                                               
     assert_csr_priv_debug_haltreq_must_ack: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_halt_req |-> ##[0:$]  debug_halt_ack);                                                                                                                                                                         

    
     cover_csr_priv_debug_enter_haltreq_in_reset: cover property (@(posedge clk) disable iff (~resetn)
                                                                 (soft_reset & ~ debug_reset_taken_retr) throughout(soft_reset_taken_retr ##[1:$]
                                                                                                                    debug_halt_req ##[1:$]
                                                                                                                    haltreq_debug_enter_taken));
                                                                                                                    

    // reset halt request
    cover_csr_priv_debug_enter_resethaltreq: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] resethaltreq_debug_enter_taken);

    // enter debug after resethaltreq, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_resethaltreq: cover property (@(posedge clk) disable iff (~resetn)
        debug_resethalt_req ##[1:$] ~(debug_reset_taken_retr | soft_reset_taken_retr) throughout(instr_retired[->2:$] ##[1:$]
                                                                                                      haltreq_debug_enter_taken ##[1:$] 
                                                                                                      debug_exit_taken ##[1:$] 
                                                                                                      instr_retired));
                                                                                                                  
    assert_csr_priv_debug_resethaltreq_must_debug: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_resethalt_req |-> ##[1:$]  (~debug_resethalt_req | debug_mode));
                                                               
                                                               
     assert_csr_priv_debug_resethaltreq_must_ack: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_resethalt_req |-> ##[0:$]  (~debug_resethalt_req |debug_resethalt_ack));                                                                                                                                                                         

    
                                                                                                                                                                                                                                        

    // ebreak
    cover_csr_priv_debug_enter_ebreak: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] ebreak_debug_enter_taken);

    // enter debug after ebreak, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_ebreak: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr) throughout(instr_retired[->2:$] ##[1:$] 
                                                                                                                 ebreak_debug_enter_taken ##[1:$] 
                                                                                                                 debug_exit_taken ##[1:$] 
                                                                                                                 instr_retired));
                                         
  end
  endgenerate  
  
  cover_csr_priv_simultaneous_irq_sw_ext_both_handled: cover property (@(posedge clk) disable iff (~resetn)  
          ext_meip throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]
          (~ext_msip throughout((trap_return & instr_completing_retr) ##[1:$] interrupt_taken ##[1:$] (trap_return & instr_completing_retr)))));

  cover_csr_priv_simultaneous_irq_sw_ext_nested_sub01: cover property (@(posedge clk) disable iff (~resetn) 
          (ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip))); 

  cover_csr_priv_simultaneous_irq_sw_ext_nested_sub1: cover property (@(posedge clk) disable iff (~resetn) 
          (ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]         
          (~ext_msip throughout((status_mie & instr_completing_retr) ##[0:$] interrupt_taken))) );             
            
  cover_csr_priv_simultaneous_irq_sw_ext_nested: cover property (@(posedge clk) disable iff (~resetn) 
          ((ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]         
          (~ext_msip throughout((status_mie & instr_completing_retr) ##[0:$] interrupt_taken)))) ##[1:$] (trap_return & instr_completing_retr));    
          
  cover_csr_priv_simultaneous_irq_sw_ext_nested_stall: cover property (@(posedge clk) disable iff (~resetn) 
          ((ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]         
          (~ext_msip throughout((status_mie & instr_completing_retr & irq_stall_lsu_req) ##[1:$] interrupt_taken)))) ##[1:$] (trap_return & instr_completing_retr));  
          
  // cover back to back CSR write then read to same location
  
  sequence seq_csr_write(prop_addr);
       ((csr_alu_wr_op_sel == csr_alu_wr_op_swap) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  sequence seq_csr_read(prop_addr);       
       ((csr_alu_rd_op_sel != csr_alu_rd_op_none) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  sequence seq_back_to_back_write_then_read_same(prop_addr);
       ((csr_alu_wr_op_sel == csr_alu_wr_op_swap) & (csr_op_addr == prop_addr) & csr_op_addr_valid) ##1 
       ((csr_alu_rd_op_sel != csr_alu_rd_op_none) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  sequence seq_csr_write_then_read_same(prop_addr);
       ((csr_alu_wr_op_sel == csr_alu_wr_op_swap) & (csr_op_addr == prop_addr) & csr_op_addr_valid) ##[1:3] 
       ((csr_alu_rd_op_sel != csr_alu_rd_op_none) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  logic [11:0] nd_prop_addr;
  assume_prop_csr_addr_stable: assume property (@(posedge clk) disable iff (~resetn) 
                                                ##1 $stable(nd_prop_addr));
                                                
  cover_csr_trace_back_to_back_write_then_read_same_any: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_back_to_back_write_then_read_same(nd_prop_addr));
                                                                                                                        
  cover_csr_trace_write_then_read_same_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write_then_read_same(l_core_csr_addr_tdata1));                                                              
                                                                                                                            
  cover_csr_trace_back_to_back_write_then_read_same_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_back_to_back_write_then_read_same(l_core_csr_addr_tdata1)); 
                                                               
  cover_csr_trace_read_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_read(l_core_csr_addr_tdata1));
 
  cover_csr_trace_write_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write(l_core_csr_addr_tdata1));    
                                                               
  cover_csr_trace_write_then_read_same_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write_then_read_same(l_core_csr_addr_tselect));                                                              
                                                                                                                            
  cover_csr_trace_back_to_back_write_then_read_same_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_back_to_back_write_then_read_same(l_core_csr_addr_tselect)); 
                                                               
  cover_csr_trace_read_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_read(l_core_csr_addr_tselect));
 
  cover_csr_trace_write_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write(l_core_csr_addr_tselect));                                                                                                                          
                                                               
`endif 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_csr_state_reg.sv
//
//   Purpose:   standard CSR register state bit, machine mode access only
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module  miv_rv32_csr_gpr_state_reg
//********************************************************************************
// Parameter description

  #(
    parameter WIDTH = 1,
    parameter FIELD_RESET_EN = 0,
    parameter FIELD_RESET_VAL = 0
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    input wire logic                clk,
    input wire logic                resetn,
    
    input wire logic                init_wr_en,               
    input wire logic [WIDTH-1:0]    init_wr_data,             
    input wire logic                machine_implicit_wr_en,   
    input wire logic [WIDTH-1:0]    machine_implicit_wr_data, 
    input wire logic                machine_sw_wr_en,         
    input wire logic [WIDTH-1:0]    machine_sw_wr_data,         
    
    output logic [WIDTH-1:0]        state_val                 
  ); 
    


//********************************************************************************
// localparams
  

// Declarations



  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  // select data to write
  // priority based (decreasing) : 
  //  - invalidate
  //  - init
  //  - implicit
  //  - software
  
  logic [WIDTH-1:0] wr_data;
  logic wr_en_data;
  logic wr_en_valid;
  
  logic               implicit_wr_en;   
  logic [WIDTH-1:0]   implicit_wr_data; 
  logic               sw_wr_en;         
  logic [WIDTH-1:0]   sw_wr_data;       

// implicit wr mux  
  assign implicit_wr_en = machine_implicit_wr_en;                                 
  assign implicit_wr_data = machine_implicit_wr_data;                           
    
// sw wr mux (for when other modes supported) 
  assign sw_wr_en = machine_sw_wr_en;
  assign sw_wr_data = machine_sw_wr_data;                             
                                                                      
  generate if(FIELD_RESET_EN) begin : gen_init_term                                                                      
    assign wr_data =  init_wr_en ? init_wr_data :
                                   implicit_wr_en ? implicit_wr_data :
                                                    sw_wr_en ? sw_wr_data : {WIDTH{1'b0}};

    assign wr_en_data = init_wr_en | implicit_wr_en | sw_wr_en;
  end
  else
  begin : gen_no_init_term
    assign wr_data =  implicit_wr_en ? implicit_wr_data :
                                   sw_wr_en ? sw_wr_data : {WIDTH{1'b0}};

    assign wr_en_data = implicit_wr_en | sw_wr_en; 
  end
  endgenerate     


// state                

    
  generate if(FIELD_RESET_EN) begin : gen_bit_reset // async reset
  
    always @(posedge clk)
    begin
      if(~resetn)
      begin
        state_val      <= FIELD_RESET_VAL[WIDTH-1:0];     
      end
      else begin
        if(wr_en_data)
            state_val  <= wr_data;  
      end
    end   
    
  end // end generate gen_bit_reset
  else
  begin :gen_bit_no_reset
  
    always @(posedge clk)
    begin
      if(wr_en_data)
            state_val  <= wr_data;  
    end   
  
  
  end // end generate gen_bit_no_reset
  endgenerate

  
                                                                 

 

endmodule


`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_csr_privarch.sv
//
//   Purpose: Core CSRs and priveleged state
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_gpr
  //****************************************************************************
  // Parameter description
  #(
	parameter l_core_cfg_hw_sp_float = 0
  )
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                         clk,
  input  wire logic                         resetn,     
  input  wire logic                         gpr_wr_valid,     
  output logic                              gpr_wr_ready,     
  input  wire logic [5:0]                   gpr_wr_sel,       
  input  wire logic [L_XLEN-1:0]            gpr_wr_data,      
  input  wire logic                         gpr_rs1_rd_valid, 
  output logic                              gpr_rs1_rd_ready, 
  input  wire logic [5:0]                   gpr_rs1_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs1_rd_data,
  output logic                              gpr_rs1_rd_data_valid,   
  input  wire logic                         gpr_rs2_rd_valid, 
  output logic                              gpr_rs2_rd_ready, 
  input  wire logic [5:0]                   gpr_rs2_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs2_rd_data,
  output logic                              gpr_rs2_rd_data_valid, 
  input  wire logic                         gpr_rs3_rd_valid, 
  output logic                              gpr_rs3_rd_ready, 
  input  wire logic [5:0]                   gpr_rs3_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs3_rd_data,
  output logic                              gpr_rs3_rd_data_valid,
  output logic                              gpr_correctable_ecc_irq_src,     
  output logic                              gpr_uncorrectable_ecc_irq_src            
 
);  

//******************************************************************************
// localparam
localparam GPR_DEPTH = (l_core_cfg_hw_sp_float) ? 64 : 32;
  
//******************************************************************************
// Declarations
  logic  [L_XLEN-1:0]            gp_reg [64];
  logic  [GPR_DEPTH-1:0]         gpr_wr_en;
  logic  [L_XLEN-1:0]            gp_reg_rd_data_rs1;
  logic  [L_XLEN-1:0]            gp_reg_rd_data_rs2;
  logic  [L_XLEN-1:0]            gp_reg_rd_data_rs3;

//******************************************************************************
// Main code

  //x0 is always 0.
  assign gp_reg[0] = {L_XLEN{1'b0}};

  genvar i_gp_reg;
  generate  
  for (i_gp_reg = 1; i_gp_reg <= GPR_DEPTH-1; i_gp_reg++) begin : gen_gp_regs
  
    assign gpr_wr_en[i_gp_reg] = gpr_wr_valid & (gpr_wr_sel == i_gp_reg[5:0]);
    
    always @(posedge clk)
    begin
      if(gpr_wr_en[i_gp_reg])
        gp_reg[i_gp_reg] <= gpr_wr_data;
    end
    
  end
  endgenerate
  
  assign gpr_wr_ready = 1'b1; // can always accept writes in this implemnetation when operand (wr data) is valid
  
  //read mux
  always @*
  begin
    gp_reg_rd_data_rs1 = {L_XLEN{1'b0}};
    gp_reg_rd_data_rs2 = {L_XLEN{1'b0}};
    gp_reg_rd_data_rs3 = {L_XLEN{1'b0}};
    for(int i = 0; i <= GPR_DEPTH-1; i++) 
    begin
      if(gpr_rs1_rd_valid & (gpr_rs1_rd_sel == i[5:0]))
        gp_reg_rd_data_rs1 = gp_reg[i];
      if(gpr_rs2_rd_valid & (gpr_rs2_rd_sel == i[5:0]))
        gp_reg_rd_data_rs2 = gp_reg[i];
      if(gpr_rs3_rd_valid & (gpr_rs3_rd_sel == i[5:0]))
        gp_reg_rd_data_rs3 = gp_reg[i];
    end
  end
  
  assign gpr_rs1_rd_data        = gp_reg_rd_data_rs1;
  assign gpr_rs1_rd_data_valid  = gpr_rs1_rd_valid;     // Pass-through in reg based version, but may not be in ram based version
  assign gpr_rs2_rd_data        = gp_reg_rd_data_rs2;
  assign gpr_rs2_rd_data_valid  = gpr_rs2_rd_valid;     // Pass-through in reg based version, but may not be in ram based version
  assign gpr_rs3_rd_data        = gp_reg_rd_data_rs3;
  assign gpr_rs3_rd_data_valid  = gpr_rs3_rd_valid;     // Pass-through in reg based version, but may not be in ram based version
  
  assign gpr_rs1_rd_ready       = 1'b1; // can always return reads immediately in this implmemtation for both ports
  assign gpr_rs2_rd_ready        = 1'b1; 
  assign gpr_rs3_rd_ready        = 1'b1; 
  
  // Curerntly no ecc on register based version of GPR
  // If implemented, exception bit asserted when GPR read and ECC error - if ECC schem does not support correction,
  // or correctable ECC error notification is required, the corerctable exception bit should be tied to 0
  // and only uncorrectbale bit used.
  assign gpr_correctable_ecc_irq_src = 1'b0;  
  assign gpr_uncorrectable_ecc_irq_src = 1'b0;  

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS



`endif 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_gpr_ram.sv
//
//   Purpose: Core CSRs and priveleged state
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype wire

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_gpr_ram
  //****************************************************************************
  // Parameter description
  #(
    parameter ECC_ENABLE = 1,
	parameter l_core_cfg_gpr_fwd_hzd = 0,
	parameter l_core_cfg_hw_sp_float = 0
  )
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                         clk,
  input  wire logic                         resetn,     
  input  wire logic                         gpr_wr_valid,     
  output logic                              gpr_wr_ready,     
  input  wire logic [5:0]                   gpr_wr_sel,       
  input  wire logic [L_XLEN-1:0]            gpr_wr_data,      
  input  wire logic                         gpr_rs1_rd_valid, 
  output logic                              gpr_rs1_rd_ready, 
  input  wire logic [5:0]                   gpr_rs1_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs1_rd_data,
  output logic                              gpr_rs1_rd_data_valid,   
  input  wire logic                         gpr_rs2_rd_valid, 
  output logic                              gpr_rs2_rd_ready, 
  input  wire logic [5:0]                   gpr_rs2_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs2_rd_data,
  output logic                              gpr_rs2_rd_data_valid,
  input  wire logic                         gpr_rs3_rd_valid, 
  output logic                              gpr_rs3_rd_ready, 
  input  wire logic [5:0]                   gpr_rs3_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs3_rd_data,
  output logic                              gpr_rs3_rd_data_valid,
  
  
  output logic                              gpr_correctable_ecc_irq_src,     
  output logic                              gpr_uncorrectable_ecc_irq_src,

  input  wire logic                         ram_init_soft_debug_reset, //signal to re-init gpr ram on a soft or debug reset
  output logic                              gpr_ram_init_done, //gpr ram init done output signal
  input  wire logic                         icache_ram_init_done,
  input wire logic [1:0]                    gpr_ecc_error_injection
);

//******************************************************************************
// localparam
localparam GPR_DEPTH = (l_core_cfg_hw_sp_float) ? 64 : 32;

//******************************************************************************
// Declarations
   logic        rs1_rd_hzd;
   logic        rs2_rd_hzd;
   logic        rs3_rd_hzd;
   logic [5:0]  gpr_wr_sel_reg;
   logic [5:0]  gpr_rs1_rd_sel_reg;
   logic [5:0]  gpr_rs2_rd_sel_reg;
   logic [5:0]  gpr_rs3_rd_sel_reg;
   logic        gpr_rs1_rd_valid_reg;
   logic        gpr_rs2_rd_valid_reg;
   logic        gpr_rs3_rd_valid_reg;
   logic        gpr_wr_valid_reg;
   logic        gpr_wr_valid_int;
   logic [31:0] rs1_data_o;
   logic [31:0] rs2_data_o;
   logic [31:0] rs3_data_o;

   logic [1:0] ecc_aerr_int;
   logic [1:0] ecc_berr_int;
   logic [1:0] ecc_cerr_int;
   logic [1:0] ecc_err;
   
   //gpr ram init nets
   logic [31:0] gpr_ram_init_data;
   logic [5:0]  gpr_ram_init_addr;
   logic        gpr_ram_init_write_en;
   
   //gpr ram mux nets
   logic [31:0] gpr_mux_data;
   logic [5:0]  gpr_mux_addr;
   logic        gpr_mux_write_en;

//******************************************************************************
// Main code
  assign gpr_rs1_rd_data_valid = (gpr_rs1_rd_valid & gpr_rs1_rd_valid_reg) & !rs1_rd_hzd & (gpr_rs1_rd_sel_reg == gpr_rs1_rd_sel);
  assign gpr_rs2_rd_data_valid = (gpr_rs2_rd_valid & gpr_rs2_rd_valid_reg) & !rs2_rd_hzd & (gpr_rs2_rd_sel_reg == gpr_rs2_rd_sel);
  assign gpr_rs3_rd_data_valid = gpr_rs3_rd_valid_reg  & !rs3_rd_hzd & (gpr_rs3_rd_sel_reg == gpr_rs3_rd_sel);
  assign rs1_rd_hzd            = (gpr_wr_valid & (gpr_rs1_rd_sel == gpr_wr_sel)) | (gpr_wr_valid_reg & (gpr_rs1_rd_sel == gpr_wr_sel_reg)/* & l_core_cfg_gpr_fwd_hzd*/);
  assign rs2_rd_hzd            = (gpr_wr_valid & (gpr_rs2_rd_sel == gpr_wr_sel)) | (gpr_wr_valid_reg & (gpr_rs2_rd_sel == gpr_wr_sel_reg)/* & l_core_cfg_gpr_fwd_hzd*/);
  assign rs3_rd_hzd            = (gpr_wr_valid & (gpr_rs3_rd_sel == gpr_wr_sel)) | (gpr_wr_valid_reg & (gpr_rs3_rd_sel == gpr_wr_sel_reg)/* & l_core_cfg_gpr_fwd_hzd*/);
  assign gpr_wr_valid_int      = (gpr_wr_sel != 6'b0) & gpr_wr_valid;
  assign gpr_rs1_rd_ready      = gpr_rs1_rd_data_valid;
  assign gpr_rs2_rd_ready      = gpr_rs2_rd_data_valid;
  assign gpr_rs3_rd_ready      = gpr_rs3_rd_data_valid;
  assign gpr_rs1_rd_data       = rs1_data_o;
  assign gpr_rs2_rd_data       = rs2_data_o;
  assign gpr_rs3_rd_data       = rs3_data_o;
  assign gpr_wr_ready          = 1'b1;
     
  always @ (posedge clk or negedge resetn)
    begin
      if(!resetn) begin
	      gpr_wr_sel_reg       <= 6'b0;
          gpr_wr_valid_reg     <= 1'b0;
          gpr_rs1_rd_sel_reg   <= 6'b0;
          gpr_rs2_rd_sel_reg   <= 6'b0;
          gpr_rs3_rd_sel_reg   <= 6'b0;
          gpr_rs1_rd_valid_reg <= 1'b0;
          gpr_rs2_rd_valid_reg <= 1'b0;
          gpr_rs3_rd_valid_reg <= 1'b0;
      end else begin
	      gpr_wr_sel_reg       <= gpr_wr_sel;
          gpr_wr_valid_reg     <= gpr_wr_valid;
          gpr_rs1_rd_sel_reg   <= (gpr_rs1_rd_valid) ? gpr_rs1_rd_sel : gpr_rs1_rd_sel_reg;
          gpr_rs2_rd_sel_reg   <= (gpr_rs2_rd_valid) ? gpr_rs2_rd_sel : gpr_rs2_rd_sel_reg;
          gpr_rs3_rd_sel_reg   <= (gpr_rs3_rd_valid) ? gpr_rs3_rd_sel : gpr_rs3_rd_sel_reg;
          gpr_rs1_rd_valid_reg <= gpr_rs1_rd_valid;
          gpr_rs2_rd_valid_reg <= gpr_rs2_rd_valid;
          gpr_rs3_rd_valid_reg <= gpr_rs3_rd_valid;
      end
    end

  generate
  if(ECC_ENABLE)    
    begin : gen_gpr_ecc
    
      //GPR RAM INIT MODULE
      miv_rv32_gpr_ram_init
      //******************************************************************
      // Parameter description
      #(
      .ECC_ENABLE                       (1),
	  .l_core_cfg_hw_sp_float           (l_core_cfg_hw_sp_float)
      )
      u_gpr_init_0
      //******************************************************************
      // Signal description
      (
      .clk                              (clk),
      .resetn                           (resetn),
      .debug_soft_reset                 (ram_init_soft_debug_reset),
      .init_done                        (gpr_ram_init_done),
      .data                             (gpr_ram_init_data),
      .addr                             (gpr_ram_init_addr),
      .write_en                         (gpr_ram_init_write_en),
	  .icache_ram_init_done             (icache_ram_init_done)
      );
      
      
      //RAM INPUT MUX
      miv_rv32_gpr_ram_mux
      u_gpr_mux_0
      //******************************************************************
      // Signal description
      (
      .clk(clk),
      .resetn(resetn),
      .mux_sel(gpr_ram_init_done),
      .addr_0(gpr_ram_init_addr),
      .data_0(gpr_ram_init_data),
      .write_en_0(gpr_ram_init_write_en),
      .addr_1(gpr_wr_sel),
      .data_1(gpr_wr_data),
      .write_en_1(gpr_wr_valid),
      .addr_out(gpr_mux_addr),
      .data_out(gpr_mux_data),
      .write_en_out(gpr_mux_write_en)
      );
      
      //GPR ECC RAM
      miv_rv32_gpr_ecc_enc_dec
      //******************************************************************
      // Parameter description
      #(
        .RAM_DEPTH                      (GPR_DEPTH),
        .ADDR_WIDTH                     (6),
        .DATA_WIDTH                     (32)
       )
      u_gpr_ecc_0
      //******************************************************************
      // Signal description
      (
        .arstb                          (resetn),
        .aclk                           (clk),
        .aaddr                          (gpr_rs1_rd_sel),
        .aceb                           (gpr_rs1_rd_valid),
        .brstb                          (resetn),
        .bclk                           (clk),
        .baddr                          (gpr_rs2_rd_sel),
        .bceb                           (gpr_rs2_rd_valid),
		
        .crstb                          (resetn),
        .cclk                           (clk),
        .caddr                          (gpr_rs3_rd_sel),
        .cceb                           (gpr_rs3_rd_valid),
		
        .ret1n                          (resetn),
        .pg_override                    (1'b0),
        .ecc_bypass                     (1'b0),
        .ram_err_inject                 (gpr_ecc_error_injection),
        .adout                          (rs1_data_o),
        .bdout                          (rs2_data_o),
		
        .cdout                          (rs3_data_o),
		
        .ecc_aerr                       (), // open
        .ecc_aerr_int                   (ecc_aerr_int), 
        .ecc_berr                       (), // open
        .ecc_berr_int                   (ecc_berr_int),
		
        .ecc_cerr                       (), // open
        .ecc_cerr_int                   (ecc_cerr_int), 
		
        .waddr                          (gpr_mux_addr),
        .wen                            (gpr_mux_write_en),
        .wdin                           (gpr_mux_data)
      );  
      
      always @ (*)
      begin
          if(~gpr_ram_init_done) //prevent ECC error signals from asserting while GPR RAM is initialising
            begin
                gpr_correctable_ecc_irq_src = 1'b0;  
                gpr_uncorrectable_ecc_irq_src = 1'b0;
            end
          else //allow ECC error signals to assert once GPR RAM is no longer initialising
            begin
                gpr_correctable_ecc_irq_src   = (ecc_aerr_int[0] || ecc_berr_int[0] || ecc_cerr_int[0]);  
                gpr_uncorrectable_ecc_irq_src = (ecc_aerr_int[1] || ecc_berr_int[1] || ecc_cerr_int[1]);
            end
      end
      
    end
  else
    begin : gen_gpr
      miv_rv32_gpr_ram_array
      //******************************************************************
      // Parameter description
      #(
        .mem_depth                     (GPR_DEPTH),
        .addr_width_gpr                (6),
        .d_width                       (32)
       )
      u_gpr_array_0
      //******************************************************************
      // Signal description
      (
            // Inputs
            .clk           ( clk              ),
            .raddr0        ( gpr_rs1_rd_sel   ),
            .raddr1        ( gpr_rs2_rd_sel   ),
            .raddr2        ( gpr_rs3_rd_sel   ),
            .waddr0        ( gpr_wr_sel       ),
            .we0           ( gpr_wr_valid_int ),
            .data0         ( gpr_wr_data      ),
            // Outputs
            .q0          ( rs1_data_o ),
            .q1          ( rs2_data_o ),
            .q2          ( rs3_data_o )
            );
     
      assign gpr_correctable_ecc_irq_src = 1'b0;  
      assign gpr_uncorrectable_ecc_irq_src = 1'b0;  
	  assign ecc_aerr_int = 2'b0;
      assign ecc_berr_int = 2'b0;
      assign ecc_err = 2'b0;
	  assign gpr_ram_init_done = 1'b1;
	end
  endgenerate


 
//******************************************************************************
// properties
`ifdef core_RTL_PROPS



`endif 
endmodule
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_gpr_ram_array.sv
//
//   Purpose: GPR RAM Array
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

import miv_rv32_hart_cfg_pkg ::*;

module miv_rv32_gpr_ram_array (data0,
                               raddr0,
                               raddr1,
                               raddr2,
                               waddr0, 
                               we0,
                               clk,
                               q0,
                               q1,
                               q2);

    parameter d_width = 32;
    parameter addr_width_gpr = 32;
    parameter mem_depth = 65536;
	
    input [d_width-1:0] data0;
    input [addr_width_gpr-1:0] waddr0, raddr0, raddr1, raddr2;
    input we0, clk;

    output [d_width-1:0] q0;
    output [d_width-1:0] q1;
    output [d_width-1:0] q2;

    reg [d_width-1:0] mem_xf [mem_depth-1:0];
    reg [d_width-1:0] q0, q1, q2;
                           
    always @(posedge clk) begin 
        if (we0) begin
		    mem_xf [waddr0[5:0]] <= data0;
		end
    end 

    always @(posedge clk) begin 
        q0 <= (raddr0 == 0) ?  0 :mem_xf[raddr0[5:0]];
        q1 <= (raddr1 == 0) ?  0 :mem_xf[raddr1[5:0]];
        q2 <= (raddr2 == 0) ?  0 :mem_xf[raddr2[5:0]];
    end 
endmodule
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_gpr_ram_init
    //****************************************************************************
    // Parameter description
    #(
    parameter ECC_ENABLE = 1,
	parameter l_core_cfg_hw_sp_float = 0
    )
    //******************************************************************************
    // Port Description
    (
    input clk,
    input resetn,
    input debug_soft_reset,
	input icache_ram_init_done,
    output reg init_done,
    output reg [31:0] data,
    output reg [5:0] addr,
    output reg write_en

    );
    //******************************************************************************  
    // Declarations
    reg [1:0] init_state;

    localparam NUM_OF_REGS = (l_core_cfg_hw_sp_float) ? 64 : 32;
    //******************************************************************************
    // Main code
    generate
        if(ECC_ENABLE)
        begin
            always @ (posedge clk)
                begin
                    if(~resetn)
                        begin
                        init_state <= 2'b0;
                        data <= 32'b0;
                        addr <= 6'b0;
                        write_en <= 1'b0;
                        init_done <= 1'b0;
                        end
                    else
                        begin
                            case(init_state)
                                2'd0: begin //STATE 0: INIT START
                                      $display("Initialisation of GPR RAM - Start");
                                      init_state <= 2'd1; //move to state 1: init in progress
                                      data <= 32'b0;
                                      addr <= 6'b0;
                                      write_en <= 1'b1;
                                      init_done <= 1'b0;
                                      end
                                      
                                2'd1: begin //STATE 1: INIT IN PROGRESS
                                      if(addr == NUM_OF_REGS - 1) //end of gprs reached, init done 
                                        begin
                                            init_state <= 2'd2; //move to init 2: init done
                                            data <= 32'b0;
                                            addr <= 6'b0;
											if(icache_ram_init_done) begin
                                                init_done <= 1'b1; //gpr ram init done
											end
                                            $display("Initialisation of GPR RAM - Complete");
                                        end
                                      else 
                                        begin
                                            addr <= addr + 1'b1; //increment to next address
                                            init_state <= 2'b1; //init still in progress
                                        end
                                      end
                                      
                                2'd2: begin //STATE 2: INIT DONE
                                        init_state <= 2'd2;
									    if(icache_ram_init_done) begin
                                            init_done <= 1'b1; //gpr ram init done
									    end
                                        
                                        if (debug_soft_reset & init_done) //if init is complete and a soft reset or debug reset is triggered, go to init start
                                            begin
                                                init_state <= 2'd0;
                                            end 
                                      end
                            default: begin  //DEFAULT STATE
                                        init_state <= 2'd0;
                                        data <= 32'b0;
                                        addr <= 6'b1;
                                        init_done <= 1'b0;
                                     end
                            endcase
                        end
                end
        end
        else
        begin
            always @ (*)
                begin
                    init_state <= 2'b0;
                    data <= 32'b0;
                    addr <= 6'b0;
                    write_en <= 1'b0;
                    init_done <= 1'b1;
                end
        end
    endgenerate
endmodule


// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_gpr_ram_mux
    //******************************************************************************
    // Parameter description
    #(
    parameter ECC_ENABLE = 1 
    )
    //******************************************************************************
    // Port Description
    (
    input clk,
    input resetn,
    input mux_sel,
    
    input [5:0]  addr_0,
    input [31:0] data_0,
    input write_en_0,
    
    input [5:0]  addr_1,
    input [31:0] data_1,
    input write_en_1, 
   
    output reg [5:0] addr_out,
    output reg [31:0] data_out,
    output reg write_en_out
    );
    //******************************************************************************
    // Main code
    
    always @ (*)
        begin
            case(mux_sel)
            1'b0: begin
                  addr_out <= addr_0;
                  data_out <= data_0;
                  write_en_out <= write_en_0;
                  end
            1'b1: begin
                  addr_out <= addr_1;
                  data_out <= data_1;
                  write_en_out <= write_en_1;
                  end
            
         default: begin
                  addr_out <= 6'b0;
                  data_out <= 32'b0;
                  write_en_out <= 1'b0;
                  end
            endcase
        end
endmodule
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: core_1rq_reg.sv
//
//   Purpose: Core IRQ capture and pending hold register bit
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_irq_reg
  //****************************************************************************
  // Parameter description
  #(parameter IRQ_STICKY_CAPTURE                  = 0
   )
  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic           clk,
  input  wire logic           resetn,     
  input  wire logic           interrupt_commit,
  input  wire logic           interrupt_src,  
  input  wire logic           interrupt_enable, 
  input  wire logic           interrupt_clr,
  output logic                interrupt_captured,
  output logic                interrupt_pending,  
  output logic                interrupt_taken          
 
);  

  
//******************************************************************************
// Declarations

  logic set_interrupt_capture;
  logic clr_interrupt_capture;
  logic interrupt_capture_reg;



//******************************************************************************
// Main code

  // capture interrupt request
  // optionally can be sticky
  // need to use registered version in any case as generates stall to the ex phase so timing critical.
  // If the capture is required to be sticky, then interrupt_capture_clr_en can be used. Where it is not required it 
  // should be tied high
    
  assign set_interrupt_capture  = interrupt_src;
  
  generate if(IRQ_STICKY_CAPTURE) 
  begin: gen_sticky_irq
    assign clr_interrupt_capture  = interrupt_clr;
  end
  else begin: gen_non_sticky_irq
    assign clr_interrupt_capture  = interrupt_commit;
  end
  endgenerate
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      interrupt_capture_reg <= 1'b0;
    else
      if(set_interrupt_capture | clr_interrupt_capture)
        interrupt_capture_reg <= set_interrupt_capture;
  end    
    
  assign interrupt_captured = interrupt_capture_reg;
  
  // When no outstanding LSU requests, and request completing, or no requests in retire stage, interrupt can be taken if still pending and enabled
  

    
  assign interrupt_pending = interrupt_commit & interrupt_capture_reg;
  
  assign interrupt_taken   =  interrupt_pending & interrupt_enable;
  
 

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS



`endif 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_priv_irq.sv
//
//   Purpose: Core interrupt handling logic
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_priv_irq
  //****************************************************************************
  // Parameter description
  #(parameter l_core_num_sys_ext_irqs = 9,
    parameter l_core_cfg_gpr_ecc_uncorrectable_irq = 0,
    parameter l_core_cfg_gpr_ecc_correctable_irq   = 0
    )
  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                        clk,
  input  wire logic                        resetn,        
  input  wire logic                        debug_mode,                    
  input  wire logic                        lsu_op_os,                      
  input  wire logic                        instr_completing_retr,         
  input  wire logic                        instr_valid_retr,              
  input  wire logic                        instr_lsu_op_retr,           
  input  wire logic [L_XLEN-1:0]           ie,                            
  input  wire logic                        global_enable,                 
  input  wire logic                        dcsr_stepie,                   
  input  wire logic                        dcsr_step,
  input  wire logic                        ip_read,                     
                              
  input  wire logic                        base_irq_src_ext,  
  input  wire logic                        base_irq_src_timer,     
  input  wire logic                        base_irq_src_sw,              
  input  wire logic [9:0]                  sys_ext_irq_src,               
  input  wire logic                        gpr_uncorrectable_ecc_irq_src, 
  input  wire logic                        gpr_uncorrectable_ecc_irq_clr,
  input  wire logic                        gpr_correctable_ecc_irq_src,  
  input  wire logic                        gpr_correctable_ecc_irq_clr,
  input  wire logic                        instret_count_irq_src, 
  input  wire logic                        instret_count_irq_clr, 
  input  wire logic                        cycle_count_irq_src, 
  input  wire logic                        cycle_count_irq_clr,
  input  wire logic                        hpm_count_irq_src, 
  input  wire logic                        hpm_count_irq_clr,
                              
  output logic                             irq_stall_lsu_req,
  output logic                             irq_abort_lsu_req,
  output logic                             locally_enabled_irq_captured,             
  output logic                             irq_taken,                   
  output logic                             base_ip_ext,    
  output logic                             base_ip_timer,
  output logic                             base_ip_sw,   
  output logic [9:0]                       sys_ext_ip,  
  output logic                             gpr_correctable_ecc_ip,   
  output logic                             gpr_uncorrectable_ecc_ip,      
  output logic                             instret_count_ip,
  output logic                             cycle_count_ip,
  output logic                             hpm_count_ip,           
  output logic [4:0]                       cause_excpt_code_irq          

                               
);  

  
//******************************************************************************
// Declarations

  logic                         irq_ext_enable;  
  logic                         irq_timer_enable;  
  logic                         irq_sw_enable; 
  logic                         interrupt_lsu_stall_ext;
  logic                         interrupt_lsu_stall_timer;
  logic                         interrupt_lsu_stall_sw;
  logic                         interrupt_captured_ext;
  logic                         interrupt_captured_timer;
  logic                         interrupt_captured_sw;
  logic                         interrupt_captured_local_en_ext;
  logic                         interrupt_captured_local_en_timer;
  logic                         interrupt_captured_local_en_sw;
  logic                         interrupt_taken_ext;
  logic                         interrupt_taken_timer;
  logic                         interrupt_taken_sw;
  logic                         interrupt_could_commit;
  
  logic [9:0]                   interrupt_lsu_stall_ext_sys;
  logic [9:0]                   interrupt_captured_local_en_ext_sys;
  logic [9:0]                   interrupt_pending_ext_sys;
  logic [9:0]                   interrupt_taken_ext_sys;  
        
  logic                         interrupt_lsu_stall_ecc_uncorrectable;
  logic                         interrupt_captured_local_en_ecc_uncorrectable;
  logic                         interrupt_pending_ecc_uncorrectable;  
  logic                         interrupt_taken_ecc_uncorrectable;        
  logic                         interrupt_lsu_stall_ecc_correctable;
  logic                         interrupt_captured_local_en_ecc_correctable;
  logic                         interrupt_pending_ecc_correctable;  
  logic                         interrupt_taken_ecc_correctable;  
         
  logic                         interrupt_lsu_stall_instret_count;
  logic                         interrupt_captured_local_en_instret_count;
  logic                         interrupt_pending_instret_count;  
  logic                         interrupt_taken_instret_count;        
  logic                         interrupt_lsu_stall_cycle_count;
  logic                         interrupt_captured_local_en_cycle_count;
  logic                         interrupt_pending_cycle_count;  
  logic                         interrupt_taken_cycle_count;         
  logic                         interrupt_lsu_stall_hpm_count;
  logic                         interrupt_captured_local_en_hpm_count;
  logic                         interrupt_pending_hpm_count;  
  logic                         interrupt_taken_hpm_count; 


  
//******************************************************************************
// Main code  

  // Interrupt taken when:
  // - asserted
  // - not masked globally (status.mie), 
  // - not masked by the correspondingie register bit,
  // - if debug step enabled then only if dcsr_stepie is asserted
  // note interrupts are not captured/latched so source must hold asserted.
  
  
  // Need to ensure interupt occurs (interrupt_taken asserted) only when an instruction is completing
  // to ensure handling trap instruction is inserted without anything outstanding in the retr stage.
  // However interrupt must take priority over new instructions and must happen if no instructions in flight
  
  // interrupt_pending is used to block LSU requests in the EX stage (to prevent stores being issued for an instruction that is subsequently dropped 
  // due to the interrupt being taken in the retr stage). 
  // This means it must only be asserted when:
  //  - there is no valid instruction in EX stage
  //  - there is a valid instruction in EX stage that is not a store (simplified to any LSU op, also loads may have side effects so also must complete)
  //  - there is a valid store instruction but the LSU has not yet accepted the request
  // The cleanest/simplest way to ensure this, is as with the retr stage, to only update when the ex stage has no valid instruction, or an instruction 
  // is completing (which means any store is already accepted by retr, and therefore will prevent the interrupt being taken until it is complete)
  // Deassertion is simpler since when an interrupt is taken, the retr stage will flush all pipeline stages, so there can be no requests to the LSU in progress
  // in the EX stage
  

  
  assign irq_ext_enable   = global_enable & (dcsr_stepie | ~dcsr_step) & (~debug_mode) & ie[11];
  assign irq_timer_enable = global_enable & (dcsr_stepie | ~dcsr_step) & (~debug_mode) & ie[7];
  assign irq_sw_enable    = global_enable & (dcsr_stepie | ~dcsr_step) & (~debug_mode) & ie[3];  
  
  assign interrupt_could_commit = (~lsu_op_os) &
                                  (instr_completing_retr & instr_valid_retr);
                                  
// Base External interrupt  
  miv_rv32_irq_reg
  #(
    .IRQ_STICKY_CAPTURE     (0)  // 
  )  
  u_miv_rv32_irq_reg_ext
  (
    .clk                         (clk                        ),
    .resetn                      (resetn                     ),
    .interrupt_commit            (interrupt_could_commit     ),
    .interrupt_src               (base_irq_src_ext           ),
    .interrupt_enable            (irq_ext_enable             ),
    .interrupt_clr               (1'b0                       ),
    .interrupt_captured          (interrupt_captured_ext     ),
    .interrupt_pending           (base_ip_ext                ),
    .interrupt_taken             (interrupt_taken_ext        )
  );
  
  assign interrupt_lsu_stall_ext          = interrupt_captured_ext & irq_ext_enable;
  assign interrupt_captured_local_en_ext  = interrupt_captured_ext & ie[11];

// Base timer interrupt  
  miv_rv32_irq_reg
  #(
    .IRQ_STICKY_CAPTURE     (0)  // 
  )  
  u_miv_rv32_irq_reg_timer
  (
    .clk                         (clk                        ),
    .resetn                      (resetn                     ),
    .interrupt_commit            (interrupt_could_commit     ),
    .interrupt_src               (base_irq_src_timer         ),
    .interrupt_enable            (irq_timer_enable           ),
    .interrupt_clr               (1'b0                       ),
    .interrupt_captured          (interrupt_captured_timer   ),
    .interrupt_pending           (base_ip_timer              ),
    .interrupt_taken             (interrupt_taken_timer      )
  );
  
  assign interrupt_lsu_stall_timer          = interrupt_captured_timer & irq_timer_enable;
  assign interrupt_captured_local_en_timer  = interrupt_captured_timer & ie[7];

// Base software interrupt  
  miv_rv32_irq_reg
  #(
    .IRQ_STICKY_CAPTURE     (0)  // 
  )
  u_miv_rv32_irq_reg_sw
  (
    .clk                         (clk                        ),
    .resetn                      (resetn                     ),
    .interrupt_commit            (interrupt_could_commit     ),
    .interrupt_src               (base_irq_src_sw            ),
    .interrupt_enable            (irq_sw_enable              ),
    .interrupt_clr               (1'b0                       ),
    .interrupt_captured          (interrupt_captured_sw      ),
    .interrupt_pending           (base_ip_sw                 ),
    .interrupt_taken             (interrupt_taken_sw         )
  );    
  
  assign interrupt_lsu_stall_sw           = interrupt_captured_sw & irq_sw_enable;
  assign interrupt_captured_local_en_sw   = interrupt_captured_sw & ie[3];
                                  
// External system interrupt(s)                                  
  genvar i_ext_sys_irq;
  generate  
  for (i_ext_sys_irq = 0; i_ext_sys_irq < 10; i_ext_sys_irq++) begin : gen_ext_sys_irq
  
    if(i_ext_sys_irq < l_core_num_sys_ext_irqs) begin : gen_ext_sys_irq_bit
      
      logic interrupt_captured_ext_sys;
      logic irq_ext_sys_enable;
    
      assign irq_ext_sys_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[22+i_ext_sys_irq];
    
      miv_rv32_irq_reg
      #(
        .IRQ_STICKY_CAPTURE     (0)  
      )
      u_miv_rv32_irq_reg_ext_sys
      (
        .clk                         (clk                                       ),
        .resetn                      (resetn                                    ),
        .interrupt_commit            (interrupt_could_commit                    ),
        .interrupt_src               (sys_ext_irq_src[i_ext_sys_irq]            ),
        .interrupt_enable            (irq_ext_sys_enable                        ),
        .interrupt_clr               (1'b0                                      ),
        .interrupt_captured          (interrupt_captured_ext_sys                ),
        .interrupt_pending           (interrupt_pending_ext_sys[i_ext_sys_irq]  ),
        .interrupt_taken             (interrupt_taken_ext_sys[i_ext_sys_irq]    )
      );    
      
      assign interrupt_lsu_stall_ext_sys[i_ext_sys_irq]         = interrupt_captured_ext_sys & irq_ext_sys_enable;
      assign interrupt_captured_local_en_ext_sys[i_ext_sys_irq] = interrupt_captured_ext_sys & ie[22+i_ext_sys_irq];
     
    end
    else begin : ngen_ext_sys_irq_bit

      assign interrupt_lsu_stall_ext_sys[i_ext_sys_irq]          = 1'b0; 
      assign interrupt_captured_local_en_ext_sys[i_ext_sys_irq]  = 1'b0; 
      assign interrupt_pending_ext_sys[i_ext_sys_irq]            = 1'b0;  
      assign interrupt_taken_ext_sys[i_ext_sys_irq]              = 1'b0;  
  
    end
  end
  endgenerate

// GPR ECC uncorrectable   
  generate if(l_core_cfg_gpr_ecc_uncorrectable_irq) begin : gen_ecc_uncorrectable_irq

    logic                         irq_ecc_uncorrectable_enable;  
    logic                         interrupt_captured_ecc_uncorrectable; 
  
    assign irq_ecc_uncorrectable_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[16];
  
    miv_rv32_irq_reg
    #(
    .IRQ_STICKY_CAPTURE     (1)  // 
    )  
    u_miv_rv32_irq_reg_ecc_uncorrectable_irq
    (
      .clk                         (clk                                  ),
      .resetn                      (resetn                               ),
      .interrupt_commit            (interrupt_could_commit               ),
      .interrupt_src               (gpr_uncorrectable_ecc_irq_src        ),
      .interrupt_enable            (irq_ecc_uncorrectable_enable         ),
      .interrupt_clr               (gpr_uncorrectable_ecc_irq_clr        ),
      .interrupt_captured          (interrupt_captured_ecc_uncorrectable ),
      .interrupt_pending           (interrupt_pending_ecc_uncorrectable  ),
      .interrupt_taken             (interrupt_taken_ecc_uncorrectable    )
    );    
    
    assign interrupt_lsu_stall_ecc_uncorrectable          = interrupt_captured_ecc_uncorrectable & irq_ecc_uncorrectable_enable;
    assign interrupt_captured_local_en_ecc_uncorrectable  = interrupt_captured_ecc_uncorrectable & ie[16];
   
  end
  else begin : ngen_ecc_uncorrectable_irq
      
    assign interrupt_lsu_stall_ecc_uncorrectable          = 1'b0;  
    assign interrupt_captured_local_en_ecc_uncorrectable  = 1'b0;
    assign interrupt_pending_ecc_uncorrectable            = 1'b0; 
    assign interrupt_taken_ecc_uncorrectable              = 1'b0; 
  
  end
  endgenerate

// GPR ECC correctable  
  generate if(l_core_cfg_gpr_ecc_correctable_irq) begin : gen_ecc_correctable_irq
            
    logic irq_ecc_correctable_enable; 
    logic interrupt_captured_ecc_correctable;
    
    assign irq_ecc_correctable_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[17];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)   
    ) 
    u_miv_rv32_irq_reg_ecc_correctable_irq
    (
      .clk                         (clk                                ),
      .resetn                      (resetn                             ),
      .interrupt_commit            (interrupt_could_commit             ),
      .interrupt_src               (gpr_correctable_ecc_irq_src        ),
      .interrupt_enable            (irq_ecc_correctable_enable         ),
      .interrupt_clr               (gpr_correctable_ecc_irq_clr        ),
      .interrupt_captured          (interrupt_captured_ecc_correctable ),
      .interrupt_pending           (interrupt_pending_ecc_correctable  ),
      .interrupt_taken             (interrupt_taken_ecc_correctable    )
    );    
    
    assign interrupt_lsu_stall_ecc_correctable          = interrupt_captured_ecc_correctable & irq_ecc_correctable_enable;
    assign interrupt_captured_local_en_ecc_correctable  = interrupt_captured_ecc_correctable & irq_ecc_correctable_enable;
   
  end
  else begin : ngen_ecc_correctable_irq
      
    assign interrupt_lsu_stall_ecc_correctable          = 1'b0;  
    assign interrupt_captured_local_en_ecc_correctable  = 1'b0;
    assign interrupt_pending_ecc_correctable            = 1'b0;    
    assign interrupt_taken_ecc_correctable              = 1'b0;      
  
  end
  endgenerate
  
  // Instruction retired count LSB set  
  generate if(l_core_cfg_instret_count_irq) begin : gen_instret_count_irq
  
    logic irq_instret_count_enable;
    logic interrupt_captured_instret_count;
  
    assign irq_instret_count_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[18];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)  // 
    ) 
    u_miv_rv32_irq_reg_instret_count_irq
    (
      .clk                         (clk                              ),
      .resetn                      (resetn                           ),
      .interrupt_commit            (interrupt_could_commit           ),
      .interrupt_src               (instret_count_irq_src            ),
      .interrupt_enable            (irq_instret_count_enable         ),
      .interrupt_clr               (instret_count_irq_clr            ),
      .interrupt_captured          (interrupt_captured_instret_count ),
      .interrupt_pending           (interrupt_pending_instret_count  ),
      .interrupt_taken             (interrupt_taken_instret_count    )
    );    
    
    assign interrupt_lsu_stall_instret_count          = interrupt_captured_instret_count & irq_instret_count_enable;
    assign interrupt_captured_local_en_instret_count  = interrupt_captured_instret_count & ie[18];
   
  end
  else begin : ngen_instret_count_irq
     
    assign interrupt_lsu_stall_instret_count          = 1'b0;  
    assign interrupt_captured_local_en_instret_count  = 1'b0;
    assign interrupt_pending_instret_count            = 1'b0;    
    assign interrupt_taken_instret_count              = 1'b0;      
  
  end
  endgenerate
  
  // Cycle count LSB set  
  generate if(l_core_cfg_cycle_count_irq) begin : gen_cycle_count_irq
      
    logic irq_cycle_count_enable; 
    logic interrupt_captured_cycle_count;
  
    assign irq_cycle_count_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[19];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)  // 
    )
    u_miv_rv32_irq_reg_cycle_count_irq
    (
      .clk                         (clk                            ),
      .resetn                      (resetn                         ),
      .interrupt_commit            (interrupt_could_commit         ),
      .interrupt_src               (cycle_count_irq_src            ),
      .interrupt_enable            (irq_cycle_count_enable         ),
      .interrupt_clr               (cycle_count_irq_clr            ),
      .interrupt_captured          (interrupt_captured_cycle_count ),
      .interrupt_pending           (interrupt_pending_cycle_count  ),
      .interrupt_taken             (interrupt_taken_cycle_count    )
    );    
    
    assign interrupt_lsu_stall_cycle_count          = interrupt_captured_cycle_count & irq_cycle_count_enable;
    assign interrupt_captured_local_en_cycle_count  = interrupt_captured_cycle_count & ie[19];
   
  end
  else begin : ngen_cycle_count_irq
       
    assign interrupt_lsu_stall_cycle_count          = 1'b0;  
    assign interrupt_captured_local_en_cycle_count  = 1'b0;
    assign interrupt_pending_cycle_count            = 1'b0;    
    assign interrupt_taken_cycle_count              = 1'b0;      
  
  end
  endgenerate
  
  // any hpm count LSB set  
  generate if(l_core_cfg_hpm_count_irq) begin : gen_hpm_count_irq
      
    logic irq_hpm_count_enable;
    logic interrupt_captured_hpm_count;
  
    assign irq_hpm_count_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[20];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)  // 
    )  
    u_miv_rv32_irq_reg_hpm_count_irq
    (
      .clk                         (clk                          ),
      .resetn                      (resetn                       ),
      .interrupt_commit            (interrupt_could_commit       ),
      .interrupt_src               (hpm_count_irq_src            ),
      .interrupt_enable            (irq_hpm_count_enable         ),
      .interrupt_clr               (hpm_count_irq_clr            ),
      .interrupt_captured          (interrupt_captured_hpm_count ),
      .interrupt_pending           (interrupt_pending_hpm_count  ),
      .interrupt_taken             (interrupt_taken_hpm_count    )
    );    
    
    assign interrupt_lsu_stall_hpm_count          = interrupt_captured_hpm_count & irq_hpm_count_enable;
    assign interrupt_captured_local_en_hpm_count  = interrupt_captured_hpm_count & ie[20];
   
  end
  else begin : ngen_hpm_count_irq
      
    assign interrupt_lsu_stall_hpm_count          = 1'b0;  
    assign interrupt_captured_local_en_hpm_count  = 1'b0;
    assign interrupt_pending_hpm_count            = 1'b0;    
    assign interrupt_taken_hpm_count              = 1'b0;      
  
  end
  endgenerate
  
  // stall the LSU request in EX stage if there is a captured interrupt that may cause an interrupt when it commits
  // Cannot allow the load/store to proceed as it may never happen if an interrupt is taken
  // Cannot abort the load/store because the interrupt may not happen if the instruction in the retr stage disables the interrupt,
  // therefore stall the lsu operation until the operation in the retr stage completes (also have to include the lsu os
  // term because interrupts will not be commited when there are outstanding load/stores/fences), then allow the load/store operation to
  // complete, but suppress load-store request (needs to complete so interrupt can commit and update MEPC)
  
  assign irq_stall_lsu_req        = (interrupt_lsu_stall_ext |
                                    interrupt_lsu_stall_timer | 
                                    interrupt_lsu_stall_sw |
                                    (|interrupt_lsu_stall_ext_sys) |
                                    interrupt_lsu_stall_ecc_uncorrectable |
                                    interrupt_lsu_stall_ecc_correctable |
                                    interrupt_lsu_stall_instret_count |
                                    interrupt_lsu_stall_cycle_count |
                                    interrupt_lsu_stall_hpm_count ) & (instr_valid_retr | lsu_op_os);   
                                    
  assign irq_abort_lsu_req        = (interrupt_lsu_stall_ext |
                                    interrupt_lsu_stall_timer | 
                                    interrupt_lsu_stall_sw |
                                    (|interrupt_lsu_stall_ext_sys) |
                                    interrupt_lsu_stall_ecc_uncorrectable |
                                    interrupt_lsu_stall_ecc_correctable |
                                    interrupt_lsu_stall_instret_count |
                                    interrupt_lsu_stall_cycle_count |
                                    interrupt_lsu_stall_hpm_count ) & ~(instr_valid_retr | lsu_op_os);                                                                                       
  
  assign irq_taken                = interrupt_taken_ext | 
                                    interrupt_taken_timer | 
                                    interrupt_taken_sw |
                                    (|interrupt_taken_ext_sys) |
                                    interrupt_taken_ecc_uncorrectable |
                                    interrupt_taken_ecc_correctable |
                                    interrupt_taken_instret_count |
                                    interrupt_taken_cycle_count |
                                    interrupt_taken_hpm_count;
                                    
  assign locally_enabled_irq_captured     = interrupt_captured_local_en_ext | 
                                            interrupt_captured_local_en_timer | 
                                            interrupt_captured_local_en_sw |
                                            (|interrupt_captured_local_en_ext_sys) |
                                            interrupt_captured_local_en_ecc_uncorrectable |
                                            interrupt_captured_local_en_ecc_correctable |
                                            interrupt_captured_local_en_instret_count |
                                            interrupt_captured_local_en_cycle_count |
                                            interrupt_captured_local_en_hpm_count;                                                                            
                                                 
  assign cause_excpt_code_irq     = interrupt_taken_ext_sys[9] ? 5'd31 :// MSYS_EI[7] to MSYS_EI[0]
                                      interrupt_taken_ext_sys[8] ? 5'd30 :
                                        interrupt_taken_ext_sys[7] ? 5'd29 :
                                          interrupt_taken_ext_sys[6] ? 5'd28 :
                                            interrupt_taken_ext_sys[5] ? 5'd27 :
                                              interrupt_taken_ext_sys[4] ? 5'd26 :
                                                interrupt_taken_ext_sys[3] ? 5'd25 :
                                                  interrupt_taken_ext_sys[2] ? 5'd24 : 
                                                    interrupt_taken_ext_sys[1] ? 5'd23 :  //SUBSYS_REG
                                                      interrupt_taken_ext_sys[0] ? 5'd22 : // SUBSYSR Spare\Reserved for Subsys
                                                        interrupt_taken_hpm_count ? 5'd20 : // Not enabled in MIV_RV32
                                                          interrupt_taken_cycle_count ? 5'd19 : // Not enabled in MIV_RV32
                                                            interrupt_taken_instret_count ? 5'd18 : // Not enabled in MIV_RV32
                                                              interrupt_taken_ecc_correctable ? 5'd17 :
                                                                interrupt_taken_ecc_uncorrectable ? 5'd16 :
                                                                  interrupt_taken_ext ? 5'd11 : 
																    interrupt_taken_sw ? 5'd3 : // SW has higher priority than Timer
																	  interrupt_taken_timer ? 5'd7 : 5'd0;
																	
                                    
  
  assign sys_ext_ip               = interrupt_pending_ext_sys;  
  assign gpr_correctable_ecc_ip   = interrupt_pending_ecc_correctable; 
  assign gpr_uncorrectable_ecc_ip = interrupt_pending_ecc_uncorrectable;   
  assign instret_count_ip         = interrupt_pending_instret_count; 
  assign cycle_count_ip           = interrupt_pending_cycle_count; 
  assign hpm_count_ip             = interrupt_pending_hpm_count; 
                                            
  


 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  // if the LSU is talled waiting for an interrupt to be possibly taken, then must be able to commit an interrupt eventually in order to clear the 
  // stall (either because the interrupt is taken or is disabled in the retr stage)
  assert_priv_irq_stall_must_commit: assert property (@(posedge clk) disable iff (~resetn) 
                                                      irq_stall_lsu_req |-> ##[0:$] interrupt_could_commit);
  
  assert_priv_irq_stall_must_unstall: assert property (@(posedge clk) disable iff (~resetn)
                                                       irq_stall_lsu_req |-> ##[1:$] ~irq_stall_lsu_req);

  cover_csr_priv_irq_simultaneous_irq_sw_ext: cover property (@(posedge clk) disable iff (~resetn)
                                                              interrupt_taken_ext & base_ip_sw & base_ip_ext);   
                                                              

                                                               

 
`endif 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_expipe.sv
//
//   Purpose: core Execution pipeline
//            Contains the main blocks of the control and execution datapath
//            Fetch, Load-store, and memory protection are outsidfe this block to allow
//            this block (and the aformentioned blocks) to be formally verified in isolation
//            core is logically a 4 stage pipeline
//              - Fetch
//              - Decode
//              - Execute
//              - Retire (Memory-Commit)
//
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_expipe
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH          = 32,
    parameter D_ADDR_WIDTH          = 32,
    parameter I_DATA_BYTES          = 4,
    parameter D_DATA_BYTES          = 4,
	parameter l_core_cfg_hw_debug           = 0,
    parameter l_core_cfg_num_triggers       = 0,
	parameter l_core_cfg_hw_multiply_divide = 0,
	parameter l_core_cfg_hw_macc_multiplier = 0,
	parameter l_core_cfg_hw_compressed      = 0,
	parameter l_core_cfg_hw_sp_float        = 0,
	parameter l_core_reset_vector           = 32'h6000_0000,
    parameter l_core_static_mtvec_base      = 32'h6000_0034,
    parameter l_core_cfg_static_mtvec_base  = 0,
    parameter l_core_cfg_static_mtvec_mode  = 0,
    parameter l_core_static_mtvec_mode      = 0,
	parameter l_core_num_sys_ext_irqs       = 9,
	parameter l_core_cfg_time_count_width   = 0,
    parameter l_core_cfg_lsu_fwd            = 1'b1,
    parameter l_core_cfg_csr_fwd            = 1'b1,
    parameter l_core_cfg_exu_fwd            = 1'b1,
	parameter l_core_cfg_gpr_type           = 0,
	parameter ECC_ENABLE                    = 0,
	parameter NO_MACC_BLK                   = 0,
    parameter l_subsys_cfg_axi_present  = 1,
    parameter l_subsys_cfg_ahb_present  = 0,
    parameter l_subsys_cfg_tcm0_present      = 1,
    parameter l_axi_start_addr         = 32'h6000_0000,
    parameter l_axi_end_addr           = 32'h6000_FFFF,
    parameter l_ahb_start_addr         = 32'h6000_0000,
    parameter l_ahb_end_addr           = 32'h6000_FFFF,
    parameter l_tcm0_start_addr             = 32'h8000_0000,
    parameter l_tcm0_end_addr               = 32'h8000_0FFF
   )
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,         
  input  wire logic                                resetn, 
  
  input  wire logic                                core_soft_reset,   
  output      logic                                gpr_uncorrectable_ecc_error,
  input  wire logic [(L_XLEN*2)-1:0]               time_count,
  input  wire logic [L_XLEN-1:0]                   hart_id,
  
  // Fetch Unit Interface
  output      logic                                ifu_expipe_fetch_en,
  output      logic                                ifu_expipe_req_branch_excpt_req_valid,
  output      logic                                ifu_expipe_req_branch_excpt_req_fenci,
  output      logic                                ifu_expipe_req_fenci_proceed,
  input wire  logic                                ifu_expipe_req_branch_excpt_req_ready,    
  output      logic [I_ADDR_WIDTH-1:0]             ifu_expipe_req_branch_excpt_vaddr,  // bcu result
  output      logic                                ifu_expipe_req_flush,
  output      logic [1:0]                          ifu_expipe_req_priv,
  input wire  logic [I_ADDR_WIDTH-1:0]             ifu_expipe_resp_next_vaddr,
   
  input wire  logic                                ifu_expipe_resp_valid,
  output      logic                                ifu_expipe_resp_ready,
  input wire  logic [31:0]                         ifu_expipe_resp_ireg,
  input wire  logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_ireg_vaddr,
  input wire  logic                                ifu_expipe_resp_ireg_vaddr_valid,
  input wire  logic                                ifu_expipe_resp_compressed,
  input wire  logic                                ifu_expipe_resp_access_fault,  
  input wire  logic                                ifu_expipe_resp_access_mem_error,
  input wire  logic                                ifu_expipe_resp_access_parity_error,
  input wire  logic                                ifu_expipe_resp_access_misalign_error,
  input wire  logic                                ifu_expipe_resp_access_aborted,  
  
  
  // Memory Management Unit Interface
  
  // Load-Store Unit Interface
  output      logic                                lsu_flush,
  input wire  logic                                lsu_op_os,
  input wire  logic                                lsu_ld_op_os,   
  input wire  logic                                lsu_fence_op_os,
  output      logic                                lsu_req_valid,  
  input wire  logic                                lsu_req_ready,  
  output      logic[D_ADDR_WIDTH-1:0]              lsu_req_addr,
  output      logic                                lsu_req_addr_valid,
  output      logic [(D_DATA_BYTES*8)-1:0]         lsu_req_wr_data, 
  output      logic                                lsu_req_wr_data_valid,
  output      t_lsu_op                             lsu_req_op,   
   
  input wire  logic                                lsu_resp_valid,
  output      logic                                lsu_resp_ready, 
  input wire  logic [(D_DATA_BYTES*8)-1:0]         lsu_resp_rd_data,
  input wire  logic                                lsu_resp_ld_addr_misalign,     
  input wire  logic                                lsu_resp_ld_access_fault,      
  input wire  logic                                lsu_resp_str_amo_addr_misalign,
  input wire  logic                                lsu_resp_str_amo_access_fault, 
  input wire  logic                                lsu_resp_access_mem_error,
  input wire  logic                                lsu_resp_access_parity_error,
  input wire  logic                                lsu_resp_access_aborted, 
          
  // Debug Unit Interface
  input  wire  logic                               debug_reset,
  input  wire  logic                               debug_core_reset,
  input  wire  logic                               debug_active,
  input  wire  logic [L_XLEN-1:0]                  debug_csr_gpr_req_wr_data,       
  output logic                                     debug_csr_req_ready,  
  input  wire  logic                               debug_csr_req_valid,   
  input  wire  logic                               debug_csr_req_wr_en,        
  input  wire  logic                               debug_csr_req_rd_en,        
  input  wire logic [11:0]                         debug_csr_req_addr,        
  output logic [L_XLEN-1:0]                        debug_csr_resp_rd_data, 
  output logic                                     debug_csr_resp_valid, 
  input  wire  logic                               debug_csr_resp_ready,    // not currently used. must always be ready to accept responses when debug request made      
  input  wire  logic                               debug_gpr_req_valid, 
  output logic                                     debug_gpr_req_ready,     
  input  wire  logic                               debug_gpr_req_wr_en,        
  input  wire  logic                               debug_gpr_req_rd_en,        
  input  wire logic [5:0]                          debug_gpr_req_addr,      
  output logic [L_XLEN-1:0]                        debug_gpr_resp_rd_data,                                                                           
  output logic                                     debug_gpr_resp_valid,                           
  input  wire  logic                               debug_gpr_resp_ready,   // not currently used. must always be ready to accept responses when debug request made                            
  input  wire logic                                debug_halt_req,   
  output logic                                     debug_halt_ack,
  input  wire logic                                debug_resethalt_req,   
  output logic                                     debug_resethalt_ack,  
  input  wire logic                                debug_resume_req,   
  output logic                                     debug_resume_ack,
  output logic                                     debug_mode,   
  
  // Interrupt (LIC) Interface     
  
  input wire  logic                                m_sw_irq,
  input wire  logic                                m_timer_irq,
  input wire  logic                                m_external_irq,       
  input wire  logic [9:0]                          sys_ext_irq_src,         
  
  // Direct State Interface
  
  // Formal Trace Interface
  
  output logic [L_XLEN-1:0]                        formal_trace_instr,
  output logic [L_XLEN-1:0]                        formal_trace_pc,
  output logic                                     formal_trace_reset_taken,  
  output logic                                     formal_trace_instr_retire,
  
  // Instruction Trace Interface
  
  output logic                                     trace_valid,
  output logic [L_XLEN-1:0]                        trace_iaddr,
  output logic [L_XLEN-1:0]                        trace_insn,
  output logic      							   trace_priv, // trace spec [2:0] to support all privelege modes. Single bit used here, maps to [2] - MM  =3'b011, DM = 3'b100
  output logic						     		   trace_exception,
  output logic									   trace_interrupt,	
  output logic [4:0]                               trace_cause,
  output logic [L_XLEN-1:0]                        trace_tval,
    
  //gpr ram init done signal to hold cpu in soft reset while init takes place
  output logic                                     gpr_ram_init_done,
  
  //fence.i instructions causes icache to flush
  output logic                                     i_flush,
  output logic                                     ram_init_soft_debug_reset,
  input wire  logic                                icache_ram_init_done,
  input wire logic [1:0]                           gpr_ecc_error_injection
  );
   


  
//******************************************************************************
// Declarations
//  localparam HW_TRIGGER                                         = 1;
//  localparam l_core_cfg_num_triggers                       = (HW_TRIGGER) ? 2 : 0;
  localparam l_core_cfg_trigger_bus_width                  = (l_core_cfg_num_triggers > 0) ? l_core_cfg_num_triggers : 1;
  localparam logic l_core_cfg_gpr_ecc_uncorrectable_irq    = ECC_ENABLE;
  localparam logic l_core_cfg_gpr_ecc_correctable_irq      = ECC_ENABLE;
  localparam l_core_cfg_gpr_fwd_hzd                        = l_core_cfg_lsu_fwd | l_core_cfg_exu_fwd;
  
// FE pipeline stage signals
  logic                         flush_fe;

// DE pipeline stage signals
  t_expipe_stage_state                          stage_state_de;
  t_expipe_stage_state                          next_stage_state_de;
  logic                                         instr_valid_de;
  logic                                         instr_completing_de;
  logic                                         instr_accepted_de; 
  logic                                         instr_req_de;
  logic                                         next_stage_ready_de; 
  logic                                         stage_ready_de;
  logic                                         flush_de; 
  logic                                         update_ex_retr_ctrl_attbs_de;
  logic                                         force_trap_branch_de;
  logic                                         force_core_soft_reset_branch_de;
  logic                                         force_debug_exit_branch_de;
  logic                                         force_debug_nop_de;
  logic                                         fence_i_in_progress;
  logic                                         csr_trigger_wr_hzd_de;
  logic                                         trigger_breakpoint_de;
  logic                                         trigger_op_addr_valid_de;
  logic [l_core_cfg_trigger_bus_width-1:0] trigger_req_de;
  logic                                         implicit_pseudo_instr_de;
  logic                                         debug_enter_req_de;
  logic                                         step_instruction_valid_de;
  
  logic                                         fetch_valid_de;
  logic                                         fetch_error_de;  
  
  logic                                         gpr_wr_en_de;     
  logic [5:0]                                   gpr_wr_sel_de;     
  logic                                         gpr_rs1_rd_valid_de;
  logic [5:0]                                   gpr_rs1_rd_sel_de;  
  logic                                         gpr_rs2_rd_valid_de; 
  logic [5:0]                                   gpr_rs2_rd_sel_de; 
  t_gpr_wr_mux_sel                              gpr_wr_mux_sel_de;
  
  logic [11:0]                                  sw_csr_addr_de;    
  t_csr_alu_wr_op_sel                           sw_csr_wr_op_de;      
  t_csr_alu_rd_op_sel                           sw_csr_rd_op_de; 
  logic                                         csr_rd_en_valid_de;
  logic                                         csr_wr_en_valid_de;
  
  logic                                         exu_op_abort_de;    
  t_exu_alu_operand0_sel                        operand0_mux_sel_de;
  t_exu_alu_operand1_sel                        operand1_mux_sel_de;
  t_exu_alu_op_sel                              alu_op_sel_de;             
  t_exu_shifter_op_sel                          shifter_unit_op_sel_de;     
  t_exu_shifter_places_sel                      shifter_unit_places_sel_de;    
  t_exu_shifter_operand_sel                     shifter_unit_operand_sel_de;
  t_exu_bcu_operand0_sel                        bcu_operand0_mux_sel_de;
  t_exu_bcu_operand1_sel                        bcu_operand1_mux_sel_de;
  t_exu_bcu_op_sel                              bcu_op_sel_de;            
  t_exu_alu_result_mux_sel                      exu_result_mux_sel_de;  
  
  t_branch_cond                                 branch_cond_de; 
  logic                                         fence_i_de;
  logic                                         fence_de;     
  t_lsu_op                                      lsu_op_de;  
  logic                                         wfi_de;  
  logic [L_XLEN-1:0]                            immediate_de;
  logic                                         illegal_instr_de;
  logic                                         csr_rd_illegal_de;
  logic                                         csr_wr_illegal_de;
  logic                                         illegal_instr_csr_de;
  logic                                         m_env_call_de;
  logic                                         m_ret_de;
  logic                                         d_ret_de;
  logic                                         dbreak_de;
  logic                                         stall_de;
  logic                                         gpr_rs1_stall_de;
  logic                                         gpr_rs2_stall_de;
  logic [L_XLEN-1:0]                            gpr_rs1_rd_data_fwd_de;      
  logic                                         gpr_rs1_rd_data_fwd_valid_de;
  logic [L_XLEN-1:0]                            gpr_rs2_rd_data_fwd_de;      
  logic                                         gpr_rs2_rd_data_fwd_valid_de;
  
// EX pipeline stage signals  
  t_expipe_stage_state                          stage_state_ex;
  t_expipe_stage_state                          next_stage_state_ex;
  logic                                         instr_valid_ex;
  logic                                         instr_completing_ex;
  logic                                         instr_can_complete_ex;
  logic                                         instr_accepted_ex; 
  logic                                         instr_req_ex;
  logic                                         next_stage_ready_ex; 
  logic                                         stage_ready_ex;
  logic                                         gpr_rd_rs1_completing_ex;
  logic                                         gpr_rd_rs2_completing_ex;   
  logic                                         gpr_rd_rs1_complete_ex; 
  logic                                         gpr_rd_rs2_complete_ex;
  logic                                         alu_op_completing_ex;  
  logic                                         alu_op_complete_ex;  
  logic                                         shift_op_completing_ex;    
  logic                                         shift_op_complete_ex; 
  logic                                         bcu_op_completing_ex;  
  logic                                         bcu_op_complete_ex; 
  logic                                         lsu_op_completing_ex;
  logic                                         lsu_op_complete_ex;
  logic                                         update_ctrl_attbs_ex; 
  
  logic                                         gpr_rs1_stall_ex;
  logic                                         gpr_rs2_stall_ex;   
  logic                                         trap_cause_hzd_ex;
  logic                                         epc_hzd_ex;       
  logic                                         trap_vec_hzd_ex;  
  logic                                         gpr_rs1_fwd_exu;
  logic                                         gpr_rs1_fwd_csr;
  logic                                         gpr_rs1_fwd_lsu;
  logic                                         gpr_rs1_stall_lsu;
  logic                                         gpr_rs1_stall_csr;
  logic                                         gpr_rs1_stall_exu;
  logic                                         gpr_rs2_fwd_exu;
  logic                                         gpr_rs2_fwd_csr;
  logic                                         gpr_rs2_fwd_lsu;
  logic                                         gpr_rs2_stall_lsu;
  logic                                         gpr_rs2_stall_csr;
  logic                                         gpr_rs2_stall_exu;
  
  logic                                         de_ex_pipe_implicit_pseudo_instr_ex;
  logic                                         de_ex_pipe_fence_i_ex;
  logic                                         de_ex_pipe_fence_ex;
  logic                                         de_ex_pipe_wfi_ex;
  logic                                         de_ex_pipe_i_access_fault_ex;
  logic                                         de_ex_pipe_i_access_mem_error_ex;
  logic                                         de_ex_pipe_i_access_parity_error_ex;
  logic                                         de_ex_pipe_i_access_misalign_error_ex;
  logic                                         de_ex_pipe_illegal_instr_ex;
  logic                                         de_ex_pipe_m_env_call_ex;
  logic                                         de_ex_pipe_trap_ret_ex;
  logic                                         de_ex_pipe_dbreak_ex;
  logic [L_XLEN-1:0]                            de_ex_pipe_immediate_ex;
  logic [31:0]                                  de_ex_pipe_curr_instr_enc_ex;
  logic [L_XLEN-1:0]                            de_ex_pipe_curr_pc_ex;
  logic                                         trap_pending_ex;
  logic                                         de_ex_pipe_any_trigger_ex;
  logic [l_core_cfg_trigger_bus_width-1:0] de_ex_pipe_trigger_ex;
  logic                                         de_ex_pipe_debug_enter_req_ex;
  logic                                         instr_inhibit_ex;
  logic                                         implicit_pseudo_instr_ex;  
  logic                                         fence_i_ex;  
  logic                                         fence_ex;  
  logic                                         wfi_ex;    
  logic                                         i_access_fault_ex;       
  logic                                         i_access_mem_error_ex;   
  logic                                         i_access_parity_error_ex;
  logic                                         i_access_misalign_error_ex;
  logic                                         illegal_instr_ex;
  logic                                         sw_csr_rd_illegal_ex;
  logic                                         m_env_call_ex;
  logic                                         trap_ret_ex;
  logic                                         dbreak_ex;
  logic [l_core_cfg_trigger_bus_width-1:0] trigger_ex;
  logic                                         debug_enter_req_ex;
  logic [L_XLEN-1:0]                            immediate_ex;
  logic [31:0]                                  curr_instr_enc_ex;
  logic [L_XLEN-1:0]                            curr_pc_ex;
  logic                                         flush_ex;  
  
  logic                                         de_ex_pipe_gpr_wr_en_ex;  
  logic                                         de_ex_pipe_gpr_rs1_rd_valid_ex;
  logic                                         de_ex_pipe_gpr_rs2_rd_valid_ex;
  logic [5:0]                                   de_ex_pipe_gpr_wr_sel_ex;  
  logic [5:0]                                   de_ex_pipe_gpr_rs1_rd_sel_ex; 
  logic [5:0]                                   de_ex_pipe_gpr_rs2_rd_sel_ex;
  t_gpr_wr_mux_sel                              de_ex_pipe_gpr_wr_mux_sel_ex; 
  logic [L_XLEN-1:0]                            de_ex_pipe_gpr_rs1_rd_data_ex;      
  logic [L_XLEN-1:0]                            de_ex_pipe_gpr_rs2_rd_data_ex;      
  logic                                         de_ex_pipe_gpr_rs1_rd_data_valid_ex;
  logic                                         de_ex_pipe_gpr_rs2_rd_data_valid_ex;
  logic                                         gpr_wr_en_ex;     
  logic [5:0]                                   gpr_wr_sel_ex;     
  logic                                         gpr_rs1_rd_valid_ex;
  logic [5:0]                                   gpr_rs1_rd_sel_ex;  
  logic [L_XLEN-1:0]                            gpr_rs1_rd_data_ex;
  logic                                         gpr_rs1_rd_data_valid_ex;
  logic [L_XLEN-1:0]                            gpr_rs1_rd_data_fwd_ex;
  logic                                         gpr_rs1_rd_data_fwd_valid_ex;
  logic [L_XLEN-1:0]                            lsu_resp_rd_data_fwd;
  logic                                         lsu_resp_valid_fwd;
  logic                                         gpr_rs2_rd_valid_ex;
  logic [5:0]                                   gpr_rs2_rd_sel_ex; 
  logic [L_XLEN-1:0]                            gpr_rs2_rd_data_ex;
  logic                                         gpr_rs2_rd_data_valid_ex;
  logic [L_XLEN-1:0]                            gpr_rs2_rd_data_fwd_ex;
  logic                                         gpr_rs2_rd_data_fwd_valid_ex;
  t_gpr_wr_mux_sel                              gpr_wr_mux_sel_ex;   
 
  t_csr_alu_rd_op_sel                           de_ex_pipe_sw_csr_rd_op_ex;
  t_csr_alu_wr_op_sel                           de_ex_pipe_sw_csr_wr_op_ex;
  logic [11:0]                                  de_ex_pipe_sw_csr_addr_ex;
  t_csr_alu_rd_op_sel                           sw_csr_rd_op_ex;     
  t_csr_alu_wr_op_sel                           sw_csr_wr_op_ex;
  logic [11:0]                                  sw_csr_addr_ex;    
  
  logic                                         exu_op_abort_ex;
  logic                                         ex_retr_exu_res_accept_retr;
  t_exu_alu_op_sel                              de_ex_pipe_alu_op_sel_ex;
  t_exu_shifter_op_sel                          de_ex_pipe_shifter_unit_op_sel_ex;
  t_exu_alu_operand0_sel                        de_ex_pipe_operand0_mux_sel_ex;
  t_exu_alu_operand1_sel                        de_ex_pipe_operand1_mux_sel_ex;
  t_exu_shifter_places_sel                      de_ex_pipe_shifter_unit_places_sel_ex;
  t_exu_shifter_operand_sel                     de_ex_pipe_shifter_unit_operand_sel_ex;
  t_exu_alu_result_mux_sel                      de_ex_pipe_exu_result_mux_sel_ex;
  t_exu_alu_op_sel                              alu_op_sel_ex;
  t_exu_shifter_op_sel                          shifter_unit_op_sel_ex;
  t_exu_alu_operand0_sel                        operand0_mux_sel_ex;
  t_exu_alu_operand1_sel                        operand1_mux_sel_ex;
  t_exu_shifter_places_sel                      shifter_unit_places_sel_ex;
  t_exu_shifter_operand_sel                     shifter_unit_operand_sel_ex;
  t_exu_alu_result_mux_sel                      exu_result_mux_sel_ex;
  logic                                         exu_result_valid_ex;
  logic [L_XLEN-1:0]                            exu_result_ex;
  t_exu_flags                                   exu_result_flags_ex;
  logic [L_XLEN-1:0]                            align_result_ex;
  logic                                         align_result_valid_ex;
  logic                                         exu_update_result_reg;
  logic                                         exu_op_ready_ex;
  logic [L_XLEN-1:0]                            lsu_addr_result_ex;
  logic                                         lsu_addr_result_valid_ex;  
  logic                                         lsu_op_str_ex; 
  logic                                         lsu_req_stall_ex;     
  
  t_exu_bcu_op_sel                              de_ex_pipe_bcu_op_sel_ex;
  t_branch_cond                                 de_ex_pipe_branch_cond_ex;
  t_exu_bcu_operand0_sel                        de_ex_pipe_bcu_operand0_mux_sel_ex;
  t_exu_bcu_operand1_sel                        de_ex_pipe_bcu_operand1_mux_sel_ex;
  t_exu_bcu_op_sel                              bcu_op_sel_ex;
  t_branch_cond                                 branch_cond_ex;
  logic                                         branch_taken_ex;
  t_exu_bcu_operand0_sel                        bcu_operand0_mux_sel_ex;
  t_exu_bcu_operand1_sel                        bcu_operand1_mux_sel_ex;
  logic [L_XLEN-1:0]                            bcu_operand_trap_cause_ex;
  logic [L_XLEN-1:0]                            bcu_operand_trap_vec_ex;
  logic [L_XLEN-1:0]                            bcu_result_ex;
  logic                                         bcu_result_valid_ex;
  
  t_lsu_op                                      de_ex_pipe_lsu_op_ex;
  t_lsu_op                                      lsu_op_ex;
  t_lsu_op                                      lsu_op_ex_pipe_reg;
  t_lsu_op                                      lsu_op_ex_pipe;
  logic                                         instr_is_lsu_ldstr_ex;
  logic                                         instr_is_lsu_ldstr_reg_ex;
  
// RETR pipeline stage signals 
  t_expipe_stage_state                          stage_state_retr;
  t_expipe_stage_state                          next_stage_state_retr;
  logic                                         instr_req_retr;
  logic                                         exu_res_req_retr;
  logic                                         instr_valid_retr;
  logic                                         instr_completing_retr;
  logic                                         instr_accepted_retr; 
  logic                                         stage_ready_retr; 
//  logic                                         stage_ready_reg_retr;
  logic                                         update_ctrl_attbs_retr;
  logic                                         exu_result_reg_ready_retr;
  logic                                         flush_retr;
  logic                                         stall_retr;
  logic                                         irq_stall_lsu_req_retr;
  logic                                         irq_abort_lsu_req_retr;
  logic                                         wfi_waiting_retr;
  logic                                         trap_pending_retr;
    
  logic                                         ex_retr_pipe_implicit_pseudo_instr_retr;
  logic                                         ex_retr_pipe_fence_i_retr;  
  logic                                         ex_retr_pipe_wfi_retr;
  logic                                         ex_retr_pipe_i_access_fault_retr;
  logic                                         ex_retr_pipe_i_access_mem_error_retr;
  logic                                         ex_retr_pipe_i_access_parity_error_retr;
  logic                                         ex_retr_pipe_i_access_misalign_error_retr;
  logic                                         ex_retr_pipe_illegal_instr_retr;
  logic                                         ex_retr_pipe_m_env_call_retr;
  logic                                         ex_retr_pipe_trap_ret_retr;
  logic                                         ex_retr_pipe_dbreak_retr; 
  logic [l_core_cfg_trigger_bus_width-1:0] ex_retr_pipe_trigger_retr;
  logic [31:0]                                  ex_retr_pipe_curr_instr_enc_retr;
  logic [L_XLEN-1:0]                            ex_retr_pipe_curr_pc_retr; 
  logic                                         ex_retr_pipe_exu_result_valid_retr;
  logic [L_XLEN-1:0]                            ex_retr_pipe_exu_result_retr;
  logic                                         implicit_pseudo_instr_retr;
  logic                                         fence_i_retr;  
  logic                                         wfi_retr;
  logic                                         i_access_fault_retr;
  logic                                         i_access_mem_error_retr;
  logic                                         i_access_parity_error_retr;
  logic                                         i_access_misalign_error_retr;
  logic                                         illegal_instr_retr;
  logic                                         m_env_call_retr;
  logic                                         trap_ret_retr;
  logic                                         dbreak_retr; 
  logic [l_core_cfg_trigger_bus_width-1:0] trigger_retr;  
  logic                                         debug_enter_req_retr;
  logic [31:0]                                  curr_instr_enc_retr;
  logic [L_XLEN-1:0]                            curr_pc_retr; 
  logic                                         instr_retire_retr; 
  logic                                         exu_result_valid_retr;
  logic [L_XLEN-1:0]                            exu_result_retr;
  logic [L_XLEN-1:0]                            debug_csr_gpr_req_wr_data_dbgpipe; 
  logic                                         debug_csr_req_wr_en_dbgpipe;  
  logic                                         debug_csr_req_rd_en_dbgpipe;  
  logic [11:0]                                  debug_csr_req_addr_dbgpipe;

  logic                                         gpr_wr_completing_retr; 
  logic                                         gpr_wr_complete_retr;
  logic                                         ex_retr_pipe_gpr_wr_en_retr;
  logic [5:0]                                   ex_retr_pipe_gpr_wr_sel_retr;
  t_gpr_wr_mux_sel                              ex_retr_pipe_gpr_wr_mux_sel_retr;
  logic                                         gpr_wr_en_retr;
  logic [5:0]                                   gpr_wr_sel_retr;
  t_gpr_wr_mux_sel                              gpr_wr_mux_sel_retr;
  logic [L_XLEN-1:0]                            gpr_wr_data_retr;
  logic                                         gpr_wr_valid_retr;
  logic                                         gpr_wr_ready_retr;    
    
  logic                                         gpr_wr_valid_mux;        
  logic [5:0]                                   gpr_wr_sel_mux;       
  logic [L_XLEN-1:0]                            gpr_wr_data_mux;      
  logic                                         gpr_rs1_rd_valid_mux; 
  logic [5:0]                                   gpr_rs1_rd_sel_mux;    
  logic                                         gpr_rs2_rd_valid_mux;
  logic [5:0]                                   gpr_rs2_rd_sel_mux;    
  logic                                         gpr_wr_ready_sig;
  logic                                         gpr_rs1_rd_ready_sig;  
  logic[L_XLEN-1:0]                             gpr_rs1_rd_data_sig;
  logic                                         gpr_rs1_rd_data_valid_sig;  
  logic                                         gpr_rs2_rd_ready_sig; 
  logic[L_XLEN-1:0]                             gpr_rs2_rd_data_sig;
  logic                                         gpr_rs2_rd_data_valid_sig; 
  logic                                         gpr_rs2_rd_valid_dbgpipe;
  logic [5:0]                                   gpr_rs2_rd_sel_dbgpipe;  
  logic                                         gpr_rs2_rd_valid_stg;
  logic [5:0]                                   gpr_rs2_rd_sel_stg; 
  
  logic                                         gpr_rs3_rd_valid_de;
  logic [5:0]                                   gpr_rs3_rd_sel_de;  
  logic                                         gpr_rs3_stall_de;
  logic [L_XLEN-1:0]                            gpr_rs3_rd_data_fwd_de;      
  logic                                         gpr_rs3_rd_data_fwd_valid_de;
  logic                                         gpr_rd_rs3_completing_ex;
  logic                                         gpr_rd_rs3_complete_ex; 
  logic                                         gpr_rs3_stall_ex;
  logic                                         gpr_rs3_fwd_exu;
  logic                                         gpr_rs3_fwd_csr;
  logic                                         gpr_rs3_fwd_lsu;
  logic                                         gpr_rs3_stall_lsu;
  logic                                         gpr_rs3_stall_csr;
  logic                                         gpr_rs3_stall_exu;
  logic                                         de_ex_pipe_gpr_rs3_rd_valid_ex;
  logic [5:0]                                   de_ex_pipe_gpr_rs3_rd_sel_ex; 
  logic [L_XLEN-1:0]                            de_ex_pipe_gpr_rs3_rd_data_ex;      
  logic                                         de_ex_pipe_gpr_rs3_rd_data_valid_ex;
  logic                                         gpr_rs3_rd_valid_ex;
  logic [5:0]                                   gpr_rs3_rd_sel_ex;  
  logic [L_XLEN-1:0]                            gpr_rs3_rd_data_ex;
  logic                                         gpr_rs3_rd_data_valid_ex;
  logic [L_XLEN-1:0]                            gpr_rs3_rd_data_fwd_ex;
  logic                                         gpr_rs3_rd_data_fwd_valid_ex;
  logic                                         gpr_rs3_rd_valid_mux; 
  logic [5:0]                                   gpr_rs3_rd_sel_mux;    
  logic                                         gpr_rs3_rd_ready_sig;  
  logic[L_XLEN-1:0]                             gpr_rs3_rd_data_sig;
  logic                                         gpr_rs3_rd_data_valid_sig; 
  
  logic[2:0]                                     fpu_frm_de;
  logic[1:0]                                     fpu_fmt_de;
  logic                                          fpu_instr_de;
  
  logic[4:0]                                     fpu_flags_ex;
  logic                                          fpu_flags_valid_ex;
  logic[2:0]                                     fpu_frm_ex;
  logic[1:0]                                     fpu_fmt_ex;
  logic                                          fpu_instr_ex;
  
  logic[2:0]                                     fpu_frm_csr;
  
  logic[2:0]                                     de_ex_pipe_fpu_frm_ex;  
  logic[1:0]                                     de_ex_pipe_fpu_fmt_ex;  
  logic                                          de_ex_pipe_fpu_instr_ex;
  
  logic                                         trap_taken_retr;
  logic                                         soft_reset_taken_retr;
  logic                                         soft_reset_taken_unmasked_retr;
  logic                                         vectored_interrupt_taken_retr;
  logic                                         csr_priv_mtvec_excpt_vectored_retr;
  logic                                         interrupt_taken_retr;
  logic                                         soft_reset_pending_retr;
  logic                                         next_soft_reset_pending_retr;
  
  logic [11:0]                                  ex_retr_pipe_sw_csr_addr_retr; 
  t_csr_alu_wr_op_sel                           ex_retr_pipe_sw_csr_wr_op_retr; 
  t_csr_alu_rd_op_sel                           ex_retr_pipe_sw_csr_rd_op_retr; 
  logic [11:0]                                  sw_csr_addr_retr;
  t_csr_alu_wr_op_sel                           sw_csr_wr_op_retr; 
  t_csr_alu_rd_op_sel                           sw_csr_rd_op_retr; 
  logic [L_XLEN-1:0]                            sw_csr_rd_data_retr;
  logic                                         sw_csr_rd_data_valid_retr; 
  logic                                         csr_completing_retr;
  logic                                         csr_complete_retr;  
  logic                                         csr_result_reg_ready_retr;  
  logic                                         sw_csr_op_ready_retr;
  logic                                         csr_explicit_wr_retr;
  logic [L_XLEN-1:0]                            csr_priv_misa_retr;
  logic [4:0]                                   csr_priv_cause_excpt_code_retr;
  logic [L_XLEN-1:0]                            csr_priv_mtvec_excpt_vec_retr;
  logic [L_XLEN-1:0]							csr_priv_mtval_retr;
  logic [L_XLEN-1:0]                            csr_priv_mtvec_epc_retr;
  logic [L_XLEN-1:0]                            csr_priv_dpc_retr;
  logic [1:0]                                   priv_mode_retr; 
  logic                                         debug_mode_retr;
  logic                                         debug_enter_retr;
  logic                                         debug_mode_retire_mask_retr;
  logic                                         debug_exit_retr; 
  logic                                         cfg_hw_mul_en_retr;  
  logic                                         cfg_hw_div_en_retr;     
  logic                                         cfg_atomics_en_retr;    
  logic                                         cfg_compressed_en_retr;
  logic                                         cfg_float_en_retr;
  
  logic                                         lsu_op_completing_retr;
  logic                                         lsu_op_complete_retr;  
  t_lsu_op                                      ex_retr_pipe_lsu_op_retr;
  t_lsu_op                                      lsu_op_retr;
  logic                                         lsu_req_stall_retr;
  logic                                         instr_is_lsu_op_retr;
  
  
  logic                                         bus_error_i_irq_src;          
  logic                                         parity_error_i_irq_src;       
  logic                                         bus_error_d_irq_src;          
  logic                                         parity_error_d_irq_src;      
  logic                                         gpr_uncorrectable_ecc_irq_src;
  logic                                         gpr_correctable_ecc_irq_src;
  
  logic											sreset;
 

//******************************************************************************
// Main code

  //--------------------------------------------------------
  // Pipeline
  //--------------------------------------------------------
  
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++
  // Fetch stage (FE)
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++
  
  // The fetch stage requests a 32 bit memory fetch from memory (even when compressed instructions fetched/executed)
  // Branches/exceptions/soft-reset will immediately cause the instructions currently fetched/being decoded to be flushed and fetching to occur  
  // at the branch/exception/reset target address generated in the ex stage
  // fence.i will be treated as a branch to the next instruction after the fence.i, such that the pipeline before the fence.i 
  // will be flushed and instructions refeteched after the fence.i has been indicated as completing in the retr stage
  
   //--------------------------------------------------------
  // Instruction fetch unit interface
  //--------------------------------------------------------
  // The fetch stage is entirely handled in the seperate instruction fetch unit to simplify independent formal verification and make IFU interchangeable for more capability 
  assign flush_fe = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr; 
  
  assign ifu_expipe_fetch_en                   = ~debug_mode_retr; 
  assign ifu_expipe_req_branch_excpt_req_valid = branch_taken_ex; 
  assign ifu_expipe_req_branch_excpt_req_fenci = fence_i_ex  & ~instr_inhibit_ex;
  assign ifu_expipe_req_branch_excpt_vaddr     = {bcu_result_ex[I_ADDR_WIDTH-1:1],1'b0};
  assign ifu_expipe_req_flush                  = flush_fe;                             
  assign ifu_expipe_req_priv                   = priv_mode_retr;
  

 
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++
  // Decode stage (DE)
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++ 
  
  // The decode stage returns a 32 bit memory fetch from memory, aligns (where required 
  // for compressed instructions and halfword aligned uncompressed instructions), and decodes the returned
  // instruction.
  // To avoid stalling the fetch stage (and requiring additional buffering), in the case of a hazard caused 
  // by an instruction in the retr stage changing MISA which may cause the current instruction to be decoded differently,
  // the fe stage will instead refetch the instruction such that it can be decoded correctly when the MISA update becomes 
  // visible
  // Insert an instruction if nothing fetched and debug entry request such that it propagates through the pipe as a nop pseudo-instruction
  // (decoder will decode nop because ifu_expipe_resp_valid) not assrted, then overide request generation)
  
  //--------------------------------------------------------
  // Stage handshaking/control
  //--------------------------------------------------------
   
  
  assign instr_req_de  = (ifu_expipe_resp_valid & ~flush_de) 
                         | force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de | 
                         force_debug_nop_de;
  
  assign instr_accepted_de   = instr_req_de & stage_ready_de;
  
  assign stall_de = csr_trigger_wr_hzd_de |
                    gpr_rs1_stall_de |
                    gpr_rs2_stall_de |
                    gpr_rs3_stall_de; 
  
  always @*
  begin
    case(stage_state_de)
      expipe_stage_state_ready : 
      begin
        next_stage_state_de = (instr_accepted_de & !(instr_completing_de | flush_de)) ? expipe_stage_state_busy : expipe_stage_state_ready;
        //instr_accepted_de   = instr_req_de & stage_ready_ex & ~csr_trigger_wr_hzd_de;
        stage_ready_de      = stage_ready_ex & ~stall_de;
        instr_valid_de      = instr_req_de;
        
      end
    
      expipe_stage_state_busy : 
      begin
        //next_stage_state_de = instr_req_de ? expipe_stage_state_busy : (instr_completing_de | flush_de) ? expipe_stage_state_ready : stage_state_de;
        next_stage_state_de = (stage_ready_ex & ~stall_de) ? expipe_stage_state_ready : stage_state_de;
        //next_stage_state_de = (instr_completing_de | flush_de) ? expipe_stage_state_ready : stage_state_de;
        //instr_accepted_de   = 1'b0;
        stage_ready_de      = 1'b0;
        instr_valid_de      = 1'b1;
      end
    
      default :
        begin
        next_stage_state_de = expipe_stage_state_ready;
        //instr_accepted_de   = 1'b0;
        stage_ready_de      = 1'b0;
        instr_valid_de      = 1'b0;
      end
    endcase
  end 

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      stage_state_de  <= expipe_stage_state_ready;
    else
      stage_state_de  <= next_stage_state_de;     
  end    
    
  assign flush_de            = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr; // 
  assign instr_completing_de = instr_accepted_ex;
  
  // Hazards
  //--------------
  
  
  // Trigger logic
  //--------------
  // Trigger comparison is done in DE stage because specification requires tha trigger occurs _before_ instruction execution
  // By performing in DE stage, trigger can be handled by the pipeline just as an EBREAK instruction  
  // If trigger compare registers are to be written by CSR instruction in EX or RETR stage, need to stall DE stage until write completes
  
  generate if(l_core_cfg_num_triggers > 0)
  begin : gen_trig_de
    assign csr_trigger_wr_hzd_de    =  (((sw_csr_addr_ex   == l_core_csr_addr_tselect) |
                                         (sw_csr_addr_ex   == l_core_csr_addr_tdata1) |
                                         (sw_csr_addr_ex   == l_core_csr_addr_tdata2) |
                                         (sw_csr_addr_ex   == l_core_csr_addr_tdata3)) & (sw_csr_wr_op_ex != csr_alu_wr_op_none)) |
                                       (((sw_csr_addr_retr == l_core_csr_addr_tselect) |
                                         (sw_csr_addr_retr == l_core_csr_addr_tdata1) |
                                         (sw_csr_addr_retr == l_core_csr_addr_tdata2) |
                                         (sw_csr_addr_retr == l_core_csr_addr_tdata3)) & (sw_csr_wr_op_retr != csr_alu_wr_op_none));                                 

    
    assign trigger_op_addr_valid_de = ifu_expipe_resp_valid & 
                                      ~(flush_de | stall_de | force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
    
  end else
  begin : ngen_trig_de
  
    assign csr_trigger_wr_hzd_de = 1'b0;
    assign trigger_op_addr_valid_de = 1'b0;
    
  end
  endgenerate    
  
  // enable step pending when valid (non-pseudo instruction) accepted by ex phase
  assign step_instruction_valid_de = instr_accepted_ex & ~implicit_pseudo_instr_de;


  //--------------------------------------------------------
  // Instruction fetch unit interface
  //--------------------------------------------------------
  
  assign ifu_expipe_resp_ready  = stage_ready_de;  
  
  assign fetch_error_de         = ifu_expipe_resp_access_fault |  
                                  ifu_expipe_resp_access_mem_error |
                                  ifu_expipe_resp_access_parity_error |
                                  ifu_expipe_resp_access_misalign_error |
                                  ifu_expipe_resp_access_aborted; 

  
  //--------------------------------------------------------
  // Instruction decoder unit instance
  //--------------------------------------------------------
  
 
  
  // inhibit decode, but still propagate valid through the pipeline such that the trap gets handled in retr                    
  assign fetch_valid_de = ifu_expipe_resp_valid & ~fetch_error_de;   
  
  // decoder will generate the decode to handle the trap action (branch to exception vector)
  // Also need to overide vectored interrupt handling (though trap has priority), and bcu_operand1_sel to be the address of the 
  // instruction in de instead of exvec - in order to pass this into the bcu in the ex stage, use imm
  
  assign force_core_soft_reset_branch_de  = soft_reset_taken_retr;
  assign force_trap_branch_de             = trap_taken_retr;
  assign force_debug_exit_branch_de       = debug_exit_retr; 
  
  // don't force a debug entry nop if a fence_i is in progress as the next address may be invalid
  // wait for the fence_i to complete
  assign fence_i_in_progress              = (fence_i_ex & instr_valid_ex) | (fence_i_retr & instr_valid_retr);
  assign force_debug_nop_de               = debug_enter_req_de & (~ifu_expipe_resp_valid) & (~fence_i_in_progress);  
                                                                                              
  assign implicit_pseudo_instr_de = (force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de) | force_debug_nop_de ;
  
  miv_rv32_idecode  
  #(
   .GEN_DECODE_RV32I                 (l_core_cfg_hw_integer),
   .GEN_DECODE_RV32M                 (l_core_cfg_hw_multiply_divide),
   .GEN_DECODE_RV32C                 (l_core_cfg_hw_compressed),
   .GEN_DECODE_RV32F                 (l_core_cfg_hw_sp_float) 
  )
  u_idecode_0
  (
  .clk                               (clk                             ),
  .resetn                            (resetn                          ),
  .core_reset                        (force_core_soft_reset_branch_de ),   
  .trap_taken                        (force_trap_branch_de            ), 
  .debug_exit                        (force_debug_exit_branch_de      ),
  .vectored_interrupt_taken          (vectored_interrupt_taken_retr   ),
  .cfg_hw_mul_en                     (cfg_hw_mul_en_retr              ), 
  .cfg_hw_div_en                     (cfg_hw_div_en_retr              ),
  .cfg_atomics_en                    (cfg_atomics_en_retr             ), // Currently not supported in core
  .cfg_compressed_en                 (cfg_compressed_en_retr          ),
  .cfg_float_en                      (cfg_float_en_retr               ),
  .idecode_ready                     (/*open*/                        ), // Fully combinatorial for now so handled externally
  .debug_mode                        (debug_mode_retr                 ),
  .priv_mode                         (priv_mode_retr                  ),
  .instruction                       (ifu_expipe_resp_ireg            ),
  .instruction_valid                 (fetch_valid_de                  ),
  .instruction_compressed            (ifu_expipe_resp_compressed      ),
  .mnemonic                          (/*open*/                        ), // Used for debug only
  .immediate                         (immediate_de                    ),
  .illegal_instr                     (illegal_instr_de                ),
  .m_env_call                        (m_env_call_de                   ),
  .m_ret                             (m_ret_de                        ),
  .d_ret                             (d_ret_de                        ),
  .dbreakpoint                       (dbreak_de                       ),
  .gpr_wr_valid                      (gpr_wr_en_de                    ),
  .gpr_wr_sel                        (gpr_wr_sel_de                   ),
  .gpr_rs1_rd_valid                  (gpr_rs1_rd_valid_de             ),
  .gpr_rs1_rd_sel                    (gpr_rs1_rd_sel_de               ),
  .gpr_rs2_rd_valid                  (gpr_rs2_rd_valid_de             ),
  .gpr_rs2_rd_sel                    (gpr_rs2_rd_sel_de               ),
  .gpr_rs3_rd_valid                  (gpr_rs3_rd_valid_de             ),
  .gpr_rs3_rd_sel                    (gpr_rs3_rd_sel_de               ),
  .gpr_wr_mux_sel                    (gpr_wr_mux_sel_de               ),
  .sw_csr_addr                       (sw_csr_addr_de                  ),
  .sw_csr_wr_op                      (sw_csr_wr_op_de                 ),
  .sw_csr_rd_op                      (sw_csr_rd_op_de                 ),
  .operand0_mux_sel                  (operand0_mux_sel_de             ),
  .operand1_mux_sel                  (operand1_mux_sel_de             ),
  .alu_op_sel                        (alu_op_sel_de                   ),
  .shifter_operand_sel               (shifter_unit_operand_sel_de     ),
  .shifter_unit_places               (shifter_unit_places_sel_de      ),
  .shifter_unit_op_sel               (shifter_unit_op_sel_de          ),
  .bcu_operand0_mux_sel              (bcu_operand0_mux_sel_de         ),
  .bcu_operand1_mux_sel              (bcu_operand1_mux_sel_de         ),
  .bcu_op_sel                        (bcu_op_sel_de                   ),
  .exu_result_mux_sel                (exu_result_mux_sel_de           ),
  .branch_cond                       (branch_cond_de                  ),
  .fence_i                           (fence_i_de                      ),
  .fence                             (fence_de                        ), 
  .lsu_op                            (lsu_op_de                       ),
  .wfi                               (wfi_de                          ),
  .fpu_frm                           (fpu_frm_de                      ),
  .fpu_fmt                           (fpu_fmt_de                      ),
  .fpu_instr                         (fpu_instr_de                    )
  );
  
  // Check for illegal CSR access in the DE stage
  // Because all CSR accesses in core are determined only by address as Core
  // is machine mode only, can perform checks in advance of retire stage which simplifies
  // trap suppression of load-stores
  
  assign csr_rd_en_valid_de = (sw_csr_rd_op_de != csr_alu_rd_op_none); 
  assign csr_wr_en_valid_de = (sw_csr_wr_op_de != csr_alu_wr_op_none); 
  
    miv_rv32_csr_decode
    #(
      .CHECK_ILLEGAL         (1), 
	  .l_core_cfg_hw_debug   (l_core_cfg_hw_debug),
	  .l_core_cfg_hw_sp_float (l_core_cfg_hw_sp_float)
    )
    u_miv_rv32_csr_decode_de_0
    (
      .clk                         (clk                 ),
      .resetn                      (resetn              ),
      .debug_mode                  (1'b0                ), // only checking for normal executing mode accesses 
      .csr_rd_addr                 (sw_csr_addr_de      ),
      .csr_rd_en_valid             (csr_rd_en_valid_de  ),
      .csr_wr_addr                 (sw_csr_addr_de      ),
      .csr_wr_en_valid             (csr_wr_en_valid_de  ),
      .csr_reg_rd_sel              (                    ),  // open, Only checking for illegal access in DE stage
      .csr_reg_wr_sel              (                    ),  // open, Only checking for illegal access in DE stage
      .csr_rd_illegal              (csr_rd_illegal_de   ),  
      .csr_wr_illegal              (csr_wr_illegal_de   )      
    ); 

  assign illegal_instr_csr_de = illegal_instr_de |
                                csr_rd_illegal_de |
                                csr_wr_illegal_de;
                                
  // if l_core_cfg_gpr_rd_ex = 0, read the GPRs in the DE stage. This makes decode timing harder, adds additional stalls for lsu and csr accesses
  // and creates additional forwarding paths and pipeline registers, but in some cases may improve EX stage timing if RAM read timing is fast compared 
  // to logic speed.
  
  generate if (l_core_cfg_lsu_fwd)
  begin : gen_rs1_lsu_fwd_data_assign
    
    assign lsu_resp_rd_data_fwd = lsu_resp_rd_data;
    assign lsu_resp_valid_fwd   = lsu_resp_valid;
    
  end
  else begin : gen_rs1_lsu_stall_data_assign
  
    assign lsu_resp_rd_data_fwd = {L_XLEN{1'b0}};
    assign lsu_resp_valid_fwd   = 1'b0;                                   
  
  end
  endgenerate
  
  //REVIST - rs3 logic
  generate if (!l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_de
  
    logic gpr_rs1_fwd_exu_ex_de;
    logic gpr_rs1_stall_csr_ex_de;
    logic gpr_rs1_stall_lsu_ex_de;
    logic gpr_rs1_fwd_exu_retr_de;
    logic gpr_rs1_fwd_csr_retr_de;
    logic gpr_rs1_fwd_lsu_retr_de;
    logic gpr_rs2_fwd_exu_ex_de;
    logic gpr_rs2_stall_csr_ex_de;
    logic gpr_rs2_stall_lsu_ex_de;
    logic gpr_rs2_fwd_exu_retr_de;
    logic gpr_rs2_fwd_csr_retr_de;
    logic gpr_rs2_fwd_lsu_retr_de;  
    logic gpr_rs3_fwd_exu_ex_de;
    logic gpr_rs3_stall_csr_ex_de;
    logic gpr_rs3_stall_lsu_ex_de;
    logic gpr_rs3_fwd_exu_retr_de;
    logic gpr_rs3_fwd_csr_retr_de;
    logic gpr_rs3_fwd_lsu_retr_de;  
    
    
    // determine if GPR read result should be forwarded from later stage or from GPR 
    // do not forward reads from x0, as the result will always be 0, even if the sat being written to it is not.
	// however ft0 behaves like all other registers
    // EX stage forwarding has priority over retr stage forwarding
    // cannot forward LSU or CSR results from EX stage as they are not known until RETR stage, so have to stall
    // 
  
    assign gpr_rs1_fwd_exu_ex_de       = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 6'd0) ) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs1_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs1_stall_csr_ex_de     = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 6'd0) ) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs1_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_csr);                            
  
    assign gpr_rs1_stall_lsu_ex_de     = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 6'd0) ) &   
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs1_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_lsu);     
                                         
    assign gpr_rs1_stall_de            =  gpr_rs1_stall_csr_ex_de |  
                                          gpr_rs1_stall_lsu_ex_de |
                                          (instr_valid_de & gpr_rs1_rd_valid_de & ~gpr_rs1_rd_ready_sig) |
                                          (instr_valid_de & gpr_rs1_rd_valid_de & ~gpr_rs1_rd_data_fwd_valid_de);                       
                                      
    assign gpr_rs1_fwd_exu_retr_de   = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 6'd0) ) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs1_fwd_csr_retr_de   = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 6'd0) ) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                              
  
    assign gpr_rs1_fwd_lsu_retr_de   = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 6'd0) ) &   
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);    
                                       
    always @*
    begin
       casez({gpr_rs1_fwd_lsu_retr_de,gpr_rs1_fwd_csr_retr_de,gpr_rs1_fwd_exu_retr_de,gpr_rs1_fwd_exu_ex_de})
         4'b0000 : // No forwarding
         begin
           gpr_rs1_rd_data_fwd_de        = gpr_rs1_rd_data_sig;      
           gpr_rs1_rd_data_fwd_valid_de  = gpr_rs1_rd_data_valid_sig;
         end
         4'b???1 : // EXU forward (ex stage)
         begin
           gpr_rs1_rd_data_fwd_de        = exu_result_ex;       // REVISIT make sure this works for multistage ops in EXU
           gpr_rs1_rd_data_fwd_valid_de  = exu_result_valid_ex;
         end
         4'b1000 : // LSU forward (retr stage only)
         begin
           gpr_rs1_rd_data_fwd_de        = lsu_resp_rd_data_fwd;
           gpr_rs1_rd_data_fwd_valid_de  = lsu_resp_valid_fwd;  
         end
         4'b0100 : // CSR forward (retr stage only)
         begin
           gpr_rs1_rd_data_fwd_de        = sw_csr_rd_data_retr;      
           gpr_rs1_rd_data_fwd_valid_de  = sw_csr_rd_data_valid_retr;
         end
         4'b0010 : // EXU forward (retr stage)
         begin
           gpr_rs1_rd_data_fwd_de        = exu_result_retr;      
           gpr_rs1_rd_data_fwd_valid_de  = exu_result_valid_retr;
         end
         default : // illegal
         begin
           gpr_rs1_rd_data_fwd_de        = {L_XLEN{1'b0}};      
           gpr_rs1_rd_data_fwd_valid_de  = 1'b1;
         end
       endcase
     end        
     
    assign gpr_rs2_fwd_exu_ex_de       = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 6'd0) ) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs2_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs2_stall_csr_ex_de     = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 6'd0) ) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs2_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_csr);                            
  
    assign gpr_rs2_stall_lsu_ex_de     = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 6'd0) ) &   
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs2_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_lsu);     
                                         
    assign gpr_rs2_stall_de            =  gpr_rs2_stall_csr_ex_de |  
                                          gpr_rs2_stall_lsu_ex_de  |
                                          (instr_valid_de & gpr_rs2_rd_valid_de & ~gpr_rs2_rd_ready_sig) |
                                          (instr_valid_de & gpr_rs2_rd_valid_de & ~gpr_rs2_rd_data_fwd_valid_de);                        
                                      
    assign gpr_rs2_fwd_exu_retr_de   = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 6'd0) ) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs2_fwd_csr_retr_de   = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 6'd0) ) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                              
  
    assign gpr_rs2_fwd_lsu_retr_de   = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 6'd0) ) &   
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);    
                                       
    always @*
    begin
       casez({gpr_rs2_fwd_lsu_retr_de,gpr_rs2_fwd_csr_retr_de,gpr_rs2_fwd_exu_retr_de,gpr_rs2_fwd_exu_ex_de})
         4'b0000 : // No forwarding
         begin
           gpr_rs2_rd_data_fwd_de        = gpr_rs2_rd_data_sig;      
           gpr_rs2_rd_data_fwd_valid_de  = gpr_rs2_rd_data_valid_sig;
         end
         4'b???1 : // EXU forward (ex stage)
         begin
           gpr_rs2_rd_data_fwd_de        = exu_result_ex;       // REVISIT make sure this works for multistage ops in EXU
           gpr_rs2_rd_data_fwd_valid_de  = exu_result_valid_ex;
         end
         4'b1000 : // LSU forward (retr stage only)
         begin
           gpr_rs2_rd_data_fwd_de        = lsu_resp_rd_data;
           gpr_rs2_rd_data_fwd_valid_de  = lsu_resp_valid;
         end
         4'b0100 : // CSR forward (retr stage only)
         begin
           gpr_rs2_rd_data_fwd_de        = sw_csr_rd_data_retr;      
           gpr_rs2_rd_data_fwd_valid_de  = sw_csr_rd_data_valid_retr;
         end
         4'b0010 : // EXU forward (retr stage)
         begin
           gpr_rs2_rd_data_fwd_de        = exu_result_retr;      
           gpr_rs2_rd_data_fwd_valid_de  = exu_result_valid_retr;
         end
         default : // illegal
         begin
           gpr_rs2_rd_data_fwd_de        = {L_XLEN{1'b0}};      
           gpr_rs2_rd_data_fwd_valid_de  = 1'b1;
         end
       endcase
     end         

   
     
    assign gpr_rs3_fwd_exu_ex_de       = (instr_valid_de & gpr_rs3_rd_valid_de & (gpr_rs3_rd_sel_de != 6'd0) ) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs3_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs3_stall_csr_ex_de     = (instr_valid_de & gpr_rs3_rd_valid_de & (gpr_rs3_rd_sel_de != 6'd0) ) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs3_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_csr);                            
  
    assign gpr_rs3_stall_lsu_ex_de     = (instr_valid_de & gpr_rs3_rd_valid_de & (gpr_rs3_rd_sel_de != 6'd0) ) &   
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs3_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_lsu);     
                                         
    assign gpr_rs3_stall_de            =  gpr_rs3_stall_csr_ex_de |  
                                          gpr_rs3_stall_lsu_ex_de  |
                                          (instr_valid_de & gpr_rs3_rd_valid_de & ~gpr_rs3_rd_ready_sig) |
                                          (instr_valid_de & gpr_rs3_rd_valid_de & ~gpr_rs3_rd_data_fwd_valid_de);                        
                                      
    assign gpr_rs3_fwd_exu_retr_de   = (instr_valid_de & gpr_rs3_rd_valid_de & (gpr_rs3_rd_sel_de != 6'd0) ) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs3_fwd_csr_retr_de   = (instr_valid_de & gpr_rs3_rd_valid_de & (gpr_rs3_rd_sel_de != 6'd0) ) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                              
  
    assign gpr_rs3_fwd_lsu_retr_de   = (instr_valid_de & gpr_rs3_rd_valid_de & (gpr_rs3_rd_sel_de != 6'd0) ) &   
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);    
                                       
    always @*
    begin
       casez({gpr_rs3_fwd_lsu_retr_de,gpr_rs3_fwd_csr_retr_de,gpr_rs3_fwd_exu_retr_de,gpr_rs3_fwd_exu_ex_de})
         4'b0000 : // No forwarding
         begin
           gpr_rs3_rd_data_fwd_de        = gpr_rs3_rd_data_sig;      
           gpr_rs3_rd_data_fwd_valid_de  = gpr_rs3_rd_data_valid_sig;
         end
         4'b???1 : // EXU forward (ex stage)
         begin
           gpr_rs3_rd_data_fwd_de        = exu_result_ex;       
           gpr_rs3_rd_data_fwd_valid_de  = exu_result_valid_ex;
         end
         4'b1000 : // LSU forward (retr stage only)
         begin
           gpr_rs3_rd_data_fwd_de        = lsu_resp_rd_data;
           gpr_rs3_rd_data_fwd_valid_de  = lsu_resp_valid;
         end
         4'b0100 : // CSR forward (retr stage only)
         begin
           gpr_rs3_rd_data_fwd_de        = sw_csr_rd_data_retr;      
           gpr_rs3_rd_data_fwd_valid_de  = sw_csr_rd_data_valid_retr;
         end
         4'b0010 : // EXU forward (retr stage)
         begin
           gpr_rs3_rd_data_fwd_de        = exu_result_retr;      
           gpr_rs3_rd_data_fwd_valid_de  = exu_result_valid_retr;
         end
         default : // illegal
         begin
           gpr_rs3_rd_data_fwd_de        = {L_XLEN{1'b0}};      
           gpr_rs3_rd_data_fwd_valid_de  = 1'b1;
         end
       endcase
     end  	 
  
  end
  else begin : ngen_read_gpr_de
    assign gpr_rs1_rd_data_fwd_de        = {L_XLEN{1'b0}};     
    assign gpr_rs1_rd_data_fwd_valid_de  = 1'b0;
    assign gpr_rs1_stall_de              = 1'b0;
    assign gpr_rs2_rd_data_fwd_de        = {L_XLEN{1'b0}};     
    assign gpr_rs2_rd_data_fwd_valid_de  = 1'b0;
    assign gpr_rs2_stall_de              = 1'b0;
    assign gpr_rs3_rd_data_fwd_de        = {L_XLEN{1'b0}};     
    assign gpr_rs3_rd_data_fwd_valid_de  = 1'b0;
    assign gpr_rs3_stall_de              = 1'b0;
  end  
  endgenerate


  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  // Execute stage (EX)
  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  
  // The execute stage executes the instruction decoded in the previous stage.
  // Arithmetic and logical operations as well as branch decision computation will be performed in the EXU
  // Load/Store operations will be performed in the LSU
  // Branch/exception target computation will be performed in the BCU
  // pipeline controls from de to ex-stage
  //
  // need to mask controls with instruction valid to deal with case where a valid instruction is decoded
  // but then suppressed due to a flush
  
  // Execution FSM
  // Instructions may comprise the result of several units results sequentially (eg store uses shift unit for alignment and alu for store address
  // computation which then are inputs to the LSU)
  // Execution may also take multiple cycles (eg (optionally) multi-cycle multiply, divide, shift)
  // The decoded operation for each unit determines if a unit is perfoming an operation for the given instruction, the ordering of operations
  // is fixed (eg GPR/CSR read -> ALU/shift/BCU -> LSU -> GPR/CSR write), though not all units required for all operations. 

  
  //---------------------------------------------------------------------------------------
  //---------------------------------------------------------------------------------------

  assign instr_req_ex  = instr_accepted_de | 
                         force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de;
  
  always @*
  begin
    case(stage_state_ex)
      expipe_stage_state_ready : 
      begin
        next_stage_state_ex = instr_req_ex ? expipe_stage_state_busy : expipe_stage_state_ready;
        instr_accepted_ex   = instr_req_ex;
        stage_ready_ex      = 1'b1;
        instr_valid_ex      = 1'b0;
      end
    
      expipe_stage_state_busy : 
      begin
        next_stage_state_ex = instr_req_ex ? expipe_stage_state_busy : (instr_completing_ex | flush_ex) ? expipe_stage_state_ready : stage_state_ex;
        instr_accepted_ex   = instr_req_ex & (instr_completing_ex | flush_ex);
        stage_ready_ex      = (instr_completing_ex | flush_ex);
        instr_valid_ex      = 1'b1;
      end
    
      default :
        begin
        next_stage_state_ex = expipe_stage_state_ready;
        instr_accepted_ex   = 1'b0;
        stage_ready_ex      = 1'b0;
        instr_valid_ex      = 1'b0;
      end
    endcase
  end
  

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      stage_state_ex  <= expipe_stage_state_ready;
    else
      stage_state_ex  <= next_stage_state_ex;     
  end    
  
  // inhibit instruction if a trap or debug entry is going to occur
  // cannot block pseudo operations as the trap branch is itself an pseudo operation 
  assign instr_inhibit_ex      = (((trap_pending_retr | trap_pending_ex) & ~implicit_pseudo_instr_ex) | 
                                  debug_enter_req_ex |
                                  (irq_abort_lsu_req_retr & instr_is_lsu_ldstr_reg_ex)) &
                                 instr_valid_ex;
  
  assign instr_can_complete_ex =   (gpr_rd_rs1_complete_ex   &
                                    gpr_rd_rs2_complete_ex   &
                                    gpr_rd_rs3_complete_ex   &
                                    alu_op_complete_ex       &
                                    shift_op_complete_ex     &
                                    bcu_op_complete_ex       &
                                    lsu_op_complete_ex);
                                  
  assign instr_completing_ex  = instr_can_complete_ex & stage_ready_retr;                               
  
  assign update_ctrl_attbs_ex = instr_accepted_ex; 
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin
    // pipeline controls
      de_ex_pipe_implicit_pseudo_instr_ex    <= implicit_pseudo_instr_de;  // tell ex stage that this is an inserted not fetched instruction
      de_ex_pipe_fence_i_ex                  <= fence_i_de;
      de_ex_pipe_fence_ex                    <= fence_de;
      de_ex_pipe_wfi_ex                      <= wfi_de;  
      de_ex_pipe_i_access_fault_ex           <= ifu_expipe_resp_access_fault & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
      de_ex_pipe_i_access_mem_error_ex       <= ifu_expipe_resp_access_mem_error & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);   
      de_ex_pipe_i_access_parity_error_ex    <= ifu_expipe_resp_access_parity_error & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
      de_ex_pipe_i_access_misalign_error_ex  <= ifu_expipe_resp_access_misalign_error & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
      de_ex_pipe_illegal_instr_ex            <= illegal_instr_csr_de;
      de_ex_pipe_m_env_call_ex               <= m_env_call_de;
      de_ex_pipe_trap_ret_ex                 <= (m_ret_de  | d_ret_de) ;
      de_ex_pipe_dbreak_ex                   <= dbreak_de;         
      de_ex_pipe_immediate_ex                <= immediate_de;
      de_ex_pipe_curr_instr_enc_ex           <= ifu_expipe_resp_ireg & {32{~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de)}};
       
    end    
  end
  
  generate if(l_core_cfg_num_triggers > 0)
  begin : gen_trig_pipe_reg_de_ex
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin
        de_ex_pipe_trigger_ex <= trigger_req_de;
      end
    end
    
    assign de_ex_pipe_any_trigger_ex = |de_ex_pipe_trigger_ex;
    assign trigger_ex                = de_ex_pipe_trigger_ex & {l_core_cfg_num_triggers{instr_valid_ex}};
    
  end
  else begin : ngen_trig_pipe_reg_de_ex
  
    assign de_ex_pipe_any_trigger_ex = 1'b0;
    
  end
  endgenerate
  
  // mark instruction if debug entry is requested
  // this will suppress load-stores in the ex phase and any state updates in the retr stage
  generate if(l_core_cfg_hw_debug)
  begin : gen_pipe_debug_enter_req_de_ex
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin
        de_ex_pipe_debug_enter_req_ex <= debug_enter_req_de; 
        de_ex_pipe_curr_pc_ex         <= force_debug_nop_de ? ifu_expipe_resp_next_vaddr : ifu_expipe_resp_ireg_vaddr;
      end
    end
    
    assign debug_enter_req_ex          = de_ex_pipe_debug_enter_req_ex & instr_valid_ex;
    
  end
  else begin : ngen_pipe_debug_enter_req_de_ex
  
    assign debug_enter_req_ex = 1'b0;
    
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin
        de_ex_pipe_curr_pc_ex                  <= ifu_expipe_resp_ireg_vaddr;
      end
    end
    
  end
  endgenerate
    
  assign trap_pending_ex             = de_ex_pipe_i_access_fault_ex |
                                       de_ex_pipe_i_access_mem_error_ex |
                                       de_ex_pipe_i_access_parity_error_ex |
                                       de_ex_pipe_i_access_misalign_error_ex |
                                       de_ex_pipe_illegal_instr_ex |
                                       de_ex_pipe_m_env_call_ex |
                                       de_ex_pipe_dbreak_ex |
                                       de_ex_pipe_any_trigger_ex;  // treat trigger as an exception in this stage as has same effect (inhibits lsu ops)
   
  assign implicit_pseudo_instr_ex    = de_ex_pipe_implicit_pseudo_instr_ex & instr_valid_ex;
  assign fence_i_ex                  = de_ex_pipe_fence_i_ex & instr_valid_ex;
  assign fence_ex                    = de_ex_pipe_fence_ex & instr_valid_ex;
  assign wfi_ex                      = de_ex_pipe_wfi_ex & instr_valid_ex;
  assign i_access_fault_ex           = de_ex_pipe_i_access_fault_ex & instr_valid_ex;
  assign i_access_mem_error_ex       = de_ex_pipe_i_access_mem_error_ex & instr_valid_ex;
  assign i_access_parity_error_ex    = de_ex_pipe_i_access_parity_error_ex & instr_valid_ex;
  assign i_access_misalign_error_ex  = de_ex_pipe_i_access_misalign_error_ex & instr_valid_ex;
  assign illegal_instr_ex            = de_ex_pipe_illegal_instr_ex  & instr_valid_ex;
  assign m_env_call_ex               = de_ex_pipe_m_env_call_ex & instr_valid_ex;
  assign trap_ret_ex                 = de_ex_pipe_trap_ret_ex & instr_valid_ex;
  assign dbreak_ex                   = de_ex_pipe_dbreak_ex & instr_valid_ex;
  assign immediate_ex                = de_ex_pipe_immediate_ex;
  assign curr_instr_enc_ex           = de_ex_pipe_curr_instr_enc_ex;
  assign curr_pc_ex                  = de_ex_pipe_curr_pc_ex;
  
  assign flush_ex                    = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr; 
    
  
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_rs1_ex
    // gpr forwarding paths 
    // Do not forward if the rd/wr is x0 as the value from the read would always be 0, but if the exu/csr result is forwarded, then this may be non-0 
    
   // gpr rs1
    if (l_core_cfg_exu_fwd)
    begin : gen_rs1_exu_fwd
   
      assign gpr_rs1_fwd_exu   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 6'd0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
      assign gpr_rs1_stall_exu = 1'b0; 
    end
    else begin : gen_rs1_exu_stall
      assign gpr_rs1_fwd_exu   = 1'b0;
      assign gpr_rs1_stall_exu = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 6'd0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
    end
    //endgenerate                           
                              
    // Optionally forward CSR result as it may arrive late, and contributes to a long path, particularly from debugger. If forwarding is disabled, hazard will cause stall instead.
    // Don't need to stall if the rd is from x0 as this will always be 0                           

    if (l_core_cfg_csr_fwd)
    begin : gen_rs1_csr_fwd                            
      assign gpr_rs1_fwd_csr   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 6'd0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                                  
      assign gpr_rs1_stall_csr = 1'b0;
      
    end
    else begin : gen_rs1_csr_stall
    
      assign gpr_rs1_fwd_csr   = 1'b0;
      assign gpr_rs1_stall_csr =  ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 6'd0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);
    end
    //endgenerate

   
    // Optionally forward LSU load result as it may arrive late in the retr cycle. If forwarding is disabled, hazard will cause LSU stall instead.
    // Don't need to stall if the rd is from x0 as this will always be 0
    if (l_core_cfg_lsu_fwd)
    begin : gen_rs1_lsu_fwd
    
      assign gpr_rs1_fwd_lsu    = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 6'd0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
      assign gpr_rs1_stall_lsu  = 1'b0;
            
    end
    else begin : gen_rs1_lsu_stall
    
      assign gpr_rs1_fwd_lsu    = 1'b0;
      assign gpr_rs1_stall_lsu  = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 6'd0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);                                 
   
    end
    //endgenerate
   
    
                           
                                             
   always @*
   begin
      unique case({gpr_rs1_fwd_exu,gpr_rs1_fwd_csr,gpr_rs1_fwd_lsu})
        3'b000 : // No forwarding
        begin
          gpr_rs1_rd_data_fwd_ex        = gpr_rs1_rd_data_ex;      
          gpr_rs1_rd_data_fwd_valid_ex  = gpr_rs1_rd_data_valid_ex;
        end
        3'b001 : // LSU forward
        begin
          gpr_rs1_rd_data_fwd_ex        = lsu_resp_rd_data_fwd;
          gpr_rs1_rd_data_fwd_valid_ex  = lsu_resp_valid_fwd;
        end
        3'b010 : // CSR forward
        begin
          gpr_rs1_rd_data_fwd_ex        = sw_csr_rd_data_retr;      
          gpr_rs1_rd_data_fwd_valid_ex  = sw_csr_rd_data_valid_retr;
        end
        3'b100 : // EXU forward
        begin
          gpr_rs1_rd_data_fwd_ex        = exu_result_retr;      
          gpr_rs1_rd_data_fwd_valid_ex  = exu_result_valid_retr;
        end
        default : // illegal
        begin
          gpr_rs1_rd_data_fwd_ex        = {L_XLEN{1'b0}};      
          gpr_rs1_rd_data_fwd_valid_ex  = 1'b1;
        end
      endcase
    end
    
    assign gpr_rs1_stall_ex = gpr_rs1_stall_lsu | gpr_rs1_stall_csr | gpr_rs1_stall_exu;
    
  end
  else begin : ngen_read_gpr_rs1_ex
  
  // read GPRs in DE stage and pipeline
  
  
    assign gpr_rs1_rd_data_fwd_ex        = gpr_rs1_rd_data_ex;      
    assign gpr_rs1_rd_data_fwd_valid_ex  = gpr_rs1_rd_data_valid_ex;
    assign gpr_rs1_stall_ex              = 1'b0;
    
  end
  endgenerate
  
 
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_rs2_ex
                               
    // gpr rs2
    if (l_core_cfg_exu_fwd)
    begin : gen_rs2_exu_fwd
   
      assign gpr_rs2_fwd_exu   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
      assign gpr_rs2_stall_exu = 1'b0; 
    end
    else begin : gen_rs2_exu_stall
      assign gpr_rs2_fwd_exu   = 1'b0;
      assign gpr_rs2_stall_exu = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
    end
    //endgenerate 
                                                     

    if (l_core_cfg_csr_fwd)
    begin : gen_rs2_csr_fwd                            
      assign gpr_rs2_fwd_csr   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                                  
      assign gpr_rs2_stall_csr = 1'b0;
      
    end
    else begin : gen_rs2_csr_stall
    
      assign gpr_rs2_fwd_csr   = 1'b0;
      assign gpr_rs2_stall_csr =  ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);
    end
    //endgenerate                            
                              
    if (l_core_cfg_lsu_fwd)
    begin : gen_rs2_lsu_fwd
    
      assign gpr_rs2_fwd_lsu    = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
      assign gpr_rs2_stall_lsu  = 1'b0;
      
    end
    else begin : gen_rs2_lsu_stall
    
      assign gpr_rs2_fwd_lsu    = 1'b0;
      assign gpr_rs2_stall_lsu  = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
   
    end
    //endgenerate                          
                                                
    always @*
    begin
      unique case({gpr_rs2_fwd_exu,gpr_rs2_fwd_csr,gpr_rs2_fwd_lsu})
        3'b000 : // No forwarding
        begin
          gpr_rs2_rd_data_fwd_ex        = gpr_rs2_rd_data_ex;      
          gpr_rs2_rd_data_fwd_valid_ex  = gpr_rs2_rd_data_valid_ex;
        end
        3'b001 : // LSU forward
        begin
          gpr_rs2_rd_data_fwd_ex        = lsu_resp_rd_data_fwd;
          gpr_rs2_rd_data_fwd_valid_ex  = lsu_resp_valid_fwd;  
        end
        3'b010 : // CSR forward
        begin
          gpr_rs2_rd_data_fwd_ex        = sw_csr_rd_data_retr;      
          gpr_rs2_rd_data_fwd_valid_ex  = sw_csr_rd_data_valid_retr;
        end
        3'b100 : // EXU forward
        begin
          gpr_rs2_rd_data_fwd_ex        = exu_result_retr;      
          gpr_rs2_rd_data_fwd_valid_ex  = exu_result_valid_retr;
        end
        default : // illegal
        begin
          gpr_rs2_rd_data_fwd_ex        = {L_XLEN{1'b0}};      
          gpr_rs2_rd_data_fwd_valid_ex  = 1'b1;
        end
      endcase
    end    
    
    assign gpr_rs2_stall_ex = gpr_rs2_stall_lsu | gpr_rs2_stall_csr | gpr_rs2_stall_exu;
    
  end
  else begin : ngen_read_gpr_rs2_ex
  
  // read GPRs in DE stage and pipeline
    assign gpr_rs2_rd_data_fwd_ex        = gpr_rs2_rd_data_ex;      
    assign gpr_rs2_rd_data_fwd_valid_ex  = gpr_rs2_rd_data_valid_ex;
    assign gpr_rs2_stall_ex              = 1'b0;
    
  end
  endgenerate                      


  // REVIST - Not all the logic here will be needed
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_rs3_ex
    // gpr forwarding paths 
    // Do not forward if the rd/wr is x0 as the value from the read would always be 0, but if the exu/csr result is forwarded, then this may be non-0 
    
   // gpr rs3
    if (l_core_cfg_exu_fwd)
    begin : gen_rs3_exu_fwd
   
      assign gpr_rs3_fwd_exu   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs3_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs3_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
      assign gpr_rs3_stall_exu = 1'b0; 
    end
    else begin : gen_rs3_exu_stall
      assign gpr_rs3_fwd_exu   = 1'b0;
      assign gpr_rs3_stall_exu = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs3_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs3_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
    end
    //endgenerate                           
                              
    // Optionally forward CSR result as it may arrive late, and contributes to a long path, particularly from debugger. If forwarding is disabled, hazard will cause stall instead.
    // Don't need to stall if the rd is from x0 as this will always be 0                           

    if (l_core_cfg_csr_fwd)
    begin : gen_rs3_csr_fwd                            
      assign gpr_rs3_fwd_csr   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs3_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs3_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                                  
      assign gpr_rs3_stall_csr = 1'b0;
      
    end
    else begin : gen_rs3_csr_stall
    
      assign gpr_rs3_fwd_csr   = 1'b0;
      assign gpr_rs3_stall_csr =  ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs3_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs3_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);
    end
    //endgenerate

   
    // Optionally forward LSU load result as it may arrive late in the retr cycle. If forwarding is disabled, hazard will cause LSU stall instead.
    // Don't need to stall if the rd is from x0 as this will always be 0
    if (l_core_cfg_lsu_fwd)
    begin : gen_rs3_lsu_fwd
    
      assign gpr_rs3_fwd_lsu    = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs3_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs3_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
      assign gpr_rs3_stall_lsu  = 1'b0;
            
    end
    else begin : gen_rs3_lsu_stall
    
      assign gpr_rs3_fwd_lsu    = 1'b0;
      assign gpr_rs3_stall_lsu  = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs3_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs3_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs3_rd_sel_ex != 6'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);                                 
   
    end
    //endgenerate
   
    
                           
                                             
   always @*
   begin
      unique case({gpr_rs3_fwd_exu,gpr_rs3_fwd_csr,gpr_rs3_fwd_lsu})
        3'b000 : // No forwarding
        begin
          gpr_rs3_rd_data_fwd_ex        = gpr_rs3_rd_data_ex;      
          gpr_rs3_rd_data_fwd_valid_ex  = gpr_rs3_rd_data_valid_ex;
        end
        3'b001 : // LSU forward
        begin
          gpr_rs3_rd_data_fwd_ex        = lsu_resp_rd_data_fwd;
          gpr_rs3_rd_data_fwd_valid_ex  = lsu_resp_valid_fwd;
        end
        3'b010 : // CSR forward
        begin
          gpr_rs3_rd_data_fwd_ex        = sw_csr_rd_data_retr;      
          gpr_rs3_rd_data_fwd_valid_ex  = sw_csr_rd_data_valid_retr;
        end
        3'b100 : // EXU forward
        begin
          gpr_rs3_rd_data_fwd_ex        = exu_result_retr;      
          gpr_rs3_rd_data_fwd_valid_ex  = exu_result_valid_retr;
        end
        default : // illegal
        begin
          gpr_rs3_rd_data_fwd_ex        = {L_XLEN{1'b0}};      
          gpr_rs3_rd_data_fwd_valid_ex  = 1'b1;
        end
      endcase
    end
    
    assign gpr_rs3_stall_ex = gpr_rs3_stall_lsu | gpr_rs3_stall_csr | gpr_rs3_stall_exu;
    
  end
  else begin : ngen_read_gpr_rs3_ex
  
  // read GPRs in DE stage and pipeline
  
  
    assign gpr_rs3_rd_data_fwd_ex        = gpr_rs3_rd_data_ex;      
    assign gpr_rs3_rd_data_fwd_valid_ex  = gpr_rs3_rd_data_valid_ex;
    assign gpr_rs3_stall_ex              = 1'b0;
    
  end
  endgenerate
  
  
  
  // PC is from the current fetched instruction in the pipeline, so no hazard possible, branches will cause flush to ensure correct PC is aligned in EX stage
  
  assign trap_cause_hzd_ex = ((stage_state_ex == expipe_stage_state_busy) & (de_ex_pipe_bcu_op_sel_ex == bcu_op_add) & 
                              (de_ex_pipe_bcu_operand0_mux_sel_ex == bcu_operand0_trap_cause)) & 
                             ((instr_valid_retr & (sw_csr_wr_op_retr != csr_alu_wr_op_none) & (sw_csr_addr_retr == l_core_csr_addr_mcause))); 
    
  assign epc_hzd_ex        = ((stage_state_ex == expipe_stage_state_busy) & (de_ex_pipe_bcu_op_sel_ex == bcu_op_add) & 
                              (de_ex_pipe_bcu_operand1_mux_sel_ex == bcu_operand1_epc)) & 
                             ((instr_valid_retr & (sw_csr_wr_op_retr != csr_alu_wr_op_none) & (sw_csr_addr_retr == l_core_csr_addr_mepc)));   
                             
  assign trap_vec_hzd_ex   = ((stage_state_ex == expipe_stage_state_busy) & (de_ex_pipe_bcu_op_sel_ex == bcu_op_add) & 
                              (de_ex_pipe_bcu_operand1_mux_sel_ex == bcu_operand1_exvec)) & 
                             ((instr_valid_retr & (sw_csr_wr_op_retr != csr_alu_wr_op_none) & (sw_csr_addr_retr == l_core_csr_addr_mtvec)));                                                

  // resetvec is static in core, so no hazard on resetvec as an operand                              
                                                                                                 
  
  //--------------------------------------------------------
  // GPRs
  //--------------------------------------------------------  
  

// gpr controls //
// GPR writes always occur at the end of the retr stage
// core reads occur in a single cycle and continue as needed (in a RAM based implementation, the RAM must have 
// 1-write, 2 read ports). For multicycle operations, the GPR read of operands must occur at the same time and 
// persist throughout the request phase of the operation.
 
  

  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin
      de_ex_pipe_gpr_wr_en_ex             <= gpr_wr_en_de;
      de_ex_pipe_gpr_wr_sel_ex            <= gpr_wr_sel_de; 
      de_ex_pipe_gpr_wr_mux_sel_ex        <= gpr_wr_mux_sel_de;  
    end    
  end

  
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_gpr_ex_attbs_rd_ex
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex | gpr_rd_rs1_completing_ex)
        de_ex_pipe_gpr_rs1_rd_valid_ex  <= update_ctrl_attbs_ex ?  gpr_rs1_rd_valid_de : 1'b0;       
    end
    
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)      
        de_ex_pipe_gpr_rs1_rd_sel_ex   <= (l_core_cfg_hw_sp_float) ? gpr_rs1_rd_sel_de : {1'b0, gpr_rs1_rd_sel_de[4:0]};  
    end
    
    if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
    begin : gen_debug_gpr_rd_sel_no_pipeline
    
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs2_completing_ex)
          de_ex_pipe_gpr_rs2_rd_valid_ex <= update_ctrl_attbs_ex ?  gpr_rs2_rd_valid_de : 1'b0;    
      end
  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex)
          de_ex_pipe_gpr_rs2_rd_sel_ex   <= (l_core_cfg_hw_sp_float) ? gpr_rs2_rd_sel_de : {1'b0, gpr_rs2_rd_sel_de[4:0]};   
      end
    
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs3_completing_ex)
          de_ex_pipe_gpr_rs3_rd_valid_ex <= update_ctrl_attbs_ex ?  gpr_rs3_rd_valid_de : 1'b0;    
      end
  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex)
          de_ex_pipe_gpr_rs3_rd_sel_ex   <= (l_core_cfg_hw_sp_float) ? gpr_rs3_rd_sel_de : {1'b0, gpr_rs3_rd_sel_de[4:0]};      
      end
      
    end
    else begin : gen_debug_gpr_rd_sel_pipeline
    
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs2_completing_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_valid_ex <= debug_mode_retr ? debug_gpr_req_rd_en : (update_ctrl_attbs_ex ?  gpr_rs2_rd_valid_de : 1'b0);    
      end
  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_sel_ex   <= debug_mode_retr ? debug_gpr_req_addr : gpr_rs2_rd_sel_de; 
      end
	  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs3_completing_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs3_rd_valid_ex <= debug_mode_retr ? debug_gpr_req_rd_en : (update_ctrl_attbs_ex ?  gpr_rs3_rd_valid_de : 1'b0);    
      end
  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs3_rd_sel_ex   <= debug_mode_retr ? debug_gpr_req_addr : gpr_rs3_rd_sel_de;      
      end
      
    end
    // endgenerate gen_debug_gpr_rd_sel_pipeline
    
    assign de_ex_pipe_gpr_rs1_rd_data_ex       = gpr_rs1_rd_data_sig;  
    assign de_ex_pipe_gpr_rs2_rd_data_ex       = gpr_rs2_rd_data_sig; 
    assign de_ex_pipe_gpr_rs3_rd_data_ex       = gpr_rs3_rd_data_sig; 
    assign de_ex_pipe_gpr_rs1_rd_data_valid_ex = gpr_rs1_rd_data_valid_sig;
    assign de_ex_pipe_gpr_rs2_rd_data_valid_ex = gpr_rs2_rd_data_valid_sig;
    assign de_ex_pipe_gpr_rs3_rd_data_valid_ex = gpr_rs3_rd_data_valid_sig;
  
  end 
  else begin : gen_gpr_ex_attbs_rd_de
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin            
        de_ex_pipe_gpr_rs1_rd_data_ex       <= gpr_rs1_rd_data_fwd_de;  
        de_ex_pipe_gpr_rs2_rd_data_ex       <= gpr_rs2_rd_data_fwd_de;  
        de_ex_pipe_gpr_rs3_rd_data_ex       <= gpr_rs3_rd_data_fwd_de;  
        de_ex_pipe_gpr_rs1_rd_data_valid_ex <= gpr_rs1_rd_data_fwd_valid_de;
        de_ex_pipe_gpr_rs2_rd_data_valid_ex <= gpr_rs2_rd_data_fwd_valid_de;
        de_ex_pipe_gpr_rs3_rd_data_valid_ex <= gpr_rs3_rd_data_fwd_valid_de;
      end    
    end
    
    assign de_ex_pipe_gpr_rs1_rd_valid_ex = 1'b0;
    assign de_ex_pipe_gpr_rs1_rd_sel_ex = 6'd0;
    
    if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug))  
    begin : gen_debug_gpr_rd_sel_no_pipeline_rdde
    
      assign de_ex_pipe_gpr_rs2_rd_valid_ex = 1'b0;
      assign de_ex_pipe_gpr_rs2_rd_sel_ex = 6'd0;
      
      assign de_ex_pipe_gpr_rs3_rd_valid_ex = 1'b0;
      assign de_ex_pipe_gpr_rs3_rd_sel_ex = 6'd0;
    end
    else begin : gen_debug_gpr_rd_sel_pipeline_rdde
      
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs2_completing_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_valid_ex      <= debug_mode_retr ? debug_gpr_req_rd_en : 1'b0;       
      end
      
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex |  debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_sel_ex        <= debug_mode_retr ? debug_gpr_req_addr : 6'b0;
      end
	  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs3_completing_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs3_rd_valid_ex      <= debug_mode_retr ? debug_gpr_req_rd_en : 1'b0;       
      end
      
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex |  debug_mode_retr)
          de_ex_pipe_gpr_rs3_rd_sel_ex        <= debug_mode_retr ?  debug_gpr_req_addr : 6'b0;  
      end

    end
    // endgenerate gen_debug_gpr_rd_sel_pipeline_rdd
    
    
  end
  endgenerate

  assign gpr_wr_en_ex                     = de_ex_pipe_gpr_wr_en_ex & instr_valid_ex & ~instr_inhibit_ex;
  assign gpr_wr_sel_ex                    = de_ex_pipe_gpr_wr_sel_ex;
  assign gpr_wr_mux_sel_ex                = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_gpr_wr_mux_sel_ex : gpr_wr_mux_sel_none;
  assign gpr_rs1_rd_valid_ex              = de_ex_pipe_gpr_rs1_rd_valid_ex & instr_valid_ex & ~instr_inhibit_ex;
  assign gpr_rs1_rd_sel_ex                = de_ex_pipe_gpr_rs1_rd_sel_ex;
  assign gpr_rs2_rd_valid_ex              = de_ex_pipe_gpr_rs2_rd_valid_ex & (debug_mode_retr | (instr_valid_ex & ~instr_inhibit_ex));
  assign gpr_rs2_rd_sel_ex                = de_ex_pipe_gpr_rs2_rd_sel_ex;
  assign gpr_rs3_rd_valid_ex              = de_ex_pipe_gpr_rs3_rd_valid_ex & (debug_mode_retr | (instr_valid_ex & ~instr_inhibit_ex));
  assign gpr_rs3_rd_sel_ex                = de_ex_pipe_gpr_rs3_rd_sel_ex;
  assign gpr_rs1_rd_data_ex               = de_ex_pipe_gpr_rs1_rd_data_ex;      
  assign gpr_rs2_rd_data_ex               = de_ex_pipe_gpr_rs2_rd_data_ex;      
  assign gpr_rs3_rd_data_ex               = de_ex_pipe_gpr_rs3_rd_data_ex;      
  assign gpr_rs1_rd_data_valid_ex         = de_ex_pipe_gpr_rs1_rd_data_valid_ex & instr_valid_ex & ~instr_inhibit_ex;
  assign gpr_rs2_rd_data_valid_ex         = de_ex_pipe_gpr_rs2_rd_data_valid_ex & instr_valid_ex & ~instr_inhibit_ex  & ~debug_mode_retr;
  assign gpr_rs3_rd_data_valid_ex         = de_ex_pipe_gpr_rs3_rd_data_valid_ex & instr_valid_ex & ~instr_inhibit_ex  & ~debug_mode_retr;
  
  // write completes in ex stage when gpr write data (alu result or csr read data) valid, or lsu ld/fence accepted and can be accepted by retr stage

  assign gpr_rd_rs1_completing_ex         = (((alu_op_sel_ex == exu_alu_op_none) | (operand0_mux_sel_ex != exu_op0_rs1) | ex_retr_exu_res_accept_retr) &              
                                             ((shifter_unit_op_sel_ex == exu_shifter_op_none) | (shifter_unit_operand_sel_ex != shifter_operand_rs1) | ex_retr_exu_res_accept_retr) &       
                                             ((lsu_op_ex == lsu_op_none) | lsu_op_complete_ex) &
                                             ((bcu_op_sel_ex == bcu_op_none) | bcu_op_complete_ex)) | instr_inhibit_ex; 
  assign gpr_rd_rs2_completing_ex         = (((alu_op_sel_ex == exu_alu_op_none) | (operand1_mux_sel_ex != exu_op1_rs2) | ex_retr_exu_res_accept_retr) &              
                                             ((shifter_unit_op_sel_ex == exu_shifter_op_none) | ((shifter_unit_operand_sel_ex != shifter_operand_rs2) & (shifter_unit_places_sel_ex != shifter_places_operand_rs2))| ex_retr_exu_res_accept_retr) &       
                                             ((lsu_op_ex == lsu_op_none) | lsu_op_complete_ex) &
                                             ((bcu_op_sel_ex == bcu_op_none) | bcu_op_complete_ex)) | instr_inhibit_ex;
  assign gpr_rd_rs3_completing_ex         = (((alu_op_sel_ex == exu_alu_op_none) | ex_retr_exu_res_accept_retr) &              
                                             ((shifter_unit_op_sel_ex == exu_shifter_op_none) | ((shifter_unit_operand_sel_ex != shifter_operand_rs3) & (shifter_unit_places_sel_ex != shifter_places_operand_rs3))| ex_retr_exu_res_accept_retr) &       
                                             ((lsu_op_ex == lsu_op_none) | lsu_op_complete_ex) &
                                             ((bcu_op_sel_ex == bcu_op_none) | bcu_op_complete_ex)) | instr_inhibit_ex;
  assign gpr_rd_rs1_complete_ex           = (~gpr_rs1_rd_valid_ex) | gpr_rd_rs1_completing_ex;
  assign gpr_rd_rs2_complete_ex           = (~gpr_rs2_rd_valid_ex) | gpr_rd_rs2_completing_ex;
  assign gpr_rd_rs3_complete_ex           = (~gpr_rs3_rd_valid_ex) | gpr_rd_rs3_completing_ex;


  //--------------------------------------------------------
  // CSRs
  //--------------------------------------------------------  

  // csr controls  //  
  // All CSR functionality occurs in RETR stage, so just operation pipelining here

  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin
      de_ex_pipe_sw_csr_wr_op_ex     <= sw_csr_wr_op_de; 
      de_ex_pipe_sw_csr_addr_ex      <= sw_csr_addr_de; 
      de_ex_pipe_sw_csr_rd_op_ex     <= sw_csr_rd_op_de;
    end    
  end  
  
  assign sw_csr_addr_ex              = de_ex_pipe_sw_csr_addr_ex;
  assign sw_csr_wr_op_ex             = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_sw_csr_wr_op_ex : csr_alu_wr_op_none;
  assign sw_csr_rd_op_ex             = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_sw_csr_rd_op_ex : csr_alu_rd_op_none;
    
  

  //--------------------------------------------------------
  // Execution unit
  //--------------------------------------------------------  
  
  // exu controls //  
  // core supports one exu request in flight in ex stage until the operation is accepted by the retr stage or lsu 
  // (no pipelined execution of arithmetic operations. though does support multi-cycle execution)
  // EXU requests persists until result is accepted by:
  //  - retr stage pipeline register accepted for all CSR ops
  //  - LSU requested accepted without error for loads and fence operations (address required for MTVAL if an exception) 
  //  - LSU requested accepted without error for stores
  //  - LSU accepted with error for all LSU ops and retr stage pipeline register accepted
  //  - retr stage pipeline register accepted for all ALU and shift ops
  //  - branch accepted for all taken branch ops
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | alu_op_completing_ex)
    begin          
      de_ex_pipe_alu_op_sel_ex               <= update_ctrl_attbs_ex ? alu_op_sel_de : exu_alu_op_none;  
      de_ex_pipe_fpu_frm_ex                  <= update_ctrl_attbs_ex ? fpu_frm_de : 3'b000;
      de_ex_pipe_fpu_fmt_ex                  <= update_ctrl_attbs_ex ? fpu_fmt_de : 2'b00;
      de_ex_pipe_fpu_instr_ex                <= update_ctrl_attbs_ex ? fpu_instr_de : 1'b0; 
    end    
  end
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | shift_op_completing_ex)
    begin                   
      de_ex_pipe_shifter_unit_op_sel_ex      <= update_ctrl_attbs_ex ? shifter_unit_op_sel_de : exu_shifter_op_none;     
    end    
  end
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin       
      de_ex_pipe_operand0_mux_sel_ex         <= operand0_mux_sel_de;   
      de_ex_pipe_operand1_mux_sel_ex         <= operand1_mux_sel_de;   
      de_ex_pipe_shifter_unit_places_sel_ex  <= shifter_unit_places_sel_de;
      de_ex_pipe_shifter_unit_operand_sel_ex <= shifter_unit_operand_sel_de;      
      de_ex_pipe_exu_result_mux_sel_ex       <= exu_result_mux_sel_de;      
    end    
  end
  
  assign operand0_mux_sel_ex         = de_ex_pipe_operand0_mux_sel_ex;
  assign operand1_mux_sel_ex         = de_ex_pipe_operand1_mux_sel_ex;
  assign alu_op_sel_ex               = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_alu_op_sel_ex : exu_alu_op_none;
  assign fpu_frm_ex                  = (alu_op_sel_ex != exu_alu_op_none) ? (de_ex_pipe_fpu_frm_ex == 3'b111) ? fpu_frm_csr : de_ex_pipe_fpu_frm_ex   : 3'b000;  //REVISIT
  assign fpu_fmt_ex                  = (alu_op_sel_ex != exu_alu_op_none) ? de_ex_pipe_fpu_fmt_ex   : 2'b00;
  assign fpu_instr_ex                = (alu_op_sel_ex != exu_alu_op_none) ? de_ex_pipe_fpu_instr_ex : 1'b0;
  assign shifter_unit_op_sel_ex      = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_shifter_unit_op_sel_ex : exu_shifter_op_none;
  assign shifter_unit_places_sel_ex  = de_ex_pipe_shifter_unit_places_sel_ex;
  assign shifter_unit_operand_sel_ex = de_ex_pipe_shifter_unit_operand_sel_ex;
  assign exu_result_mux_sel_ex       = de_ex_pipe_exu_result_mux_sel_ex;
    
  assign alu_op_completing_ex        = (ex_retr_exu_res_accept_retr &                
                                        ((branch_cond_ex == branch_cond_compare_true) ? bcu_op_complete_ex : 1'b1)) | instr_inhibit_ex;           
  assign alu_op_complete_ex          = (alu_op_sel_ex == exu_alu_op_none)  | alu_op_completing_ex;

  assign shift_op_completing_ex      = ((lsu_op_ex != lsu_op_none) ? lsu_op_complete_ex : ex_retr_exu_res_accept_retr) |  // shift nly needed for store, but no shift op for any
                                       instr_inhibit_ex;                                             // other LSU ops started anyway so simpler to decode any lsu op
                                       
  assign shift_op_complete_ex        = (shifter_unit_op_sel_ex == exu_shifter_op_none) | shift_op_completing_ex;  
  
  // exu may be performing a multicycle operation when a trap is taken, abort the operation and replay (if required) after trap return
  assign exu_op_abort_ex             = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr ;
  
  miv_rv32_exu 
  #(
   .l_core_cfg_hw_multiply_divide(l_core_cfg_hw_multiply_divide),
   .l_core_cfg_hw_macc_multiplier(l_core_cfg_hw_macc_multiplier),
   .l_core_cfg_hw_sp_float       (l_core_cfg_hw_sp_float       ),
   .l_core_cfg_hw_debug          (l_core_cfg_hw_debug          ),
   .NO_MACC_BLK                  (NO_MACC_BLK                  )
   ) 
  u_exu_0
  (
    .clk                            (clk                               ),
    .resetn                         (resetn                            ),
    // controls                                                        
    .exu_op_abort                   (exu_op_abort_ex                   ), 
    .debug_mode                     (debug_mode_retr                   ), 
//    .exu_op_valid                                                    
    .exu_op_ready                   (exu_op_ready_ex                   ),  // Not currently used 
    .alu_operand0_mux_sel           (operand0_mux_sel_ex               ),
    .alu_operand1_mux_sel           (operand1_mux_sel_ex               ),
    .alu_op_sel                     (alu_op_sel_ex                     ),
    .shifter_unit_op_sel            (shifter_unit_op_sel_ex            ),
    .shifter_unit_places_sel        (shifter_unit_places_sel_ex        ),
    .shifter_operand_sel            (shifter_unit_operand_sel_ex       ),
    .exu_result_mux_sel             (exu_result_mux_sel_ex             ),
    //operands                                                         
    .exu_operand_gpr_rs1            (gpr_rs1_rd_data_fwd_ex            ),
    .exu_operand_gpr_rs1_valid      (gpr_rs1_rd_data_fwd_valid_ex      ),
    .exu_operand_gpr_rs2            (gpr_rs2_rd_data_fwd_ex            ),
    .exu_operand_gpr_rs2_valid      (gpr_rs2_rd_data_fwd_valid_ex      ),
    .exu_operand_gpr_rs3            (gpr_rs3_rd_data_fwd_ex            ),
    .exu_operand_gpr_rs3_valid      (gpr_rs3_rd_data_fwd_valid_ex      ),
    .exu_operand_immediate          (immediate_ex                      ),
    .exu_operand_immediate_valid    (instr_valid_ex                    ), 
    .exu_operand_pc                 (curr_pc_ex                        ),
    .exu_operand_pc_valid           (instr_valid_ex                    ),
    .acu_result                     (bcu_result_ex                     ),
    .acu_result_valid               (bcu_result_valid_ex               ),
    .debug_wr_data                  (debug_csr_gpr_req_wr_data         ),
    .debug_wr_data_valid            (1'b1                              ),
    // result                                                          
    .exu_result                     (exu_result_ex                     ),
    .exu_result_valid               (exu_result_valid_ex               ),
    .exu_result_ready               (1'b1                              ),  
    .exu_result_flags               (exu_result_flags_ex               ),
    .lsu_align_result               (align_result_ex                   ),
    .lsu_align_result_valid         (align_result_valid_ex             ),
    .lsu_align_result_ready         (1'b1                              ),  
    .update_result_reg              (exu_update_result_reg             ),
    .exu_result_reg                 (ex_retr_pipe_exu_result_retr      ),
    .exu_result_reg_valid           (ex_retr_pipe_exu_result_valid_retr),
    .fpu_frm                        (fpu_frm_ex                        ),
    .fpu_fmt                        (fpu_fmt_ex                        ),
    .fpu_instr                      (fpu_instr_ex                      ),
	.fpu_flags                      (fpu_flags_ex                      ),
	.fpu_flags_valid                (fpu_flags_valid_ex                )
  );
  
  //--------------------------------------------------------
  // Branch computation unit
  //--------------------------------------------------------  
  // bcu controls //  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | bcu_op_completing_ex)
    begin      
      de_ex_pipe_bcu_op_sel_ex            <= update_ctrl_attbs_ex ? bcu_op_sel_de : bcu_op_none;           
      de_ex_pipe_branch_cond_ex           <= update_ctrl_attbs_ex ? branch_cond_de : branch_cond_none;         
    end    
  end  
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin      
      de_ex_pipe_bcu_operand0_mux_sel_ex  <= bcu_operand0_mux_sel_de;
      de_ex_pipe_bcu_operand1_mux_sel_ex  <= bcu_operand1_mux_sel_de;          
    end    
  end  
  
  assign bcu_operand0_mux_sel_ex      = de_ex_pipe_bcu_operand0_mux_sel_ex;
  assign bcu_operand1_mux_sel_ex      = de_ex_pipe_bcu_operand1_mux_sel_ex;
  assign bcu_op_sel_ex                = instr_valid_ex ? de_ex_pipe_bcu_op_sel_ex : bcu_op_none;
  assign branch_cond_ex               = instr_valid_ex ? de_ex_pipe_branch_cond_ex : branch_cond_none;                                
  assign bcu_op_complete_ex           = (bcu_op_sel_ex == bcu_op_none) | bcu_op_completing_ex; 
  assign bcu_operand_trap_cause_ex    = {25'd0,csr_priv_cause_excpt_code_retr,2'b00};
  assign bcu_operand_trap_vec_ex      = csr_priv_mtvec_excpt_vec_retr; 
  
    
  // test branch condition
  //----------------------
  
  always @*
  begin
    unique case(branch_cond_ex)
      branch_cond_none : 
      begin 
        branch_taken_ex       = 1'b0;
        bcu_op_completing_ex  = (instr_is_lsu_ldstr_ex  ? (lsu_op_complete_ex & ex_retr_exu_res_accept_retr) : 1'b0) | instr_inhibit_ex;
      end     
      branch_cond_always : 
      begin
        branch_taken_ex       = bcu_result_valid_ex & instr_valid_ex & ~instr_inhibit_ex;
        bcu_op_completing_ex  = (ifu_expipe_req_branch_excpt_req_ready & bcu_result_valid_ex) | 
                                    instr_inhibit_ex; 
      end
      branch_cond_compare_true : 
      begin
        branch_taken_ex       = exu_result_flags_ex.cmp_cond & instr_valid_ex & exu_result_valid_ex & ~instr_inhibit_ex;
        bcu_op_completing_ex  = ((~exu_result_flags_ex.cmp_cond | (ifu_expipe_req_branch_excpt_req_ready & bcu_result_valid_ex)) & exu_result_valid_ex) | 
                                    instr_inhibit_ex; 
      end
      default :      
      begin 
        branch_taken_ex       = 1'b0;
        bcu_op_completing_ex  = 1'b0;
      end
    endcase
  end
  
    
  miv_rv32_bcu
  u_bcu_0
  (
    .clk                            (clk                           ),
    .resetn                         (resetn                        ),
    // controls
    .bcu_operand0_mux_sel           (bcu_operand0_mux_sel_ex       ),
    .bcu_operand1_mux_sel           (bcu_operand1_mux_sel_ex       ),
    .bcu_op_sel                     (bcu_op_sel_ex                 ),
    .bcu_op_ready                   (                              ),  // Currently not used
    //operands
    .bcu_operand_pc                 (curr_pc_ex                    ),
    .bcu_operand_pc_valid           (instr_valid_ex                ),        
    .bcu_operand_gpr_rs1            (gpr_rs1_rd_data_fwd_ex        ), 
    .bcu_operand_gpr_rs1_valid      (gpr_rs1_rd_data_fwd_valid_ex  ),    
    .bcu_operand_trap_cause         (bcu_operand_trap_cause_ex     ),
    .bcu_operand_trap_cause_valid   (~trap_cause_hzd_ex            ),
    .bcu_operand_immediate          (immediate_ex                  ),
    .bcu_operand_immediate_valid    (instr_valid_ex                ), 
    .bcu_operand_epc                (csr_priv_mtvec_epc_retr       ), 
    .bcu_operand_epc_valid          (~epc_hzd_ex                   ),       
    .bcu_operand_dpc                (csr_priv_dpc_retr             ),    
    .bcu_operand_dpc_valid          (1'b1                          ),           
    .bcu_operand_trap_vec           (bcu_operand_trap_vec_ex       ), 
    .bcu_operand_trap_vec_valid     (~trap_vec_hzd_ex              ),  
    .bcu_operand_reset_vec          (l_core_reset_vector      ),
    .bcu_operand_reset_vec_valid    (1'b1                          ),
    // result
    .bcu_result                     (bcu_result_ex                 ),
    .bcu_result_valid               (bcu_result_valid_ex           ),
    .bcu_result_ready               (1'b1                          )  
  );
  
  // BCU also generate load-store address
  assign lsu_addr_result_ex       = bcu_result_ex;
  assign lsu_addr_result_valid_ex = bcu_result_valid_ex;

  //--------------------------------------------------------
  // LSU Interface
  //--------------------------------------------------------    
  // LSU is external to the pipeline to simplify independent formal verification and make LSU interchangeable for more capability
  
// lsu controls 
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | lsu_op_completing_ex)
    begin    
      de_ex_pipe_lsu_op_ex    <= update_ctrl_attbs_ex ? lsu_op_de : lsu_op_none;    
    end    
  end  
  
  // required to pass the lsu op to the retr stage. In ex stage it may be set to none (to prevent repeated requests) before being
  // accepted by retr stage so use a seperate version (lsu_op_ex_pipe) so retr stage knows to retire an lsu op.
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin    
      lsu_op_ex_pipe_reg      <= lsu_op_de;   
    end    
  end  
  
  assign lsu_op_ex_pipe         = (instr_valid_ex & ~instr_inhibit_ex) ? lsu_op_ex_pipe_reg : lsu_op_none;
  assign lsu_op_ex              = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_lsu_op_ex : lsu_op_none;
  
  assign instr_is_lsu_ldstr_ex  = (lsu_op_ex_pipe == lsu_op_ld_byte_s) |
                                  (lsu_op_ex_pipe == lsu_op_ld_hword_s) |
                                  (lsu_op_ex_pipe == lsu_op_ld_word) |
                                  (lsu_op_ex_pipe == lsu_op_ld_byte_u) |
                                  (lsu_op_ex_pipe == lsu_op_ld_hword_u) |
                                  (lsu_op_ex_pipe == lsu_op_str_byte) |
                                  (lsu_op_ex_pipe == lsu_op_str_word) |
                                  (lsu_op_ex_pipe == lsu_op_str_hword);
                                  
  assign instr_is_lsu_ldstr_reg_ex  = (lsu_op_ex_pipe_reg == lsu_op_ld_byte_s) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_hword_s) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_word) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_byte_u) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_hword_u) |
                                      (lsu_op_ex_pipe_reg == lsu_op_str_byte) |
                                      (lsu_op_ex_pipe_reg == lsu_op_str_word) |
                                      (lsu_op_ex_pipe_reg == lsu_op_str_hword);                              
  
  // lsu op complete in ex stage when request accepted by lsu
  // don't inhibit the request with lsu_flush because may arrive late, instead indicate to lsu to drop the resulting response if already accepted.
  // Also need to prevent store operations (and loads, fences, but the ywill be dropped silently anyhow in retr stage) if there is an exception going to occur
  // on the retiring instruction
  // Exceptions caused by the LSU (access faults) will be dealt with in the LSU and the request suppressed there.
  // Interrupts are imprecise so though they are taken in the retr stage, it does not matter architecturally if a store request has already been made in
  // the EX stage, however if it is made, the interrupt must be taken on the instruction following the store as that is the instruction that is interrupted, not the store.
  // If suppressing the request, need to tell retr stage not to expect a response - this should happen anyhow, since trap_taken_retr will be asserted.
  
  assign lsu_flush              = flush_ex;
  assign i_flush                = fence_i_ex | flush_ex;
                                  
  assign lsu_op_completing_ex   = (lsu_req_ready & lsu_req_valid) | lsu_flush | instr_inhibit_ex;
  assign lsu_op_complete_ex     = (lsu_op_ex == lsu_op_none) | lsu_op_completing_ex;
  
  assign lsu_op_str_ex = (lsu_op_ex_pipe == lsu_op_str_byte) | 
                         (lsu_op_ex_pipe == lsu_op_str_word) |
                         (lsu_op_ex_pipe == lsu_op_str_hword);                                  
  
  generate if(l_core_cfg_spec_load == 0)
  begin : gen_no_spec_after_load
    assign lsu_req_stall_ex  = lsu_ld_op_os |
                               lsu_fence_op_os;
  end else
  begin : gen_spec_load_fence_after_load
    assign lsu_req_stall_ex  = (lsu_ld_op_os & ~lsu_op_str_ex) |
                               lsu_fence_op_os;    
  end
  endgenerate                  
    
  assign lsu_req_valid          =  (lsu_op_ex != lsu_op_none) &
                                   (lsu_addr_result_valid_ex | fence_i_ex | fence_ex) &
                                   ((~lsu_op_str_ex) | align_result_valid_ex) &
                                    ~instr_inhibit_ex &
                                    ~lsu_req_stall_ex &
                                    ~lsu_req_stall_retr; 

  assign lsu_req_addr           = lsu_addr_result_ex;
  assign lsu_req_addr_valid     = lsu_addr_result_valid_ex;
  assign lsu_req_wr_data        = align_result_ex;
  assign lsu_req_wr_data_valid  = align_result_valid_ex;
  assign lsu_req_op             = lsu_op_ex; 
  
  // for a load-store-fence the alu op must be none
  // for a load-store-fence the bcu op must be add
  // for a load-store-fence the branch condition must be none
  // for a fence.i the branch condition must be always
  // fora conditional branch the bcu_op must be add
  // for a load or fence the shift op must be none
  // for a store the shift op must be shift left

  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  // Retire stage (RETR)
  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  
  // The retire stage writes back the result from exu/lsu to memory/gprs/csrs as required
  //
  // Exceptions and interrupts will be evaluated/taken in the retr stage
  // If a trap is taken in the retr stage, the decoder will be forced to decode the "trap" operation (a branch to the exception vector)
  // in the following instruction. The CSRs will be updated in the current ex_retr cycle with the trap information (mcause, mepc) since the 
  // following branch-to-trap-vector computation can only be premepted by another exception which would also need to update the csrs and would also
  // force a following branch-to-trap-vector


  //---------------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------------- 
  
  assign instr_req_retr   = instr_valid_ex & instr_completing_ex & ~flush_retr & ~stall_retr; //
  assign exu_res_req_retr = ((exu_result_mux_sel_ex == exu_alu_result_mux_acu) ? bcu_result_valid_ex : exu_result_valid_ex) & ~stall_retr;
  
  always @*
  begin
    case(stage_state_retr)
      expipe_stage_state_ready : 
      begin
        next_stage_state_retr       = instr_req_retr ? expipe_stage_state_busy : expipe_stage_state_ready;
        instr_accepted_retr         = instr_req_retr;
        ex_retr_exu_res_accept_retr = exu_res_req_retr;
        instr_valid_retr            = 1'b0;
        stage_ready_retr            = ~stall_retr;
      end
    
      expipe_stage_state_busy : 
      begin
        next_stage_state_retr       = instr_req_retr ? expipe_stage_state_busy : instr_completing_retr ? expipe_stage_state_ready : stage_state_retr;
        instr_accepted_retr         = instr_req_retr & instr_completing_retr;
        ex_retr_exu_res_accept_retr = exu_res_req_retr & instr_completing_retr;
        instr_valid_retr            = 1'b1;
        stage_ready_retr            = instr_completing_retr & ~stall_retr;
      end
    
      default :
        begin
        next_stage_state_retr       = expipe_stage_state_ready;
        instr_accepted_retr         = 1'b0;
        ex_retr_exu_res_accept_retr = 1'b0;
        instr_valid_retr            = 1'b0;
        stage_ready_retr            = 1'b0;
      end
    endcase
  end
  

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      stage_state_retr  <= expipe_stage_state_ready;
    else
      stage_state_retr  <= next_stage_state_retr;     
  end    
  
  assign instr_completing_retr = (gpr_wr_complete_retr & 
                                  csr_complete_retr &
                                  lsu_op_complete_retr) | debug_enter_retr;                                 
                                 
  assign flush_retr            = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr;  
  
  assign stall_retr            = wfi_waiting_retr |
                                 debug_mode_retr;                             
  
  assign update_ctrl_attbs_retr = instr_accepted_retr;
   
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_retr)
    begin
    // pipeline controls
      ex_retr_pipe_implicit_pseudo_instr_retr    <= implicit_pseudo_instr_ex;
      ex_retr_pipe_fence_i_retr                  <= fence_i_ex;
      ex_retr_pipe_wfi_retr                      <= wfi_ex;  
      ex_retr_pipe_i_access_fault_retr           <= i_access_fault_ex;           
      ex_retr_pipe_i_access_mem_error_retr       <= i_access_mem_error_ex;       
      ex_retr_pipe_i_access_parity_error_retr    <= i_access_parity_error_ex;    
      ex_retr_pipe_i_access_misalign_error_retr  <= i_access_misalign_error_ex;    
      ex_retr_pipe_illegal_instr_retr            <= illegal_instr_ex; 
      ex_retr_pipe_m_env_call_retr               <= m_env_call_ex; 
      ex_retr_pipe_trap_ret_retr                 <= trap_ret_ex; 
      ex_retr_pipe_dbreak_retr                   <= dbreak_ex;       
      ex_retr_pipe_curr_instr_enc_retr           <= curr_instr_enc_ex; 
    end    
  end
  
  generate if(l_core_cfg_num_triggers > 0)
  begin : gen_trig_pipe_reg_ex_retr
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
      begin
        ex_retr_pipe_trigger_retr <= trigger_ex;
      end
    end
    
    assign trigger_retr = ex_retr_pipe_trigger_retr & {l_core_cfg_trigger_bus_width{instr_valid_retr}};
    
  end
  else begin : ngen_trig_pipe_reg_ex_retr
  
    assign trigger_retr = {l_core_cfg_trigger_bus_width{1'b0}};
    
  end
  endgenerate
  
  generate if(l_core_cfg_hw_debug)
  begin : gen_pipe_debug_enter_req_ex_retr
     
    logic ex_retr_debug_enter_req_retr;
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
        ex_retr_debug_enter_req_retr <= debug_enter_req_ex;
    end
  
    always @(posedge clk)
    begin
      //if(soft_reset_taken_unmasked_retr)
      //  ex_retr_pipe_curr_pc_retr <= l_core_reset_vector;
      //else 
      if(update_ctrl_attbs_retr)
        ex_retr_pipe_curr_pc_retr <= ((branch_cond_ex == branch_cond_always) & debug_enter_req_ex & implicit_pseudo_instr_ex) ? {bcu_result_ex[I_ADDR_WIDTH-1:1],1'b0} : curr_pc_ex;
    end
    
    assign debug_enter_req_retr   = ex_retr_debug_enter_req_retr & instr_valid_retr;
    
  end
  else begin : ngen_pipe_debug_enter_req_ex_retr
  
    assign debug_enter_req_retr   =  1'b0;
    
    always @(posedge clk)
    begin
      //if(soft_reset_taken_unmasked_retr)
      //  ex_retr_pipe_curr_pc_retr <= l_core_reset_vector;
      //else 
      if(update_ctrl_attbs_retr)
        ex_retr_pipe_curr_pc_retr <= curr_pc_ex;  
    end 
    
  end
  endgenerate

  // Fence.i handling. 
  // Fence.i is implemented as a fence followed by a branch to the following instruction.
  // The branch is issued in the ex stage, but held off until the fence operation completes in the retr stage
  
  assign ifu_expipe_req_fenci_proceed  = fence_i_retr & lsu_op_completing_retr & ~debug_mode_retire_mask_retr;
                                          
  assign exu_result_retr               = ex_retr_pipe_exu_result_retr;          
  assign exu_result_valid_retr         = ex_retr_pipe_exu_result_valid_retr & (instr_valid_retr | debug_mode_retr);   
                                                
  assign implicit_pseudo_instr_retr    = ex_retr_pipe_implicit_pseudo_instr_retr;
  assign fence_i_retr                  = ex_retr_pipe_fence_i_retr & instr_valid_retr;
  assign wfi_retr                      = ex_retr_pipe_wfi_retr & instr_valid_retr & ~debug_mode_retire_mask_retr;
  assign i_access_fault_retr           = ex_retr_pipe_i_access_fault_retr & instr_valid_retr;
  assign i_access_mem_error_retr       = ex_retr_pipe_i_access_mem_error_retr & instr_valid_retr;
  assign i_access_parity_error_retr    = ex_retr_pipe_i_access_parity_error_retr & instr_valid_retr;
  assign i_access_misalign_error_retr  = ex_retr_pipe_i_access_misalign_error_retr & instr_valid_retr;
  assign illegal_instr_retr            = ex_retr_pipe_illegal_instr_retr & instr_valid_retr;  
  assign m_env_call_retr               = ex_retr_pipe_m_env_call_retr & instr_valid_retr;
  assign trap_ret_retr                 = ex_retr_pipe_trap_ret_retr & instr_valid_retr & ~debug_mode_retire_mask_retr;
  assign dbreak_retr                   = ex_retr_pipe_dbreak_retr & instr_valid_retr;
  assign curr_instr_enc_retr           = ex_retr_pipe_curr_instr_enc_retr;
  assign curr_pc_retr                  = ex_retr_pipe_curr_pc_retr;   


  // Stage handshaking/control  
  
  assign instr_retire_retr             = instr_completing_retr & instr_valid_retr & ~implicit_pseudo_instr_retr & ~debug_mode_retire_mask_retr; 
  
  // trap taken is only indicated when the instruction retires, however to prevent stores being initiated in the EX stage, need to 
  // determine when a trap is pending instruction completion in case the instruction retire is delayed (by a delayed LSU response)
  // LSU traps will be handled by the LSU, so do not need to include them here, bus errors are imprecise, so again do not need to include
  // them here.
  // Do not need to include interrupts here as they are also imprecise, but if not included must delay interrupts being taken until any stores 
  // in flight complete because otherwise store can occur without instruction that caused it seeming to execute. 
  // May also apply to loads that have read side-effects, so also include loads (fence has no side effects, but simpler to include it)
  // Such that interrupts eventually happen with reasonably predictable latency in a long sequence of stores, prevent new stores when an interrupt 
  // that will be taken is pending.
  
  assign trap_pending_retr                   = (i_access_fault_retr |         
                                                i_access_mem_error_retr |     
                                                i_access_parity_error_retr | 
                                                i_access_misalign_error_retr |
                                                illegal_instr_retr |
                                                m_env_call_retr |   
                                                dbreak_retr); 
              
  //--------------------------------------------------------
  // GPRs
  //--------------------------------------------------------  

  // gpr pipelining and controls //
  // GPR writes always occur at the end of the retr, and in core always in a single cycle,
  // therefore the write operation persists until the write completes when the operand results are valid from 
  // preceding ex stage or lsu

  // Option to select debug CSR/GPR read/write control pipelining.
  generate if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
  begin : gen_debug_gpr_ctrl_no_pipeline
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | gpr_wr_completing_retr)
      begin
        ex_retr_pipe_gpr_wr_en_retr       <= update_ctrl_attbs_retr ? gpr_wr_en_ex : 1'b0;    
      end    
    end  
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
      begin
        ex_retr_pipe_gpr_wr_sel_retr      <= gpr_wr_sel_ex;   
        ex_retr_pipe_gpr_wr_mux_sel_retr  <= gpr_wr_mux_sel_ex;   
      end    
    end
  
    assign gpr_wr_valid_mux         = debug_mode_retr ? (debug_gpr_req_wr_en & debug_gpr_req_valid) : gpr_wr_valid_retr; 
    assign gpr_wr_sel_mux           = debug_mode_retr ? debug_gpr_req_addr                          : gpr_wr_sel_retr; 
    assign gpr_wr_data_mux          = debug_mode_retr ? debug_csr_gpr_req_wr_data                   : gpr_wr_data_retr;
    
    assign exu_update_result_reg    = ex_retr_exu_res_accept_retr;
    
    assign gpr_rs2_rd_valid_dbgpipe = debug_mode_retr ? (debug_gpr_req_rd_en & debug_gpr_req_valid) : gpr_rs2_rd_valid_stg; 
    assign gpr_rs2_rd_sel_dbgpipe   = debug_mode_retr ?  debug_gpr_req_addr                         : gpr_rs2_rd_sel_stg;
	
    
  end
  else begin : gen_debug_gpr_ctrl_pipeline
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | gpr_wr_completing_retr | debug_mode_retr)
      begin
        ex_retr_pipe_gpr_wr_en_retr       <= debug_mode_retr ? (debug_gpr_req_wr_en & debug_gpr_req_valid) : 
                                                               (update_ctrl_attbs_retr ? gpr_wr_en_ex : 1'b0);    
      end    
    end  
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | debug_mode_retr)
      begin
        ex_retr_pipe_gpr_wr_sel_retr      <= debug_mode_retr ? debug_gpr_req_addr  : gpr_wr_sel_ex;   
        ex_retr_pipe_gpr_wr_mux_sel_retr  <= debug_mode_retr ? gpr_wr_mux_sel_exu  : gpr_wr_mux_sel_ex;   
      end    
    end
  
    assign gpr_wr_valid_mux      = gpr_wr_valid_retr; 
    assign gpr_wr_sel_mux        = gpr_wr_sel_retr;
    assign gpr_wr_data_mux       = gpr_wr_data_retr;
    
    assign exu_update_result_reg = ex_retr_exu_res_accept_retr | debug_mode_retr; 
    
    assign gpr_rs2_rd_valid_dbgpipe = debug_mode_retr ? gpr_rs2_rd_valid_ex : gpr_rs2_rd_valid_stg; 
    assign gpr_rs2_rd_sel_dbgpipe   = debug_mode_retr ? gpr_rs2_rd_sel_ex   : gpr_rs2_rd_sel_stg;
	
	
    
  end
  endgenerate
  
  assign gpr_wr_en_retr         = ex_retr_pipe_gpr_wr_en_retr & (instr_valid_retr | debug_mode_retr);
  assign gpr_wr_sel_retr        = ex_retr_pipe_gpr_wr_sel_retr;
  assign gpr_wr_mux_sel_retr    = ex_retr_pipe_gpr_wr_mux_sel_retr;  
  assign gpr_wr_complete_retr   = (~gpr_wr_en_retr) | gpr_wr_completing_retr;

  
 // GPR write data mux

  always @*
  begin
    case(gpr_wr_mux_sel_retr)
      gpr_wr_mux_sel_none :       
      begin
        gpr_wr_data_retr        = {L_XLEN{1'b0}};
        gpr_wr_valid_retr       = 1'b0;
        gpr_wr_completing_retr  = 1'b1;
      end  
      gpr_wr_mux_sel_lsu :       
      begin
        gpr_wr_data_retr        = lsu_resp_rd_data;
        gpr_wr_valid_retr       = lsu_resp_valid & gpr_wr_en_retr & ~flush_retr;        
        gpr_wr_completing_retr  = gpr_wr_ready_retr & lsu_resp_valid & gpr_wr_en_retr;
      end  
      gpr_wr_mux_sel_exu :       
      begin
        gpr_wr_data_retr        = exu_result_retr; 
        gpr_wr_valid_retr       = gpr_wr_en_retr & exu_result_valid_retr & (debug_mode_retr | ~flush_retr);
        gpr_wr_completing_retr  = gpr_wr_ready_retr & exu_result_valid_retr & gpr_wr_en_retr;
      end  
      gpr_wr_mux_sel_csr :       
      begin
        gpr_wr_data_retr        = sw_csr_rd_data_retr;      
        gpr_wr_valid_retr       = sw_csr_rd_data_valid_retr & gpr_wr_en_retr & ~flush_retr;
        gpr_wr_completing_retr  = (gpr_wr_ready_retr & sw_csr_rd_data_valid_retr & gpr_wr_en_retr); 
      end  
      default :        
      begin
        gpr_wr_data_retr        = {L_XLEN{1'b0}};
        gpr_wr_valid_retr       = 1'b0;
        gpr_wr_completing_retr  = 1'b1;
      end                    
    endcase
  end 
  
  // Debug read path currently muxed into rs2 path as this is likely less critical than rs1
  
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_gpr_ex_ctrls_rd_ex
    assign gpr_rs1_rd_valid_mux = gpr_rs1_rd_valid_ex & ~gpr_rs1_stall_ex;
    assign gpr_rs1_rd_sel_mux   = gpr_rs1_rd_sel_ex;
	
    assign gpr_rs2_rd_valid_stg = (gpr_rs2_rd_valid_ex & ~gpr_rs2_stall_ex);
    assign gpr_rs2_rd_sel_stg   = gpr_rs2_rd_sel_ex;
	
    assign gpr_rs3_rd_valid_mux = (gpr_rs3_rd_valid_ex & ~gpr_rs3_stall_ex);
    assign gpr_rs3_rd_sel_mux   = gpr_rs3_rd_sel_ex;
	
  end
  else begin : gen_gpr_ex_ctrls_rd_de
    assign gpr_rs1_rd_valid_mux = instr_valid_de & gpr_rs1_rd_valid_de;
    assign gpr_rs1_rd_sel_mux   = (l_core_cfg_hw_sp_float) ? gpr_rs1_rd_sel_de : {1'b0, gpr_rs1_rd_sel_de[4:0]};
	
    assign gpr_rs2_rd_valid_stg = instr_valid_de & gpr_rs2_rd_valid_de;
    assign gpr_rs2_rd_sel_stg   = (l_core_cfg_hw_sp_float) ? gpr_rs2_rd_sel_de : {1'b0, gpr_rs2_rd_sel_de[4:0]};
	
    assign gpr_rs3_rd_valid_mux = instr_valid_de & gpr_rs3_rd_valid_de;
    assign gpr_rs3_rd_sel_mux   = (l_core_cfg_hw_sp_float) ? gpr_rs3_rd_sel_de : {1'b0, gpr_rs3_rd_sel_de[4:0]};
	
  end
  endgenerate
  
  
  assign gpr_rs2_rd_valid_mux = gpr_rs2_rd_valid_dbgpipe;
  assign gpr_rs2_rd_sel_mux   = gpr_rs2_rd_sel_dbgpipe; 
  
  
  generate 
  if(l_core_cfg_gpr_type == 1)
    begin : gen_gpr
      miv_rv32_gpr #(  .l_core_cfg_hw_sp_float (l_core_cfg_hw_sp_float)
				    ) u_gpr_0 ( .clk                            (clk                          ),
                                .resetn                         (resetn                       ),
                                .gpr_wr_valid                   (gpr_wr_valid_mux             ),
                                .gpr_wr_ready                   (gpr_wr_ready_sig             ),
                                .gpr_wr_sel                     (gpr_wr_sel_mux               ),
                                .gpr_wr_data                    (gpr_wr_data_mux              ),
                                .gpr_rs1_rd_valid               (gpr_rs1_rd_valid_mux         ),
                                .gpr_rs1_rd_ready               (gpr_rs1_rd_ready_sig         ),
                                .gpr_rs1_rd_sel                 (gpr_rs1_rd_sel_mux           ),
                                .gpr_rs1_rd_data                (gpr_rs1_rd_data_sig          ),
                                .gpr_rs1_rd_data_valid          (gpr_rs1_rd_data_valid_sig    ),
                                .gpr_rs2_rd_valid               (gpr_rs2_rd_valid_mux         ),
                                .gpr_rs2_rd_ready               (gpr_rs2_rd_ready_sig         ),
                                .gpr_rs2_rd_sel                 (gpr_rs2_rd_sel_mux           ),
                                .gpr_rs2_rd_data                (gpr_rs2_rd_data_sig          ),
                                .gpr_rs2_rd_data_valid          (gpr_rs2_rd_data_valid_sig    ),
	                            
                                .gpr_rs3_rd_valid               (gpr_rs3_rd_valid_mux         ),
                                .gpr_rs3_rd_ready               (gpr_rs3_rd_ready_sig         ),
                                .gpr_rs3_rd_sel                 (gpr_rs3_rd_sel_mux           ),
                                .gpr_rs3_rd_data                (gpr_rs3_rd_data_sig          ),
                                .gpr_rs3_rd_data_valid          (gpr_rs3_rd_data_valid_sig    ),
	                            
                                .gpr_correctable_ecc_irq_src    (gpr_correctable_ecc_irq_src  ), 
                                .gpr_uncorrectable_ecc_irq_src  (gpr_uncorrectable_ecc_irq_src)
                              );
	 
	 assign gpr_ram_init_done = 1'b1;
    end
  else
    begin : gen_gpr_ram
      miv_rv32_gpr_ram #( .l_core_cfg_gpr_fwd_hzd (l_core_cfg_gpr_fwd_hzd),
	                      .l_core_cfg_hw_sp_float (l_core_cfg_hw_sp_float),
                          .ECC_ENABLE             (ECC_ENABLE            )
						  )
      u_gpr_0
     (
      .clk                            (clk                          ),
      .resetn                         (resetn                       ),
      .gpr_wr_valid                   (gpr_wr_valid_mux             ),
      .gpr_wr_ready                   (gpr_wr_ready_sig             ),
      .gpr_wr_sel                     (gpr_wr_sel_mux               ),
      .gpr_wr_data                    (gpr_wr_data_mux              ),
      .gpr_rs1_rd_valid               (gpr_rs1_rd_valid_mux         ),
      .gpr_rs1_rd_ready               (gpr_rs1_rd_ready_sig         ),
      .gpr_rs1_rd_sel                 (gpr_rs1_rd_sel_mux           ),
      .gpr_rs1_rd_data                (gpr_rs1_rd_data_sig          ),
      .gpr_rs1_rd_data_valid          (gpr_rs1_rd_data_valid_sig    ),
      .gpr_rs2_rd_valid               (gpr_rs2_rd_valid_mux         ),
      .gpr_rs2_rd_ready               (gpr_rs2_rd_ready_sig         ),
      .gpr_rs2_rd_sel                 (gpr_rs2_rd_sel_mux           ),
      .gpr_rs2_rd_data                (gpr_rs2_rd_data_sig          ),
      .gpr_rs2_rd_data_valid          (gpr_rs2_rd_data_valid_sig    ),
	  
      .gpr_rs3_rd_valid               (gpr_rs3_rd_valid_mux         ),
      .gpr_rs3_rd_ready               (gpr_rs3_rd_ready_sig         ),
      .gpr_rs3_rd_sel                 (gpr_rs3_rd_sel_mux           ),
      .gpr_rs3_rd_data                (gpr_rs3_rd_data_sig          ),
      .gpr_rs3_rd_data_valid          (gpr_rs3_rd_data_valid_sig    ),   
	  
      .gpr_correctable_ecc_irq_src    (gpr_correctable_ecc_irq_src  ), 
      .gpr_uncorrectable_ecc_irq_src  (gpr_uncorrectable_ecc_irq_src),
      .gpr_ram_init_done              (gpr_ram_init_done),
      .ram_init_soft_debug_reset      (ram_init_soft_debug_reset),
	  .icache_ram_init_done           (icache_ram_init_done),
	  .gpr_ecc_error_injection         (gpr_ecc_error_injection)
     );
    end
endgenerate
 
  assign gpr_wr_ready_retr            = gpr_wr_ready_sig & ~debug_mode_retr;
  assign gpr_uncorrectable_ecc_error  = gpr_uncorrectable_ecc_irq_src;
  
  assign debug_gpr_req_ready          = debug_mode_retr;
  assign debug_gpr_resp_rd_data       = gpr_rs2_rd_data_sig;
  assign debug_gpr_resp_valid         = gpr_rs2_rd_data_valid_sig & debug_mode_retr;
  
  
 
 //--------------------------------------------------------
  // CSRs
  //--------------------------------------------------------  

  // Trap handling //
  
  // if a trap is taken, CSRs will be updated in retr cycle they occur on, the decoder will be overidden to 
  // decode the "trap" instruction which computes the exception branch target and initiates a branch operation
  // software (explicit) CSR read/writes, GPR writes and LSU operations will be inhibited.

  assign vectored_interrupt_taken_retr    = interrupt_taken_retr & csr_priv_mtvec_excpt_vectored_retr;
  
  // pipelining and controls
  

  
  assign sw_csr_addr_retr              = ex_retr_pipe_sw_csr_addr_retr;
  assign sw_csr_wr_op_retr             = instr_valid_retr ? ex_retr_pipe_sw_csr_wr_op_retr : csr_alu_wr_op_none;  
  assign sw_csr_rd_op_retr             = instr_valid_retr ? ex_retr_pipe_sw_csr_rd_op_retr : csr_alu_rd_op_none;  
  assign csr_completing_retr           = ((sw_csr_wr_op_retr != csr_alu_wr_op_none) | (sw_csr_rd_op_retr != csr_alu_rd_op_none)) & sw_csr_op_ready_retr;
  assign csr_complete_retr             = ((sw_csr_wr_op_retr == csr_alu_wr_op_none) & (sw_csr_rd_op_retr == csr_alu_rd_op_none)) | csr_completing_retr;
  
  generate if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
  begin : gen_debug_csr_ctrl_no_pipeline
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | csr_completing_retr)
      begin
        ex_retr_pipe_sw_csr_wr_op_retr   <= update_ctrl_attbs_retr ? sw_csr_wr_op_ex : csr_alu_wr_op_none;
        ex_retr_pipe_sw_csr_rd_op_retr   <= update_ctrl_attbs_retr ? sw_csr_rd_op_ex : csr_alu_rd_op_none;
      end    
    end   
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
        ex_retr_pipe_sw_csr_addr_retr    <= sw_csr_addr_ex;    
    end  
  
    assign debug_csr_gpr_req_wr_data_dbgpipe  = debug_csr_gpr_req_wr_data;
    assign debug_csr_req_wr_en_dbgpipe        = debug_csr_req_wr_en & debug_csr_req_valid;     
    assign debug_csr_req_rd_en_dbgpipe        = debug_csr_req_rd_en & debug_csr_req_valid;     
    assign debug_csr_req_addr_dbgpipe         = debug_csr_req_addr;  
  end
  else begin : gen_debug_csr_ctrl_pipeline 
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | csr_completing_retr | debug_mode_retr)
      begin
        ex_retr_pipe_sw_csr_wr_op_retr   <= debug_mode_retr ? ((debug_csr_req_wr_en & debug_csr_req_valid)? csr_alu_wr_op_swap : csr_alu_wr_op_none) :
                                                              (update_ctrl_attbs_retr ? sw_csr_wr_op_ex : csr_alu_wr_op_none);
        ex_retr_pipe_sw_csr_rd_op_retr   <= debug_mode_retr ? ((debug_csr_req_rd_en & debug_csr_req_valid) ? csr_alu_rd_op_rd : csr_alu_rd_op_none) : 
                                                              (update_ctrl_attbs_retr ? sw_csr_rd_op_ex : csr_alu_rd_op_none);
      end    
    end   
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | debug_mode_retr)
        ex_retr_pipe_sw_csr_addr_retr    <= debug_mode_retr ? debug_csr_req_addr : sw_csr_addr_ex;    
    end  
    
    assign debug_csr_gpr_req_wr_data_dbgpipe  = ex_retr_pipe_exu_result_retr;
    assign debug_csr_req_wr_en_dbgpipe        = (ex_retr_pipe_sw_csr_wr_op_retr == csr_alu_wr_op_swap);    // re-use swap encoding to indicate debug write
    assign debug_csr_req_rd_en_dbgpipe        = (ex_retr_pipe_sw_csr_rd_op_retr == csr_alu_rd_op_rd);     
    assign debug_csr_req_addr_dbgpipe         = ex_retr_pipe_sw_csr_addr_retr;  
  end
  endgenerate
  
  assign debug_csr_req_ready = debug_mode_retr;
  
  miv_rv32_csr_privarch
  #(
     .I_ADDR_WIDTH                         (I_ADDR_WIDTH                         ),
	 .l_core_reset_vector                  (l_core_reset_vector                  ),
     .l_core_cfg_hw_multiply_divide        (l_core_cfg_hw_multiply_divide        ),
     .l_core_cfg_hw_compressed             (l_core_cfg_hw_compressed             ),
	 .l_core_cfg_hw_sp_float               (l_core_cfg_hw_sp_float               ),
     .l_core_static_mtvec_base             (l_core_static_mtvec_base             ),
     .l_core_cfg_static_mtvec_base         (l_core_cfg_static_mtvec_base         ),
     .l_core_cfg_static_mtvec_mode         (l_core_cfg_static_mtvec_mode         ),
     .l_core_static_mtvec_mode             (l_core_static_mtvec_mode             ),
	 .l_core_num_sys_ext_irqs              (l_core_num_sys_ext_irqs              ),
	 .l_core_cfg_time_count_width          (l_core_cfg_time_count_width          ),
	 .l_core_cfg_num_triggers              (l_core_cfg_num_triggers              ),
	 .l_core_cfg_trigger_bus_width         (l_core_cfg_trigger_bus_width         ),
	 .l_core_cfg_gpr_ecc_uncorrectable_irq (l_core_cfg_gpr_ecc_uncorrectable_irq ),
     .l_core_cfg_gpr_ecc_correctable_irq   (l_core_cfg_gpr_ecc_correctable_irq   ),
     .l_core_cfg_hw_debug                  (l_core_cfg_hw_debug                  ) ,
     .l_subsys_cfg_axi_present         (l_subsys_cfg_axi_present ),
     .l_subsys_cfg_ahb_present         (l_subsys_cfg_ahb_present ),
     .l_subsys_cfg_tcm0_present             (l_subsys_cfg_tcm0_present     ),
     .l_axi_start_addr                (l_axi_start_addr        ),
     .l_axi_end_addr                  (l_axi_end_addr          ),
     .l_ahb_start_addr                (l_ahb_start_addr        ),
     .l_ahb_end_addr                  (l_ahb_end_addr          ),
     .l_tcm0_start_addr                    (l_tcm0_start_addr            ),
     .l_tcm0_end_addr                      (l_tcm0_end_addr              )
  )
  u_csr_privarch_0
  (
    .clk                                      (clk                               ),                                                                    
    .resetn                                   (resetn                            ),                                                                          
    .soft_reset                               (core_soft_reset || ~gpr_ram_init_done ), //must hold the cpu in reset while initialising gpr ram
    .debug_soft_reset                         (debug_core_reset                  ),                                                                   
    .debug_reset                              (debug_reset                       ),                                                             
    .hart_id                                  (hart_id                           ), 
    .instr_completing_retr                    (instr_completing_retr             ),                                                            
    .instr_valid_retr                         (instr_valid_retr                  ),                                                                          
    .cycle_executed                           (~debug_mode_retr                  ),                                                 
    .time_count                               (time_count                        ),                                                            
    .instr_retired                            (instr_retire_retr                 ),                                                            
    .instr_wfi                                (wfi_retr                          ),                                                            
    .wfi_waiting                              (wfi_waiting_retr                  ),                                                            
    .instr_lsu_op_retr                        (instr_is_lsu_op_retr              ),  
    .lsu_op_os                                (lsu_op_os                         ),
    .irq_stall_lsu_req                        (irq_stall_lsu_req_retr            ),
    .irq_abort_lsu_req                        (irq_abort_lsu_req_retr            ),
    .flush                                    (flush_retr                        ),                                                                                                                                                                                   
    .csr_op_gpr_imm                           (exu_result_retr                   ),                                                                    
    .csr_op_gpr_imm_valid                     (exu_result_valid_retr             ), 
    .csr_op_rd_data                           (sw_csr_rd_data_retr               ),  // required for GPR forwarding path when GPR written from CSR
    .csr_op_rd_data_valid                     (sw_csr_rd_data_valid_retr         ),                                                                    
    .csr_op_ready                             (sw_csr_op_ready_retr              ),                                                                    
    .csr_alu_wr_op_sel                        (sw_csr_wr_op_retr                 ),                                                                     
    .csr_alu_rd_op_sel                        (sw_csr_rd_op_retr                 ),                                                                        
    .csr_op_addr                              (sw_csr_addr_retr                  ),                                                                     
    .csr_op_addr_valid                        (1'b1                              ),                                                                
    .ext_msip                                 (m_sw_irq                          ), 
    .ext_mtip                                 (m_timer_irq                       ),                                                                         
    .ext_meip                                 (m_external_irq                    ),  
    .sys_ext_irq_src                          (sys_ext_irq_src                   ),
    .gpr_uncorrectable_ecc_irq_src            (gpr_uncorrectable_ecc_irq_src     ),
    .gpr_correctable_ecc_irq_src              (gpr_correctable_ecc_irq_src       ), 
    .curr_pc                                  (curr_pc_retr                      ),                                                                         
    .curr_instr_enc                           (curr_instr_enc_retr               ),                                                                         
    .curr_ld_addr                             (exu_result_retr                   ), 
    .curr_str_addr                            (exu_result_retr                   ),  
    .excpt_i_addr_misalign                    (i_access_misalign_error_retr      ),                                                                         
    .excpt_i_access_fault                     (i_access_fault_retr               ),                                                                         
    .excpt_illegal_instr                      (illegal_instr_retr                ),                                                                         
    .excpt_breakpoint                         (dbreak_retr                       ),                                                                         
    .excpt_trigger                            (trigger_retr                      ),                                                                         
    .excpt_ld_addr_misalign                   (lsu_resp_ld_addr_misalign         ),                                                               
    .excpt_ld_access_fault                    (lsu_resp_ld_access_fault          ),                                                               
    .excpt_str_amo_addr_misalign              (lsu_resp_str_amo_addr_misalign    ),                                                               
    .excpt_str_amo_access_fault               (lsu_resp_str_amo_access_fault     ),                                                               
    .excpt_m_env_call                         (m_env_call_retr                   ),                                                               
    .excpt_s_env_call                         (1'b0                              ),                                                               
    .excpt_u_env_call                         (1'b0                              ),
    .excpt_bus_error_i                        (i_access_mem_error_retr           ), 
    .excpt_parity_error_i                     (i_access_parity_error_retr        ), 
    .excpt_bus_error_d                        (lsu_resp_access_mem_error         ), 
    .excpt_parity_error_d                     (lsu_resp_access_parity_error      ),                                                              
    .trap_taken                               (trap_taken_retr                   ),                                                               
    .trap_return                              (trap_ret_retr                     ),                                                               
    .extension_context_state                  (2'b00                             ),                                                                                                                                                                                                            
    .debug_csr_op_wr_data                     (debug_csr_gpr_req_wr_data_dbgpipe ),                                                    
    .debug_csr_wr_en                          (debug_csr_req_wr_en_dbgpipe       ),                                                                    
    .debug_csr_rd_en                          (debug_csr_req_rd_en_dbgpipe       ),                                                      
    .debug_csr_op_addr                        (debug_csr_req_addr_dbgpipe        ),                                                      
    .debug_csr_op_rd_data                     (debug_csr_resp_rd_data            ),
    .debug_csr_op_rd_data_valid               (debug_csr_resp_valid              ), 
    .debug_active                             (debug_active                      ),                                                     
    .debug_halt_req                           (debug_halt_req                    ), 
    .debug_halt_ack                           (debug_halt_ack                    ),                                                     
    .debug_resethalt_req                      (debug_resethalt_req               ), 
    .debug_resethalt_ack                      (debug_resethalt_ack               ),                                             
    .debug_resume_req                         (debug_resume_req                  ),                                                      
    .debug_resume_ack                         (debug_resume_ack                  ),  
    .debug_mode_enter_req                     (debug_enter_req_de                ), 
    .debug_instr_debug_enter_req              (debug_enter_req_retr              ),                                      
    .debug_mode_enter                         (debug_enter_retr                  ),
    .debug_mode_retire_mask                   (debug_mode_retire_mask_retr       ),                                             
    .debug_mode_exit                          (debug_exit_retr                   ),                                                                                                                                                                                                  
    .csr_priv_misa                            (csr_priv_misa_retr                ),                                                                   
    .csr_priv_cause_excpt_code                (csr_priv_cause_excpt_code_retr    ),                                                                   
    .csr_priv_mtvec_excpt_vectored            (csr_priv_mtvec_excpt_vectored_retr),                                                                   
    .csr_priv_mtvec_excpt_vec                 (csr_priv_mtvec_excpt_vec_retr     ),
	.csr_priv_mtval							  (csr_priv_mtval_retr				 ),
    .csr_priv_epc                             (csr_priv_mtvec_epc_retr           ), 
    .csr_priv_dpc                             (csr_priv_dpc_retr                 ),    
    .csr_priv_soft_reset_taken                (soft_reset_taken_unmasked_retr    ),                                                                  
    .csr_priv_interrupt_taken                 (interrupt_taken_retr              ),
    .csr_priv_priv_mode                       (priv_mode_retr                    ), // core only supports machine mode
    .csr_priv_debug_mode                      (debug_mode_retr                   ),                                                                   
    .trigger_instruction_opcode               (ifu_expipe_resp_ireg              ),                                                                   
    .trigger_instruction_address              (ifu_expipe_resp_ireg_vaddr        ),                                                                   
    .trigger_instruction_valid                (trigger_op_addr_valid_de          ),
    .step_instruction_valid                   (step_instruction_valid_de         ),                                                                  
    .trigger_req                              (trigger_req_de                    ),
    .ram_init_soft_debug_reset                (ram_init_soft_debug_reset         ),                                                                      
    .fpu_flags                                (fpu_flags_ex                      ),
	.fpu_flags_valid                          (fpu_flags_valid_ex                ),
    .fpu_frm                                  (fpu_frm_csr                       ) 
                                                                                                                                                  
  );                                                                                                                                              
  
  // outside of the state update in the CSR PRIV block (and formal model), taking a reset whilst in debug mode should have no effect.
  assign soft_reset_taken_retr = soft_reset_taken_unmasked_retr & ~(debug_enter_retr | debug_mode_retr);                                                                                                                                                
  assign debug_mode = debug_mode_retr;                                               
  
  
  assign cfg_hw_mul_en_retr         = csr_priv_misa_retr[12] & l_core_cfg_hw_multiply;
  assign cfg_hw_div_en_retr         = csr_priv_misa_retr[12] & l_core_cfg_hw_divide;  
  assign cfg_atomics_en_retr        = csr_priv_misa_retr[0] & l_core_cfg_hw_atomics;
  assign cfg_compressed_en_retr     = csr_priv_misa_retr[2] & l_core_cfg_hw_compressed;  
  assign cfg_float_en_retr          = csr_priv_misa_retr[5] & l_core_cfg_hw_sp_float;  


  //--------------------------------------------------------
  // LSU Interface
  //--------------------------------------------------------    

// lsu controls 
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_retr | lsu_op_completing_retr)
    begin    
      ex_retr_pipe_lsu_op_retr  <= (update_ctrl_attbs_retr & ~instr_inhibit_ex) ? lsu_op_ex_pipe : lsu_op_none;    
    end    
  end  

  assign lsu_op_retr            = instr_valid_retr ? ex_retr_pipe_lsu_op_retr : lsu_op_none;
  
  assign lsu_op_completing_retr = lsu_resp_ready & lsu_resp_valid;
  assign lsu_op_complete_retr   = (lsu_op_retr == lsu_op_none) | lsu_op_completing_retr;
  
  assign instr_is_lsu_op_retr   = (lsu_op_retr != lsu_op_none);
  
  // LSU is external to the pipeline to simplify independent formal verification 
  // LSU resp always goes to gpr, so ready when expecting LSU response and gpr can be written   
  assign lsu_resp_ready         =  ((((lsu_op_retr == lsu_op_ld_byte_s) |
                                      (lsu_op_retr == lsu_op_ld_hword_s) |
                                      (lsu_op_retr == lsu_op_ld_word)    |
                                      (lsu_op_retr == lsu_op_ld_byte_u) |
                                      (lsu_op_retr == lsu_op_ld_hword_u)) & gpr_wr_ready_retr & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu)) |
                                   (lsu_op_retr == lsu_op_str_byte) |
                                   (lsu_op_retr == lsu_op_str_word) |
                                   (lsu_op_retr == lsu_op_str_hword) |
                                   (lsu_op_retr == lsu_op_fence));

  // input wire  logic                                lsu_resp_access_aborted       // - not currently used 
  
  // Must block LSU requests in the ex stage if the retr stage is going to be unable to accept them.
  // This does not include the lsu response itself as this may be late, and the issue this protects
  // against is being able to not accept an LSU response for the second request - if the first request is the
  // cause of the stall, then inherently the second response cannot be attempting to return as Core
  // requires requests complete in order
  
  assign lsu_req_stall_retr = stall_retr | irq_stall_lsu_req_retr;
    

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
     sreset  <= 1'b1;
    else
     sreset  <= 1'b0;     
  end

  //--------------------------------------------------------
  // Formal Trace Interface
  //--------------------------------------------------------
	generate if (l_core_cfg_formal_dbg_if)
		begin
			assign formal_trace_instr             = curr_instr_enc_retr;
			assign formal_trace_pc                = curr_pc_retr;
			assign formal_trace_reset_taken       = soft_reset_taken_unmasked_retr;  
			assign formal_trace_instr_retire      = instr_retire_retr;  
		end
	else
		begin
			assign formal_trace_instr             = {L_XLEN{1'b0}};
			assign formal_trace_pc                = {L_XLEN{1'b0}};
			assign formal_trace_reset_taken       = soft_reset_taken_unmasked_retr;  
			assign formal_trace_instr_retire      = instr_retire_retr; 		
		end
	endgenerate
 
  //--------------------------------------------------------
  // Instruction Trace Interface
  //--------------------------------------------------------
  
  assign trace_valid            = instr_retire_retr; 
  assign trace_iaddr            = curr_pc_retr;
  assign trace_insn             = curr_instr_enc_retr;
  assign trace_priv				= debug_mode_retr; // DM = 1, MM = 0  
  assign trace_exception   		= trap_taken_retr;   // Revist after testing, csr_priv_mtvec_excpt_vectored_retr?
  assign trace_interrupt   		= interrupt_taken_retr;
  assign trace_cause            = csr_priv_cause_excpt_code_retr;
  assign trace_tval				= csr_priv_mtval_retr;
  
  
 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  // cannot force a reset when in or entering debug mode
  assert_expipe_no_soft_reset_when_debug: assert property (@(posedge clk) disable iff (~resetn)
      force_core_soft_reset_branch_de |-> ~(debug_enter_retr | debug_mode_retr));
  
   
  
  // cannot force a trap branch when in or entering debug mode
  
  assert_expipe_no_trap_branche_when_debug: assert property (@(posedge clk) disable iff (~resetn)
      force_trap_branch_de |-> ~(debug_enter_retr | debug_mode_retr));
  

  // If an instruction is accepted from the IFU, the de_ex pipeline registers must be able to accept it
  assert_expipe_ifu_instr_accept_must_update_de_ex: assert property (@(posedge clk) disable iff (~resetn)
                                                                     (ifu_expipe_resp_ready & ifu_expipe_resp_valid) |-> update_ctrl_attbs_ex);

  // can always accept an LSU response if a request is accepted
  assert_expipe_lsu_req_must_accepte_response: assert property (@(posedge clk) disable iff (~resetn)
                                                                (lsu_req_valid & lsu_req_ready & ~lsu_flush) |-> ##1 lsu_resp_ready);
                                                                       
                                                                       
  // in retr stage, if lsu op is for a load, gpr wr enable must be asserted and must have lsu as the source
  assert_expipe_retr_load_must_write_gpr: assert property (@(posedge clk) disable iff (~resetn)
                                                           ((lsu_op_retr == lsu_op_ld_byte_s) |
                                                            (lsu_op_retr == lsu_op_ld_hword_s) |
                                                            (lsu_op_retr == lsu_op_ld_word) |
                                                            (lsu_op_retr == lsu_op_ld_byte_u) |
                                                            (lsu_op_retr == lsu_op_ld_hword_u)) |-> gpr_wr_en_retr);
                                                            
  assert_expipe_retr_load_must_write_sel_lsu: assert property (@(posedge clk) disable iff (~resetn)
                                                           ((lsu_op_retr == lsu_op_ld_byte_s) |
                                                            (lsu_op_retr == lsu_op_ld_hword_s) |
                                                            (lsu_op_retr == lsu_op_ld_word) |
                                                            (lsu_op_retr == lsu_op_ld_byte_u) |
                                                            (lsu_op_retr == lsu_op_ld_hword_u)) |-> (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu));
                                                            
  // if writing the GPR, then the source can't be none
  assert_expipe_retr_gpr_write_must_have_src: assert property (@(posedge clk) disable iff (~resetn)
                                                               gpr_wr_en_retr |-> (gpr_wr_mux_sel_retr != gpr_wr_mux_sel_none)); 
                                                               
                                                                                                            
                                                             
  // if using exu result in retr stage then exu_result_valid_retr must be asserted
  assert_expipe_retr_using_exu_must_be_valid_gpr: assert property (@(posedge clk) disable iff (~resetn)  
                                                                  (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu) & instr_valid_retr |-> exu_result_valid_retr);
                                                                  
  assert_expipe_retr_using_exu_must_be_valid_csr: assert property (@(posedge clk) disable iff (~resetn)  
                                                                  (sw_csr_wr_op_retr != csr_alu_wr_op_none) & instr_valid_retr |-> exu_result_valid_retr); 
                                                                  
  // if a csr op is accepted, csr and gpr must be written or trap taken when instruction completes 
  // (as csr update is atomic, gpr and csr must complete in the same cycle)
  assert_expipe_retr_csr_must_write_or_trap: assert property (@(posedge clk) disable iff (~resetn) 
                                                              (sw_csr_wr_op_retr!= csr_alu_wr_op_none) & instr_valid_retr |-> ##[0:$] (csr_completing_retr | trap_taken_retr));
                                                              
  assert_expipe_retr_csr_gpr_wr_same_cycle: assert property (@(posedge clk) disable iff (~resetn)                                                            
                                                             (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr) & gpr_wr_en_retr & instr_valid_retr |-> (csr_completing_retr == gpr_wr_completing_retr));
  
  
  // if a gpr write op is accepted, gpr must be written or trap taken when instruction completes 
  assert_expipe_retr_gpr_must_write_or_trap: assert property (@(posedge clk) disable iff (~resetn) 
                                                              (gpr_wr_en_retr & instr_valid_retr) |-> ##[0:$] (gpr_wr_completing_retr | trap_taken_retr));  
                                                              
                                                              
  
  // if an instruction is accepted it must eventually complete  
  
  assert_expipe_ex_must_complete: assert property (@(posedge clk) disable iff (~resetn) 
                                                              instr_valid_ex & ~implicit_pseudo_instr_ex  |-> ##[0:$] (instr_completing_ex | flush_ex));  
                                                              
  assert_expipe_retr_must_complete: assert property (@(posedge clk) disable iff (~resetn) 
                                                              instr_valid_retr & ~implicit_pseudo_instr_retr  |-> ##[0:$] (instr_completing_retr | flush_retr));                                                               
                                                              
  assert_expipe_retr2_must_complete: assert property (@(posedge clk) disable iff (~resetn) 
                                                              instr_req_retr & ~implicit_pseudo_instr_retr  |-> ##[1:$] instr_completing_retr);   
                                                              
  // retr stage request must complete in the same cycle any lsu request is returned (because in the case of an exception, the bits are not written until the instruction completes)    
  
  // If a debug halt request is made, eventually enter debug mode
  assert_expipe_debug_halt_req_must_halt: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_halt_req & ~debug_mode |-> ##[0:$] (debug_mode | ~debug_halt_req));
                                                           
  assert_expipe_debug_halt_req_must_ack: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_halt_req & ~debug_mode |-> ##[0:$] (debug_halt_ack | ~debug_halt_req));
  
  // if a debug resume request is made, eventually leave debug mode 
  assert_expipe_debug_resume_req_must_leave: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_resume_req & debug_mode |-> ##[0:$] ((~debug_mode) | (~debug_resume_req)));
                                                           
  assert_expipe_debug_resume_req_must_ack: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_resume_req & debug_mode |-> ##[0:$] (debug_resume_ack | ~debug_resume_req));  
                                                             
                                                 
                                                                                                              
`endif                                                        

 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   miv_rv32_exu.sv
//
//   Purpose:
//   Execution unit for core
//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none
import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module  miv_rv32_exu
//********************************************************************************
// Parameter description

  #(
    parameter USE_FORMAL = 1,
    parameter USE_SIM = 1,
	parameter l_core_cfg_hw_debug           = 0,
	parameter l_core_cfg_hw_multiply_divide = 0,
	parameter l_core_cfg_hw_macc_multiplier = 0,
	parameter l_core_cfg_hw_sp_float        = 0,
	parameter NO_MACC_BLK                   = 0
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    
    input wire  logic                         clk,
    input wire  logic                         resetn,
    // controls
    input wire  logic                         exu_op_abort, 
    output      logic                         exu_op_ready,
    input wire  logic                         debug_mode,
                  
    input wire  t_exu_alu_operand0_sel        alu_operand0_mux_sel,                 
    input wire  t_exu_alu_operand1_sel        alu_operand1_mux_sel,                 
    input wire  t_exu_alu_op_sel              alu_op_sel,                       
    input wire  t_exu_shifter_operand_sel     shifter_operand_sel,              
    input wire  t_exu_shifter_places_sel      shifter_unit_places_sel,          
    input wire  t_exu_shifter_op_sel          shifter_unit_op_sel,                    
    input wire  t_exu_alu_result_mux_sel      exu_result_mux_sel,         
      //operands
    input wire  logic [L_XLEN-1:0]            exu_operand_gpr_rs1,            
    input wire  logic                         exu_operand_gpr_rs1_valid,      
    input wire  logic [L_XLEN-1:0]            exu_operand_gpr_rs2,            
    input wire  logic                         exu_operand_gpr_rs2_valid,        
    input wire  logic [L_XLEN-1:0]            exu_operand_gpr_rs3,            
    input wire  logic                         exu_operand_gpr_rs3_valid,  
    input wire  logic [L_XLEN-1:0]            exu_operand_immediate,          
    input wire  logic                         exu_operand_immediate_valid,             
    input wire  logic [L_XLEN-1:0]            exu_operand_pc,                 
    input wire  logic                         exu_operand_pc_valid,   
    input wire  logic [L_XLEN-1:0]            acu_result,
    input wire  logic                         acu_result_valid, 
    input wire  logic [L_XLEN-1:0]            debug_wr_data, 
    input wire  logic                         debug_wr_data_valid,                  
      // result
           
    output      logic [L_XLEN-1:0]            exu_result,            
    output      logic                         exu_result_valid,  
    input wire  logic                         exu_result_ready,     
    output      t_exu_flags                   exu_result_flags,           
    output      logic [L_XLEN-1:0]            lsu_align_result,      
    output      logic                         lsu_align_result_valid,
    input wire  logic                         lsu_align_result_ready,  
    input wire  logic                         update_result_reg,  
    output      logic [L_XLEN-1:0]            exu_result_reg,            
    output      logic                         exu_result_reg_valid,
	
    input wire logic[2:0]                       fpu_frm,
	input wire logic[1:0]                       fpu_fmt,
	input wire logic                            fpu_instr,
	output     logic[4:0]                       fpu_flags,
	output     logic                            fpu_flags_valid

  );

//********************************************************************************
// localparams
  localparam cfg_div_en     = l_core_cfg_hw_multiply_divide & l_core_cfg_hw_divide;
  localparam cfg_fast_mul   = l_core_cfg_hw_multiply_divide & l_core_cfg_hw_multiply & (l_core_cfg_hw_macc_multiplier != 0);
  localparam cfg_slow_mul   = l_core_cfg_hw_multiply_divide & l_core_cfg_hw_multiply & (l_core_cfg_hw_macc_multiplier == 0);

// Declarations
  logic [L_XLEN-1:0]            exu_alu_operand0;
  logic                         exu_alu_operand0_valid;
  logic [L_XLEN-1:0]            exu_alu_operand1;
  logic                         exu_alu_operand1_valid;
  logic [L_XLEN-1:0]            exu_alu_operand2;
  logic                         exu_alu_operand2_valid;
  logic [L_XLEN-1:0]            exu_shifter_operand;      
  logic                         exu_shifter_operand_valid;
  logic [L_XLEN-1:0]            exu_shifter_places;      
  logic                         exu_shifter_places_valid; 
  logic                         exu_alu_ready;
  
  logic [1:0]                   addr_shift_bits;
  logic                         addr_shift_bits_valid;
  logic [L_XLEN:0]              exu_alu_result; 
  logic                         exu_alu_result_valid;
  logic [L_XLEN-1:0]            shifter_result;      
  logic                         shifter_result_valid;
  logic                         exu_shifter_ready;
  
  logic [L_XLEN-1:0]            exu_mux_result;      
  logic                         exu_mux_result_valid; 
  logic                         exu_mux_result_valid_dbgsel;
  t_exu_flags                   exu_mux_result_flags;
  
  logic [L_XLEN:0]              exu_alu_operand0_int;
  logic [L_XLEN:0]              exu_alu_operand1_int;
  logic [(L_XLEN*2)-2:0]        div_divisor;
  logic [(L_XLEN*2):0]          exu_result_reg_int;  
  logic [(L_XLEN*2):0]          exu_mux_result_dbgsel;
  logic [(L_XLEN*2)-1:0]        slow_mul_result; 
  logic [L_XLEN:0]              exu_alu_operand0_s;
  logic [L_XLEN:0]              exu_alu_operand1_s;
  logic [L_XLEN:0]              exu_alu_operand0_u;
  logic [L_XLEN:0]              exu_alu_operand1_u;
  logic [L_XLEN:0]              mul_mp;
  logic [L_XLEN:0]              mul_mc;
  logic [L_XLEN:0]              mulh_mp;
  logic [L_XLEN:0]              mulh_mc;
  
  logic [L_XLEN-1:0]            div_result;
  logic [1:0]                   operand_sign_det;
  
  logic [L_XLEN-1:0]            mul_div_cnt;
  t_exu_alu_op_sel              alu_op_sel_int;
  
  logic                         div_finish;
  logic                         mul_finish;
  logic                         slow_mul_ack;
  logic                         start_mul;
  logic                         start_slow_mul;
  
  logic [L_XLEN-1:0]            dividend;
  logic [L_XLEN-1:0]            quotient;
  logic                         start_div;
  logic                         res_pos_neg;
  logic                         div_ack;
    
  logic [(L_XLEN*2)-1:0]        exu_alu_result_sel; 
  logic                         exu_mux_result_valid_sel; 
  
  logic [(L_XLEN*2)-2:0]        next_dividend_int;
  logic [(L_XLEN*2)-2:0]        dividend_int;
  
  logic                         exu_fpu_valid;
  logic [L_XLEN-1:0]            fpu_data_out;  
  logic                         fpu_valid_result;
  logic                         start_fpu;
  
  roundmode_e                   fpu_frm_i;
  operation_e                   op_i;
  status_t                      status_o;
  fp_format_e                   src_fmt_i = FP32;
  fp_format_e                   dst_fmt_i = FP32;
  int_format_e                  int_fmt_i = INT32;
  
  logic [95:0]                  fpu_operand_order;
  logic                         op_mod_i;
  logic                         in_ready_o;
  logic                         in_valid_i;
  logic                         out_ready_i;
  logic                         fpu_st;

// Internal nets

//********************************************************************************
// Assignments
//********************************************************************************
  assign exu_result_reg[L_XLEN-1:0] = exu_result_reg_int[L_XLEN-1:0];
  
  generate
  if(cfg_fast_mul) begin : fast_mul
      assign exu_alu_operand0_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand0_u       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_u       = {L_XLEN+1{1'b0}};
      assign mul_mc                   = {L_XLEN+1{1'b0}};
      assign mul_mp                   = {L_XLEN+1{1'b0}};
      assign mulh_mc                  = {L_XLEN+1{1'b0}};
      assign mulh_mp                  = {L_XLEN+1{1'b0}};
      assign operand_sign_det         = 2'b0;
      assign start_slow_mul           = 1'b0;
      assign start_mul                = (exu_alu_operand0_valid & exu_alu_operand1_valid & (alu_op_sel == exu_alu_op_multiply_signed_op0_signed_op1          | alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1 | 
                                                                                            alu_op_sel == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1 | alu_op_sel == exu_alu_op_multiply_high_signed_op0_unsigned_op1));

      assign exu_mux_result_valid_sel = (start_mul) ? mul_finish : 1'b0;
      assign alu_op_sel_int           = alu_op_sel;
      assign exu_alu_operand0_int     = {1'b0, exu_alu_operand0};
      assign exu_alu_operand1_int     = {1'b0, exu_alu_operand1};
      assign slow_mul_result          = {(L_XLEN*2){1'b0}};

      miv_rv32_mul #(.l_core_cfg_hw_macc_multiplier(l_core_cfg_hw_macc_multiplier)
	                  ) miv_rv32_mul_0 ( .clk          (clk),
                                           .resetn       (resetn),
                                           .data_in_0    (exu_alu_operand0),
                                           .data_in_1    (exu_alu_operand1),
                                           .start_mul    (start_mul),
                                           .mul_type     (alu_op_sel),
                                           .data_out     (exu_alu_result_sel),
                                           .valid_result (mul_finish)
         );

  end else if(cfg_slow_mul) begin: slow_mul
      assign exu_alu_operand0_s       = {exu_alu_operand0[L_XLEN-1], exu_alu_operand0[L_XLEN-1:0]};
      assign exu_alu_operand1_s       = {exu_alu_operand1[L_XLEN-1], exu_alu_operand1[L_XLEN-1:0]};
      assign exu_alu_operand0_u       = {1'b0, exu_alu_operand0[L_XLEN-1:0]};
      assign exu_alu_operand1_u       = {1'b0, exu_alu_operand1[L_XLEN-1:0]};
      assign mul_mc                   = (alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1) ? mulh_mc : ((alu_op_sel == exu_alu_op_multiply_unsigned_op0_unsigned_op1) | (alu_op_sel == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1))  ? exu_alu_operand0_u : exu_alu_operand0_s;
      assign mul_mp                   = (alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1) ? mulh_mp :  (alu_op_sel == exu_alu_op_multiply_signed_op0_signed_op1)                                                                            ? exu_alu_operand1_s : exu_alu_operand1_u;
      assign mulh_mc                  = (operand_sign_det == 2'b00) ? exu_alu_operand1_u: (operand_sign_det == 2'b10) ? exu_alu_operand1_s:  (operand_sign_det == 2'b11) ? {{L_XLEN{1'b0}}, (~exu_alu_operand0[L_XLEN-1:0])+1} : exu_alu_operand0_s;
      assign mulh_mp                  = (operand_sign_det == 2'b00) ? exu_alu_operand0_u: (operand_sign_det == 2'b10) ? exu_alu_operand0_u:  (operand_sign_det == 2'b11) ? {{L_XLEN{1'b0}}, (~exu_alu_operand1[L_XLEN-1:0])+1} : exu_alu_operand1_u;
      assign start_slow_mul           = (exu_alu_operand0_valid & exu_alu_operand1_valid & (alu_op_sel == exu_alu_op_multiply_signed_op0_signed_op1          | alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1 | 
                                                                                            alu_op_sel == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1 | alu_op_sel == exu_alu_op_multiply_high_signed_op0_unsigned_op1));
      assign start_mul                = 1'b0;
      assign slow_mul_result          = exu_result_reg_int[(L_XLEN*2)-1:0];
      assign exu_mux_result_valid_sel = (start_slow_mul) ? ((mul_div_cnt[5]) | exu_op_abort) : 1'b0;  
      assign exu_alu_result_sel       = slow_mul_result;
      assign alu_op_sel_int           = (start_slow_mul & !(mul_div_cnt[5])) ? exu_alu_op_add_op0_op1 : alu_op_sel;
      assign exu_alu_operand0_int     = (start_slow_mul) ? mul_mc                              : {1'b0, exu_alu_operand0};
      assign exu_alu_operand1_int     = (start_slow_mul) ? exu_result_reg_int[L_XLEN*2:L_XLEN] : {1'b0, exu_alu_operand1};
      assign mul_finish               = 1'b0;
      assign operand_sign_det[1]      = exu_alu_operand1[L_XLEN-1];
      assign operand_sign_det[0]      = exu_alu_operand0[L_XLEN-1]; 
  end else begin : no_mul
      assign exu_alu_operand0_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand0_u       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_u       = {L_XLEN+1{1'b0}};
      assign mul_mc                   = {L_XLEN+1{1'b0}};
      assign mul_mp                   = {L_XLEN+1{1'b0}};
      assign mulh_mc                  = {L_XLEN+1{1'b0}};
      assign mulh_mp                  = {L_XLEN+1{1'b0}};
      assign operand_sign_det         = 2'b0;
      assign start_slow_mul           = 1'b0;
      assign start_mul                = 1'b0;
      assign alu_op_sel_int           = alu_op_sel;
      assign exu_alu_operand0_int     = {1'b0, exu_alu_operand0};
      assign exu_alu_operand1_int     = {1'b0, exu_alu_operand1};
      assign slow_mul_result          = {(L_XLEN*2){1'b0}};
      assign exu_mux_result_valid_sel = 1'b0;
      assign exu_alu_result_sel       = {(L_XLEN*2){1'b0}};
      assign mul_finish               = 1'b1;
  end
  endgenerate
  
  generate
  if(cfg_div_en) begin : div 
      assign dividend_int = { {(L_XLEN-2){1'b0}}, dividend };
      assign next_dividend_int = dividend_int - div_divisor;
      assign div_finish = ((start_div & ((mul_div_cnt[5]) | exu_op_abort))) ? 1'b1 : 1'b0;
      assign div_result = ((alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1) | 
                           (alu_op_sel == exu_alu_op_divide_unsigned_op0_unsigned_op1)) ? (res_pos_neg ? -quotient : quotient) : (res_pos_neg ? -dividend : dividend);   
      assign start_div  = (exu_alu_operand0_valid & exu_alu_operand1_valid & (alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1 | 
                                                                              alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1 | 
                                                                              alu_op_sel == exu_alu_op_divide_unsigned_op0_unsigned_op1 |
                                                                              alu_op_sel == exu_alu_op_remainder_unsigned_op0_unsigned_op1));
  end else begin : no_div     
      assign dividend_int               = {(L_XLEN*2)-2{1'b0}};
      assign next_dividend_int          = {(L_XLEN*2)-2{1'b0}};
      assign div_finish                 = 1'b1;
      assign div_result                 = {L_XLEN{1'b0}};
      assign start_div                  = 1'b0;
  end
  endgenerate
  
  
//********************************************************************************
// Main code
//********************************************************************************

  // Adder/Logical Unit/Fast-multiplier/Fast-dividr operand multiplexors
  
    // exu_alu_operand0
  always @*
  begin
    case(alu_operand0_mux_sel)
      exu_op0_rs1 :
      begin
        exu_alu_operand0        = exu_operand_gpr_rs1;      
        exu_alu_operand0_valid  = exu_operand_gpr_rs1_valid;
      end
      exu_op0_pc : 
      begin
        exu_alu_operand0        = exu_operand_pc;      
        exu_alu_operand0_valid  = exu_operand_pc_valid;
      end
      default :
      begin
        exu_alu_operand0        = {L_XLEN{1'b0}};
        exu_alu_operand0_valid  = 1'b0;
      end
    endcase
  end
  
    // exu_alu_operand1
  always @*
  begin
    case(alu_operand1_mux_sel)
      exu_op1_rs2 :
      begin
        exu_alu_operand1        = exu_operand_gpr_rs2;      
        exu_alu_operand1_valid  = exu_operand_gpr_rs2_valid;
      end
      exu_op1_imm :
      begin
        exu_alu_operand1        = exu_operand_immediate;       
        exu_alu_operand1_valid  = exu_operand_immediate_valid;
      end
      exu_op1_lit4 :
      begin
        exu_alu_operand1        = 32'd4;     
        exu_alu_operand1_valid  = 1'b1;
      end
      exu_op1_lit2 :
      begin
        exu_alu_operand1        = 32'd2;     
        exu_alu_operand1_valid  = 1'b1;
      end
      default :
      begin
        exu_alu_operand1        = {L_XLEN{1'b0}};
        exu_alu_operand1_valid  = 1'b0;
      end
    endcase
  end
  
 // exu_alu_operand2
  assign exu_alu_operand2        = exu_operand_gpr_rs3;  
  assign exu_alu_operand2_valid  = exu_operand_gpr_rs3_valid;

  
    // shifter_operand
  always @*
  begin
    case(shifter_operand_sel)
      shifter_operand_none :
      begin
        exu_shifter_operand        = {L_XLEN{1'b0}};
        exu_shifter_operand_valid  = 1'b1;
      end
      shifter_operand_rs1 :
      begin
        exu_shifter_operand        = exu_operand_gpr_rs1;      
        exu_shifter_operand_valid  = exu_operand_gpr_rs1_valid;
      end
      shifter_operand_rs2 :
      begin
        exu_shifter_operand        = exu_operand_gpr_rs2;     
        exu_shifter_operand_valid  = exu_operand_gpr_rs2_valid;
      end
      default :
      begin
        exu_shifter_operand        = {L_XLEN{1'b0}};
        exu_shifter_operand_valid  = 1'b0;
      end
    endcase
  end
  
    // shifter_places
  always @*
  begin
    case(shifter_unit_places_sel)
      shifter_places_operand_none :
      begin
        exu_shifter_places        =  {L_XLEN{1'b0}};
        exu_shifter_places_valid  = 1'b0;
      end
      shifter_places_operand_addr_byte :
      begin
        exu_shifter_places        = (addr_shift_bits == 2'b11) ? 32'd24 : 
                                      (addr_shift_bits == 2'b10) ? 32'd16 : 
                                        (addr_shift_bits == 2'b01) ? 32'd8 : {L_XLEN{1'b0}};;                                         
        exu_shifter_places_valid  = addr_shift_bits_valid;
      end
      shifter_places_operand_addr_hword :
      begin
        exu_shifter_places        = (addr_shift_bits[1] == 1'b1) ? 32'd16 :  {L_XLEN{1'b0}};;                                         
        exu_shifter_places_valid  = addr_shift_bits_valid;
      end
      shifter_places_operand_rs2 :
      begin
        exu_shifter_places        = {{(L_XLEN-5){1'b0}}, exu_operand_gpr_rs2[4:0]};   
        exu_shifter_places_valid  = exu_operand_gpr_rs2_valid;
      end
      shifter_places_operand_imm :
      begin
        exu_shifter_places        = {{(L_XLEN-5){1'b0}}, exu_operand_immediate[4:0]};      
        exu_shifter_places_valid  = exu_operand_immediate_valid;
      end
      shifter_places_operand_noshift :
      begin
        exu_shifter_places        =  {L_XLEN{1'b0}};
        exu_shifter_places_valid  = 1'b1;
      end
      default :
      begin
        exu_shifter_places        = {L_XLEN{1'b0}};
        exu_shifter_places_valid  = 1'b0;
      end
    endcase
  end

  // arithmetic/logical/shifter units and result multiplexor
  // REVISIT big simple case statement for now - optimize later
  // REVISIT compare results currently computed inline, change to subtract and compute flags
  logic [L_XLEN:0] exu_alu_result_int;
  assign exu_alu_result_int = exu_alu_operand0_int + exu_alu_operand1_int;
  
  always @*
  begin
    exu_fpu_valid              = 1'b0;
    case(alu_op_sel_int)
      exu_alu_op_none :
      begin
        exu_alu_result        = {L_XLEN+1{1'b0}};
        exu_alu_result_valid  = 1'b0;
        exu_alu_ready         = 1'b1; 
      end
      exu_alu_op_add_op0_op1 :
      begin
        exu_alu_result        = exu_alu_result_int; 
        exu_alu_result_valid  = (start_slow_mul) ? exu_mux_result_valid_sel : exu_alu_operand0_valid & exu_alu_operand1_valid;        
        exu_alu_ready         = exu_result_ready;
      end
      exu_alu_op_sub_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 - exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;               
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_xor_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 ^ exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;               
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_or_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 | exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_and_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 & exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_multiply_signed_op0_signed_op1 :
      begin  
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[L_XLEN-1:0];
        exu_alu_result_valid       = exu_mux_result_valid_sel; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_multiply_high_signed_op0_signed_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
        exu_alu_result_valid       = exu_mux_result_valid_sel; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      //exu_alu_op_multiply_unsigned_op0_unsigned_op1 :
      //begin
      //  exu_alu_result[L_XLEN]     = 1'b0;
      //  exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[L_XLEN-1:0] 
      //  exu_alu_result_valid       = exu_mux_result_valid_sel; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
      //  exu_alu_ready              = exu_result_ready;
      //end
      exu_alu_op_multiply_high_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
        exu_alu_result_valid       = exu_mux_result_valid_sel; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      //exu_alu_op_multiply_signed_op0_unsigned_op1 :
      //begin
      //  exu_alu_result[L_XLEN]     = 1'b0;
      //  exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
      //  exu_alu_result_valid       = exu_mux_result_valid_sel; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
      //  exu_alu_ready              = exu_result_ready;
      //end
      exu_alu_op_multiply_high_signed_op0_unsigned_op1 :
      begin 
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
        exu_alu_result_valid       = exu_mux_result_valid_sel; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_divide_signed_op0_signed_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = div_finish; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_divide_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = div_finish; //exu_alu_operand0_valid & exu_alu_operand1_valid;
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_remainder_signed_op0_signed_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = div_finish; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_remainder_unsigned_op0_unsigned_op1 : 
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = div_finish; //exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end      
      exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) < $unsigned(exu_alu_operand1)) ? 33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_lt_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) < $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_gte_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) >= $unsigned(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_gte_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) >= $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_equal_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) == $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_equal_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) == $unsigned(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_not_equal_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) != $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_not_equal_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) != $unsigned(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
	  ////////////////////////////
      
      
      
      exu_alu_op_fmadd_op0_op1_op2,
      exu_alu_op_fmsub_op0_op1_op2,
      exu_alu_op_fnmadd_op0_op1_op2,
      exu_alu_op_fnmsub_op0_op1_op2,
      exu_alu_op_fadd_op0_op1,
      exu_alu_op_fsub_op0_op1,
      exu_alu_op_fmul_op0_op1,
      exu_alu_op_fdiv_op0_op1,
      exu_alu_op_fsqrt_op0_op1,
      exu_alu_op_fsgnj_op0_op1,
      exu_alu_op_fsgnjn_op0_op1,
      exu_alu_op_fsgnjx_op0_op1,
      exu_alu_op_fmin_op0_op1,
      exu_alu_op_fmax_op0_op1,
      exu_alu_op_fcvt_w_s_op0_op1,
      exu_alu_op_fcvt_wu_s_op0_op1,
      exu_alu_op_feq_op0_op1,
      exu_alu_op_flt_op0_op1,
      exu_alu_op_fle_op0_op1,
      exu_alu_op_fclass_s_op0_op1,
      exu_alu_op_fcvt_s_w_op0_op1,
      exu_alu_op_fcvt_s_wu_op0_op1: 
      begin
        exu_alu_result             = {1'b0, fpu_data_out};
        //exu_alu_result_valid       = fpu_valid_result & in_ready_o;    
        exu_alu_result_valid       = fpu_valid_result;      
        exu_alu_ready              = exu_result_ready;
		exu_fpu_valid              = 1'b1;
      end
	  ////////////////////////////
      default :
      begin
        exu_alu_result             = {L_XLEN+1{1'b0}};
        exu_alu_result_valid       = 1'b0;       
        exu_alu_ready              = 1'b1;
      end
    endcase
  end
  
  // Shift unit
  
  assign addr_shift_bits        = exu_operand_gpr_rs1[1:0] + exu_operand_immediate[1:0];
  assign addr_shift_bits_valid  = exu_operand_gpr_rs1_valid & exu_operand_immediate_valid;
  
  logic [(L_XLEN*2)-1:0]  tmp_ls_operand0;
  logic [(L_XLEN*2)-1:0]  tmp_ms_operand0;
  logic [(L_XLEN*2)-1:0]  tmp_ls_operand0_signed;
  assign tmp_ls_operand0        = {{L_XLEN{1'b0}},exu_shifter_operand} ;
  assign tmp_ms_operand0        = {exu_shifter_operand,{L_XLEN{1'b0}}} ;
  assign tmp_ls_operand0_signed = {{L_XLEN{exu_shifter_operand[L_XLEN-1]}},exu_shifter_operand} ;
  
  always @*
  begin
    case(shifter_unit_op_sel)
    
      exu_shifter_op_none :
      begin
        shifter_result        = {L_XLEN{1'b0}};
        shifter_result_valid  = 1'b0;
        exu_shifter_ready     = 1'b1;
      end
      exu_shifter_op_shift_left : 
      begin
        shifter_result        = tmp_ms_operand0[(((L_XLEN*2)-1) - exu_shifter_places) -: L_XLEN];
        shifter_result_valid  = exu_shifter_operand_valid & exu_shifter_places_valid;
        exu_shifter_ready     = lsu_align_result_ready & exu_result_ready;  // only shift left used for lsu
      end 
      exu_shifter_op_shift_right :  
      begin
        shifter_result        = tmp_ls_operand0[((L_XLEN-1) + exu_shifter_places) -: L_XLEN];
        shifter_result_valid  = exu_shifter_operand_valid & exu_shifter_places_valid;
        exu_shifter_ready     = exu_result_ready;
      end   
      exu_shifter_op_arithmetic_shift_right :
      begin
        shifter_result        = tmp_ls_operand0_signed[((L_XLEN-1) + exu_shifter_places) -: L_XLEN];
        shifter_result_valid  = exu_shifter_operand_valid & exu_shifter_places_valid;
        exu_shifter_ready     = exu_result_ready;
      end      
      default
      begin
        shifter_result        = {L_XLEN{1'b0}};
        shifter_result_valid  = 1'b0;
        exu_shifter_ready     = 1'b1;
      end 
    endcase
  end
  
  
  always @*
  begin
    case(exu_result_mux_sel)
      exu_alu_result_mux_none :
      begin
        exu_mux_result          = {L_XLEN{1'b0}}; 
        exu_mux_result_valid    = 1'b0;
      end
      exu_alu_result_mux_cmp_lit :      // REVISIT computed directly for now, but eventually generate from adder result flags
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_shifter :
      begin
        exu_mux_result          = shifter_result;      
        exu_mux_result_valid    = shifter_result_valid;
      end
      exu_alu_result_mux_adder :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_logical :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_multiplier :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_divider :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid; 
      end
      exu_alu_result_mux_acu :   
      begin
        exu_mux_result          = acu_result;
        exu_mux_result_valid    = acu_result_valid;
      end
	  exu_alu_result_mux_float :   
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end 
      default :
      begin
        exu_mux_result          = {L_XLEN{1'b0}};
        exu_mux_result_valid    = 1'b0;
      end
    endcase
  end
  
  assign exu_mux_result_flags.cmp_cond = exu_alu_result[0];


  // Assign outputs
  
  assign exu_op_ready             = exu_alu_ready & exu_shifter_ready;
  
  assign exu_result               = exu_mux_result;      
  assign exu_result_valid         = exu_mux_result_valid; 
  assign exu_result_flags         = exu_mux_result_flags;
  assign lsu_align_result         = shifter_result;      
  assign lsu_align_result_valid   = shifter_result_valid;
  
  generate if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
  begin : gen_debug_dbg_wrdata_no_pipeline
    assign exu_mux_result_dbgsel        = {{L_XLEN+1{1'b0}}, exu_mux_result};
    assign exu_mux_result_valid_dbgsel  = exu_mux_result_valid;
  end else 
  begin : gen_debug_dbg_wrdata_pipeline 
    assign exu_mux_result_dbgsel        = debug_mode ? {{L_XLEN+1{1'b0}}, debug_wr_data} : {{L_XLEN+1{1'b0}}, exu_mux_result}; 
    assign exu_mux_result_valid_dbgsel  = debug_mode ? debug_wr_data_valid : exu_mux_result_valid;
  end
  endgenerate   
  


  // Multiplier / Divider
  
  logic [(L_XLEN*2):0]          next_exu_result_reg_int;
  logic                         next_slow_mul_ack;      
  logic [L_XLEN-1:0]            next_mul_cnt;  
  logic [L_XLEN-1:0]            next_div_cnt; 
  logic                         next_div_ack;    
  logic [(L_XLEN*2)-2:0]        next_div_divisor;
  logic [L_XLEN-1:0]            next_dividend;   
  logic                         next_res_pos_neg;
  logic [L_XLEN-1:0]            next_quotient;             
  
  // multiplier next state
  always @*
  begin
  
    //defaults
    next_exu_result_reg_int = exu_result_reg_int;
    next_slow_mul_ack       = slow_mul_ack;
    next_mul_cnt            = mul_div_cnt;
      
    if (~debug_mode & (start_slow_mul & (!(mul_div_cnt[5]) & !exu_op_abort))) 
    begin
      if (!slow_mul_ack) 
      begin
        next_exu_result_reg_int  = {(L_XLEN*2)+1{1'b0}};
        next_slow_mul_ack        = 1'b1;
        next_mul_cnt             = {L_XLEN{1'b0}};
      end else 
      begin
        next_exu_result_reg_int[(L_XLEN*2)]      = mul_mp[mul_div_cnt] ? (((alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1) |  
                                                                          (alu_op_sel == exu_alu_op_multiply_high_signed_op0_unsigned_op1)) ? exu_alu_result_int[L_XLEN] : 1'b0) : 
                                                                          exu_result_reg_int[(L_XLEN*2)];                
        next_exu_result_reg_int[(L_XLEN*2)-1:0]  = mul_mp[mul_div_cnt] ? {exu_alu_result_int, exu_result_reg_int[L_XLEN-1:1]} :                                                                          
                                                                          exu_result_reg_int[(L_XLEN*2):1];    
        next_slow_mul_ack                        = slow_mul_ack;
        next_mul_cnt                             = mul_div_cnt + 1;
      end
    end else if(update_result_reg | exu_op_abort) 
    begin
      next_exu_result_reg_int = exu_mux_result_dbgsel;   
      next_slow_mul_ack       = 1'b0;
      next_mul_cnt            = {L_XLEN{1'b0}};    
    end 
  end
  
  // divider next state
  always @*
  begin
  
    // defaults
    next_div_ack      = div_ack;
    next_div_divisor  = div_divisor; 
    next_dividend     = dividend;    
    next_res_pos_neg  = res_pos_neg; 
    next_quotient     = quotient;    
    next_div_cnt      = mul_div_cnt;
  
    if(~debug_mode & (start_div & (!(mul_div_cnt[5]) & !exu_op_abort))) 
    begin
      if(!div_ack) begin
        next_div_divisor = ((alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1 | alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1) & exu_alu_operand1[L_XLEN-1] ? -{{L_XLEN-1{1'b0}}, exu_alu_operand1} : exu_alu_operand1) << L_XLEN-1;
        next_dividend    =  (alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1 | alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1) & exu_alu_operand0[L_XLEN-1] ? -exu_alu_operand0 : exu_alu_operand0;                  
        next_res_pos_neg = ((alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1) & (exu_alu_operand0[L_XLEN-1] != exu_alu_operand1[L_XLEN-1]) & |exu_alu_operand1) | ((alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1) & exu_alu_operand0[L_XLEN-1]);
        next_quotient    = {L_XLEN{1'b0}};
        next_div_ack     = 1'b1;
        next_div_cnt     = {L_XLEN{1'b0}};   
      end else 
      begin
        if (div_divisor <= {{L_XLEN-1{1'b0}}, dividend}) 
        begin
          next_dividend                          = next_dividend_int[L_XLEN-1:0];
          next_quotient[(L_XLEN-1)-mul_div_cnt]  = 1'b1;
        end         
        next_div_divisor  = div_divisor[(L_XLEN*2)-2:0] >> 1; 
        next_div_cnt      = mul_div_cnt + 1;
      end
    end else if(update_result_reg | exu_op_abort) 
    begin
      next_div_ack       = 1'b0;
      next_div_cnt       = {L_XLEN{1'b0}};    
    end 
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      mul_div_cnt        <= {L_XLEN{1'b0}};      
    else   
      mul_div_cnt        <= start_slow_mul ? next_mul_cnt : next_div_cnt;                   
  end 

  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn) 
      slow_mul_ack       <= 1'b0;     
    else
      slow_mul_ack       <= next_slow_mul_ack;                
  end 
  

  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      div_ack            <= 1'b0;     
    else 
      div_ack            <= next_div_ack;                   
  end 
  
  always @(posedge clk)
  begin
    div_divisor  <= next_div_divisor;
    dividend     <= next_dividend;   
    res_pos_neg  <= next_res_pos_neg;
    quotient     <= next_quotient;          
  end 
  
    
  // output register

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      exu_result_reg_valid <= 1'b0;
    else
      if(update_result_reg)
        exu_result_reg_valid <= exu_mux_result_valid_dbgsel;
  end 
  
  always @(posedge clk)
  begin
    exu_result_reg_int <= next_exu_result_reg_int;               
  end 

//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

   //-------------                                                              
   // covers
   //------------
   
   // helper (stepping-stone/guidepoint) covers for multicycle ops 
   
  localparam MAX_MULT_DIV_STEPS = L_XLEN+1;  
   
  genvar i_cover_muldiv_seq;
  generate
  for (i_cover_muldiv_seq = 0; i_cover_muldiv_seq < MAX_MULT_DIV_STEPS; i_cover_muldiv_seq++) 
  begin : gen_cover_muldiv_seq   
  
    if(cfg_slow_mul | cfg_div_en) 
    begin : gen_mul_div_step_cov
      cover_exu_mult_cnt: cover property (@(posedge clk) disable iff (~resetn)
                                             start_slow_mul & (mul_div_cnt == i_cover_muldiv_seq[L_XLEN-1:0]));
                                             
      cover_exu_div_cnt: cover property (@(posedge clk) disable iff (~resetn)
                                             start_div & (mul_div_cnt == i_cover_muldiv_seq[L_XLEN-1:0]));                                       
    end // end if-generate
  
  end 
  endgenerate                                                                          
                                        
`endif 
  
////////////////////////////////////////
//  FPU
////////

generate
if(l_core_cfg_hw_sp_float) begin : gen_fpu
											 
  assign out_ready_i     = 1'b1;
  assign in_valid_i      = ((fpu_st == 1'b0) & start_fpu) ? 1'b1 : 1'b0;
  assign fpu_flags       = status_o;
  assign fpu_flags_valid = fpu_valid_result;
 
  assign start_fpu = ((fpu_instr & exu_fpu_valid) & ((exu_alu_operand0_valid & exu_alu_operand1_valid) & 
                     (exu_alu_operand2_valid | ((alu_op_sel != exu_alu_op_fmadd_op0_op1_op2 )  & 
					                            (alu_op_sel != exu_alu_op_fmsub_op0_op1_op2 )  & 
					                            (alu_op_sel != exu_alu_op_fnmadd_op0_op1_op2)  & 
					                            (alu_op_sel != exu_alu_op_fnmsub_op0_op1_op2)))));
	
  assign op_i = (alu_op_sel == exu_alu_op_fmadd_op0_op1_op2 ) ? FMADD  :       		
                (alu_op_sel == exu_alu_op_fmsub_op0_op1_op2 ) ? FMADD  :            	
                (alu_op_sel == exu_alu_op_fnmadd_op0_op1_op2) ? FNMSUB :            	
                (alu_op_sel == exu_alu_op_fnmsub_op0_op1_op2) ? FNMSUB :          	
                (alu_op_sel == exu_alu_op_fadd_op0_op1      ) ? ADD    :     
                (alu_op_sel == exu_alu_op_fsub_op0_op1      ) ? ADD    :     
                (alu_op_sel == exu_alu_op_fmul_op0_op1      ) ? MUL    :            
                (alu_op_sel == exu_alu_op_fdiv_op0_op1      ) ? DIV    :           	
                (alu_op_sel == exu_alu_op_fsqrt_op0_op1     ) ? SQRT   :            	
                (alu_op_sel == exu_alu_op_fsgnj_op0_op1     ) ? SGNJ   :                	
                (alu_op_sel == exu_alu_op_fsgnjn_op0_op1    ) ? SGNJ   :                	
                (alu_op_sel == exu_alu_op_fsgnjx_op0_op1    ) ? SGNJ   :                	
                (alu_op_sel == exu_alu_op_fmin_op0_op1      ) ? MINMAX :                	
                (alu_op_sel == exu_alu_op_fmax_op0_op1      ) ? MINMAX : 
                (alu_op_sel == exu_alu_op_fcvt_w_s_op0_op1  ) ? F2I :  
                (alu_op_sel == exu_alu_op_fcvt_wu_s_op0_op1 ) ? F2I : 
                (alu_op_sel == exu_alu_op_feq_op0_op1       ) ? CMP : 
                (alu_op_sel == exu_alu_op_flt_op0_op1       ) ? CMP : 
                (alu_op_sel == exu_alu_op_fle_op0_op1       ) ? CMP : 
                (alu_op_sel == exu_alu_op_fclass_s_op0_op1  ) ? CLASSIFY: 
                (alu_op_sel == exu_alu_op_fcvt_s_w_op0_op1  ) ? I2F : 
                (alu_op_sel == exu_alu_op_fcvt_s_wu_op0_op1 ) ? I2F : 
                                                                   ADD;  //NOP ?
																  
  assign op_mod_i = (alu_op_sel == exu_alu_op_fmsub_op0_op1_op2 ) |            	
                    (alu_op_sel == exu_alu_op_fnmadd_op0_op1_op2) |     
                    (alu_op_sel == exu_alu_op_fsub_op0_op1      ) |       
                    (alu_op_sel == exu_alu_op_fcvt_wu_s_op0_op1 ) | 
                    (alu_op_sel == exu_alu_op_fcvt_s_wu_op0_op1 ) ? 1'b1 : 1'b0; 

  assign fpu_frm_i = (fpu_frm == 3'b000) ? RNE:
                     (fpu_frm == 3'b001) ? RTZ:
                     (fpu_frm == 3'b010) ? RDN:
                     (fpu_frm == 3'b011) ? RUP:
                     (fpu_frm == 3'b100) ? RMM:
                     (fpu_frm == 3'b111) ? DYN: RNE;
					 
  assign fpu_operand_order = (op_i == ADD)  ? {exu_alu_operand1, exu_alu_operand0, 32'b0} :
                             (op_i == SQRT) ? {exu_alu_operand0, exu_alu_operand0, exu_alu_operand0} :  // REVISIT 
                                              {exu_alu_operand2, exu_alu_operand1, exu_alu_operand0};

  //FPU Ready/Valid FSM 
  always @(posedge clk or negedge resetn)
    begin
      if(!resetn) begin
  	    fpu_st <= 1'b0; 
  	  end else begin
  	      case(fpu_st)
  	         1'b0: begin
  		             if(start_fpu & in_ready_o & !fpu_valid_result) begin
  		  		         fpu_st <= 1'b1;
  		  		     end else begin
  		  		         fpu_st <= 1'b0;
  		  		     end
  		           end
  	         1'b1: begin
  		             if(fpu_valid_result) begin
  		  		         fpu_st <= 1'b0;
  		  		     end else begin
  		  		         fpu_st <= 1'b1;
  		  		     end
  		           end
  	      default: begin
  	                 fpu_st <= 1'b0; 
  		           end
  	      endcase
  	 end
    end
					  
   miv_rv32_fpnew_top /*#(
               .Features       ( FPU_FEATURES       ),
               .Implementation ( FPU_IMPLEMENTATION ),
               .TagType        ( logic              )
              )*/ #(.NO_MACC_BLK( NO_MACC_BLK ))
			      fpnew_top_0 ( .clk_i          (clk),
                                .rst_ni         (resetn),
                                .operands_i     (fpu_operand_order),
                                .rnd_mode_i     (fpu_frm_i),
                                .op_i           (op_i),
                                .op_mod_i       (op_mod_i), 
                                .src_fmt_i      (src_fmt_i),
                                .dst_fmt_i      (dst_fmt_i),
                                .int_fmt_i      (int_fmt_i),
                                .vectorial_op_i (1'b0),
                                .tag_i          (1'b0),
                                .in_valid_i     (in_valid_i),
                                .in_ready_o     (in_ready_o ),
                                .flush_i        (1'b0 ),
                                .result_o       (fpu_data_out), 
                                .status_o       (status_o),
                                .tag_o          ( /* unused */),
                                .out_valid_o    ( fpu_valid_result), 
                                .out_ready_i    ( out_ready_i),
                                .busy_o         ( /* unused */ )
                              );


end else begin : ngen_fpu
    assign start_fpu = 1'b0;
    assign fpu_data_out = {L_XLEN{1'b0}};
	assign fpu_valid_result = 1'b0;
	assign fpu_st = 1'b0;
	assign in_valid_i = 1'b0;
	assign out_ready_i = 1'b0;
	assign in_ready_o = 1'b0;
    assign fpu_flags = 5'b0;
    assign fpu_flags_valid = 1'b0;
end
endgenerate

endmodule

`default_nettype wire
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   miv_rv32_exu.sv
//
//   Purpose:
//   Execution unit for core
//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_mul
  //****************************************************************************
  // Parameter description 
  #(
    parameter l_core_cfg_hw_macc_multiplier = 0
   )
//********************************************************************************
// Port description

  (
    //inputs
    input wire  logic                   clk,
    input wire  logic                   resetn,
    input wire  signed [L_XLEN-1:0]     data_in_0,
    input wire  signed [L_XLEN-1:0]     data_in_1,
    input wire  logic                   start_mul,
    input wire  t_exu_alu_op_sel        mul_type,
            
    //outputs
    output logic signed[(L_XLEN*2)-1:0] data_out /* synthesis syn_multstyle="dsp" */,
    output logic                        valid_result

   );
   
   localparam [0:0] l_core_cfg_macc_reg = (l_core_cfg_hw_macc_multiplier == 2) ? 1 : 0;
   logic start_mul_ack;
   
 generate
  if(l_core_cfg_macc_reg == 1) begin : gen_reg_macc
    logic [(L_XLEN*2)-1:0] in_reg0, in_reg1;
   
    always @ (posedge clk) begin
        if (!resetn) begin
            start_mul_ack <= 1'b0;
            valid_result  <= 1'b0;
            in_reg0       <= {L_XLEN{1'b0}};
            in_reg1       <= {L_XLEN{1'b0}};
        end else begin
            start_mul_ack <= start_mul;
            in_reg0       <= (((mul_type == exu_alu_op_multiply_unsigned_op0_unsigned_op1) | (mul_type == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1)) ? $signed({1'b0, data_in_0})  : $signed( data_in_0));
            in_reg1       <= (((mul_type == exu_alu_op_multiply_signed_op0_signed_op1)     | (mul_type == exu_alu_op_multiply_high_signed_op0_signed_op1))     ? $signed(data_in_1)          : $signed({1'b0, data_in_1}));

            if(start_mul_ack & valid_result) begin
                valid_result <= 1'b0;
            end else begin
                valid_result <= start_mul;
            end       
        end
    end
  
    assign data_out = in_reg0 * in_reg1;
    
  end else begin: gen_macc
    assign start_mul_ack = 1'b0;
    assign valid_result = start_mul;
    assign data_out     = (((mul_type == exu_alu_op_multiply_unsigned_op0_unsigned_op1) | (mul_type == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1)) ? $signed({1'b0, data_in_0})  : $signed( data_in_0))  * 
                          (((mul_type == exu_alu_op_multiply_signed_op0_signed_op1)     | (mul_type == exu_alu_op_multiply_high_signed_op0_signed_op1))     ? $signed(data_in_1)          : $signed({1'b0, data_in_1}));

  end
endgenerate

endmodule

`default_nettype wire




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_fetch_unit.sv
//
//   Purpose: Fetch unit for core CPU.
//            Includes instruction pointer, fetch buffer/queue, and bus interface
//
//            Accepts request (instruction pointer) from control piplene (expipe) and returns the instruction
//            performing buffering and alignment as required to deal with misaligned and compressed instructions
//            in any arbritrary mix
//
//        
//           
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_fetch_unit
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH        = 32,
	parameter l_core_reset_vector = 32'h6000_0000,
	parameter MI_I_MEM            = 0
   )
  
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,
  input  wire logic                                resetn,
  
  input  wire logic                                parity_en,
  
  // external memory bus interface
  output      logic                                ifu_emi_req_valid,
  input wire  logic                                ifu_emi_req_ready, 
  output      logic[3:0]                           ifu_emi_req_rd_byte_en,
  output      logic[I_ADDR_WIDTH-1:0]              ifu_emi_req_addr,
  output      logic                                ifu_emi_req_addr_p,
  
  input wire  logic                                ifu_emi_resp_valid,
  output      logic                                ifu_emi_resp_ready,
  input wire  logic [31:0]                         ifu_emi_resp_data,
  input wire  logic [3:0]                          ifu_emi_resp_data_p,   
  input wire  logic                                ifu_emi_resp_error,
  
  // internal core pipeline (expipe) interface      

  input wire  logic                                ifu_expipe_fetch_en,
  input wire  logic                                ifu_expipe_req_branch_excpt_req_valid,
  input wire  logic                                ifu_expipe_req_branch_excpt_req_fenci,
  input wire  logic                                ifu_expipe_req_fenci_proceed,
  output      logic                                ifu_expipe_req_branch_excpt_req_ready, 
  input wire  logic [I_ADDR_WIDTH-1:0]             ifu_expipe_req_branch_excpt_vaddr, 
  input wire  logic [1:0]                          ifu_expipe_req_priv, 
  input wire  logic                                ifu_expipe_req_flush,
   
  output      logic                                ifu_expipe_resp_valid,
  input wire  logic                                ifu_expipe_resp_ready,
  output      logic [31:0]                         ifu_expipe_resp_ireg,
  output      logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_ireg_vaddr,
  output      logic                                ifu_expipe_resp_ireg_vaddr_valid,
  output      logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_next_vaddr,
  output      logic                                ifu_expipe_resp_compressed,
  output      logic                                ifu_expipe_resp_access_fault,  
  output      logic                                ifu_expipe_resp_access_mem_error,
  output      logic                                ifu_expipe_resp_access_parity_error,
  output      logic                                ifu_expipe_resp_access_misalign_error,
  output      logic                                ifu_expipe_resp_access_aborted  
  );
   

  
//******************************************************************************
// Declarations


  typedef enum logic [1:0] {fetch_ptr_sel_reset,
                            fetch_ptr_sel_branch,
                            fetch_ptr_sel_incr4} t_fetch_ptr_sel;
                                                       
                            
  localparam IAB_BUFF_DEPTH       = 3;
  localparam LOG2_IAB_BUFF_DEPTH  = 2;  
  
  localparam MAX_IFU_EMI_OS       = 3;
  localparam LOG2_MAX_IFU_EMI_OS  = 2;
  
  localparam RESP_ERROR_WIDTH     = 2;  
  localparam IFU_MEM_ERROR_BIT    = 0;
  localparam IFU_PARITY_ERROR_BIT = 1;
  
  
  
  logic [3:0]                         bus_byte_parity;      
  logic                               ifu_emi_resp_parity_error;  
  
  t_iab_rd_alignment                  iab_rd_alignment;
  t_iab_rd_alignment                  last_iab_rd_alignment;
  t_iab_rd_alignment                  next_iab_rd_alignment;
  
  logic [I_ADDR_WIDTH-1:0]            iab_resp_addr;
  logic                               iab_resp_addr_valid;
  logic                               iab_resp_hword_high_only;  
  logic [31:0]                        iab_resp_data;
  logic [RESP_ERROR_WIDTH-1:0]        iab_resp_error;  
  logic [RESP_ERROR_WIDTH-1:0]        iab_alloc_error;
  
  logic                               emi_resp_head_compressed;                                     
  logic                               emi_resp_head_uncompressed_full;
  logic                               emi_resp_head_uncompressed_half;    
  logic                               iab_head_compressed;       
  logic                               iab_head_uncompressed_full;
  logic                               iab_head_uncompressed_half;                       

  t_fetch_ptr_sel                     fetch_ptr_sel; 
  logic [I_ADDR_WIDTH-1:0]            req_fetch_ptr;
  logic [I_ADDR_WIDTH-1:0]            next_req_fetch_ptr;
  logic                               next_req_fetch_ptr_valid;
  logic                               next_req_is_hword_high_only;  
  
  logic                               ifu_emi_req_accepted;
  logic                               ifu_emi_resp_accepted;
  
  logic                               emi_req_os;
  logic [LOG2_MAX_IFU_EMI_OS-1:0]     num_emi_req_os;
  logic                               req_flush;
  logic                               req_flush_branch;
  logic                               req_flush_pipe;  
  logic                               no_flush_req_os;
  logic                               iab_req_empty;
  logic                               iab_alloc_req;        
  logic                               iab_alloc_req_fence_i;
  logic                               iab_resp_alloc;  
  logic                               iab_resp_complete;      
  logic                               iab_resp_empty;  
  logic                               iab_ready;  
  
  logic [LOG2_IAB_BUFF_DEPTH-1:0]     buff_fill_level;  
  
  logic                               sticky_reset;
  logic                               sticky_reset_reg;   
  
  logic                               sticky_branch;
  logic                               sticky_branch_reg;
  
  logic                               fence_i_req;
  logic                               fence_i_hold;
  logic                               sticky_fence;
  logic                               sticky_fence_reg;
  logic                               branch_req_no_fence_i;
  logic                               branch_req_fence_i;
  

//******************************************************************************
// Main code


  assign ifu_expipe_req_branch_excpt_req_ready    = ((ifu_emi_req_ready & ifu_expipe_fetch_en) | ifu_expipe_req_branch_excpt_req_fenci) & iab_ready; 
  
  // compute bus parity. Instruction fetches are always 4-bytes
  
  assign bus_byte_parity  = {^ifu_emi_resp_data[31:24],
                             ^ifu_emi_resp_data[23:16],
                             ^ifu_emi_resp_data[15:8],
                             ^ifu_emi_resp_data[7:0]};
                             
  assign ifu_emi_resp_parity_error = ifu_emi_resp_valid & 
                            (bus_byte_parity != ifu_emi_resp_data_p) &
                            parity_en;
  
  

  

  // fetch pointer is the virtual address of the word currently being returned from memory
  // need to identify responses that are for a high halfword only (caused by a hword aligned branch target)  
  
  // To save area, the fetch_ptr holds the address of the outstanding request rather than the next request
  // (because need to return the address of the outstanding request later to the expipe)
  // After reset, need to ensure that the current fetch address (indicated buy next_fetch_ptr) is 
  // the reset vector, and not reset_vector+4,so need to make the reset sticky and force selection of
  // reset_vector. A branch cannot occur after reset because there should not be any valid instruction in the ex_retr stage
  // so ok to be lower priority.
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      sticky_reset_reg <= 1'b1;
    else
      sticky_reset_reg <= sticky_reset_reg  & ~ifu_emi_req_accepted;
  end
  
  assign sticky_reset = sticky_reset_reg; 
  
  // After a branch, need to ensure that the current fetch address (indicated buy next_fetch_ptr) is 
  // the branch target, and not branch target+4,so need to make the branch request sticky and force selection of
  // branch target. 
  // Also force the selection to be branch when flushing, since to resume after a flush a branch must always be taken
  // this prevents spurious fetches occuring after a flush that are then subsequently dropped.
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      sticky_branch_reg <= 1'b0;
    else
      sticky_branch_reg <= (sticky_branch_reg | branch_req_no_fence_i | ifu_expipe_req_flush) & ~(ifu_emi_req_accepted) ;
  end
  
  assign sticky_branch = sticky_branch_reg; 
  
  // If the branch is for a fence.i instruction (branches to the next instruction after the fence.i instruction in order to cause a pipeline/iab flush)
  // then need to wait until all memory accesses are complete before fetching by isuuing a FENCE operation and waiting for the response before issuing the fetch
  // The expipe will indicate the fence has completed and fetch request can proceed by asserting ifu_expipe_req_fenci_proceed
  // If a trap or reset occurs before the fence completes (can occur as the branch request is issued in the ex stage, and the instruction in retr may trap) then the
  // fence_i hold will be released immediately and piepline flushed as usual.
  
  assign fence_i_req            = ifu_expipe_req_branch_excpt_req_valid & ifu_expipe_req_branch_excpt_req_fenci;
  assign branch_req_no_fence_i  = ifu_expipe_req_branch_excpt_req_valid & ~ifu_expipe_req_branch_excpt_req_fenci;
  assign branch_req_fence_i     = ifu_expipe_req_branch_excpt_req_valid & ifu_expipe_req_branch_excpt_req_fenci;
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      fence_i_hold <= 1'b0;
    else
      fence_i_hold <= (fence_i_hold | fence_i_req) & ~(ifu_expipe_req_fenci_proceed | ifu_expipe_req_flush);
  end
  
  // first fetch after fence needs to use the full address to determine if the first fetch is high halfword only
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      sticky_fence_reg <= 1'b0;
    else
      sticky_fence_reg <= (sticky_fence_reg | branch_req_fence_i) & ~(ifu_emi_req_accepted | ifu_expipe_req_flush) ;
  end
  
  assign sticky_fence = sticky_fence_reg;
  


  assign ifu_emi_req_accepted = ifu_emi_req_ready & ifu_emi_req_valid; 
  assign fetch_ptr_sel = sticky_reset ? fetch_ptr_sel_reset :
                             ifu_expipe_req_branch_excpt_req_valid ? fetch_ptr_sel_branch : 
                                 sticky_branch ? fetch_ptr_sel_branch :                             
                                     fetch_ptr_sel_incr4;                                         
                            
  
  always @* 
  begin
    case(fetch_ptr_sel)
      fetch_ptr_sel_reset:  
      begin
        next_req_fetch_ptr          = l_core_reset_vector;
        next_req_fetch_ptr_valid    = 1'b1;
        next_req_is_hword_high_only = 1'b0;
      end
      
      fetch_ptr_sel_branch: 
      begin
        next_req_fetch_ptr          = ifu_expipe_req_branch_excpt_vaddr;
        next_req_fetch_ptr_valid    = ifu_expipe_req_branch_excpt_req_valid;
        next_req_is_hword_high_only = ifu_expipe_req_branch_excpt_vaddr[1];
      end
      
      fetch_ptr_sel_incr4:  
      begin
        next_req_fetch_ptr          = req_fetch_ptr + {{I_ADDR_WIDTH-3{1'b0}},3'd4};
        next_req_fetch_ptr_valid    = 1'b1;
        next_req_is_hword_high_only = sticky_fence ? req_fetch_ptr[1] : 1'b0;
      end
      
      default:              
      begin
        next_req_fetch_ptr          = l_core_reset_vector;
        next_req_fetch_ptr_valid    = 1'b0;
        next_req_is_hword_high_only = 1'b0;
      end
    endcase
  end
  
  // Can generate a request when there is space for any outstanding requests to be allocated
  // Use > rather than >= because if this cycle generates a request it is not yet accounted for
  //assign iab_ready = (IAB_BUFF_DEPTH - buff_fill_level) > num_emi_req_os;
  //assign iab_ready = (buff_fill_level <= (IAB_BUFF_DEPTH - 1));  // need space for any requests currently outstanding to the EMI 
  assign iab_ready = (buff_fill_level <= (IAB_BUFF_DEPTH - 1)) & (num_emi_req_os < MAX_IFU_EMI_OS);

  assign ifu_emi_req_valid      = ifu_expipe_fetch_en & iab_ready & next_req_fetch_ptr_valid  & ~(fence_i_hold | fence_i_req); 
  assign ifu_emi_req_addr       = {next_req_fetch_ptr[I_ADDR_WIDTH-1:2],2'b00}; //always word aligned
  assign ifu_emi_req_addr_p     = (^ifu_emi_req_addr) & parity_en;
  assign ifu_emi_req_rd_byte_en = {4{ifu_emi_req_valid}}; 
  
  assign ifu_emi_resp_ready                 = 1'b1; // When a request is made it will always be accepted
  
  assign emi_resp_head_compressed           = (iab_rd_alignment == iab_rd_alignment_hword) ? (ifu_emi_resp_data[17:16] != 2'b11) : 
                                                                                             (ifu_emi_resp_data[1:0] != 2'b11);  
  assign emi_resp_head_uncompressed_full    = (iab_rd_alignment == iab_rd_alignment_word) & (ifu_emi_resp_data[1:0] == 2'b11);
  assign emi_resp_head_uncompressed_half    = (iab_rd_alignment == iab_rd_alignment_hword) & (ifu_emi_resp_data[17:16] == 2'b11);
  
  // if a flush is required due to reset or branch/exception taken/reset taken, need to drop any outstanding requests
  // and make the next fetch request the reset vector or branch/exception target (this is currently done by forcing a branch 
  //to the trap/reset vector in the decode stage)
  // Since a request made could still be in flight, need to wait for the memory response, but not return it to the expipe
  // flush is not used to block requests in the current cycle since it may be generated late in the cycle, therefore if a 
  // a request is being made when flush is asserted, drop the associated response
  // 
  // Need to also drop any responses made by requests prior to the branch or reset but not yet allocated.
  // Note that core supports same cycle responses, as well as pipelined req-resp (though only one non-completing outstanding).
  // fence.i also requires instructions in the pipline to be flushed (as they could have been written)
  // this will be performed by executiong a branch to the next instruction following the fence.i so that the
  // same mechanism as a branch taken can be used.
  // iab will also drop spurious responses. These may occur after a reset; this prevents deadlock
  
  assign req_flush_branch = ifu_expipe_req_branch_excpt_req_valid; 
  assign req_flush_pipe   = ifu_expipe_req_flush; 
  assign req_flush        = req_flush_branch | req_flush_pipe;

  // Instruction alignment buffer holds responses from the EMI until they are accepted by the expipe.
  // The IAB also aligns compressed instructions and responses that span 2 fetches and compressed instructions
  
  assign ifu_emi_resp_accepted  = ifu_emi_resp_valid & ifu_emi_resp_ready;
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      last_iab_rd_alignment <= iab_rd_alignment_word;
    else
      if(req_flush)
        last_iab_rd_alignment <= next_req_fetch_ptr[1] ? iab_rd_alignment_hword : iab_rd_alignment_word;
      else if (ifu_expipe_resp_valid & ifu_expipe_resp_ready)
        last_iab_rd_alignment <= next_iab_rd_alignment;
  end
  
  assign iab_rd_alignment = iab_resp_hword_high_only ? iab_rd_alignment_hword : last_iab_rd_alignment;
  
  // if there is somesthing in the iab, the response must come from the iab (partially or fully)\
  // otherwise can come directly from the response.
  // For uncompressed requests that span word, the first part may come from the iab and the other from the response directly       
  // Seperate allocation controls from response controls to removing expipe ready timing path
  always @*
  begin
    case({ifu_emi_resp_accepted, ifu_expipe_resp_ready, iab_resp_empty})

      3'b000,3'b001 : // EMI no new response, expipe not ready
      begin
        iab_resp_alloc                        = 1'b0;
        iab_resp_complete                     = 1'b0; 
        next_iab_rd_alignment                 = iab_rd_alignment;      
      end
      
      3'b010 : // EMI no new response, expipe ready,    iab not empty (responses available in iab)
      begin
        iab_resp_alloc                        = 1'b0;
        iab_resp_complete                     = ~((iab_head_compressed & (iab_rd_alignment == iab_rd_alignment_word)) | 
                                                  iab_head_uncompressed_half);      
        next_iab_rd_alignment                 = iab_head_compressed ? ((iab_rd_alignment == iab_rd_alignment_word) ?  iab_rd_alignment_hword : 
                                                                                                                      iab_rd_alignment_word) : 
                                                                      iab_rd_alignment;       
      end
      
      3'b100,3'b101 : // EMI new response,    expipe not ready
      begin
        iab_resp_alloc                        = emi_req_os;  // Always allocated  if there is an expected emi resp outstanding (ie ignore spurious responses)
        iab_resp_complete                     = 1'b0;     
        next_iab_rd_alignment                 = iab_rd_alignment;
      end     
    
      3'b110 : // EMI new response,    expipe ready,    iab not empty (responses available in iab)
      begin
        iab_resp_alloc                        = emi_req_os;  // Always allocated  if there is an expected emi resp outstanding (ie ignore spurious responses)
        iab_resp_complete                     = ~(iab_head_compressed & (iab_rd_alignment == iab_rd_alignment_word));  
        next_iab_rd_alignment                 = iab_head_compressed ? ((iab_rd_alignment == iab_rd_alignment_word) ?  iab_rd_alignment_hword : 
                                                                                                                      iab_rd_alignment_word) : 
                                                                      iab_rd_alignment;      
      end      
      
      3'b111 : // EMI new response,    expipe ready,    iab empty (no responses available in iab)
      begin
        iab_resp_alloc                        = emi_req_os;  // Always allocated  if there is an expected emi resp outstanding (ie ignore spurious responses)
        iab_resp_complete                     = ~((emi_resp_head_compressed & (iab_rd_alignment == iab_rd_alignment_word)) | emi_resp_head_uncompressed_half);  
        next_iab_rd_alignment                 = emi_resp_head_compressed ? ((iab_rd_alignment == iab_rd_alignment_word) ?  iab_rd_alignment_hword : 
                                                                                                                           iab_rd_alignment_word) : 
                                                                           iab_rd_alignment; 
      end                                       
  
      default :
      begin
        iab_resp_alloc                        = 1'b0;
        iab_resp_complete                     = 1'b0;  
        next_iab_rd_alignment                 = iab_rd_alignment; 
      end
    endcase
  end
  
  always @*
  begin
    case({ifu_emi_resp_accepted, iab_resp_empty})

      
      2'b00 : // EMI no new response,   iab not empty (responses available in iab)
      begin
        ifu_expipe_resp_valid                 = (iab_head_compressed | iab_head_uncompressed_full) & no_flush_req_os & ~req_flush;
        ifu_expipe_resp_ireg                  = iab_resp_data;
        ifu_expipe_resp_compressed            = iab_head_compressed;
        ifu_expipe_resp_access_mem_error      = iab_resp_error[IFU_MEM_ERROR_BIT];
        ifu_expipe_resp_access_misalign_error = iab_resp_addr[0]; 
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = iab_resp_error[IFU_PARITY_ERROR_BIT];        
        ifu_expipe_resp_access_aborted        = 1'b0;
        
      end
     
    
      2'b10 : // EMI new response,      iab not empty (responses available in iab)
      begin   
        ifu_expipe_resp_valid                 = no_flush_req_os & ~req_flush;
        ifu_expipe_resp_ireg                  = iab_head_uncompressed_half ? {ifu_emi_resp_data[15:0],iab_resp_data[15:0]} : iab_resp_data;
        ifu_expipe_resp_compressed            = iab_head_compressed;
        ifu_expipe_resp_access_mem_error      = iab_head_uncompressed_half ? (ifu_emi_resp_error | iab_resp_error[IFU_MEM_ERROR_BIT]): iab_resp_error[IFU_MEM_ERROR_BIT];
        ifu_expipe_resp_access_misalign_error = iab_resp_addr[0]; 
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = iab_head_uncompressed_half ? (ifu_emi_resp_parity_error | iab_resp_error[IFU_PARITY_ERROR_BIT]): iab_resp_error[IFU_PARITY_ERROR_BIT];
        ifu_expipe_resp_access_aborted        = 1'b0;
      end      
      
      2'b11 : // EMI new response,      iab empty (no responses available in iab)
      begin 
        ifu_expipe_resp_valid                 = (emi_resp_head_compressed | emi_resp_head_uncompressed_full) & no_flush_req_os & ~req_flush;
        ifu_expipe_resp_ireg                  = emi_resp_head_uncompressed_full ? ifu_emi_resp_data :
                                                                                  iab_resp_hword_high_only ? {{16{1'b0}},ifu_emi_resp_data[31:16]} :
                                                                                                             {{16{1'b0}},ifu_emi_resp_data[15:0]};
        ifu_expipe_resp_compressed            = emi_resp_head_compressed;
        ifu_expipe_resp_access_mem_error      = ifu_emi_resp_error;
        ifu_expipe_resp_access_misalign_error = iab_resp_addr[0]; 
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = ifu_emi_resp_parity_error;
        ifu_expipe_resp_access_aborted        = 1'b0;
      end                                       
  
      default :
      begin
        ifu_expipe_resp_valid                 = 1'b0;
        ifu_expipe_resp_ireg                  = {32{1'b0}};
        ifu_expipe_resp_compressed            = 1'b0;
        ifu_expipe_resp_access_mem_error      = 1'b0;
        ifu_expipe_resp_access_misalign_error = 1'b0;
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = 1'b0;
        ifu_expipe_resp_access_aborted        = 1'b0;
      end
    endcase
  end
  
  assign ifu_expipe_resp_ireg_vaddr       = {iab_resp_addr[I_ADDR_WIDTH-1:2],(iab_rd_alignment == iab_rd_alignment_hword),iab_resp_addr[0]};
  assign ifu_expipe_resp_ireg_vaddr_valid = iab_resp_addr_valid;
  
  assign ifu_expipe_resp_next_vaddr       = (iab_req_empty | ifu_expipe_req_branch_excpt_req_valid)? next_req_fetch_ptr : 
                                                 {iab_resp_addr[I_ADDR_WIDTH-1:2],(iab_rd_alignment == iab_rd_alignment_hword),iab_resp_addr[0]};

  // allocate the branch request as part of fence.i to the aib 
  // before the request is accepted (unlike all other iab allocations which occur
  // when the emi accepts the request)
  // This then allows the request to be generated as an incremental request(fetch_ptr+4)
  assign iab_alloc_req         = ifu_emi_req_accepted | fence_i_req;
  assign iab_alloc_req_fence_i = fence_i_req;
  
  assign iab_alloc_error[IFU_MEM_ERROR_BIT]    = ifu_emi_resp_error;
  assign iab_alloc_error[IFU_PARITY_ERROR_BIT] = ifu_emi_resp_parity_error;
  
  miv_rv32_ifu_iab
  #(
 
    .I_ADDR_WIDTH                      (I_ADDR_WIDTH        ),
    .RESP_ERROR_WIDTH                  (RESP_ERROR_WIDTH    ),
    .BUFF_DEPTH                        (IAB_BUFF_DEPTH      ),
    .LOG2_BUFF_DEPTH                   (LOG2_IAB_BUFF_DEPTH ),
	.MI_I_MEM                          (MI_I_MEM)
  )
  u_miv_rv32_ifu_iab_0
  (
    .clk                               (clk                        ),   
    .resetn                            (resetn                     ),   
    .req_flush_branch                  (req_flush_branch           ),   
    .req_flush_pipe                    (req_flush_pipe             ),  
    .alloc_req                         (iab_alloc_req              ),   
    .alloc_req_fence_i                 (iab_alloc_req_fence_i      ), 
    .alloc_req_addr                    (next_req_fetch_ptr         ),   
    .alloc_req_hword_high              (next_req_is_hword_high_only),   
    .buff_curr_fetch_ptr               (req_fetch_ptr              ),   
    .alloc_resp                        (iab_resp_alloc             ),   
    .alloc_resp_data                   (ifu_emi_resp_data          ),   
    .alloc_resp_error                  (iab_alloc_error            ),   
    .resp_complete                     (iab_resp_complete          ),   
    .iab_rd_alignment                  (iab_rd_alignment           ),   
    .buff_resp_head_data               (iab_resp_data              ),   
    .buff_resp_head_error              (iab_resp_error             ),   
    .buff_resp_head_addr               (iab_resp_addr              ),   
    .buff_resp_head_addr_valid         (iab_resp_addr_valid        ), 
    .buff_resp_head_hword_high_only    (iab_resp_hword_high_only   ),   
    .buff_resp_head_compressed         (iab_head_compressed        ),   
    .buff_resp_head_uncompressed_full  (iab_head_uncompressed_full ),   
    .buff_resp_head_uncompressed_half  (iab_head_uncompressed_half ),   
    .buff_full                         (                           ), // open                            
    .buff_empty                        (iab_req_empty              ),                             
    .buff_resp_empty                   (iab_resp_empty             ),   
    .buff_fill_level                   (buff_fill_level            ),   
    .num_emi_req_os                    (num_emi_req_os             ),   
    .emi_req_os                        (emi_req_os                 ),
    .no_flush_req_os                   (no_flush_req_os            )    

  );
  
               

//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS


  // EMI request sequence correct
  
  // Expipe response sequence correct
  
  logic [I_ADDR_WIDTH-1:0]       prop_next_resp_addr;
  logic [I_ADDR_WIDTH-1:0]       prop_resp_addr;
  logic prop_expipe_resp_accept;
  logic prop_expipe_resp_compressed;
  logic prop_ifu_expipe_req_branch_excpt_req_accepted;
  
  assign prop_expipe_resp_accept      = ifu_expipe_resp_valid & ifu_expipe_resp_ready;
  assign prop_expipe_resp_compressed  = ifu_expipe_resp_compressed;
  assign prop_ifu_expipe_req_branch_excpt_req_accepted = ifu_expipe_req_branch_excpt_req_valid & ifu_expipe_req_branch_excpt_req_ready;
  
  always @*
  begin
    case({prop_ifu_expipe_req_branch_excpt_req_accepted, prop_expipe_resp_accept})   
      2'b00         : prop_next_resp_addr = prop_resp_addr;
      2'b01         : prop_next_resp_addr = prop_resp_addr + (prop_expipe_resp_compressed ? {{I_ADDR_WIDTH-3{1'd0}},3'd2} : {{I_ADDR_WIDTH-3{1'd0}},3'd4});
      2'b10,2'b11   : prop_next_resp_addr = ifu_expipe_req_branch_excpt_req_fenci ? (ifu_expipe_req_branch_excpt_vaddr + {{I_ADDR_WIDTH-3{1'd0}},3'd4}) : ifu_expipe_req_branch_excpt_vaddr ;
      default: prop_next_resp_addr = l_core_reset_vector;
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_resp_addr <= l_core_reset_vector;
    else
      prop_resp_addr <= prop_next_resp_addr;
  end
  
  assert_ifu_fetch_sequence: assert property (@(posedge clk) disable iff (~resetn)
                                                prop_expipe_resp_accept |-> (ifu_expipe_resp_ireg_vaddr == prop_resp_addr));
                                                
                                               
  
  // Data transport from EMI to expipe correct (not fabricated, dropped, duplicated, corrupted...)  
  // Simple end to end data check
  // For a selected non-deterministic location (instruction), pick a non-deterministic, stable value. When the location is returned to the expipe it should 
  // always be the expected instruction.
  
  logic                     nd_loc_compressed;
  logic [I_ADDR_WIDTH-1:0]  nd_loc_addr;
  logic [31:0]              nd_loc_instruction;
  
  assume_ifu_nd_loc_compressed_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                                     ##1 $stable(nd_loc_compressed));
                                                    
  assume_ifu_nd_loc_addr_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                               ##1 $stable(nd_loc_addr));  
                                               
  assume_ifu_nd_loc_instruction_compressed_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                                nd_loc_compressed |-> ##1 $stable(nd_loc_instruction[15:0]));                                                                                               
                                               
  assume_ifu_nd_loc_instruction_uncompressed_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                                  !nd_loc_compressed |-> ##1 $stable(nd_loc_instruction));    
                                                  
  assume_ifu_nd_loc_instruction_compressed_encoding : assume property (@(posedge clk) disable iff (~resetn)  
                                                    nd_loc_compressed |-> (nd_loc_instruction[1:0] != 2'b11));  
                                                    
  assume_ifu_nd_loc_instruction_uncompressed_encoding : assume property (@(posedge clk) disable iff (~resetn)  
                                                    !nd_loc_compressed |-> (nd_loc_instruction[1:0] == 2'b11));                                                                                                     
  
  // Need to know address associated with the response. All responses must be in order, so keep a list of requests made and re-associate with response when 
  // received.  
  
  logic [I_ADDR_WIDTH-1:0]  prop_emi_resp_addr;
  logic [I_ADDR_WIDTH-1:0]  nd_loc_addr_next;
  
  assign nd_loc_addr_next = nd_loc_addr + 32'd4;
  
  // store location of outstanding request
  // make this bigger if more outstanding
  
// logic [I_ADDR_WIDTH-1:0] prop_req_os_addr;
// 
// always @(posedge clk)
// begin
//   if(ifu_emi_req_valid & ifu_emi_req_ready)
//     prop_emi_resp_addr <= ifu_emi_req_addr;
// end
  
  
  
 miv_rv32_common_buffer_behav
 #(

   .BUFF_WIDTH                        (I_ADDR_WIDTH       ),
   .BUFF_SIZE                         (MAX_IFU_EMI_OS     ),
   .PTR_SIZE                          (LOG2_MAX_IFU_EMI_OS)
 )
 u_core_ifu_prop_emi_os_list_0
 (
   .clk                               (clk                                    ),
   .resetn                            (resetn                                 ),
   .valid_in                          (ifu_emi_req_valid & ifu_emi_req_ready  ),
   .ready_in                          (                                       ), //open
   .data_in                           (ifu_emi_req_addr                       ),
   .data_out                          (prop_emi_resp_addr                     ),
   .valid_out                         (                                       ), //open
   .ready_out                         (ifu_emi_resp_valid & ifu_emi_resp_ready)
 );
  
    // constrain ifu_emi_resp_data if the address contains the monitored location
    // note that a halfword aligned uncompressed instruction will span 2 fetches 

  assume_ifu_nd_loc_monitored_uncompressed_word_align : assume property (@(posedge clk) disable iff (~resetn)  
                                                    ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & !nd_loc_addr[1] & ifu_emi_resp_valid & !nd_loc_compressed) |-> 
                                                       (ifu_emi_resp_data == nd_loc_instruction));


  assume_ifu_nd_loc_monitored_uncompressed_hword_align_hi : assume property (@(posedge clk) disable iff (~resetn)  
                                                         ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & nd_loc_addr[1] & ifu_emi_resp_valid & !nd_loc_compressed) |->  
                                                            (ifu_emi_resp_data[31:16] == nd_loc_instruction[15:0]));   
                                                            
  assume_ifu_nd_loc_monitored_uncompressed_hword_align_lo : assume property (@(posedge clk) disable iff (~resetn)  
                                                         ((prop_emi_resp_addr[31:2] == nd_loc_addr_next[31:2]) & nd_loc_addr[1] & ifu_emi_resp_valid & !nd_loc_compressed) |->  
                                                            (ifu_emi_resp_data[15:0] == nd_loc_instruction[31:16]));  
                                                            
  assume_ifu_nd_loc_monitored_compressed_word_align : assume property (@(posedge clk) disable iff (~resetn)  
                                                    ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & !nd_loc_addr[1] & ifu_emi_resp_valid & nd_loc_compressed) |-> 
                                                       (ifu_emi_resp_data[15:0] == nd_loc_instruction[15:0]));  
                                                       
  assume_ifu_nd_loc_monitored_compressed_hword_align : assume property (@(posedge clk) disable iff (~resetn)  
                                                    ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & nd_loc_addr[1] & ifu_emi_resp_valid & nd_loc_compressed) |-> 
                                                       (ifu_emi_resp_data[31:16] == nd_loc_instruction[15:0]));
                                                       
                                                       

  assert_ifu_compressed_correct: assert property (@(posedge clk) disable iff (~resetn)  
                                                  ((ifu_expipe_resp_valid & ifu_expipe_resp_ready) & (ifu_expipe_resp_ireg_vaddr[31:1] == nd_loc_addr[31:1])) |->
                                                  (ifu_expipe_resp_compressed == nd_loc_compressed));                                                       
                                                       
  assert_ifu_instruction_correct_compressed: assert property (@(posedge clk) disable iff (~resetn)  
                                            ((ifu_expipe_resp_valid & ifu_expipe_resp_ready) & (ifu_expipe_resp_ireg_vaddr[31:1] == nd_loc_addr[31:1]) & nd_loc_compressed) |->
                                            (ifu_expipe_resp_ireg == {{16{1'b0}},  nd_loc_instruction[15:0]}));
                                            
  assert_ifu_instruction_correct_uncompressed: assert property (@(posedge clk) disable iff (~resetn)  
                                              ((ifu_expipe_resp_valid & ifu_expipe_resp_ready) & (ifu_expipe_resp_ireg_vaddr[31:1] == nd_loc_addr[31:1]) & !nd_loc_compressed) |->
                                              (ifu_expipe_resp_ireg == nd_loc_instruction));                                                                                                                                                                                                                                                                                                       
                                                  
  // if a request is made, the corresponding instruction(s) are returned to the expipe, unless flushed
  
  // Cannot have an entry completing if nothing valid returned (unless flushing)
  
  // Cannot have anything returned if there was not a request for that location
  
  assert_ifu_no_complete_without_valid: assert property (@(posedge clk) disable iff (~resetn)
                                                         (iab_resp_complete & ~(req_flush | ~no_flush_req_os)) |-> ifu_expipe_resp_valid & ifu_expipe_resp_ready);   
                                                           
  // after a fence.i hold, the next fetch accepted must be for pc+4 (incr)
  assert_ifu_post_fence_fetch_incr: assert property (@(posedge clk) disable iff (~resetn)  
                                                     $fell(fence_i_hold) & !$past(ifu_expipe_req_flush) |-> (fetch_ptr_sel == fetch_ptr_sel_incr4) & ifu_emi_req_valid);     
                                                     
  // when taking a fence branch, the request will always allocate to the iab straight away    
  assert_ifu_fence_alloc_iab: assert property (@(posedge clk) disable iff (~resetn)                                                                                              
                                               fence_i_req |-> iab_alloc_req);    
  
  // after a flush, a branch must always occur (note may be in debug mode so may be delayed until debug mode left)
  logic prop_pipe_flush_seen;
  logic prop_branch_req_accepted;
  
  assign prop_branch_req_accepted = ifu_expipe_req_branch_excpt_req_valid & ifu_emi_req_valid & ifu_emi_req_ready;
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_pipe_flush_seen <= 1'b0;
    else
      prop_pipe_flush_seen <= (prop_pipe_flush_seen & ~prop_branch_req_accepted) | ifu_expipe_req_flush;
  end
  
  assert_branch_must_follow_flush: assert property (@(posedge clk) disable iff (~resetn)                                                                                              
                                               prop_pipe_flush_seen |-> ##[1:$] prop_branch_req_accepted); 
                                              
  assert_can_always_fetch: assert property (@(posedge clk) disable iff (~resetn)  
                                                (ifu_emi_req_valid & ifu_emi_req_valid) |-> ##[1:$] (ifu_emi_req_valid & ifu_emi_req_valid));        
   //-------------                                                              
   // covers
   //------------

   // return any response   
   sequence seq_expipe_any_resp_consec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready)[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_resp_nonconsec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready)[->cycles] ;
   endsequence
   
   // return any compressed response
   sequence seq_expipe_any_compressed_consec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed)[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_compressed_nonconsec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed)[->cycles] ;
   endsequence
   
   // return any uncompressed response
   sequence seq_expipe_any_uncompressed_consec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed)[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_uncompressed_nonconsec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed)[->cycles] ;
   endsequence
   
   // return compressed (word aligned)
   sequence seq_expipe_any_compressed_consec_word_aligned;
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1]) ;
   endsequence
   
   sequence seq_expipe_any_compressed_nonconsec_word_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
   // return compressed (hword aligned)
   sequence seq_expipe_any_compressed_consec_hword_aligned;
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1]) ;
   endsequence
   
   sequence seq_expipe_any_compressed_nonconsec_hword_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
   // return uncompressed (word aligned)
   sequence seq_expipe_any_uncompressed_consec_word_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1])[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_uncompressed_nonconsec_word_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
   // return uncompressed (hword aligned)
   sequence seq_expipe_any_uncompressed_consec_hword_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1])[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_uncompressed_nonconsec_hword_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
  genvar i_cover_fetch_seq;
  generate
  for (i_cover_fetch_seq = 1; i_cover_fetch_seq <= 10; i_cover_fetch_seq++) begin : gen_cover_instr_seq
  
       cover_ifu_seq_expipe_any_resp_consec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_resp_consec(i_cover_fetch_seq));
  
       cover_ifu_seq_expipe_any_resp_nonconsec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_resp_nonconsec(i_cover_fetch_seq)); 

       cover_ifu_seq_expipe_any_compressed_consec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_consec(i_cover_fetch_seq));   
   
       cover_ifu_seq_expipe_any_compressed_nonconsec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_nonconsec(i_cover_fetch_seq));      

       cover_ifu_seq_expipe_any_uncompressed_consec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_consec(i_cover_fetch_seq)); 
   
       cover_ifu_seq_expipe_any_uncompressed_nonconsec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_nonconsec(i_cover_fetch_seq));    

       cover_ifu_seq_expipe_any_compressed_nonconsec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_nonconsec_word_aligned(i_cover_fetch_seq));  
   
       cover_ifu_seq_expipe_any_compressed_nonconsec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_nonconsec_hword_aligned(i_cover_fetch_seq));

       cover_ifu_seq_expipe_any_uncompressed_consec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_consec_word_aligned(i_cover_fetch_seq));
                                                                    
       cover_ifu_seq_expipe_any_uncompressed_nonconsec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_nonconsec_word_aligned(i_cover_fetch_seq)); 

       cover_ifu_seq_expipe_any_uncompressed_consec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_consec_hword_aligned(i_cover_fetch_seq)); 
   
       cover_ifu_seq_expipe_any_uncompressed_nonconsec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_nonconsec_hword_aligned(i_cover_fetch_seq)); 
   
  

  end
  endgenerate
  
  // cannot have sequences of back-to-back compressed words with the same alignement, so just cover single instance
  
  
  cover_ifu_seq_expipe_any_compressed_consec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_consec_word_aligned); 

  cover_ifu_seq_expipe_any_compressed_consec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_consec_hword_aligned);                                                                                 
                                        
`endif   

 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//#112763   Sept 20  KOH   rv32c_nop debug step fix to prevent forced nop on step, rv32c_dec_fence_i = 1'b1;
// Notes:
//
////////////////////////////////////////////////////////////////////////////////       
                                                                                         
////////////////////////////////////////////////////////////////////////////////         
//                                                                                       
//   File: miv_rv32_idecode.sv                                                        
//                                                                                       
//   Purpose: Core CPU instruction decode                                              
//   Auto-generated by Proteus Python generation tools                                           
//                                                                                       
//   Author:                                                                             
//                                                                                       
//   Version: 1.0                                                                        
//                                                                                       
////////////////////////////////////////////////////////////////////////////////         
                                                                                         
`default_nettype none                                                                    
                                                                                         
import miv_rv32_pkg::*; 
import miv_rv32_hart_cfg_pkg::*;
module miv_rv32_idecode
  //****************************************************************************         
  // Parameter description   
  #(
    parameter GEN_DECODE_RV32I          = 1,
    parameter GEN_DECODE_RV32M          = 1,
    parameter GEN_DECODE_RV32C          = 1,
    parameter GEN_DECODE_RV32F          = 1
   )                                                            
                                                                                         
                                                                                         
//******************************************************************************         
// Port Description                                                                      
   (                                                                                     
                                                                                         
   // clk/reset                                                                          
    input   wire logic                    clk,                          
    input   wire logic                    resetn,   
    input   wire logic                    core_reset, 
    input   wire logic                    trap_taken, 
    input   wire logic                    debug_exit, 
    input   wire logic                    vectored_interrupt_taken,
    
    
    input   wire logic                    cfg_hw_mul_en,    
    input   wire logic                    cfg_hw_div_en,    
    input   wire logic                    cfg_atomics_en,   
    input   wire logic                    cfg_compressed_en,
    input   wire logic                    cfg_float_en,
    
    output  logic                         idecode_ready, 
    
    input   wire logic                    debug_mode,
    input   wire logic [1:0]              priv_mode,                 
                                                    
    input   wire logic [31:0]             instruction,
    input   wire logic                    instruction_valid,
    input   wire logic                    instruction_compressed,
    
    output  t_mnemonic_list               mnemonic,
    output  logic[31:0]                   immediate,
    output  logic                         illegal_instr,
    output  logic                         m_env_call,
    output  logic                         m_ret,
    output  logic                         d_ret,
    output  logic                         dbreakpoint,
    output  logic                         gpr_wr_valid,
    output  logic[5:0]                    gpr_wr_sel,
    output  logic                         gpr_rs1_rd_valid,
    output  logic[5:0]                    gpr_rs1_rd_sel,
    output  logic                         gpr_rs2_rd_valid,
    output  logic[5:0]                    gpr_rs2_rd_sel,
    output  logic                         gpr_rs3_rd_valid,
    output  logic[5:0]                    gpr_rs3_rd_sel,
    output  t_gpr_wr_mux_sel              gpr_wr_mux_sel,
    output  logic[11:0]                   sw_csr_addr,
    output  t_csr_alu_wr_op_sel           sw_csr_wr_op,
    output  t_csr_alu_rd_op_sel           sw_csr_rd_op,
    output  t_exu_alu_operand0_sel        operand0_mux_sel,
    output  t_exu_alu_operand1_sel        operand1_mux_sel,
    output  t_exu_alu_op_sel              alu_op_sel,
    output  t_exu_shifter_operand_sel     shifter_operand_sel,
    output  t_exu_shifter_places_sel      shifter_unit_places,
    output  t_exu_shifter_op_sel          shifter_unit_op_sel,
    output  t_exu_bcu_operand0_sel        bcu_operand0_mux_sel,
    output  t_exu_bcu_operand1_sel        bcu_operand1_mux_sel,
    output  t_exu_bcu_op_sel              bcu_op_sel,
    output  t_exu_alu_result_mux_sel      exu_result_mux_sel,
    output  t_branch_cond                 branch_cond,
    output  logic                         fence_i,
    output  logic                         fence,
    output  t_lsu_op                      lsu_op,
    output  logic                         wfi,
    output  logic[2:0]                    fpu_frm,
	output  logic[1:0]                    fpu_fmt,
	output  logic                         fpu_instr
   );                                                                                    
                                                                     
//******************************************************************************         
// Declarations     
  logic[31:0] imm_dec_u;
  logic[31:0] imm_dec_i;
  logic[31:0] imm_dec_ishft;
  logic[31:0] imm_dec_istr;
  logic[31:0] imm_dec_j;
  logic[31:0] imm_dec_b;
  logic[31:0] imm_dec_uimm5;
  logic[31:0] imm_dec_cbi;
  logic[31:0] imm_dec_clo;
  logic[31:0] imm_dec_cso;
  logic[31:0] imm_dec_cii;
  logic[31:0] imm_dec_cjo;
  logic[31:0] imm_dec_ciisp16;
  logic[31:0] imm_dec_ciwisp4;
  logic[31:0] imm_dec_cbo;
  logic[31:0] imm_dec_cio;
  logic[31:0] imm_dec_csso;   
  
  logic[4:0] gpr_src_rs1_gpr_dec_i;  
  logic[4:0] gpr_src_rs1_gpr_dec_b;  
  logic[4:0] gpr_src_rs1_gpr_dec_s;  
  logic[4:0] gpr_src_rs1_gpr_dec_r;  
  logic[4:0] gpr_src_rs1_gpr_dec_r4;  
  logic[4:0] gpr_src_rs1_gpr_dec_lrsc;
  logic[4:0] gpr_src_rs1_gpr_dec_cl; 
  logic[4:0] gpr_src_rs1_gpr_dec_cs; 
  logic[4:0] gpr_src_rs1_gpr_dec_ci; 
  logic[4:0] gpr_src_rs1_gpr_dec_cb; 
  logic[4:0] gpr_src_rs1_gpr_dec_cr;   
  
  logic[4:0] gpr_src_rs2_gpr_dec_b;
  logic[4:0] gpr_src_rs2_gpr_dec_s;
  logic[4:0] gpr_src_rs2_gpr_dec_r;
  logic[4:0] gpr_src_rs2_gpr_dec_r4;
  logic[4:0] gpr_src_rs2_gpr_dec_lrsc;
  logic[4:0] gpr_src_rs2_gpr_dec_cs;
  logic[4:0] gpr_src_rs2_gpr_dec_cr;
  logic[4:0] gpr_src_rs2_gpr_dec_css;  
  
  logic[4:0] gpr_src_rs3_gpr_dec_r4;
  
  logic[4:0] gpr_dest_gpr_dec_u;   
  logic[4:0] gpr_dest_gpr_dec_i;   
  logic[4:0] gpr_dest_gpr_dec_r;   
  logic[4:0] gpr_dest_gpr_dec_r4;   
  logic[4:0] gpr_dest_gpr_dec_lrsc;
  logic[4:0] gpr_dest_gpr_dec_ciw; 
  logic[4:0] gpr_dest_gpr_dec_cl;  
  logic[4:0] gpr_dest_gpr_dec_ci;  
  logic[4:0] gpr_dest_gpr_dec_cs;  
  logic[4:0] gpr_dest_gpr_dec_cb; 
  
  logic [11:0] csr_src_csr_dec_i;       
  
  logic[2:0] rv32f_src_frm;   
  logic[2:0] rv32f_dec_frm;    
  logic[1:0] rv32f_dec_fmt;                                                                
                                                                                      
//******************************************************************************         
// Main code        

   // literals for immediate and register/csr src/dest definition
   
  assign imm_dec_u       = {instruction[31:12], {12{1'b0}}};  
  assign imm_dec_i       = {{20{instruction[31]}},instruction[31:20]};
  assign imm_dec_ishft   = {{27{1'b0}},instruction[24:20]}; 
  assign imm_dec_istr    = {{21{instruction[31]}},instruction[30:25],instruction[11:7]};
  assign imm_dec_j       = {{12{instruction[31]}}, instruction[19:12],instruction[20],instruction[30:21], 1'b0};
  assign imm_dec_b       = {{20{instruction[31]}},instruction[7],instruction[30:25],instruction[11:8],1'b0};
  assign imm_dec_uimm5   = {{27{1'b0}},instruction[19:15]};
  assign imm_dec_cbi     = {{27{instruction[12]}},instruction[6:2]};
  assign imm_dec_clo     = {{25{1'b0}},instruction[5],instruction[12:10],instruction[6],2'b00};
  assign imm_dec_cso     = {{25{1'b0}},instruction[5],instruction[12:10],instruction[6],2'b00};
  assign imm_dec_cii     = {{27{instruction[12]}},instruction[6:2]};
  assign imm_dec_cjo     = {{21{instruction[12]}},instruction[8],instruction[10:9],instruction[6],instruction[7],instruction[2],instruction[11],instruction[5:3],1'b0};
  assign imm_dec_ciisp16 = {{23{instruction[12]}}, instruction[4:3], instruction[5], instruction[2], instruction[6], 4'b0000};
  assign imm_dec_ciwisp4 = {{22{1'b0}},instruction[10:7], instruction[12:11], instruction[5], instruction[6], 2'b00};
  assign imm_dec_cbo     = {{24{instruction[12]}},instruction[6:5],instruction[2],instruction[11:10],instruction[4:3],1'b0};
  assign imm_dec_cio     = {{24{1'b0}},instruction[3:2],instruction[12],instruction[6:4],2'b00};
  assign imm_dec_csso    = {{24{1'b0}},instruction[8:7],instruction[12:9],2'b00};  
  
  assign gpr_src_rs1_gpr_dec_i    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_b    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_s    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_r    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_r4   = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_lrsc = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_cl   = {2'b01,instruction[7+:3]};
  assign gpr_src_rs1_gpr_dec_cs   = {2'b01,instruction[7+:3]};
  assign gpr_src_rs1_gpr_dec_ci   = instruction[7+:5];
  assign gpr_src_rs1_gpr_dec_cb   = {2'b01,instruction[7+:3]};
  assign gpr_src_rs1_gpr_dec_cr   = instruction[7+:5];
  
  assign gpr_src_rs2_gpr_dec_b    = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_s    = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_r    = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_r4   = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_lrsc = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_cs   = {2'b01,instruction[2+:3]};
  assign gpr_src_rs2_gpr_dec_cr   = instruction[2+:5];
  assign gpr_src_rs2_gpr_dec_css  = instruction[2+:5];
  
  assign gpr_src_rs3_gpr_dec_r4   = instruction[27+:5];
  
  assign gpr_dest_gpr_dec_u     = instruction[7+:5];
  assign gpr_dest_gpr_dec_i     = instruction[7+:5];
  assign gpr_dest_gpr_dec_r     = instruction[7+:5];
  assign gpr_dest_gpr_dec_r4    = instruction[7+:5];
  assign gpr_dest_gpr_dec_lrsc  = instruction[7+:5];
  assign gpr_dest_gpr_dec_ciw   = {2'b01,instruction[2+:3]};
  assign gpr_dest_gpr_dec_cl    = {2'b01,instruction[2+:3]};
  assign gpr_dest_gpr_dec_ci    = instruction[7+:5];
  assign gpr_dest_gpr_dec_cs    = {2'b01,instruction[7+:3]};
  assign gpr_dest_gpr_dec_cb    = {2'b01,instruction[7+:3]};
  
  assign csr_src_csr_dec_i      = instruction[20+:12];
  
  assign rv32f_src_frm          = instruction[12+:3];
  
  // decoder always able to accept an instruction in core
  assign idecode_ready = 1'b1;
                              
  t_mnemonic_list                         rv32i_dec_mnemonic;
  t_mnemonic_list                         rv32m_dec_mnemonic;
  t_mnemonic_list                         rv32c_dec_mnemonic;
  t_mnemonic_list                         rv32f_dec_mnemonic;
  t_mnemonic_list                         case_dec_mnemonic;
  logic[31:0]                         rv32i_dec_immediate;
  logic[31:0]                         rv32m_dec_immediate;
  logic[31:0]                         rv32c_dec_immediate;
  logic[31:0]                         rv32f_dec_immediate;
  logic[31:0]                         case_dec_immediate;
  logic                         rv32i_dec_illegal_instr;
  logic                         rv32m_dec_illegal_instr;
  logic                         rv32c_dec_illegal_instr;
  logic                         rv32f_dec_illegal_instr;
  logic                         case_dec_illegal_instr;
  logic                         rv32i_dec_m_env_call;
  logic                         rv32m_dec_m_env_call;
  logic                         rv32c_dec_m_env_call;
  logic                         rv32f_dec_m_env_call;
  logic                         case_dec_m_env_call;
  logic                         rv32i_dec_m_ret;
  logic                         rv32m_dec_m_ret;
  logic                         rv32c_dec_m_ret;
  logic                         rv32f_dec_m_ret;
  logic                         case_dec_m_ret;
  logic                         rv32i_dec_d_ret;
  logic                         rv32m_dec_d_ret;
  logic                         rv32c_dec_d_ret;
  logic                         rv32f_dec_d_ret;
  logic                         case_dec_d_ret;
  logic                         rv32i_dec_dbreakpoint;
  logic                         rv32m_dec_dbreakpoint;
  logic                         rv32c_dec_dbreakpoint;
  logic                         rv32f_dec_dbreakpoint;
  logic                         case_dec_dbreakpoint;
  logic                         rv32i_dec_gpr_wr_valid;
  logic                         rv32m_dec_gpr_wr_valid;
  logic                         rv32c_dec_gpr_wr_valid;
  logic                         rv32f_dec_gpr_wr_valid;
  logic                         case_dec_gpr_wr_valid;
  logic[4:0]                         rv32i_dec_gpr_wr_sel;
  logic[4:0]                         rv32m_dec_gpr_wr_sel;
  logic[4:0]                         rv32c_dec_gpr_wr_sel;
  logic[4:0]                         rv32f_dec_gpr_wr_sel;
  logic                              rv32c_dec_fgpr_wr_sel;
  logic                              rv32f_dec_fgpr_wr_sel;
  logic[5:0]                         case_dec_gpr_wr_sel;
  logic                         rv32i_dec_gpr_rs1_rd_valid;
  logic                         rv32m_dec_gpr_rs1_rd_valid;
  logic                         rv32c_dec_gpr_rs1_rd_valid;
  logic                         rv32f_dec_gpr_rs1_rd_valid;
  logic                         case_dec_gpr_rs1_rd_valid;
  logic[4:0]                         rv32i_dec_gpr_rs1_rd_sel;
  logic[4:0]                         rv32m_dec_gpr_rs1_rd_sel;
  logic[4:0]                         rv32c_dec_gpr_rs1_rd_sel;
  logic[4:0]                         rv32f_dec_gpr_rs1_rd_sel;
  logic                              rv32c_dec_fgpr_rs1_rd_sel;
  logic                              rv32f_dec_fgpr_rs1_rd_sel;
  logic[5:0]                         case_dec_gpr_rs1_rd_sel;
  logic                         rv32i_dec_gpr_rs2_rd_valid;
  logic                         rv32m_dec_gpr_rs2_rd_valid;
  logic                         rv32c_dec_gpr_rs2_rd_valid;
  logic                         rv32f_dec_gpr_rs2_rd_valid;
  logic                         case_dec_gpr_rs2_rd_valid; 
  logic                             rv32f_dec_gpr_rs3_rd_valid;
  logic                             case_dec_gpr_rs3_rd_valid;
  logic[4:0]                             rv32i_dec_gpr_rs2_rd_sel;
  logic[4:0]                             rv32m_dec_gpr_rs2_rd_sel;
  logic[4:0]                             rv32c_dec_gpr_rs2_rd_sel;
  logic[4:0]                             rv32f_dec_gpr_rs2_rd_sel;
  logic                                  rv32c_dec_fgpr_rs2_rd_sel;
  logic                                  rv32f_dec_fgpr_rs2_rd_sel;
  logic[5:0]                             case_dec_gpr_rs2_rd_sel; 
  logic[4:0]                        rv32f_dec_gpr_rs3_rd_sel;
  logic                             rv32f_dec_fgpr_rs3_rd_sel;
  logic[5:0]                        case_dec_gpr_rs3_rd_sel;
  t_gpr_wr_mux_sel                         rv32i_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         rv32m_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         rv32c_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         rv32f_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         case_dec_gpr_wr_mux_sel;
  logic[11:0]                         rv32i_dec_sw_csr_addr;
  logic[11:0]                         rv32m_dec_sw_csr_addr;
  logic[11:0]                         rv32c_dec_sw_csr_addr;
  logic[11:0]                         rv32f_dec_sw_csr_addr;
  logic[11:0]                         case_dec_sw_csr_addr;
  t_csr_alu_wr_op_sel                         rv32i_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         rv32m_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         rv32c_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         rv32f_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         case_dec_sw_csr_wr_op;
  t_csr_alu_rd_op_sel                         rv32i_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         rv32m_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         rv32c_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         rv32f_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         case_dec_sw_csr_rd_op;
  t_exu_alu_operand0_sel                         rv32i_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         rv32m_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         rv32c_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         rv32f_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         case_dec_operand0_mux_sel;
  t_exu_alu_operand1_sel                         rv32i_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         rv32m_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         rv32c_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         rv32f_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         case_dec_operand1_mux_sel;
  t_exu_alu_operand2_sel                         rv32f_dec_operand2_mux_sel;
  t_exu_alu_operand2_sel                         case_dec_operand2_mux_sel;
  t_exu_alu_op_sel                         rv32i_dec_alu_op_sel;
  t_exu_alu_op_sel                         rv32m_dec_alu_op_sel;
  t_exu_alu_op_sel                         rv32c_dec_alu_op_sel;
  t_exu_alu_op_sel                         rv32f_dec_alu_op_sel;
  t_exu_alu_op_sel                         case_dec_alu_op_sel;
  t_exu_shifter_operand_sel                         rv32i_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         rv32m_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         rv32c_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         rv32f_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         case_dec_shifter_operand_sel;
  t_exu_shifter_places_sel                         rv32i_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         rv32m_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         rv32c_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         rv32f_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         case_dec_shifter_unit_places;
  t_exu_shifter_op_sel                         rv32i_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         rv32m_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         rv32c_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         rv32f_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         case_dec_shifter_unit_op_sel;
  t_exu_bcu_operand0_sel                         rv32i_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         rv32m_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         rv32c_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         rv32f_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         case_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand1_sel                         rv32i_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         rv32m_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         rv32c_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         rv32f_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         case_dec_bcu_operand1_mux_sel;
  t_exu_bcu_op_sel                         rv32i_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         rv32m_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         rv32c_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         rv32f_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         case_dec_bcu_op_sel;
  t_exu_alu_result_mux_sel                         rv32i_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         rv32m_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         rv32c_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         rv32f_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         case_dec_exu_result_mux_sel;
  t_branch_cond                         rv32i_dec_branch_cond;
  t_branch_cond                         rv32m_dec_branch_cond;
  t_branch_cond                         rv32c_dec_branch_cond;
  t_branch_cond                         rv32f_dec_branch_cond;
  t_branch_cond                         case_dec_branch_cond;
  logic                         rv32i_dec_fence_i;
  logic                         rv32m_dec_fence_i;
  logic                         rv32c_dec_fence_i;
  logic                         rv32f_dec_fence_i;
  logic                         case_dec_fence_i;
  logic                         rv32i_dec_fence;
  logic                         rv32m_dec_fence;
  logic                         rv32c_dec_fence;
  logic                         rv32f_dec_fence;
  logic                         case_dec_fence;
  t_lsu_op                         rv32i_dec_lsu_op;
  t_lsu_op                         rv32m_dec_lsu_op;
  t_lsu_op                         rv32c_dec_lsu_op;
  t_lsu_op                         rv32f_dec_lsu_op;
  t_lsu_op                         case_dec_lsu_op;
  logic                         rv32i_dec_wfi;
  logic                         rv32m_dec_wfi;
  logic                         rv32c_dec_wfi;
  logic                         rv32f_dec_wfi;
  logic                         case_dec_wfi;
  logic                         rv32i_instr_decoded;
  logic                         rv32m_instr_decoded;
  logic                         rv32c_instr_decoded;
  logic                         rv32f_instr_decoded;
  logic[2:0]                        case_dec_frm;
  logic                             case_f_instr;
  logic[1:0]                        case_dec_fmt;
  
generate if(GEN_DECODE_RV32I)
begin : gen_decode_rv32i
  always @*
  begin

    // assign defaults

    rv32i_dec_mnemonic = rv32_default;
    rv32i_dec_immediate = 32'd0;
    rv32i_dec_illegal_instr = 1'b1;
    rv32i_dec_m_env_call = 1'b0;
    rv32i_dec_m_ret = 1'b0;
    rv32i_dec_d_ret = 1'b0;
    rv32i_dec_dbreakpoint = 1'b0;
    rv32i_dec_gpr_wr_valid = 1'b0;
    rv32i_dec_gpr_wr_sel = 5'd0;
    rv32i_dec_gpr_rs1_rd_valid = 1'b0;
    rv32i_dec_gpr_rs1_rd_sel = 5'd0;
    rv32i_dec_gpr_rs2_rd_valid = 1'b0;
    rv32i_dec_gpr_rs2_rd_sel = 5'd0;
    rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32i_dec_sw_csr_addr = 12'd0;
    rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32i_dec_operand0_mux_sel = exu_op0_rs1;
    rv32i_dec_operand1_mux_sel = exu_op1_rs2;
    rv32i_dec_alu_op_sel = exu_alu_op_none;
    rv32i_dec_shifter_operand_sel = shifter_operand_none;
    rv32i_dec_shifter_unit_places = shifter_places_operand_none;
    rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32i_dec_bcu_op_sel = bcu_op_none;
    rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32i_dec_branch_cond = branch_cond_none;
    rv32i_dec_fence_i = 1'b0;
    rv32i_dec_fence = 1'b0;
    rv32i_dec_lsu_op = lsu_op_none;
    rv32i_dec_wfi = 1'b0;
    rv32i_instr_decoded = 1'b0;

    unique casez(instruction)
      32'b?????????????????????????0110111:
      begin
        rv32i_dec_mnemonic = rv32i_lui;
        rv32i_dec_immediate = imm_dec_u;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_u;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????????????0010111:
      begin
        rv32i_dec_mnemonic = rv32i_auipc;
        rv32i_dec_immediate = imm_dec_u;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_u;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_pc;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????????????1101111:
      begin
        rv32i_dec_mnemonic = rv32i_jal;
        rv32i_dec_immediate = imm_dec_j;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_pc;
        rv32i_dec_operand1_mux_sel = exu_op1_lit4;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????1100111:
      begin
        rv32i_dec_mnemonic = rv32i_jalr;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_pc;
        rv32i_dec_operand1_mux_sel = exu_op1_lit4;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_beq;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_equal_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bne;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_not_equal_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????100?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_blt;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????101?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bge;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_gte_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????110?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bltu;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????111?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bgeu;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_gte_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lb;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_byte_s;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lh;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_hword_s;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lw;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_word;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????100?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lbu;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_byte_u;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????101?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lhu;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_hword_u;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????0100011:
      begin
        rv32i_dec_mnemonic = rv32i_sb;
        rv32i_dec_immediate = imm_dec_istr;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32i_dec_shifter_unit_places = shifter_places_operand_addr_byte;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_str_byte;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????0100011:
      begin
        rv32i_dec_mnemonic = rv32i_sh;
        rv32i_dec_immediate = imm_dec_istr;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32i_dec_shifter_unit_places = shifter_places_operand_addr_hword;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_str_hword;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????0100011:
      begin
        rv32i_dec_mnemonic = rv32i_sw;
        rv32i_dec_immediate = imm_dec_istr;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32i_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_str_word;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_addi;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_slti;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????011?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_sltiu;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????100?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_xori;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_xor_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????110?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_ori;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????111?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_andi;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????001?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_slli;
        rv32i_dec_immediate = imm_dec_ishft;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_imm;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????101?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_srli;
        rv32i_dec_immediate = imm_dec_ishft;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_imm;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0100000??????????101?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_srai;
        rv32i_dec_immediate = imm_dec_ishft;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_imm;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_arithmetic_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????000?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_add;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0100000??????????000?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sub;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_sub_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????001?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sll;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_rs2;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????010?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_slt;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????011?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sltu;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????100?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_xor;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_xor_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????101?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_srl;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_rs2;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0100000??????????101?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sra;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_rs2;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_arithmetic_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????110?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_or;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????111?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_and;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000????????00000000000000001111:
      begin
        rv32i_dec_mnemonic = rv32i_fence;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b1;
        rv32i_dec_lsu_op = lsu_op_fence;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00000000000000000001000000001111:
      begin
        rv32i_dec_mnemonic = rv32i_fence_i;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b1;
        rv32i_dec_fence = 1'b1;
        rv32i_dec_lsu_op = lsu_op_fence;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrw;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = gpr_dest_gpr_dec_i != 5'd0;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_swap;
        rv32i_dec_sw_csr_rd_op = (gpr_dest_gpr_dec_i != 5'd0) ? csr_alu_rd_op_rd : csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrs;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (gpr_src_rs1_gpr_dec_i != 5'd0) ? csr_alu_wr_op_set : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????011?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrc;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (gpr_src_rs1_gpr_dec_i != 5'd0) ? csr_alu_wr_op_clr : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????101?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrwi;
        rv32i_dec_immediate = imm_dec_uimm5;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = gpr_dest_gpr_dec_i != 5'd0;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_swap;
        rv32i_dec_sw_csr_rd_op = (gpr_dest_gpr_dec_i != 5'd0) ? csr_alu_rd_op_rd  : csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????110?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrsi;
        rv32i_dec_immediate = imm_dec_uimm5;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (imm_dec_uimm5 != 32'd0) ? csr_alu_wr_op_set : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????111?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrci;
        rv32i_dec_immediate = imm_dec_uimm5;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (imm_dec_uimm5 != 32'd0) ? csr_alu_wr_op_clr : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00000000000000000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_ecall;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b1;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00000000000100000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_ebreak;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b1;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b01111011001000000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_dret;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = ~debug_mode;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b1;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_dpc;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00110000001000000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_mret;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b1;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_epc;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00010000010100000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_wfi;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b1;
        rv32i_instr_decoded = 1'b1;
      end
      default :
      begin
      end
    endcase
  end

end
else begin : ngen_decode_rv32i

  assign rv32i_dec_mnemonic = rv32_default;
  assign rv32i_dec_immediate = 32'd0;
  assign rv32i_dec_illegal_instr = 1'b1;
  assign rv32i_dec_m_env_call = 1'b0;
  assign rv32i_dec_m_ret = 1'b0;
  assign rv32i_dec_d_ret = 1'b0;
  assign rv32i_dec_dbreakpoint = 1'b0;
  assign rv32i_dec_gpr_wr_valid = 1'b0;
  assign rv32i_dec_gpr_wr_sel = 5'd0;
  assign rv32i_dec_gpr_rs1_rd_valid = 1'b0;
  assign rv32i_dec_gpr_rs1_rd_sel = 5'd0;
  assign rv32i_dec_gpr_rs2_rd_valid = 1'b0;
  assign rv32i_dec_gpr_rs2_rd_sel = 5'd0;
  assign rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
  assign rv32i_dec_sw_csr_addr = 12'd0;
  assign rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
  assign rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
  assign rv32i_dec_operand0_mux_sel = exu_op0_rs1;
  assign rv32i_dec_operand1_mux_sel = exu_op1_rs2;
  assign rv32i_dec_alu_op_sel = exu_alu_op_none;
  assign rv32i_dec_shifter_operand_sel = shifter_operand_none;
  assign rv32i_dec_shifter_unit_places = shifter_places_operand_none;
  assign rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
  assign rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
  assign rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
  assign rv32i_dec_bcu_op_sel = bcu_op_none;
  assign rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
  assign rv32i_dec_branch_cond = branch_cond_none;
  assign rv32i_dec_fence_i = 1'b0;
  assign rv32i_dec_fence = 1'b0;
  assign rv32i_dec_lsu_op = lsu_op_none;
  assign rv32i_dec_wfi = 1'b0;
  assign rv32i_instr_decoded = 1'b0;

end
endgenerate
generate if(GEN_DECODE_RV32M)
begin : gen_decode_rv32m
  always @*
  begin

    // assign defaults

    rv32m_dec_mnemonic = rv32_default;
    rv32m_dec_immediate = 32'd0;
    rv32m_dec_illegal_instr = 1'b1;
    rv32m_dec_m_env_call = 1'b0;
    rv32m_dec_m_ret = 1'b0;
    rv32m_dec_d_ret = 1'b0;
    rv32m_dec_dbreakpoint = 1'b0;
    rv32m_dec_gpr_wr_valid = 1'b0;
    rv32m_dec_gpr_wr_sel = 5'd0;
    rv32m_dec_gpr_rs1_rd_valid = 1'b0;
    rv32m_dec_gpr_rs1_rd_sel = 5'd0;
    rv32m_dec_gpr_rs2_rd_valid = 1'b0;
    rv32m_dec_gpr_rs2_rd_sel = 5'd0;
    rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32m_dec_sw_csr_addr = 12'd0;
    rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32m_dec_operand0_mux_sel = exu_op0_rs1;
    rv32m_dec_operand1_mux_sel = exu_op1_rs2;
    rv32m_dec_alu_op_sel = exu_alu_op_none;
    rv32m_dec_shifter_operand_sel = shifter_operand_none;
    rv32m_dec_shifter_unit_places = shifter_places_operand_none;
    rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32m_dec_bcu_op_sel = bcu_op_none;
    rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32m_dec_branch_cond = branch_cond_none;
    rv32m_dec_fence_i = 1'b0;
    rv32m_dec_fence = 1'b0;
    rv32m_dec_lsu_op = lsu_op_none;
    rv32m_dec_wfi = 1'b0;
    rv32m_instr_decoded = 1'b0;

    unique casez(instruction)
      32'b0000001??????????000?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mul;                               
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????001?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mulh;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_high_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????010?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mulhsu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_high_signed_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????011?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mulhu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_high_unsigned_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????100?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_div;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_divide_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????101?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_divu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_divide_unsigned_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????110?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_rem;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_remainder_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????111?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_remu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_remainder_unsigned_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      default :
      begin
      end
    endcase
  end

end
else begin : ngen_decode_rv32m

  assign rv32m_dec_mnemonic = rv32_default;
  assign rv32m_dec_immediate = 32'd0;
  assign rv32m_dec_illegal_instr = 1'b1;
  assign rv32m_dec_m_env_call = 1'b0;
  assign rv32m_dec_m_ret = 1'b0;
  assign rv32m_dec_d_ret = 1'b0;
  assign rv32m_dec_dbreakpoint = 1'b0;
  assign rv32m_dec_gpr_wr_valid = 1'b0;
  assign rv32m_dec_gpr_wr_sel = 5'd0;
  assign rv32m_dec_gpr_rs1_rd_valid = 1'b0;
  assign rv32m_dec_gpr_rs1_rd_sel = 5'd0;
  assign rv32m_dec_gpr_rs2_rd_valid = 1'b0;
  assign rv32m_dec_gpr_rs2_rd_sel = 5'd0;
  assign rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
  assign rv32m_dec_sw_csr_addr = 12'd0;
  assign rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
  assign rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
  assign rv32m_dec_operand0_mux_sel = exu_op0_rs1;
  assign rv32m_dec_operand1_mux_sel = exu_op1_rs2;
  assign rv32m_dec_alu_op_sel = exu_alu_op_none;
  assign rv32m_dec_shifter_operand_sel = shifter_operand_none;
  assign rv32m_dec_shifter_unit_places = shifter_places_operand_none;
  assign rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
  assign rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
  assign rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
  assign rv32m_dec_bcu_op_sel = bcu_op_none;
  assign rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_none;
  assign rv32m_dec_branch_cond = branch_cond_none;
  assign rv32m_dec_fence_i = 1'b0;
  assign rv32m_dec_fence = 1'b0;
  assign rv32m_dec_lsu_op = lsu_op_none;
  assign rv32m_dec_wfi = 1'b0;
  assign rv32m_instr_decoded = 1'b0;

end
endgenerate
generate if(GEN_DECODE_RV32C)
begin : gen_decode_rv32c
  always @*
  begin

    // assign defaults

    rv32c_dec_mnemonic = rv32_default;
    rv32c_dec_immediate = 32'd0;
    rv32c_dec_illegal_instr = 1'b1;
    rv32c_dec_m_env_call = 1'b0;
    rv32c_dec_m_ret = 1'b0;
    rv32c_dec_d_ret = 1'b0;
    rv32c_dec_dbreakpoint = 1'b0;
    rv32c_dec_gpr_wr_valid = 1'b0;
    rv32c_dec_gpr_wr_sel = 5'd0;
    rv32c_dec_gpr_rs1_rd_valid = 1'b0;
    rv32c_dec_gpr_rs1_rd_sel = 5'd0;
    rv32c_dec_gpr_rs2_rd_valid = 1'b0;
    rv32c_dec_gpr_rs2_rd_sel = 5'd0;
    rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32c_dec_sw_csr_addr = 12'd0;
    rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32c_dec_operand0_mux_sel = exu_op0_rs1;
    rv32c_dec_operand1_mux_sel = exu_op1_rs2;
    rv32c_dec_alu_op_sel = exu_alu_op_none;
    rv32c_dec_shifter_operand_sel = shifter_operand_none;
    rv32c_dec_shifter_unit_places = shifter_places_operand_none;
    rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32c_dec_bcu_op_sel = bcu_op_none;
    rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32c_dec_branch_cond = branch_cond_none;
    rv32c_dec_fence_i = 1'b0;
    rv32c_dec_fence = 1'b0;
    rv32c_dec_lsu_op = lsu_op_none;
    rv32c_dec_wfi = 1'b0;
    rv32c_instr_decoded = 1'b0;
    rv32c_dec_fgpr_wr_sel = 1'b0;                       
    rv32c_dec_fgpr_rs1_rd_sel = 1'b0;                    
    rv32c_dec_fgpr_rs2_rd_sel = 1'b0;    

    unique casez(instruction)
      32'b????????????????000???????????00:
      begin
        if(((imm_dec_ciwisp4 == 32'd0) && (gpr_dest_gpr_dec_ciw == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_illegal0;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = 1'b1;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b0;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((imm_dec_ciwisp4 != 32'd0))
        begin
          rv32c_dec_mnemonic = rv32c_addi4spn;
          rv32c_dec_immediate = imm_dec_ciwisp4;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ciw;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd2;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????010???????????00:
      begin
        rv32c_dec_mnemonic = rv32c_lw;
        rv32c_dec_immediate = imm_dec_clo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cl;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cl;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_ld_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????110???????????00:
      begin
        rv32c_dec_mnemonic = rv32c_sw;
        rv32c_dec_immediate = imm_dec_cso;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32c_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_str_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????000???????????01:
      begin
        if(((gpr_dest_gpr_dec_ci) != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_addi;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_ci;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if(((gpr_dest_gpr_dec_ci) == 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_nop;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b1; //c.nop debug step fix SAR#112763
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????001???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_jal;
        rv32c_dec_immediate = imm_dec_cjo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = 5'd1;
        rv32c_dec_gpr_rs1_rd_valid = 1'b0;
        rv32c_dec_gpr_rs1_rd_sel = 5'd0;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_pc;
        rv32c_dec_operand1_mux_sel = exu_op1_lit2;
        rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_always;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????010???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_li;
        rv32c_dec_immediate = imm_dec_cii;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = 5'd0;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????011???????????01:
      begin
        if((gpr_dest_gpr_dec_ci == 5'd2) && (imm_dec_ciisp16 != 32'd0))
        begin
          rv32c_dec_mnemonic = rv32c_addi16sp;
          rv32c_dec_immediate = imm_dec_ciisp16;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = 5'd2;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd2;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((gpr_dest_gpr_dec_ci != 5'd2)  && (imm_dec_cii != 32'd0))
        begin
          rv32c_dec_mnemonic = rv32c_lui;
          rv32c_dec_immediate = {imm_dec_cii[0+:20],{12{1'b0}}};
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????100000????????01:
      begin
        if((!instruction[12]))
        begin
          rv32c_dec_mnemonic = rv32c_srli;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cb;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_rs1;
          rv32c_dec_shifter_unit_places = shifter_places_operand_imm;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_right;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????100001????????01:
      begin
        if((!instruction[12]))
        begin
          rv32c_dec_mnemonic = rv32c_srai;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cb;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_rs1;
          rv32c_dec_shifter_unit_places = shifter_places_operand_imm;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_arithmetic_shift_right;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????100?10????????01:
      begin
        rv32c_dec_mnemonic = rv32c_andi;
        rv32c_dec_immediate = imm_dec_cbi;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cb;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???00???01:
      begin
        rv32c_dec_mnemonic = rv32c_sub;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_sub_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???01???01:
      begin
        rv32c_dec_mnemonic = rv32c_xor;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_xor_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???10???01:
      begin
        rv32c_dec_mnemonic = rv32c_or;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???11???01:
      begin
        rv32c_dec_mnemonic = rv32c_and;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????101???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_j;
        rv32c_dec_immediate = imm_dec_cjo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b0;
        rv32c_dec_gpr_rs1_rd_sel = 5'd0;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_pc;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_always;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????110???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_beqz;
        rv32c_dec_immediate = imm_dec_cbo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_cmp_op_compare_equal_signed_op0_signed_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_compare_true;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????111???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_bnez;
        rv32c_dec_immediate = imm_dec_cbo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_cmp_op_compare_not_equal_signed_op0_signed_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_compare_true;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????000???????????10:
      begin
        if((!instruction[12]))
        begin
          rv32c_dec_mnemonic = rv32c_slli;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_ci;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_rs1;
          rv32c_dec_shifter_unit_places = shifter_places_operand_imm;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????010???????????10:
      begin
        if((gpr_dest_gpr_dec_ci != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_lwsp;
          rv32c_dec_immediate = imm_dec_cio;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd2;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_add;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_ld_word;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????1000??????????10:
      begin
        if(((gpr_src_rs1_gpr_dec_cr != 5'd0) &&  (gpr_src_rs2_gpr_dec_cr == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_jr;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cr;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_add;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_always;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((gpr_src_rs2_gpr_dec_cr != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_mv;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cr;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????1001??????????10:
      begin
        if(((gpr_src_rs1_gpr_dec_cr == 5'd0) &&  (gpr_src_rs2_gpr_dec_cr == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_ebreak;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b1;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b0;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if(((gpr_src_rs1_gpr_dec_cr != 5'd0) &&  (gpr_src_rs2_gpr_dec_cr == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_jalr;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = 5'd1;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cr;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_pc;
          rv32c_dec_operand1_mux_sel = exu_op1_lit2;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_add;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_always;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((gpr_src_rs2_gpr_dec_cr != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_add;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cr;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cr;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????110???????????10:
      begin
        rv32c_dec_mnemonic = rv32c_swsp;
        rv32c_dec_immediate = imm_dec_csso;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = 5'd2;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_css;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32c_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_str_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????011???????????00:
      begin
        rv32c_dec_mnemonic = rv32c_flw;
        rv32c_dec_immediate = imm_dec_clo;
        rv32c_dec_illegal_instr = !cfg_compressed_en || !cfg_float_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cl;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cl;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_ld_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
		rv32c_dec_fgpr_wr_sel = 1'b1;                       
		rv32c_dec_fgpr_rs1_rd_sel = 1'b0;                    
		rv32c_dec_fgpr_rs2_rd_sel = 1'b0;       
      end
      32'b????????????????111???????????00:
      begin
        rv32c_dec_mnemonic = rv32c_fsw;
        rv32c_dec_immediate = imm_dec_cso;
        rv32c_dec_illegal_instr = !cfg_compressed_en || !cfg_float_en;;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32c_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_str_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
	    rv32c_dec_fgpr_wr_sel = 1'b0; 
	    rv32c_dec_fgpr_rs1_rd_sel = 1'b0;                    
	    rv32c_dec_fgpr_rs2_rd_sel = 1'b1;  
      end      
	  32'b????????????????011???????????10:
      begin
        rv32c_dec_mnemonic = rv32c_flwsp;
        rv32c_dec_immediate = imm_dec_cio;
        rv32c_dec_illegal_instr = !cfg_compressed_en || !cfg_float_en;;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = 5'd2;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_ld_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
        rv32c_dec_fgpr_wr_sel = 1'b1;                       
        rv32c_dec_fgpr_rs1_rd_sel = 1'b0;                    
        rv32c_dec_fgpr_rs2_rd_sel = 1'b0;
      end
      32'b????????????????111???????????10:
      begin
        rv32c_dec_mnemonic = rv32c_fswsp;
        rv32c_dec_immediate = imm_dec_csso;
        rv32c_dec_illegal_instr = !cfg_compressed_en || !cfg_float_en;;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = 5'd2;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_css;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32c_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_str_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      default :
      begin
      end
    endcase
  end

end
else begin : ngen_decode_rv32c

  assign rv32c_dec_mnemonic = rv32_default;
  assign rv32c_dec_immediate = 32'd0;
  assign rv32c_dec_illegal_instr = 1'b1;
  assign rv32c_dec_m_env_call = 1'b0;
  assign rv32c_dec_m_ret = 1'b0;
  assign rv32c_dec_d_ret = 1'b0;
  assign rv32c_dec_dbreakpoint = 1'b0;
  assign rv32c_dec_gpr_wr_valid = 1'b0;
  assign rv32c_dec_gpr_wr_sel = 5'd0;
  assign rv32c_dec_gpr_rs1_rd_valid = 1'b0;
  assign rv32c_dec_gpr_rs1_rd_sel = 5'd0;
  assign rv32c_dec_gpr_rs2_rd_valid = 1'b0;
  assign rv32c_dec_gpr_rs2_rd_sel = 5'd0;
  assign rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
  assign rv32c_dec_sw_csr_addr = 12'd0;
  assign rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
  assign rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
  assign rv32c_dec_operand0_mux_sel = exu_op0_rs1;
  assign rv32c_dec_operand1_mux_sel = exu_op1_rs2;
  assign rv32c_dec_alu_op_sel = exu_alu_op_none;
  assign rv32c_dec_shifter_operand_sel = shifter_operand_none;
  assign rv32c_dec_shifter_unit_places = shifter_places_operand_none;
  assign rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
  assign rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
  assign rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
  assign rv32c_dec_bcu_op_sel = bcu_op_none;
  assign rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
  assign rv32c_dec_branch_cond = branch_cond_none;
  assign rv32c_dec_fence_i = 1'b0;
  assign rv32c_dec_fence = 1'b0;
  assign rv32c_dec_lsu_op = lsu_op_none;
  assign rv32c_dec_wfi = 1'b0;
  assign rv32c_instr_decoded = 1'b0;
  assign rv32c_dec_fgpr_wr_sel = 1'b0;                       
  assign rv32c_dec_fgpr_rs1_rd_sel = 1'b0;                    
  assign rv32c_dec_fgpr_rs2_rd_sel = 1'b0;   
end
endgenerate


generate if(GEN_DECODE_RV32F)
begin : gen_decode_rv32f
  always @*
  begin

    // assign defaults

    rv32f_dec_mnemonic = rv32_default;
    rv32f_dec_immediate = 32'd0;
    rv32f_dec_illegal_instr = 1'b1;
    rv32f_dec_m_env_call = 1'b0;
    rv32f_dec_m_ret = 1'b0;
    rv32f_dec_d_ret = 1'b0;
    rv32f_dec_dbreakpoint = 1'b0;
    rv32f_dec_gpr_wr_valid = 1'b0;
    rv32f_dec_gpr_wr_sel = 5'd0;
    rv32f_dec_gpr_rs1_rd_valid = 1'b0;
    rv32f_dec_gpr_rs1_rd_sel = 5'd0;
    rv32f_dec_gpr_rs2_rd_valid = 1'b0;
    rv32f_dec_gpr_rs2_rd_sel = 5'd0;
    rv32f_dec_gpr_rs3_rd_valid = 1'b0;
    rv32f_dec_gpr_rs3_rd_sel = 5'd0;
    rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32f_dec_sw_csr_addr = 12'd0;
    rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32f_dec_operand0_mux_sel = exu_op0_rs1;
    rv32f_dec_operand1_mux_sel = exu_op1_rs2;
    rv32f_dec_operand2_mux_sel = exu_op2_rs3;
    rv32f_dec_alu_op_sel = exu_alu_op_none;
    rv32f_dec_shifter_operand_sel = shifter_operand_none;
    rv32f_dec_shifter_unit_places = shifter_places_operand_none;
    rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32f_dec_bcu_op_sel = bcu_op_none;
    rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32f_dec_branch_cond = branch_cond_none;
    rv32f_dec_fence_i = 1'b0;
    rv32f_dec_fence = 1'b0;
    rv32f_dec_lsu_op = lsu_op_none;
    rv32f_dec_wfi = 1'b0;
    rv32f_instr_decoded = 1'b0; 
	rv32f_dec_frm = 3'b0;
	rv32f_dec_fmt = 2'b0;  // Only supports single-precission
	rv32f_dec_fgpr_wr_sel = 1'b0;    
	rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
	rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
	rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  

    unique casez(instruction)
      32'b?????????????????010?????0000111: 
      begin
        rv32f_dec_mnemonic = rv32f_flw;                               
        rv32f_dec_immediate = imm_dec_i;                              
        rv32f_dec_illegal_instr = !cfg_float_en;                      
        rv32f_dec_m_env_call = 1'b0;                                  
        rv32f_dec_m_ret = 1'b0;                                       
        rv32f_dec_d_ret = 1'b0;                                       
        rv32f_dec_dbreakpoint = 1'b0;                                 
		rv32f_dec_gpr_wr_valid = 1'b1;                                
		rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;     
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;             
        rv32f_dec_gpr_rs2_rd_valid = 1'b0;                            
        rv32f_dec_gpr_rs2_rd_sel = 5'd0;                              
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                            
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                              
		rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;                
        rv32f_dec_sw_csr_addr = 12'd0;                                
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                  
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                  
		rv32f_dec_operand0_mux_sel = exu_op0_rs1;                     
		rv32f_dec_operand1_mux_sel = exu_op1_imm;                     
		rv32f_dec_operand2_mux_sel = exu_op2_rs3;                     
		rv32f_dec_alu_op_sel = exu_alu_op_none;                       
        rv32f_dec_shifter_operand_sel = shifter_operand_none;         
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;  
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;          
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;            
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;            
        rv32f_dec_bcu_op_sel = bcu_op_add;                            
		rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_acu;        
        rv32f_dec_branch_cond = branch_cond_none;                     
        rv32f_dec_fence_i = 1'b0;                                     
        rv32f_dec_fence = 1'b0;                                       
		rv32f_dec_lsu_op = lsu_op_ld_word;                         
        rv32f_dec_wfi = 1'b0;                                         
        rv32f_instr_decoded = 1'b1;                                   
	    rv32f_dec_frm = 3'b0;                
		rv32f_dec_fgpr_wr_sel = 1'b1;                       
		rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;     
	  
	  end
      32'b?????????????????010?????0100111:
      begin
        rv32f_dec_mnemonic = rv32f_fsw;                                 
        rv32f_dec_immediate = imm_dec_istr;                             
        rv32f_dec_illegal_instr = !cfg_float_en;                                 
        rv32f_dec_m_env_call = 1'b0;                                    
        rv32f_dec_m_ret = 1'b0;                                         
        rv32f_dec_d_ret = 1'b0;                                         
        rv32f_dec_dbreakpoint = 1'b0;                                   
        rv32f_dec_gpr_wr_valid = 1'b0;                                  
        rv32f_dec_gpr_wr_sel = 5'd0;  
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                              
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;               
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                              
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;               
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                              
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;                 
        rv32f_dec_sw_csr_addr = 12'd0;                                  
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                    
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                    
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                       
        rv32f_dec_operand1_mux_sel = exu_op1_imm;   
		rv32f_dec_operand2_mux_sel = exu_op2_rs3;                       
        rv32f_dec_alu_op_sel = exu_alu_op_none;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_rs2;            
        rv32f_dec_shifter_unit_places = shifter_places_operand_noshift; 
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;      
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;              
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;              
        rv32f_dec_bcu_op_sel = bcu_op_add;                              
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_acu;          
        rv32f_dec_branch_cond = branch_cond_none;                       
        rv32f_dec_fence_i = 1'b0;                                       
        rv32f_dec_fence = 1'b0;                                         
        rv32f_dec_lsu_op = lsu_op_str_word;                             
        rv32f_dec_wfi = 1'b0;                                           
        rv32f_instr_decoded = 1'b1;                                     
	    rv32f_dec_frm = 3'b0;
	    rv32f_dec_fgpr_wr_sel = 1'b0; 
	    rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
	    rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
	    rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  
	  end
      32'b?????00??????????????????1000011:                                      
      begin
        rv32f_dec_mnemonic = rv32f_fmadd_s;                                         
        rv32f_dec_immediate = 32'b0;                                   
        rv32f_dec_illegal_instr = !cfg_float_en;                          
        rv32f_dec_m_env_call = 1'b0;                                   
        rv32f_dec_m_ret = 1'b0;                                        
        rv32f_dec_d_ret = 1'b0;                                        
        rv32f_dec_dbreakpoint = 1'b0;                                  
        rv32f_dec_gpr_wr_valid = 1'b1;                                 
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r4;                 
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r4;             
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r4;             
        rv32f_dec_gpr_rs3_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs3_rd_sel = gpr_src_rs3_gpr_dec_r4;             
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                 
        rv32f_dec_sw_csr_addr = 12'd0;                                 
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                   
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                   
		rv32f_dec_operand0_mux_sel = exu_op0_rs1;                      
		rv32f_dec_operand1_mux_sel = exu_op1_rs2;                      
		rv32f_dec_operand2_mux_sel = exu_op2_rs3;                      
		rv32f_dec_alu_op_sel = exu_alu_op_fmadd_op0_op1_op2;           
        rv32f_dec_shifter_operand_sel = shifter_operand_none;          
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;   
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;           
		rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;              
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;             
        rv32f_dec_bcu_op_sel = bcu_op_none;                            
		rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;       
        rv32f_dec_branch_cond = branch_cond_none;                      
        rv32f_dec_fence_i = 1'b0;                                      
        rv32f_dec_fence = 1'b0;                                        
        rv32f_dec_lsu_op = lsu_op_none;                                
        rv32f_dec_wfi = 1'b0;                                          
        rv32f_instr_decoded = 1'b1;                                    
	    rv32f_dec_frm = rv32f_src_frm;                              
        rv32f_dec_fgpr_wr_sel = 1'b1;   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                   
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b1;  		
	  end
      32'b?????00??????????????????1000111:
      begin
        rv32f_dec_mnemonic = rv32f_fmsub_s;                                         
        rv32f_dec_immediate = 32'b0;                                   
        rv32f_dec_illegal_instr = !cfg_float_en;                          
        rv32f_dec_m_env_call = 1'b0;                                   
        rv32f_dec_m_ret = 1'b0;                                        
        rv32f_dec_d_ret = 1'b0;                                        
        rv32f_dec_dbreakpoint = 1'b0;                                  
        rv32f_dec_gpr_wr_valid = 1'b1;                                 
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r4;                 
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r4;             
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r4;             
        rv32f_dec_gpr_rs3_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs3_rd_sel = gpr_src_rs3_gpr_dec_r4;             
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                 
        rv32f_dec_sw_csr_addr = 12'd0;                                 
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                   
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                   
		rv32f_dec_operand0_mux_sel = exu_op0_rs1;                      
		rv32f_dec_operand1_mux_sel = exu_op1_rs2;                      
		rv32f_dec_operand2_mux_sel = exu_op2_rs3;                      
		rv32f_dec_alu_op_sel = exu_alu_op_fmsub_op0_op1_op2;           
        rv32f_dec_shifter_operand_sel = shifter_operand_none;          
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;   
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;           
		rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;              
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;             
        rv32f_dec_bcu_op_sel = bcu_op_none;                            
		rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;       
        rv32f_dec_branch_cond = branch_cond_none;                      
        rv32f_dec_fence_i = 1'b0;                                      
        rv32f_dec_fence = 1'b0;                                        
        rv32f_dec_lsu_op = lsu_op_none;                                
        rv32f_dec_wfi = 1'b0;                                          
        rv32f_instr_decoded = 1'b1;                                    
	    rv32f_dec_frm = rv32f_src_frm;                              
        rv32f_dec_fgpr_wr_sel = 1'b1;   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                   
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b1;  		
	  end
      32'b?????00??????????????????1001011: 
      begin
        rv32f_dec_mnemonic = rv32f_fnmsub_s;                                         
        rv32f_dec_immediate = 32'b0;                                   
        rv32f_dec_illegal_instr = !cfg_float_en;                          
        rv32f_dec_m_env_call = 1'b0;                                   
        rv32f_dec_m_ret = 1'b0;                                        
        rv32f_dec_d_ret = 1'b0;                                        
        rv32f_dec_dbreakpoint = 1'b0;                                  
        rv32f_dec_gpr_wr_valid = 1'b1;                                 
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r4;                 
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r4;             
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r4;             
        rv32f_dec_gpr_rs3_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs3_rd_sel = gpr_src_rs3_gpr_dec_r4;             
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                 
        rv32f_dec_sw_csr_addr = 12'd0;                                 
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                   
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                   
		rv32f_dec_operand0_mux_sel = exu_op0_rs1;                      
		rv32f_dec_operand1_mux_sel = exu_op1_rs2;                      
		rv32f_dec_operand2_mux_sel = exu_op2_rs3;                      
		rv32f_dec_alu_op_sel = exu_alu_op_fnmsub_op0_op1_op2;           
        rv32f_dec_shifter_operand_sel = shifter_operand_none;          
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;   
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;           
		rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;              
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;             
        rv32f_dec_bcu_op_sel = bcu_op_none;                            
		rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;       
        rv32f_dec_branch_cond = branch_cond_none;                      
        rv32f_dec_fence_i = 1'b0;                                      
        rv32f_dec_fence = 1'b0;                                        
        rv32f_dec_lsu_op = lsu_op_none;                                
        rv32f_dec_wfi = 1'b0;                                          
        rv32f_instr_decoded = 1'b1;                                    
	    rv32f_dec_frm = rv32f_src_frm;                              
        rv32f_dec_fgpr_wr_sel = 1'b1;   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                   
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b1;  		
	  end
      32'b?????00??????????????????1001111:
      begin
        rv32f_dec_mnemonic = rv32f_fnmadd_s;                                         
        rv32f_dec_immediate = 32'b0;                                   
        rv32f_dec_illegal_instr = !cfg_float_en;                          
        rv32f_dec_m_env_call = 1'b0;                                   
        rv32f_dec_m_ret = 1'b0;                                        
        rv32f_dec_d_ret = 1'b0;                                        
        rv32f_dec_dbreakpoint = 1'b0;                                  
        rv32f_dec_gpr_wr_valid = 1'b1;                                 
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r4;                 
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r4;             
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r4;             
        rv32f_dec_gpr_rs3_rd_valid = 1'b1;                             
        rv32f_dec_gpr_rs3_rd_sel = gpr_src_rs3_gpr_dec_r4;             
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                 
        rv32f_dec_sw_csr_addr = 12'd0;                                 
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                   
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                   
		rv32f_dec_operand0_mux_sel = exu_op0_rs1;                      
		rv32f_dec_operand1_mux_sel = exu_op1_rs2;                      
		rv32f_dec_operand2_mux_sel = exu_op2_rs3;                      
		rv32f_dec_alu_op_sel = exu_alu_op_fnmadd_op0_op1_op2;           
        rv32f_dec_shifter_operand_sel = shifter_operand_none;          
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;   
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;           
		rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;              
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;             
        rv32f_dec_bcu_op_sel = bcu_op_none;                            
		rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;       
        rv32f_dec_branch_cond = branch_cond_none;                      
        rv32f_dec_fence_i = 1'b0;                                      
        rv32f_dec_fence = 1'b0;                                        
        rv32f_dec_lsu_op = lsu_op_none;                                
        rv32f_dec_wfi = 1'b0;                                          
        rv32f_instr_decoded = 1'b1;                                    
	    rv32f_dec_frm = rv32f_src_frm;                              
        rv32f_dec_fgpr_wr_sel = 1'b1;   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                   
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b1;  	  
	  end
      32'b0000000??????????????????1010011: 
      begin
        rv32f_dec_mnemonic = rv32f_fadd_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fadd_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b1;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;       
	  end
      32'b0000100??????????????????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fsub_s;                                  
        rv32f_dec_immediate = 32'd0;                                        
        rv32f_dec_illegal_instr = !cfg_float_en;                            
        rv32f_dec_m_env_call = 1'b0;                                        
        rv32f_dec_m_ret = 1'b0;                                             
        rv32f_dec_d_ret = 1'b0;                                             
        rv32f_dec_dbreakpoint = 1'b0;                                       
        rv32f_dec_gpr_wr_valid = 1'b1;                                      
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                   
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                   
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                  
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                    
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                      
        rv32f_dec_sw_csr_addr = 12'd0;                                      
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                        
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                        
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                           
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                           
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                           
        rv32f_dec_alu_op_sel = exu_alu_op_fsub_op0_op1;                     
        rv32f_dec_shifter_operand_sel = shifter_operand_none;               
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;        
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                   
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                  
        rv32f_dec_bcu_op_sel = bcu_op_none;                                 
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;            
        rv32f_dec_branch_cond = branch_cond_none;                           
        rv32f_dec_fence_i = 1'b0;                                           
        rv32f_dec_fence = 1'b0;                                             
        rv32f_dec_lsu_op = lsu_op_none;                                     
        rv32f_dec_wfi = 1'b0;                                               
        rv32f_instr_decoded = 1'b1;                                         
	    rv32f_dec_frm = rv32f_src_frm;                        
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;                                                               
	  end                                                                  
      32'b0001000??????????????????1010011:            
      begin                      
        rv32f_dec_mnemonic = rv32f_fmul_s;                                  
        rv32f_dec_immediate = 32'd0;                                        
        rv32f_dec_illegal_instr = !cfg_float_en;                            
        rv32f_dec_m_env_call = 1'b0;                                        
        rv32f_dec_m_ret = 1'b0;                                             
        rv32f_dec_d_ret = 1'b0;                                             
        rv32f_dec_dbreakpoint = 1'b0;                                       
        rv32f_dec_gpr_wr_valid = 1'b1;                                      
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                   
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                   
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                  
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                    
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                      
        rv32f_dec_sw_csr_addr = 12'd0;                                      
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                        
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                        
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                           
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                           
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                           
        rv32f_dec_alu_op_sel = exu_alu_op_fmul_op0_op1;                     
        rv32f_dec_shifter_operand_sel = shifter_operand_none;               
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;        
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                   
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                  
        rv32f_dec_bcu_op_sel = bcu_op_none;                                 
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;            
        rv32f_dec_branch_cond = branch_cond_none;                           
        rv32f_dec_fence_i = 1'b0;                                           
        rv32f_dec_fence = 1'b0;                                             
        rv32f_dec_lsu_op = lsu_op_none;                                     
        rv32f_dec_wfi = 1'b0;                                               
        rv32f_instr_decoded = 1'b1;                                         
	    rv32f_dec_frm = rv32f_src_frm;                        
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;    
	  end
      32'b0001100??????????????????1010011:
      begin 
        rv32f_dec_mnemonic = rv32f_fdiv_s;                                  
        rv32f_dec_immediate = 32'd0;                                        
        rv32f_dec_illegal_instr = !cfg_float_en;                            
        rv32f_dec_m_env_call = 1'b0;                                        
        rv32f_dec_m_ret = 1'b0;                                             
        rv32f_dec_d_ret = 1'b0;                                             
        rv32f_dec_dbreakpoint = 1'b0;                                       
        rv32f_dec_gpr_wr_valid = 1'b1;                                      
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                   
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                   
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                  
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                    
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                      
        rv32f_dec_sw_csr_addr = 12'd0;                                      
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                        
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                        
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                           
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                           
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                           
        rv32f_dec_alu_op_sel = exu_alu_op_fdiv_op0_op1;                     
        rv32f_dec_shifter_operand_sel = shifter_operand_none;               
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;        
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                   
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                  
        rv32f_dec_bcu_op_sel = bcu_op_none;                                 
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;            
        rv32f_dec_branch_cond = branch_cond_none;                           
        rv32f_dec_fence_i = 1'b0;                                           
        rv32f_dec_fence = 1'b0;                                             
        rv32f_dec_lsu_op = lsu_op_none;                                     
        rv32f_dec_wfi = 1'b0;                                               
        rv32f_instr_decoded = 1'b1;                                         
	    rv32f_dec_frm = rv32f_src_frm;                        
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;      
	  end
      32'b010110000000?????????????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fsqrt_s;                                  
        rv32f_dec_immediate = 32'd0;                                        
        rv32f_dec_illegal_instr = !cfg_float_en;                            
        rv32f_dec_m_env_call = 1'b0;                                        
        rv32f_dec_m_ret = 1'b0;                                             
        rv32f_dec_d_ret = 1'b0;                                             
        rv32f_dec_dbreakpoint = 1'b0;                                       
        rv32f_dec_gpr_wr_valid = 1'b1;                                      
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                   
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                   
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                  
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                    
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                      
        rv32f_dec_sw_csr_addr = 12'd0;                                      
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                        
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                        
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                           
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                           
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                           
        rv32f_dec_alu_op_sel = exu_alu_op_fsqrt_op0_op1;                     
        rv32f_dec_shifter_operand_sel = shifter_operand_none;               
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;        
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                   
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                  
        rv32f_dec_bcu_op_sel = bcu_op_none;                                 
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;            
        rv32f_dec_branch_cond = branch_cond_none;                           
        rv32f_dec_fence_i = 1'b0;                                           
        rv32f_dec_fence = 1'b0;                                             
        rv32f_dec_lsu_op = lsu_op_none;                                     
        rv32f_dec_wfi = 1'b0;                                               
        rv32f_instr_decoded = 1'b1;                                         
	    rv32f_dec_frm = rv32f_src_frm;                        
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;           
	  end
      32'b0010000??????????000?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fsgnj_s;                                  
        rv32f_dec_immediate = 32'd0;                                        
        rv32f_dec_illegal_instr = !cfg_float_en;                            
        rv32f_dec_m_env_call = 1'b0;                                        
        rv32f_dec_m_ret = 1'b0;                                             
        rv32f_dec_d_ret = 1'b0;                                             
        rv32f_dec_dbreakpoint = 1'b0;                                       
        rv32f_dec_gpr_wr_valid = 1'b1;                                      
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                   
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                   
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                  
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                    
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                      
        rv32f_dec_sw_csr_addr = 12'd0;                                      
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                        
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                        
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                           
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                           
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                           
        rv32f_dec_alu_op_sel = exu_alu_op_fsgnj_op0_op1;                     
        rv32f_dec_shifter_operand_sel = shifter_operand_none;               
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;        
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                   
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                  
        rv32f_dec_bcu_op_sel = bcu_op_none;                                 
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;            
        rv32f_dec_branch_cond = branch_cond_none;                           
        rv32f_dec_fence_i = 1'b0;                                           
        rv32f_dec_fence = 1'b0;                                             
        rv32f_dec_lsu_op = lsu_op_none;                                     
        rv32f_dec_wfi = 1'b0;                                               
        rv32f_instr_decoded = 1'b1;                                         
	    rv32f_dec_frm = rv32f_src_frm;                        
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;   
	  end
      32'b0010000??????????001?????1010011: 
      begin
        rv32f_dec_mnemonic = rv32f_fsgnjn_s;                                  
        rv32f_dec_immediate = 32'd0;                                        
        rv32f_dec_illegal_instr = !cfg_float_en;                            
        rv32f_dec_m_env_call = 1'b0;                                        
        rv32f_dec_m_ret = 1'b0;                                             
        rv32f_dec_d_ret = 1'b0;                                             
        rv32f_dec_dbreakpoint = 1'b0;                                       
        rv32f_dec_gpr_wr_valid = 1'b1;                                      
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                   
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                                  
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                   
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                  
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                    
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                      
        rv32f_dec_sw_csr_addr = 12'd0;                                      
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                        
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                        
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                           
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                           
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                           
        rv32f_dec_alu_op_sel = exu_alu_op_fsgnjn_op0_op1;                     
        rv32f_dec_shifter_operand_sel = shifter_operand_none;               
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;        
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                   
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                  
        rv32f_dec_bcu_op_sel = bcu_op_none;                                 
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;            
        rv32f_dec_branch_cond = branch_cond_none;                           
        rv32f_dec_fence_i = 1'b0;                                           
        rv32f_dec_fence = 1'b0;                                             
        rv32f_dec_lsu_op = lsu_op_none;                                     
        rv32f_dec_wfi = 1'b0;                                               
        rv32f_instr_decoded = 1'b1;                                         
	    rv32f_dec_frm = rv32f_src_frm;                        
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;        
	  end
      32'b0010000??????????010?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fsgnjx_s;
        rv32f_dec_immediate = 32'd0;
        rv32f_dec_illegal_instr = !cfg_float_en;
        rv32f_dec_m_env_call = 1'b0;
        rv32f_dec_m_ret = 1'b0;
        rv32f_dec_d_ret = 1'b0;
        rv32f_dec_dbreakpoint = 1'b0;
        rv32f_dec_gpr_wr_valid = 1'b1;
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32f_dec_sw_csr_addr = 12'd0;
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;
        rv32f_dec_alu_op_sel = exu_alu_op_fsgnjx_op0_op1;
        rv32f_dec_shifter_operand_sel = shifter_operand_none;
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32f_dec_bcu_op_sel = bcu_op_none;
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;
        rv32f_dec_branch_cond = branch_cond_none;
        rv32f_dec_fence_i = 1'b0;
        rv32f_dec_fence = 1'b0;
        rv32f_dec_lsu_op = lsu_op_none;
        rv32f_dec_wfi = 1'b0;
        rv32f_instr_decoded = 1'b1;
	    rv32f_dec_frm = rv32f_src_frm;                 
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  
	  end
      32'b0010100??????????000?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fmin_s;
        rv32f_dec_immediate = 32'd0;
        rv32f_dec_illegal_instr = !cfg_float_en;
        rv32f_dec_m_env_call = 1'b0;
        rv32f_dec_m_ret = 1'b0;
        rv32f_dec_d_ret = 1'b0;
        rv32f_dec_dbreakpoint = 1'b0;
        rv32f_dec_gpr_wr_valid = 1'b1;
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32f_dec_sw_csr_addr = 12'd0;
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;
        rv32f_dec_alu_op_sel = exu_alu_op_fmin_op0_op1;
        rv32f_dec_shifter_operand_sel = shifter_operand_none;
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32f_dec_bcu_op_sel = bcu_op_none;
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;
        rv32f_dec_branch_cond = branch_cond_none;
        rv32f_dec_fence_i = 1'b0;
        rv32f_dec_fence = 1'b0;
        rv32f_dec_lsu_op = lsu_op_none;
        rv32f_dec_wfi = 1'b0;
        rv32f_instr_decoded = 1'b1;
	    rv32f_dec_frm = rv32f_src_frm;                 
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  
	  end
      32'b0010100??????????001?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fmax_s;
        rv32f_dec_immediate = 32'd0;
        rv32f_dec_illegal_instr = !cfg_float_en;
        rv32f_dec_m_env_call = 1'b0;
        rv32f_dec_m_ret = 1'b0;
        rv32f_dec_d_ret = 1'b0;
        rv32f_dec_dbreakpoint = 1'b0;
        rv32f_dec_gpr_wr_valid = 1'b1;
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32f_dec_sw_csr_addr = 12'd0;
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;
        rv32f_dec_alu_op_sel = exu_alu_op_fmax_op0_op1;
        rv32f_dec_shifter_operand_sel = shifter_operand_none;
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32f_dec_bcu_op_sel = bcu_op_none;
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;
        rv32f_dec_branch_cond = branch_cond_none;
        rv32f_dec_fence_i = 1'b0;
        rv32f_dec_fence = 1'b0;
        rv32f_dec_lsu_op = lsu_op_none;
        rv32f_dec_wfi = 1'b0;
        rv32f_instr_decoded = 1'b1;
	    rv32f_dec_frm = rv32f_src_frm;                 
	    rv32f_dec_fgpr_wr_sel = 1'b1;                   
        rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
        rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  
	  end
      32'b110000000000?????????????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fcvt_w_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fcvt_w_s_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;       
	  end
      32'b110000000001?????????????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fcvt_wu_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fcvt_wu_s_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;          
	  end
	  32'b111100000000?????000?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fmv_w_x;                             
        rv32f_dec_immediate = 32'd0;                                    
        rv32f_dec_illegal_instr = !cfg_float_en;                        
        rv32f_dec_m_env_call = 1'b0;                                    
        rv32f_dec_m_ret = 1'b0;                                         
        rv32f_dec_d_ret = 1'b0;                                         
        rv32f_dec_dbreakpoint = 1'b0;                                   
        rv32f_dec_gpr_wr_valid = 1'b1;                                  
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;                      
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                              
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;               
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                              
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                                
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                  
        rv32f_dec_sw_csr_addr = 12'd0;                                  
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                    
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                    
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                       
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                       
        rv32f_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32f_dec_shifter_operand_sel = shifter_operand_none;            
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;     
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;             
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;               
        rv32f_dec_bcu_op_sel = bcu_op_none;                              
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;         
        rv32f_dec_branch_cond = branch_cond_none;                        
        rv32f_dec_fence_i = 1'b0;                                        
        rv32f_dec_fence = 1'b0;                                          
        rv32f_dec_lsu_op = lsu_op_none;                                  
        rv32f_dec_wfi = 1'b0;                                            
        rv32f_instr_decoded = 1'b1;                                      
	    rv32f_dec_frm = 3'b0;               
		rv32f_dec_fgpr_wr_sel = 1'b1;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;   
	  end
      32'b1010000??????????010?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_feq_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_feq_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;       
	  end
      32'b1010000??????????001?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_flt_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                        
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_flt_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;   
	  end
      32'b1010000??????????000?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fle_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;                        
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fle_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;         
	  end
      32'b111000000000?????001?????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fclass_s;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fclass_s_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;          
	  end
      32'b110100000000?????????????1010011: 
      begin
        rv32f_dec_mnemonic = rv32f_fcvt_s_w;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fcvt_s_w_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b1;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;       
	  end
      32'b110100000001?????????????1010011:
      begin
        rv32f_dec_mnemonic = rv32f_fcvt_s_wu;                                      
        rv32f_dec_immediate = 32'd0;                                            
        rv32f_dec_illegal_instr = !cfg_float_en;                                
        rv32f_dec_m_env_call = 1'b0;                                            
        rv32f_dec_m_ret = 1'b0;                                                 
        rv32f_dec_d_ret = 1'b0;                                                 
        rv32f_dec_dbreakpoint = 1'b0;                                           
        rv32f_dec_gpr_wr_valid = 1'b1;                                          
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;       
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                                      
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;                       
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                            
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                       
        rv32f_dec_gpr_rs3_rd_valid = 1'b0;                                      
        rv32f_dec_gpr_rs3_rd_sel = 5'd0;                                        
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                          
        rv32f_dec_sw_csr_addr = 12'd0;                                          
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                            
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                            
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                               
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                               
        rv32f_dec_operand2_mux_sel = exu_op2_rs3;                               
        rv32f_dec_alu_op_sel = exu_alu_op_fcvt_s_wu_op0_op1;                         
        rv32f_dec_shifter_operand_sel = shifter_operand_none;                   
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;            
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;                    
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;                       
		rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;                      
        rv32f_dec_bcu_op_sel = bcu_op_none;                                     
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;                
        rv32f_dec_branch_cond = branch_cond_none;                               
        rv32f_dec_fence_i = 1'b0;                                               
        rv32f_dec_fence = 1'b0;                                                 
        rv32f_dec_lsu_op = lsu_op_none;                                         
        rv32f_dec_wfi = 1'b0;                                                   
        rv32f_instr_decoded = 1'b1;                                             
	    rv32f_dec_frm = rv32f_src_frm;                        
		rv32f_dec_fgpr_wr_sel = 1'b1;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;                
	  end	  
      32'b111000000000?????000?????1010011: 
      begin
        rv32f_dec_mnemonic = rv32f_fmv_x_w;                             
        rv32f_dec_immediate = 32'd0;                                    
        rv32f_dec_illegal_instr = !cfg_float_en;                        
        rv32f_dec_m_env_call = 1'b0;                                    
        rv32f_dec_m_ret = 1'b0;                                         
        rv32f_dec_d_ret = 1'b0;                                         
        rv32f_dec_dbreakpoint = 1'b0;                                   
        rv32f_dec_gpr_wr_valid = 1'b1;                                  
        rv32f_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;                      
        rv32f_dec_gpr_rs1_rd_valid = 1'b1;                              
        rv32f_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;               
        rv32f_dec_gpr_rs2_rd_valid = 1'b1;                              
        rv32f_dec_gpr_rs2_rd_sel = 5'b0;                                
        rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;                  
        rv32f_dec_sw_csr_addr = 12'd0;                                  
        rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;                    
        rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;                    
        rv32f_dec_operand0_mux_sel = exu_op0_rs1;                       
        rv32f_dec_operand1_mux_sel = exu_op1_rs2;                       
        rv32f_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32f_dec_shifter_operand_sel = shifter_operand_none;           
        rv32f_dec_shifter_unit_places = shifter_places_operand_none;    
        rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;            
        rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;               
        rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;              
        rv32f_dec_bcu_op_sel = bcu_op_none;                             
        rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_float;        
        rv32f_dec_branch_cond = branch_cond_none;                       
        rv32f_dec_fence_i = 1'b0;                                       
        rv32f_dec_fence = 1'b0;                                         
        rv32f_dec_lsu_op = lsu_op_none;                                 
        rv32f_dec_wfi = 1'b0;                                           
        rv32f_instr_decoded = 1'b1;                                     
	    rv32f_dec_frm = 3'b0;               
		rv32f_dec_fgpr_wr_sel = 1'b0;                   
		rv32f_dec_fgpr_rs1_rd_sel = 1'b1;                    
		rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
		rv32f_dec_fgpr_rs3_rd_sel = 1'b0;   
	  end  
      default : begin
                   rv32f_dec_mnemonic = rv32_default;
                   rv32f_dec_immediate = 32'd0;
                   rv32f_dec_illegal_instr = 1'b1;
                   rv32f_dec_m_env_call = 1'b0;
                   rv32f_dec_m_ret = 1'b0;
                   rv32f_dec_d_ret = 1'b0;
                   rv32f_dec_dbreakpoint = 1'b0;
                   rv32f_dec_gpr_wr_valid = 1'b0;
                   rv32f_dec_gpr_wr_sel = 5'd0;
                   rv32f_dec_gpr_rs1_rd_valid = 1'b0;
                   rv32f_dec_gpr_rs1_rd_sel = 5'd0;
                   rv32f_dec_gpr_rs2_rd_valid = 1'b0;
                   rv32f_dec_gpr_rs2_rd_sel = 5'd0;
                   rv32f_dec_gpr_rs3_rd_valid = 1'b0;
                   rv32f_dec_gpr_rs3_rd_sel = 5'd0;
                   rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
                   rv32f_dec_sw_csr_addr = 12'd0;
                   rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;
                   rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;
                   rv32f_dec_operand0_mux_sel = exu_op0_rs1;
                   rv32f_dec_operand1_mux_sel = exu_op1_rs2;
                   rv32f_dec_operand2_mux_sel = exu_op2_rs3;
                   rv32f_dec_alu_op_sel = exu_alu_op_none;
                   rv32f_dec_shifter_operand_sel = shifter_operand_none;
                   rv32f_dec_shifter_unit_places = shifter_places_operand_none;
                   rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;
                   rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
                   rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
                   rv32f_dec_bcu_op_sel = bcu_op_none;
                   rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_none;
                   rv32f_dec_branch_cond = branch_cond_none;
                   rv32f_dec_fence_i = 1'b0;
                   rv32f_dec_fence = 1'b0;
                   rv32f_dec_lsu_op = lsu_op_none;
                   rv32f_dec_wfi = 1'b0;
                   rv32f_instr_decoded = 1'b0;
                   rv32f_dec_frm = 3'b0;
	               rv32f_dec_fgpr_wr_sel = 1'b0;    
	               rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
	               rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
	               rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  
                end
	 endcase
  end
end else begin : ngen_decode_rv32f
      assign rv32f_dec_mnemonic = rv32_default;
      assign rv32f_dec_immediate = 32'd0;
      assign rv32f_dec_illegal_instr = 1'b1;
      assign rv32f_dec_m_env_call = 1'b0;
      assign rv32f_dec_m_ret = 1'b0;
      assign rv32f_dec_d_ret = 1'b0;
      assign rv32f_dec_dbreakpoint = 1'b0;
      assign rv32f_dec_gpr_wr_valid = 1'b0;
      assign rv32f_dec_gpr_wr_sel = 5'd0;
      assign rv32f_dec_gpr_rs1_rd_valid = 1'b0;
      assign rv32f_dec_gpr_rs1_rd_sel = 5'd0;
      assign rv32f_dec_gpr_rs2_rd_valid = 1'b0;
      assign rv32f_dec_gpr_rs2_rd_sel = 5'd0;
      assign rv32f_dec_gpr_rs3_rd_valid = 1'b0;
      assign rv32f_dec_gpr_rs3_rd_sel = 5'd0;
      assign rv32f_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
      assign rv32f_dec_sw_csr_addr = 12'd0;
      assign rv32f_dec_sw_csr_wr_op = csr_alu_wr_op_none;
      assign rv32f_dec_sw_csr_rd_op = csr_alu_rd_op_none;
      assign rv32f_dec_operand0_mux_sel = exu_op0_rs1;
      assign rv32f_dec_operand1_mux_sel = exu_op1_rs2;
      assign rv32f_dec_operand2_mux_sel = exu_op2_rs3;
      assign rv32f_dec_alu_op_sel = exu_alu_op_none;
      assign rv32f_dec_shifter_operand_sel = shifter_operand_none;
      assign rv32f_dec_shifter_unit_places = shifter_places_operand_none;
      assign rv32f_dec_shifter_unit_op_sel = exu_shifter_op_none;
      assign rv32f_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
      assign rv32f_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
      assign rv32f_dec_bcu_op_sel = bcu_op_none;
      assign rv32f_dec_exu_result_mux_sel = exu_alu_result_mux_none;
      assign rv32f_dec_branch_cond = branch_cond_none;
      assign rv32f_dec_fence_i = 1'b0;
      assign rv32f_dec_fence = 1'b0;
      assign rv32f_dec_lsu_op = lsu_op_none;
      assign rv32f_dec_wfi = 1'b0;
      assign rv32f_instr_decoded = 1'b0;
      assign rv32f_dec_frm = 3'b0;         
      assign rv32f_dec_fmt = 2'b0;	  
	  assign rv32f_dec_fgpr_wr_sel = 1'b0;    
	  assign rv32f_dec_fgpr_rs1_rd_sel = 1'b0;                    
	  assign rv32f_dec_fgpr_rs2_rd_sel = 1'b0;                    
	  assign rv32f_dec_fgpr_rs3_rd_sel = 1'b0;  
end
endgenerate

always @*
begin

  unique case({rv32f_instr_decoded, rv32i_instr_decoded,rv32m_instr_decoded,rv32c_instr_decoded})
   4'b1000 :
    begin
      case_dec_mnemonic = rv32f_dec_mnemonic;
      case_dec_immediate = rv32f_dec_immediate;
      case_dec_illegal_instr = rv32f_dec_illegal_instr;
      case_dec_m_env_call = rv32f_dec_m_env_call;
      case_dec_m_ret = rv32f_dec_m_ret;
      case_dec_d_ret = rv32f_dec_d_ret;
      case_dec_dbreakpoint = rv32f_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32f_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = {rv32f_dec_fgpr_wr_sel, rv32f_dec_gpr_wr_sel};
      case_dec_gpr_rs1_rd_valid = rv32f_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = {rv32f_dec_fgpr_rs1_rd_sel , rv32f_dec_gpr_rs1_rd_sel};
      case_dec_gpr_rs2_rd_valid = rv32f_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = {rv32f_dec_fgpr_rs2_rd_sel , rv32f_dec_gpr_rs2_rd_sel};
      case_dec_gpr_rs3_rd_valid = rv32f_dec_gpr_rs3_rd_valid;
      case_dec_gpr_rs3_rd_sel = {rv32f_dec_fgpr_rs3_rd_sel , rv32f_dec_gpr_rs3_rd_sel};
      case_dec_gpr_wr_mux_sel = rv32f_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32f_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32f_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32f_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32f_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32f_dec_operand1_mux_sel;
      case_dec_operand2_mux_sel = rv32f_dec_operand2_mux_sel;
      case_dec_alu_op_sel = rv32f_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32f_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32f_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32f_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32f_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32f_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32f_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32f_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32f_dec_branch_cond;
      case_dec_fence_i = rv32f_dec_fence_i;
      case_dec_fence = rv32f_dec_fence;
      case_dec_lsu_op = rv32f_dec_lsu_op;
      case_dec_wfi = rv32f_dec_wfi;
	  case_dec_frm = rv32f_dec_frm;
	  case_dec_fmt = rv32f_dec_fmt;
	  case_f_instr = 1'b1;
	end
   4'b0100 :
    begin
      case_dec_mnemonic = rv32i_dec_mnemonic;
      case_dec_immediate = rv32i_dec_immediate;
      case_dec_illegal_instr = rv32i_dec_illegal_instr;
      case_dec_m_env_call = rv32i_dec_m_env_call;
      case_dec_m_ret = rv32i_dec_m_ret;
      case_dec_d_ret = rv32i_dec_d_ret;
      case_dec_dbreakpoint = rv32i_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32i_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = {1'b0, rv32i_dec_gpr_wr_sel};
      case_dec_gpr_rs1_rd_valid = rv32i_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = {1'b0, rv32i_dec_gpr_rs1_rd_sel};
      case_dec_gpr_rs2_rd_valid = rv32i_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = {1'b0, rv32i_dec_gpr_rs2_rd_sel};
      case_dec_gpr_rs3_rd_valid = 1'b0;
      case_dec_gpr_rs3_rd_sel = 6'b0;
      case_dec_gpr_wr_mux_sel = rv32i_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32i_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32i_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32i_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32i_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32i_dec_operand1_mux_sel;
      case_dec_operand2_mux_sel = exu_op2_rs3;
      case_dec_alu_op_sel = rv32i_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32i_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32i_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32i_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32i_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32i_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32i_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32i_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32i_dec_branch_cond;
      case_dec_fence_i = rv32i_dec_fence_i;
      case_dec_fence = rv32i_dec_fence;
      case_dec_lsu_op = rv32i_dec_lsu_op;
      case_dec_wfi = rv32i_dec_wfi;
	  case_dec_frm = 3'b0;
	  case_dec_fmt = 2'b0;
	  case_f_instr = 1'b0;
    end

   4'b0010 :
    begin
      case_dec_mnemonic = rv32m_dec_mnemonic;
      case_dec_immediate = rv32m_dec_immediate;
      case_dec_illegal_instr = rv32m_dec_illegal_instr;
      case_dec_m_env_call = rv32m_dec_m_env_call;
      case_dec_m_ret = rv32m_dec_m_ret;
      case_dec_d_ret = rv32m_dec_d_ret;
      case_dec_dbreakpoint = rv32m_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32m_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = {1'b0, rv32m_dec_gpr_wr_sel};
      case_dec_gpr_rs1_rd_valid = rv32m_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = {1'b0, rv32m_dec_gpr_rs1_rd_sel};
      case_dec_gpr_rs2_rd_valid = rv32m_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = {1'b0, rv32m_dec_gpr_rs2_rd_sel};
      case_dec_gpr_rs3_rd_valid = 1'b0;
      case_dec_gpr_rs3_rd_sel = 6'b0;
      case_dec_gpr_wr_mux_sel = rv32m_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32m_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32m_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32m_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32m_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32m_dec_operand1_mux_sel;
      case_dec_operand2_mux_sel = exu_op2_rs3;
      case_dec_alu_op_sel = rv32m_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32m_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32m_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32m_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32m_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32m_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32m_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32m_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32m_dec_branch_cond;
      case_dec_fence_i = rv32m_dec_fence_i;
      case_dec_fence = rv32m_dec_fence;
      case_dec_lsu_op = rv32m_dec_lsu_op;
      case_dec_wfi = rv32m_dec_wfi;
	  case_dec_frm = 3'b0;
	  case_dec_fmt = 2'b0;
	  case_f_instr = 1'b0;
    end

   4'b0001 :   
    begin
      case_dec_mnemonic = rv32c_dec_mnemonic;
      case_dec_immediate = rv32c_dec_immediate;
      case_dec_illegal_instr = rv32c_dec_illegal_instr;
      case_dec_m_env_call = rv32c_dec_m_env_call;
      case_dec_m_ret = rv32c_dec_m_ret;
      case_dec_d_ret = rv32c_dec_d_ret;
      case_dec_dbreakpoint = rv32c_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32c_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = {rv32c_dec_fgpr_wr_sel, rv32c_dec_gpr_wr_sel};
      case_dec_gpr_rs1_rd_valid = rv32c_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = {rv32c_dec_fgpr_rs1_rd_sel, rv32c_dec_gpr_rs1_rd_sel};
      case_dec_gpr_rs2_rd_valid = rv32c_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = {rv32c_dec_fgpr_rs2_rd_sel, rv32c_dec_gpr_rs2_rd_sel};
      case_dec_gpr_rs3_rd_valid = 1'b0;
      case_dec_gpr_rs3_rd_sel = 6'b0;
      case_dec_gpr_wr_mux_sel = rv32c_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32c_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32c_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32c_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32c_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32c_dec_operand1_mux_sel;
      case_dec_operand2_mux_sel = exu_op2_rs3;
      case_dec_alu_op_sel = rv32c_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32c_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32c_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32c_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32c_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32c_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32c_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32c_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32c_dec_branch_cond;
      case_dec_fence_i = rv32c_dec_fence_i;
      case_dec_fence = rv32c_dec_fence;
      case_dec_lsu_op = rv32c_dec_lsu_op;
      case_dec_wfi = rv32c_dec_wfi;
	  case_dec_frm = 3'b0;
	  case_dec_fmt = 2'b0;
	  case_f_instr = 1'b0;
    end

    default :
    begin
      case_dec_mnemonic = rv32_default;
      case_dec_immediate = 32'd0;
      case_dec_illegal_instr = 1'b1;
      case_dec_m_env_call = 1'b0;
      case_dec_m_ret = 1'b0;
      case_dec_d_ret = 1'b0;
      case_dec_dbreakpoint = 1'b0;
      case_dec_gpr_wr_valid = 1'b0;
      case_dec_gpr_wr_sel = 6'd0;
      case_dec_gpr_rs1_rd_valid = 1'b0;
      case_dec_gpr_rs1_rd_sel = 6'd0;
      case_dec_gpr_rs2_rd_valid = 1'b0;
      case_dec_gpr_rs2_rd_sel = 5'd0;
      case_dec_gpr_rs3_rd_valid = 1'b0;
      case_dec_gpr_rs3_rd_sel = 6'b0;
      case_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
      case_dec_sw_csr_addr = 12'd0;
      case_dec_sw_csr_wr_op = csr_alu_wr_op_none;
      case_dec_sw_csr_rd_op = csr_alu_rd_op_none;
      case_dec_operand0_mux_sel = exu_op0_rs1;
      case_dec_operand1_mux_sel = exu_op1_rs2;
      case_dec_operand2_mux_sel = exu_op2_rs3;
      case_dec_alu_op_sel = exu_alu_op_none;
      case_dec_shifter_operand_sel = shifter_operand_none;
      case_dec_shifter_unit_places = shifter_places_operand_none;
      case_dec_shifter_unit_op_sel = exu_shifter_op_none;
      case_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
      case_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
      case_dec_bcu_op_sel = bcu_op_none;
      case_dec_exu_result_mux_sel = exu_alu_result_mux_none;
      case_dec_branch_cond = branch_cond_none;
      case_dec_fence_i = 1'b0;
      case_dec_fence = 1'b0;
      case_dec_lsu_op = lsu_op_none;
      case_dec_wfi = 1'b0;
	  case_dec_frm = 3'b0;
	  case_dec_fmt = 2'b0;
	  case_f_instr = 1'b0;
    end
  endcase
end


always @*
begin
  if (core_reset == 1'b1) 
  begin 
     mnemonic = rv32_reset;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 6'd0;
     gpr_rs1_rd_valid = 1'b1;
     gpr_rs1_rd_sel = 6'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 6'd0;
     gpr_rs3_rd_valid = 1'b0;
     gpr_rs3_rd_sel = 6'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = bcu_operand0_rs1;
     bcu_operand1_mux_sel = bcu_operand1_resetvec;
     bcu_op_sel = bcu_op_add;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_always;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
	 fpu_frm = 3'b0;
	 fpu_fmt = 2'b0;
	 fpu_instr = 1'b0;
  end 
  else 
  if (trap_taken)
  begin 
     mnemonic = rv32_trap;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 6'd0;
     gpr_rs1_rd_valid = 1'b1;
     gpr_rs1_rd_sel = 6'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 6'd0;
     gpr_rs3_rd_valid = 1'b0;
     gpr_rs3_rd_sel = 6'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = vectored_interrupt_taken ? bcu_operand0_trap_cause : bcu_operand0_rs1;
     bcu_operand1_mux_sel = bcu_operand1_exvec;
     bcu_op_sel = bcu_op_add;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_always;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
	 fpu_frm = 3'b0;
	 fpu_fmt = 2'b0;
	 fpu_instr = 1'b0;
  end 
  else 
  if (debug_exit)
  begin 
     mnemonic = rv32_dbgexit;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 6'd0;
     gpr_rs1_rd_valid = 1'b1;
     gpr_rs1_rd_sel = 6'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 6'd0;
     gpr_rs3_rd_valid = 1'b0;
     gpr_rs3_rd_sel = 6'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = bcu_operand0_rs1;
     bcu_operand1_mux_sel = bcu_operand1_dpc;
     bcu_op_sel = bcu_op_add;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_always;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
	 fpu_frm = 3'b0;
	 fpu_fmt = 2'b0;
	 fpu_instr = 1'b0;
  end 
  else 
  if (instruction_valid)
  begin 
     mnemonic = case_dec_mnemonic;
     immediate = case_dec_immediate;
     illegal_instr = case_dec_illegal_instr;
     m_env_call = case_dec_m_env_call;
     m_ret = case_dec_m_ret;
     d_ret = case_dec_d_ret;
     dbreakpoint = case_dec_dbreakpoint;
     gpr_wr_valid = case_dec_gpr_wr_valid;
     gpr_wr_sel = (GEN_DECODE_RV32F) ? case_dec_gpr_wr_sel : {1'b0, case_dec_gpr_wr_sel[4:0]};
     gpr_rs1_rd_valid = case_dec_gpr_rs1_rd_valid;
     gpr_rs1_rd_sel = (GEN_DECODE_RV32F) ? case_dec_gpr_rs1_rd_sel : {1'b0, case_dec_gpr_rs1_rd_sel[4:0]};
     gpr_rs2_rd_valid = case_dec_gpr_rs2_rd_valid;
     gpr_rs2_rd_sel =  (GEN_DECODE_RV32F) ? case_dec_gpr_rs2_rd_sel : {1'b0, case_dec_gpr_rs2_rd_sel[4:0]};
     gpr_rs3_rd_valid = case_dec_gpr_rs3_rd_valid;
     gpr_rs3_rd_sel =  (GEN_DECODE_RV32F) ? case_dec_gpr_rs3_rd_sel : {1'b0, case_dec_gpr_rs3_rd_sel[4:0]};
     gpr_wr_mux_sel = case_dec_gpr_wr_mux_sel;
     sw_csr_addr = case_dec_sw_csr_addr;
     sw_csr_wr_op = case_dec_sw_csr_wr_op;
     sw_csr_rd_op = case_dec_sw_csr_rd_op;
     operand0_mux_sel = case_dec_operand0_mux_sel;
     operand1_mux_sel = case_dec_operand1_mux_sel;
     alu_op_sel = case_dec_alu_op_sel;
     shifter_operand_sel = case_dec_shifter_operand_sel;
     shifter_unit_places = case_dec_shifter_unit_places;
     shifter_unit_op_sel = case_dec_shifter_unit_op_sel;
     bcu_operand0_mux_sel = case_dec_bcu_operand0_mux_sel;
     bcu_operand1_mux_sel = case_dec_bcu_operand1_mux_sel;
     bcu_op_sel = case_dec_bcu_op_sel;
     exu_result_mux_sel = case_dec_exu_result_mux_sel;
     branch_cond = case_dec_branch_cond;
     fence_i = case_dec_fence_i;
     fence = case_dec_fence;
     lsu_op = case_dec_lsu_op;
     wfi = case_dec_wfi;
	 fpu_frm = case_dec_frm;
	 fpu_fmt = case_dec_fmt;
	 fpu_instr = case_f_instr;
  end 
  else begin 
     mnemonic = rv32_noexec;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 6'd0;
     gpr_rs1_rd_valid = 1'b0;
     gpr_rs1_rd_sel = 6'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 6'd0;
     gpr_rs3_rd_valid = 1'b0;
     gpr_rs3_rd_sel = 6'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = bcu_operand0_pc;
     bcu_operand1_mux_sel = bcu_operand1_imm;
     bcu_op_sel = bcu_op_none;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_none;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
	 fpu_frm = 3'b0;
	 fpu_fmt = 2'b0;
	 fpu_instr = 1'b0;
  end 
end

                                                                                         
                                                                                         
                                                                              
//******************************************************************************         
// properties                                                                            
                                                                                         
                                                                                         
                                                                                         
endmodule                                                                                
                                                                                         
`default_nettype wire                                                                    
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_ifu_iab.sv
//
//   Purpose: 
//
//        
//           
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_ifu_iab
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH         = 32,
    parameter RESP_ERROR_WIDTH     = 1,
    parameter BUFF_DEPTH           = 3,
    parameter LOG2_BUFF_DEPTH      = 2,
	parameter MI_I_MEM             = 0
   )
  
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,
  input  wire logic                                resetn,
  
  input  wire logic                                req_flush_branch, 
  input  wire logic                                req_flush_pipe, 
  
  input  wire logic                                alloc_req, 
  input  wire logic                                alloc_req_fence_i,
  input  wire logic [I_ADDR_WIDTH-1:0]             alloc_req_addr,      
  input  wire logic                                alloc_req_hword_high,
  output      logic [I_ADDR_WIDTH-1:0]             buff_curr_fetch_ptr,
  
  input  wire logic                                alloc_resp, 
  input  wire logic [31:0]                         alloc_resp_data,  
  input  wire logic [RESP_ERROR_WIDTH-1:0]         alloc_resp_error,
  input  wire logic                                resp_complete,  
  input  wire logic                                iab_rd_alignment,
  output      logic [31:0]                         buff_resp_head_data,
  output      logic [RESP_ERROR_WIDTH-1:0]         buff_resp_head_error,
  output      logic [I_ADDR_WIDTH-1:0]             buff_resp_head_addr,
  output      logic                                buff_resp_head_addr_valid,
  output      logic                                buff_resp_head_hword_high_only,
  output      logic                                buff_resp_head_compressed,
  output      logic                                buff_resp_head_uncompressed_full,
  output      logic                                buff_resp_head_uncompressed_half,
  
  output      logic                                buff_full,
  output      logic                                buff_empty,
  output      logic                                buff_resp_empty,
  output      logic [LOG2_BUFF_DEPTH-1:0]          buff_fill_level,
  output      logic [LOG2_BUFF_DEPTH-1:0]          num_emi_req_os,
  output      logic                                emi_req_os,
  output      logic                                no_flush_req_os
  );
   

  
//******************************************************************************
// Declarations

  function logic [LOG2_BUFF_DEPTH:0] calc_fill (logic [LOG2_BUFF_DEPTH:0] a_op, b_op, max);
  
    calc_fill = ((a_op[LOG2_BUFF_DEPTH] ^ b_op[LOG2_BUFF_DEPTH]) & (a_op[LOG2_BUFF_DEPTH-1:0] == b_op[LOG2_BUFF_DEPTH-1:0])) ? max :
                {1'b0,(a_op[LOG2_BUFF_DEPTH-1:0] - b_op[LOG2_BUFF_DEPTH-1:0])};    
  endfunction
  

  logic [LOG2_BUFF_DEPTH-1:0]   buff_req_wr_ptr;  
  logic [LOG2_BUFF_DEPTH-1:0]   next_buff_req_wr_ptr; 
  logic [LOG2_BUFF_DEPTH-1:0]   buff_resp_wr_ptr;  
  logic [LOG2_BUFF_DEPTH-1:0]   next_buff_resp_wr_ptr; 
  logic [LOG2_BUFF_DEPTH-1:0]   buff_req_rd_ptr;
  logic [LOG2_BUFF_DEPTH-1:0]   buff_resp_rd_ptr;
  logic [LOG2_BUFF_DEPTH-1:0]   next_buff_resp_rd_ptr;
  logic [LOG2_BUFF_DEPTH-1:0]   buff_resp_rd_ptr_plus_one;
  
  logic [LOG2_BUFF_DEPTH-1:0]   req_count;
  logic [LOG2_BUFF_DEPTH-1:0]   next_req_count;
  logic [LOG2_BUFF_DEPTH-1:0]   emi_req_os_count;
  logic [LOG2_BUFF_DEPTH-1:0]   next_emi_req_os_count;
  logic [LOG2_BUFF_DEPTH-1:0]   resp_count;
  logic [LOG2_BUFF_DEPTH-1:0]   next_resp_count;  
  logic [LOG2_BUFF_DEPTH-1:0]   emi_req_os_at_flush;
  logic [LOG2_BUFF_DEPTH-1:0]   emi_req_os_count_at_flush;
  logic                         flush_req_os;
  logic                         alloc_resp_qual;
  logic                         resp_complete_qual;
  logic                         alloc_req_qual;
  logic                         req_flush;
  
  logic [I_ADDR_WIDTH-1:0]      buff_entry_addr_req[BUFF_DEPTH-1:0] /* synthesis syn_ramstyle="registers" */;
  logic [BUFF_DEPTH-1:0]        buff_entry_hword_high_only_req;
  logic [31:0]                  buff_entry_data_resp[BUFF_DEPTH-1:0] /* synthesis syn_ramstyle="registers" */;
  logic [RESP_ERROR_WIDTH-1:0]  buff_entry_error_resp[BUFF_DEPTH-1:0] /* synthesis syn_ramstyle="registers" */;


  logic [31:0]                    curr_head_data_resp;
  logic [31:0]                    next_head_data_resp;
  logic [31:0]                    buff_resp_head_data_resp_compressed;       
  logic [31:0]                    buff_resp_head_data_resp_uncompressed_full;
  logic [31:0]                    buff_resp_head_data_resp_uncompressed_half;
  logic [31:0]                    buff_resp_head_data_resp;

  logic [RESP_ERROR_WIDTH-1:0]    curr_head_error_resp;
  logic [RESP_ERROR_WIDTH-1:0]    next_head_error_resp;  
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp_compressed;       
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp_uncompressed_full;
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp_uncompressed_half;
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp;

//******************************************************************************
// Main code

  //when allocating a fence i request, the aib is just used as a holding register so doesn't change pointers or counts
  // the next read after the fence hold is released will use this as the fetch_ptr (even though it indicates the buffer is empty)
  
  assign alloc_req_qual  = alloc_req & ~alloc_req_fence_i;
  assign alloc_resp_qual = (MI_I_MEM) ? alloc_resp : alloc_resp & no_flush_req_os;
  assign resp_complete_qual = resp_complete & no_flush_req_os;
  
  // need to differentiate between branch flushes and pipe flushes (pipe flushes take priority)
  // Branch flush still allows a new request to be made in the same cycle as the branch flush,
  // pipe flush completely flushes including new requests made in the flush cycle.
  
  assign req_flush = req_flush_branch | req_flush_pipe;

  
  assign next_buff_req_wr_ptr = (buff_req_wr_ptr[LOG2_BUFF_DEPTH-1:0] == BUFF_DEPTH-1) ? {LOG2_BUFF_DEPTH{1'b0}} : (buff_req_wr_ptr + 'd1);
                                              
  assign next_buff_resp_wr_ptr = alloc_resp_qual   ? ((buff_resp_wr_ptr[LOG2_BUFF_DEPTH-1:0] == BUFF_DEPTH-1) ? {LOG2_BUFF_DEPTH{1'b0}} : buff_resp_wr_ptr + 'd1) : 
                                                buff_resp_wr_ptr;                                         
                                                 
  assign buff_resp_rd_ptr_plus_one = (buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0] == BUFF_DEPTH-1) ? {LOG2_BUFF_DEPTH{1'b0}} : buff_resp_rd_ptr + 'd1;                                                    
                                                                                               
  assign next_buff_resp_rd_ptr = resp_complete_qual ? buff_resp_rd_ptr_plus_one : 
                                                      buff_resp_rd_ptr;
                                                 
// when flushing, all pointers revert to buff_req_wr_ptr (except buff_req_wr_ptr!)
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_req_wr_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(alloc_req_qual & ~req_flush_pipe)  // can still allocate a new branch request when flushing 
        buff_req_wr_ptr <= next_buff_req_wr_ptr;
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_resp_wr_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(req_flush)  
        buff_resp_wr_ptr <= buff_req_wr_ptr;
      else if(alloc_resp_qual)
        buff_resp_wr_ptr <= next_buff_resp_wr_ptr;
  end
  
  // buff_req_rd_ptr is the pointer to the latest fetched instruction (this is effectively fetch_ptr)
  // always follows the req write pointer
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_req_rd_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(req_flush | alloc_req_qual)
        buff_req_rd_ptr <= buff_req_wr_ptr;
  end
  
  
  // buff_resp_rd_ptr is the next response to return to the expipe
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_resp_rd_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(req_flush)
        buff_resp_rd_ptr <= buff_req_wr_ptr;
      else if(resp_complete_qual)
        buff_resp_rd_ptr <= next_buff_resp_rd_ptr;
  end
  
  // request/response counters 
  always @*
  begin
    case({alloc_req_qual,resp_complete_qual})
      2'b00 : next_req_count = req_count;
      2'b01 : next_req_count = req_count - 'd1; 
      2'b10 : next_req_count = req_count + 'd1;
      2'b11 : next_req_count = req_count;
      default : next_req_count = {LOG2_BUFF_DEPTH{1'b0}};    
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      req_count <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      req_count <= req_flush ? ((alloc_req_qual & ~req_flush_pipe) ? 'd1 : {LOG2_BUFF_DEPTH{1'b0}}) : next_req_count;  
  end
  
  // will still generate an emi request whether flush is occuring or not (because do not suppress emi_req for timing reasons)
  // so still need to count flushing requests
  always @*
  begin
    case({alloc_req_qual,alloc_resp})
      2'b00 : next_emi_req_os_count = emi_req_os_count;
      2'b01 : next_emi_req_os_count = emi_req_os_count - 'd1; 
      2'b10 : next_emi_req_os_count = emi_req_os_count + 'd1;
      2'b11 : next_emi_req_os_count = emi_req_os_count;
      default : next_emi_req_os_count = {LOG2_BUFF_DEPTH{1'b0}};   
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      emi_req_os_count <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      emi_req_os_count <= next_emi_req_os_count;
  end
  
  always @*
  begin
    case({alloc_resp_qual,resp_complete_qual})
      2'b00 : next_resp_count = resp_count;
      2'b01 : next_resp_count = resp_count - 'd1; 
      2'b10 : next_resp_count = resp_count + 'd1;
      2'b11 : next_resp_count = resp_count;
      default : next_resp_count = {LOG2_BUFF_DEPTH{1'b0}};    
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      resp_count <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      resp_count <= req_flush ? {LOG2_BUFF_DEPTH{1'b0}} :  next_resp_count;
  end
  

  
  genvar i_buff;
  generate
  
  for(i_buff = 0; i_buff<BUFF_DEPTH; i_buff++)
  begin : gen_buff_loop

   //Initialization for Simulation
   initial
     begin
       buff_entry_addr_req[i_buff]               <= {I_ADDR_WIDTH{1'b0}};
     end
    
    always @(posedge clk)
    begin
      if(alloc_req & ~req_flush_pipe & (buff_req_wr_ptr[LOG2_BUFF_DEPTH-1:0] == i_buff[LOG2_BUFF_DEPTH-1:0]))
      begin
        buff_entry_addr_req[i_buff]               <= alloc_req_addr;
        buff_entry_hword_high_only_req[i_buff]    <= alloc_req_hword_high;
      end
    end  
    
    always @(posedge clk)
    begin
      if(alloc_resp_qual & (buff_resp_wr_ptr[LOG2_BUFF_DEPTH-1:0] == i_buff[LOG2_BUFF_DEPTH-1:0]))
      begin
        buff_entry_data_resp[i_buff]               <= alloc_resp_data;
        buff_entry_error_resp[i_buff]              <= alloc_resp_error;
      end
    end 
    
  end
  endgenerate 
  
  assign buff_curr_fetch_ptr   = buff_entry_addr_req[buff_req_rd_ptr];
  assign buff_full             = req_count == BUFF_DEPTH;
  assign buff_empty            = req_count == {LOG2_BUFF_DEPTH{1'b0}};  
  assign buff_resp_empty       = resp_count == {LOG2_BUFF_DEPTH{1'b0}}; 
  assign buff_fill_level       = req_count;
  assign num_emi_req_os        = emi_req_os_count;
  assign emi_req_os            = ( emi_req_os_count != {LOG2_BUFF_DEPTH{1'b0}}) | flush_req_os; 
  
  // need to drop all outstanding responses still in flight after a flush
  // except request allocated in the flush cycle if a branch flush
  
  always @*
  begin
    case({(alloc_req_qual & req_flush_pipe),alloc_resp})
      2'b00 : emi_req_os_count_at_flush = emi_req_os_count;
      2'b01 : emi_req_os_count_at_flush = emi_req_os_count - 'd1; 
      2'b10 : emi_req_os_count_at_flush = emi_req_os_count + 'd1;
      2'b11 : emi_req_os_count_at_flush = emi_req_os_count;
      default : emi_req_os_count_at_flush = {LOG2_BUFF_DEPTH{1'b0}};   
    endcase
  end
  
    always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      emi_req_os_at_flush <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      emi_req_os_at_flush <= req_flush ? emi_req_os_count_at_flush: 
                                        (alloc_resp & (emi_req_os_at_flush != {LOG2_BUFF_DEPTH{1'b0}})) ? emi_req_os_at_flush -'d1 :
                                                                                  emi_req_os_at_flush;
  end
  
  assign no_flush_req_os = (emi_req_os_at_flush == {LOG2_BUFF_DEPTH{1'b0}});
  assign flush_req_os    = ~no_flush_req_os;
  
  
  assign curr_head_data_resp                        = buff_entry_data_resp[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
  assign next_head_data_resp                        = buff_entry_data_resp[buff_resp_rd_ptr_plus_one[LOG2_BUFF_DEPTH-1:0]];
  assign curr_head_error_resp                       = buff_entry_error_resp[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
  assign next_head_error_resp                       = buff_entry_error_resp[buff_resp_rd_ptr_plus_one[LOG2_BUFF_DEPTH-1:0]];

  assign buff_resp_head_compressed                  = ~buff_empty & ((iab_rd_alignment == iab_rd_alignment_hword) ? (curr_head_data_resp[17:16] != 2'b11) : 
                                                                                                                    (curr_head_data_resp[1:0] != 2'b11));
  assign buff_resp_head_uncompressed_full           = (~buff_empty & (iab_rd_alignment == iab_rd_alignment_word) & (curr_head_data_resp[1:0] == 2'b11)) |
                                                      ((resp_count >= 'd2) & (iab_rd_alignment == iab_rd_alignment_hword) & (curr_head_data_resp[17:16] == 2'b11));
  assign buff_resp_head_uncompressed_half           = ((resp_count == 'd1) & (iab_rd_alignment == iab_rd_alignment_hword) & (curr_head_data_resp[17:16] == 2'b11));  
  
  assign buff_resp_head_data_resp_compressed        = (iab_rd_alignment == iab_rd_alignment_hword) ? {{16{1'b0}}, curr_head_data_resp [31:16]} : {{16{1'b0}}, curr_head_data_resp [15:0]};
  assign buff_resp_head_data_resp_uncompressed_full = (iab_rd_alignment == iab_rd_alignment_word) ? curr_head_data_resp : {next_head_data_resp[15:0],curr_head_data_resp [31:16]};
  assign buff_resp_head_data_resp_uncompressed_half = {{16{1'b0}},curr_head_data_resp [31:16]};
  
  assign buff_resp_head_data_resp                   = ({32{buff_resp_head_compressed}}        & buff_resp_head_data_resp_compressed) |
                                                      ({32{buff_resp_head_uncompressed_full}} & buff_resp_head_data_resp_uncompressed_full) |
                                                      ({32{buff_resp_head_uncompressed_half}} & buff_resp_head_data_resp_uncompressed_half);                                                      
                                                      
  assign buff_resp_head_error_resp_compressed        = curr_head_error_resp;
  assign buff_resp_head_error_resp_uncompressed_full = (iab_rd_alignment == iab_rd_alignment_word) ? curr_head_error_resp : (curr_head_error_resp | next_head_error_resp);
  assign buff_resp_head_error_resp_uncompressed_half = curr_head_error_resp;

  assign buff_resp_head_error_resp                   = ({RESP_ERROR_WIDTH{buff_resp_head_compressed}}        & buff_resp_head_error_resp_compressed) |
                                                       ({RESP_ERROR_WIDTH{buff_resp_head_uncompressed_full}} & buff_resp_head_error_resp_uncompressed_full) |
                                                       ({RESP_ERROR_WIDTH{buff_resp_head_uncompressed_half}} & buff_resp_head_error_resp_uncompressed_half);

  assign buff_resp_head_data                         = buff_resp_head_data_resp;
  assign buff_resp_head_error                        = buff_resp_head_error_resp;
  assign buff_resp_head_addr                         = buff_entry_addr_req[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
  assign buff_resp_head_addr_valid                   = ~buff_empty;
  assign buff_resp_head_hword_high_only              = buff_entry_hword_high_only_req[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
 
 
                          

//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  assert_ifu_iab_head_type_onehot0: assert property (@(posedge clk) disable iff (~resetn)
                                                     $onehot0({buff_resp_head_compressed,buff_resp_head_uncompressed_full,buff_resp_head_uncompressed_half}));
                                                                             
  assert_ifu_iab_no_alloc_req_if_full: assert property (@(posedge clk) disable iff (~resetn)
                                                        alloc_req |-> (!buff_full) | req_flush);
                                                                                                                
  assert_ifu_iab_no_alloc_resp_if_no_req: assert property (@(posedge clk) disable iff (~resetn)
                                                           alloc_resp_qual |-> (req_count >= {LOG2_BUFF_DEPTH{1'b0}}));      
                                                                                                                                                                       
  assert_ifu_iab_no_dealloc_resp_if_empty: assert property (@(posedge clk) disable iff (~resetn)                            
                                                      resp_complete_qual |-> !buff_empty);

  assert_ifu_iab_empt_resp_not_empty: assert property (@(posedge clk) disable iff (~resetn)
                                                        buff_empty |-> buff_resp_empty);
                                                        

                                                    
`endif
 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_lsu.sv
//
//   Purpose: core Load-Store Unit
//
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_hart_cfg_pkg::*;

module miv_rv32_lsu
  //****************************************************************************
  // Parameter description
  #(
    parameter D_ADDR_WIDTH          = 32

   )
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,         
  input  wire logic                                resetn, 
  
  input  wire logic                                parity_en,
  
  input  wire logic                                lsu_flush,
  output      logic                                lsu_op_os,
  output      logic                                lsu_ld_op_os,   
  output      logic                                lsu_fence_op_os,
  
  // External memory interface
  output      logic                                lsu_emi_req_valid,
  input wire  logic                                lsu_emi_req_ready, 
  output      logic [3:0]                          lsu_emi_req_rd_byte_en,  
  output      logic [3:0]                          lsu_emi_req_wr_byte_en,
  output      logic [31:0]                         lsu_emi_req_addr,
  output      logic                                lsu_emi_req_addr_p,
  output      logic                                lsu_emi_req_fence,
  output      logic                                lsu_emi_req_read,
  output      logic                                lsu_emi_req_write,
  output      logic [31:0]                         lsu_emi_req_wr_data,
  output      logic [3:0]                          lsu_emi_req_wr_data_p,

  input wire  logic                                lsu_emi_resp_valid,
  output      logic                                lsu_emi_resp_ready,
  input wire  logic                                lsu_emi_resp_error,
  input wire  logic [31:0]                         lsu_emi_resp_rd_data,
  input wire  logic [3:0]                          lsu_emi_resp_rd_data_p,
  // expipe interface
  
  input wire  logic                                lsu_expipe_req_valid,  
  output      logic                                lsu_expipe_req_ready,  
  input wire  logic[D_ADDR_WIDTH-1:0]              lsu_expipe_req_addr,
  input wire  logic                                lsu_expipe_req_addr_valid,
  input wire  logic [31:0]                         lsu_expipe_req_wr_data,
  input wire  logic                                lsu_expipe_req_wr_data_valid, 
  input wire  t_lsu_op                             lsu_expipe_req_op,   
   
  output      logic                                lsu_expipe_resp_valid,
  input wire  logic                                lsu_expipe_resp_ready,       
  output      logic [31:0]                         lsu_expipe_resp_rd_data,
  output      logic                                lsu_expipe_resp_ld_addr_misalign,
  output      logic                                lsu_expipe_resp_ld_access_fault,
  output      logic                                lsu_expipe_resp_str_amo_addr_misalign,
  output      logic                                lsu_expipe_resp_str_amo_access_fault,
  output      logic                                lsu_expipe_resp_access_mem_error,
  output      logic                                lsu_expipe_resp_access_parity_error,
  output      logic                                lsu_expipe_resp_access_aborted
  );
   


  
//******************************************************************************
// Declarations

  localparam REQ_BUFF_DEPTH        = 2;
  localparam LOG2_REQ_BUFF_DEPTH   = 1;
  localparam OS_COUNT_WIDTH        = 2;
  localparam MAX_OS                = 2;
  

  logic                               expipe_req_accepted;
  logic                               req_buff_ready;
  logic                               alloc_req_buff;      
  logic                               dealloc_resp_buff;   
  t_lsu_op                            alloc_req_buff_state;
  t_lsu_op                            req_buff_resp_state[REQ_BUFF_DEPTH-1:0];     
  logic [1:0]                         req_buff_resp_addr_align[REQ_BUFF_DEPTH-1:0]; 
  logic [3:0]                         req_buff_resp_fault[REQ_BUFF_DEPTH-1:0];  
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_resp_state_valid;  
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_resp_drop;
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_resp_exception_os;
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_load_os;
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_fence_os;
  logic [LOG2_REQ_BUFF_DEPTH-1:0]     buff_rd_ptr;  
  logic [LOG2_REQ_BUFF_DEPTH-1:0]     buff_wr_ptr;
  logic [REQ_BUFF_DEPTH-1:0]          buff_rd_strb; 
  logic [REQ_BUFF_DEPTH-1:0]          buff_wr_strb;
  t_lsu_op                            req_resp_state;
  logic [1:0]                         req_resp_addr_align;  
  logic [3:0]                         req_resp_fault;
  logic                               req_resp_drop;
  logic                               req_resp_state_valid;  
  logic                               req_resp_ld_req_buff_access_fault;
  logic                               req_resp_ld_req_buff_addr_misalign;
  logic                               req_resp_str_req_buff_access_fault;
  logic                               req_resp_str_req_buff_addr_misalign;
  logic                               req_resp_exception;
  logic                               lsu_emi_req_accepted;
  logic                               lsu_emi_resp_accepted;
  logic                               lsu_emi_resp_accepted_qual;
  logic [OS_COUNT_WIDTH-1:0]          emi_req_os_count;
  logic [OS_COUNT_WIDTH-1:0]          next_emi_req_os_count;
  logic [OS_COUNT_WIDTH-1:0]          emi_req_os_count_at_flush;
  logic [OS_COUNT_WIDTH-1:0]          next_emi_req_os_count_at_flush;
  logic                               inc_os_count;
  logic                               dec_os_count;
  logic                               emi_req_os_at_flush;
  logic                               next_emi_req_os;

  logic                               alloc_ld_req_buff_addr_misalign;
  logic                               alloc_ld_req_buff_access_fault; 
  logic                               alloc_str_req_buff_addr_misalign;
  logic                               alloc_str_req_buff_access_fault;
  logic                               alloc_exception;
  logic                               exception_os;
  logic [1:0]                         alloc_req_addr_align;
  logic [3:0]                         alloc_req_fault;
  
  logic [63:0]                        lsu_emi_resp_rd_data_double_s;
  logic [63:0]                        lsu_emi_resp_rd_data_double_u;
  
  logic                               lsu_resp_valid;                 
  logic [31:0]                        lsu_resp_rd_data;               
  logic                               lsu_resp_access_mem_error;      
  logic                               lsu_resp_access_parity_error; 
  logic                               lsu_resp_ld_req_buff_access_fault;  
  logic                               lsu_resp_ld_req_buff_addr_misalign; 
  logic                               lsu_resp_str_req_buff_access_fault; 
  logic                               lsu_resp_str_req_buff_addr_misalign;  
  logic [3:0]                         lsu_emi_resp_byte_parity_error;
 

  
//******************************************************************************
// Main code

// When a request is accepted, put it in the request buffer (required in order to know what to do 
// with the response in the retr stage)

// Core LSU is intended for simple memory systems, therefore all requests must complete in order, including
// reads and writes. RISC-V memory model does not require this, therefore the subsystem may choose to 
// reorder read and write requests without causal dependencies by indicating to the core that the 
// request has completed, though it must do so with the response in the order requested
// The subsystem may also choose to provide an early response for writes. In this case it is responsible for ensuring
// read-after-write ordering of requests.

// Allocate req buffer when memory accepts a request (all request types)           
  
  assign expipe_req_accepted    = lsu_expipe_req_valid & lsu_expipe_req_ready;  
  
  assign req_buff_ready         = ~(&req_buff_resp_state_valid); 
  assign lsu_expipe_req_ready   = req_buff_ready &    
                                  (lsu_emi_req_ready | alloc_exception) &
                                  ~exception_os;   
                                  
  
  assign lsu_op_os               = |req_buff_resp_state_valid;   
  assign lsu_ld_op_os            = |req_buff_load_os;  
  assign lsu_fence_op_os         = |req_buff_fence_os;  
  
  // compute parity error
  
  assign lsu_emi_resp_byte_parity_error = {4{parity_en}} & {((^lsu_emi_resp_rd_data[31:24]) != lsu_emi_resp_rd_data_p[3]),
                                                            ((^lsu_emi_resp_rd_data[23:16]) != lsu_emi_resp_rd_data_p[2]),
                                                            ((^lsu_emi_resp_rd_data[15:8]) != lsu_emi_resp_rd_data_p[1]),
                                                            ((^lsu_emi_resp_rd_data[7:0]) != lsu_emi_resp_rd_data_p[0])};
                         
  always @*
  begin
    case(lsu_expipe_req_op)
      lsu_op_none : 
      begin
        lsu_emi_req_valid                  = 1'b0;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b0000;
        lsu_emi_req_fence                  = 1'b0;
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b0;
        alloc_req_buff                     = 1'b0;         
        alloc_ld_req_buff_addr_misalign    = 1'b0; 
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_ld_byte_s : 
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1:0]  == 2'b00) ? 4'b0001 :
                                               (lsu_expipe_req_addr[1:0]  == 2'b01) ? 4'b0010 :
                                                 (lsu_expipe_req_addr[1:0]  == 2'b10) ? 4'b0100 :
                                                   (lsu_expipe_req_addr[1:0]  == 2'b11) ? 4'b1000 : 4'b0000) &
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000;          
        lsu_emi_req_fence                  = 1'b0;  
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush)); 
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
                 
      lsu_op_ld_hword_s : 
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1]  == 1'b0) ? 4'b0011 :
                                               (lsu_expipe_req_addr[1]  == 1'b1) ? 4'b1100 : 4'b0000 ) &
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0; 
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));   
        alloc_ld_req_buff_addr_misalign    = lsu_expipe_req_addr[0] == 1'b1;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
          
      lsu_op_ld_word :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b1111 & {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;   
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));    
        alloc_ld_req_buff_addr_misalign    = lsu_expipe_req_addr[1:0] != 2'b00; 
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_ld_byte_u :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1:0]  == 2'b00) ? 4'b0001 :
                                               (lsu_expipe_req_addr[1:0]  == 2'b01) ? 4'b0010 :
                                                 (lsu_expipe_req_addr[1:0]  == 2'b10) ? 4'b0100 :
                                                   (lsu_expipe_req_addr[1:0]  == 2'b11) ? 4'b1000 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;  
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));    
        alloc_ld_req_buff_addr_misalign    = 1'b0; 
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_ld_hword_u :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1]  == 1'b0) ? 4'b0011 :
                                               (lsu_expipe_req_addr[1]  == 1'b1) ? 4'b1100 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;  
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;    
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));        
        alloc_ld_req_buff_addr_misalign    = lsu_expipe_req_addr[0] == 1'b1;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_str_byte :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = ((lsu_expipe_req_addr[1:0]  == 2'b00) ? 4'b0001 :
                                               (lsu_expipe_req_addr[1:0]  == 2'b01) ? 4'b0010 :
                                                 (lsu_expipe_req_addr[1:0]  == 2'b10) ? 4'b0100 :
                                                   (lsu_expipe_req_addr[1:0]  == 2'b11) ? 4'b1000 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b1;    
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));    
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_str_hword :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = ((lsu_expipe_req_addr[1]  == 1'b0) ? 4'b0011 :
                                               (lsu_expipe_req_addr[1]  == 1'b1) ? 4'b1100 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_fence                  = 1'b0;    
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b1; 
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));  
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = lsu_expipe_req_addr[0] == 1'b1; 
      end
      
      lsu_op_str_word :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b1111 & {4{~alloc_exception}};
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b1;  
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush)); 
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = lsu_expipe_req_addr[1:0] != 2'b00;
      end
      
      // Fence will be implemented like a non-posted write with no strobes (also marked a fence)
      // external memory will respond when all preceding memory operations complete
      lsu_op_fence :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b0000;
        lsu_emi_req_fence                  = 1'b1;    
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b0;   
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));        
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      default :     
      begin
        lsu_emi_req_valid                  = 1'b0;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b0000;
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b0;    
        alloc_req_buff                     = 1'b0;       
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
    endcase    
  end
  
    // no memory management/protection supported in core
  assign alloc_ld_req_buff_access_fault     = 1'b0; 
  assign alloc_str_req_buff_access_fault    = 1'b0;
  
  assign alloc_exception      = alloc_ld_req_buff_access_fault |
                                alloc_ld_req_buff_addr_misalign |
                                alloc_str_req_buff_access_fault |
                                alloc_str_req_buff_addr_misalign;
  
  assign lsu_emi_req_addr      = lsu_expipe_req_addr;
  assign lsu_emi_req_addr_p    = (^lsu_expipe_req_addr) & parity_en;
  assign lsu_emi_req_wr_data   = lsu_expipe_req_wr_data;
  assign lsu_emi_req_wr_data_p = {(^lsu_expipe_req_wr_data[31:24]),(^lsu_expipe_req_wr_data[23:16]),(^lsu_expipe_req_wr_data[15:8]),(^lsu_expipe_req_wr_data[7:0])} & {4{parity_en}};
  
  assign alloc_req_buff_state = lsu_expipe_req_op;         
  assign alloc_req_addr_align = lsu_expipe_req_addr[1:0];  
  assign alloc_req_fault      = {alloc_ld_req_buff_access_fault,
                                 alloc_ld_req_buff_addr_misalign,
                                 alloc_str_req_buff_access_fault,
                                 alloc_str_req_buff_addr_misalign};
//  assign dealloc_resp_buff    = lsu_expipe_resp_valid;


// request buffer
// store request here and match with response
// EMI response must always be 1 or more cycles after request
// Optionally implement as 2 entry buffer, even though only one request max outstanding
// So that request timing can be decoupled from response
// 


  logic [LOG2_REQ_BUFF_DEPTH-1:0] next_buff_rd_ptr;
  logic [LOG2_REQ_BUFF_DEPTH-1:0] next_buff_wr_ptr;
  
  assign next_buff_rd_ptr = (buff_rd_ptr == (REQ_BUFF_DEPTH-1)) ? {LOG2_REQ_BUFF_DEPTH{1'b0}} : buff_rd_ptr+'d1;
  assign next_buff_wr_ptr = (buff_wr_ptr == (REQ_BUFF_DEPTH-1)) ? {LOG2_REQ_BUFF_DEPTH{1'b0}} : buff_wr_ptr+'d1;

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_rd_ptr <= {LOG2_REQ_BUFF_DEPTH{1'b0}};
    else
      if(dealloc_resp_buff)
        buff_rd_ptr <= next_buff_rd_ptr;
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_wr_ptr <= {LOG2_REQ_BUFF_DEPTH{1'b0}};
    else
      if(alloc_req_buff)
        buff_wr_ptr <= next_buff_wr_ptr;
  end
  


  genvar i_req_buff;
  generate
  
  for(i_req_buff = 0; i_req_buff<REQ_BUFF_DEPTH; i_req_buff++)
  begin : gen_req_buff_loop
  
  
    assign buff_wr_strb[i_req_buff] = alloc_req_buff & (buff_wr_ptr == i_req_buff[LOG2_REQ_BUFF_DEPTH-1:0]);
    assign buff_rd_strb[i_req_buff] = dealloc_resp_buff & (buff_rd_ptr == i_req_buff[LOG2_REQ_BUFF_DEPTH-1:0]);
    
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
      begin
        req_buff_resp_fault[i_req_buff]       <= 4'b0000;
      end
      else
        if(buff_wr_strb[i_req_buff]) // still update even if flushing, because use this to drop requests with exceptions at allocation
        begin
          req_buff_resp_fault[i_req_buff]       <= alloc_req_fault;
        end
    end  
    
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
      begin
        req_buff_resp_state[i_req_buff]       <= lsu_op_none;
        req_buff_resp_addr_align[i_req_buff]  <= 2'b00;
        req_buff_resp_drop[i_req_buff]        <= 1'b0;
      end
      else
        if(lsu_flush)
        begin
          req_buff_resp_state[i_req_buff]       <= lsu_op_none;
          req_buff_resp_addr_align[i_req_buff]  <= 2'b00;
          req_buff_resp_drop[i_req_buff]        <= 1'b1;
        end 
        else if(buff_wr_strb[i_req_buff])
        begin
          req_buff_resp_state[i_req_buff]       <= alloc_req_buff_state;
          req_buff_resp_addr_align[i_req_buff]  <= alloc_req_addr_align;
          req_buff_resp_drop[i_req_buff]        <= 1'b0;
        end
    end  
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        req_buff_resp_state_valid[i_req_buff] <= 1'b0;
      else
        req_buff_resp_state_valid[i_req_buff] <= (req_buff_resp_state_valid[i_req_buff] & ~buff_rd_strb[i_req_buff]) | buff_wr_strb[i_req_buff];
    end 
  
    assign req_buff_resp_exception_os[i_req_buff] = req_buff_resp_state_valid[i_req_buff] & (|req_buff_resp_fault[i_req_buff]);
    assign req_buff_load_os[i_req_buff] = ((req_buff_resp_state[i_req_buff] == lsu_op_ld_byte_s)  |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_hword_s) |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_word)    |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_byte_u)  |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_hword_u)) & req_buff_resp_state_valid[i_req_buff];
    
    assign req_buff_fence_os[i_req_buff] = (req_buff_resp_state[i_req_buff] == lsu_op_fence) & req_buff_resp_state_valid[i_req_buff];
    
  end
  endgenerate 
  
  // block emi requests and do not accept new request from expipe when an entry in the response buffer will cause an exception
  // (simplifies exception handling and reduces timing pressure on exception flushing in the expipe)  
  assign exception_os                          = |req_buff_resp_exception_os;  
  
  assign req_resp_state                        = req_buff_resp_state[buff_rd_ptr];     
  assign req_resp_addr_align                   = req_buff_resp_addr_align[buff_rd_ptr];
  assign {req_resp_ld_req_buff_access_fault,      
          req_resp_ld_req_buff_addr_misalign,
          req_resp_str_req_buff_access_fault,
          req_resp_str_req_buff_addr_misalign} = req_buff_resp_fault[buff_rd_ptr]; 
  assign req_resp_state_valid                  = req_buff_resp_state_valid[buff_rd_ptr];
  assign req_resp_drop                         = req_buff_resp_drop[buff_rd_ptr];
  
  assign req_resp_exception                    = |req_buff_resp_fault[buff_rd_ptr];
  
  // Return response when emi responds if something in or allocating to the buffer (for a load, store, or fence), otherwise respond straight away  in retr stage  
  // if a request is not expecting an emi response (align error, access fault)        
  // May get a response not associated with a request buffer entry if a reset occurs after a request but before a response,
  // to avoid deadlock, drop such responses silently.
  

  
  assign lsu_emi_resp_ready = 1'b1;
  assign lsu_emi_resp_accepted = lsu_emi_resp_valid & lsu_emi_resp_ready;  
  assign lsu_emi_resp_accepted_qual = lsu_emi_resp_accepted; // & ~emi_req_os_at_flush;  // mask with emi_req_os_at_flush so unmatched responses are dropped
  
  assign lsu_emi_resp_rd_data_double_s = {{32{lsu_emi_resp_rd_data[31]}},lsu_emi_resp_rd_data};
  assign lsu_emi_resp_rd_data_double_u = {{32{1'b0}},lsu_emi_resp_rd_data};
  
  
   always @*
  begin
    case(req_resp_state)
      
      lsu_op_ld_byte_s :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = (req_resp_addr_align == 2'b00) ? {{24{lsu_emi_resp_rd_data[7]}},lsu_emi_resp_rd_data[7:0]} :
                                               (req_resp_addr_align == 2'b01) ? {{24{lsu_emi_resp_rd_data[15]}},lsu_emi_resp_rd_data[15:8]} :
                                               (req_resp_addr_align == 2'b10) ? {{24{lsu_emi_resp_rd_data[23]}},lsu_emi_resp_rd_data[23:16]} :
                                                                                {{24{lsu_emi_resp_rd_data[31]}},lsu_emi_resp_rd_data[31:24]};         
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (req_resp_addr_align == 2'b00) ? lsu_emi_resp_byte_parity_error[0] :
                                               (req_resp_addr_align == 2'b01) ? lsu_emi_resp_byte_parity_error[1] :
                                               (req_resp_addr_align == 2'b10) ? lsu_emi_resp_byte_parity_error[2] :
                                                                                lsu_emi_resp_byte_parity_error[3];  
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end  
      lsu_op_ld_hword_s :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = lsu_emi_resp_rd_data_double_s[(16*req_resp_addr_align[1])+:32]; 
        lsu_resp_rd_data                     = (req_resp_addr_align[1] == 1'b0) ? {{16{lsu_emi_resp_rd_data[15]}},lsu_emi_resp_rd_data[15:0]} :
                                                                                  {{16{lsu_emi_resp_rd_data[31]}},lsu_emi_resp_rd_data[31:16]};
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (req_resp_addr_align[1] == 1'b0) ? (|lsu_emi_resp_byte_parity_error[1:0]) :
                                                                                  (|lsu_emi_resp_byte_parity_error[3:2]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end 
      lsu_op_ld_word :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = lsu_emi_resp_rd_data;
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (|lsu_emi_resp_byte_parity_error[3:0]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end    
      lsu_op_ld_byte_u :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = (req_resp_addr_align == 2'b00) ? {{24{1'b0}},lsu_emi_resp_rd_data[7:0]} :
                                               (req_resp_addr_align == 2'b01) ? {{24{1'b0}},lsu_emi_resp_rd_data[15:8]} :
                                               (req_resp_addr_align == 2'b10) ? {{24{1'b0}},lsu_emi_resp_rd_data[23:16]} :
                                                                                {{24{1'b0}},lsu_emi_resp_rd_data[31:24]};  
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (|lsu_emi_resp_byte_parity_error[3:0]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end  
      lsu_op_ld_hword_u :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = (req_resp_addr_align[1] == 1'b0) ? {{16{1'b0}},lsu_emi_resp_rd_data[15:0]} :
                                                                                  {{16{1'b0}},lsu_emi_resp_rd_data[31:16]};
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (req_resp_addr_align[1] == 1'b0) ? (|lsu_emi_resp_byte_parity_error[1:0]) :
                                                                                  (|lsu_emi_resp_byte_parity_error[3:2]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end 
      
      lsu_op_fence :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid); // fence waits until memory response
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end 
      
      lsu_op_str_byte :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid;
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = req_resp_str_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_str_req_buff_addr_misalign  = req_resp_str_req_buff_addr_misalign & req_resp_state_valid;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;          
      end
      
      lsu_op_str_hword :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid;
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = req_resp_str_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_str_req_buff_addr_misalign  = req_resp_str_req_buff_addr_misalign & req_resp_state_valid;  
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;  
      end
      
      lsu_op_str_word :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid;
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = req_resp_str_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_str_req_buff_addr_misalign  = req_resp_str_req_buff_addr_misalign & req_resp_state_valid;  
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;   
      end
      
      lsu_op_none :
      begin
        lsu_resp_valid                       = 1'b0;
        lsu_resp_rd_data                     = {32{1'b0}};
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = req_resp_drop & req_resp_state_valid & (lsu_emi_resp_accepted | req_resp_exception);
      end
           
      default :
      begin
        lsu_resp_valid                       = 1'b0;
        lsu_resp_rd_data                     = {32{1'b0}};
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = 1'b0;
      end 
    endcase
  end                                      
  
  assign lsu_expipe_resp_valid                        = lsu_resp_valid;               
  assign lsu_expipe_resp_rd_data                      = lsu_resp_rd_data;       
  assign lsu_expipe_resp_ld_addr_misalign             = lsu_resp_ld_req_buff_addr_misalign;
  assign lsu_expipe_resp_ld_access_fault              = lsu_resp_ld_req_buff_access_fault;
  assign lsu_expipe_resp_str_amo_addr_misalign        = lsu_resp_str_req_buff_addr_misalign;
  assign lsu_expipe_resp_str_amo_access_fault         = lsu_resp_str_req_buff_access_fault;
  assign lsu_expipe_resp_access_mem_error             = lsu_resp_access_mem_error;
  assign lsu_expipe_resp_access_parity_error          = lsu_resp_access_parity_error;
  assign lsu_expipe_resp_access_aborted               = 1'b0; 
  

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  localparam MAX_SEQ_LEN = 10;

  logic [1:0]  prop_trx_os;
  logic [1:0]  prop_next_trx_os;
  logic        prop_resp_is_ld;
  logic        prop_req_is_str;
  logic        prop_req_is_ld;
  logic        prop_resp_is_fence;
  logic        prop_resp_is_str;
  logic        prop_resp_is_dropped;
  logic        prop_ld_str_req_align_access_error;
  logic        prop_mem_parity_error;
  logic        prop_lsu_emi_req_accepted;
  logic        prop_expipe_req_accepted;
  logic        prop_expipe_resp_accepted;
  
  assign prop_lsu_emi_req_accepted   = lsu_emi_req_valid & lsu_emi_req_ready;
  assign prop_expipe_req_accepted    = lsu_expipe_req_valid & lsu_expipe_req_ready; 
  assign prop_expipe_resp_accepted   = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
  
  assign prop_resp_is_ld = ((req_resp_state == lsu_op_ld_byte_s)  |
                            (req_resp_state == lsu_op_ld_hword_s) |
                            (req_resp_state == lsu_op_ld_word)    |
                            (req_resp_state == lsu_op_ld_byte_u)  |
                            (req_resp_state == lsu_op_ld_hword_u) ) & req_resp_state_valid;

  assign prop_resp_is_str = ((req_resp_state == lsu_op_str_byte)  |
                             (req_resp_state == lsu_op_str_hword) |
                             (req_resp_state == lsu_op_str_word)  ) & req_resp_state_valid;                            
                            
                          
  assign prop_req_is_str = (lsu_expipe_req_op ==lsu_op_str_byte) |  
                           (lsu_expipe_req_op ==lsu_op_str_hword) | 
                           (lsu_expipe_req_op ==lsu_op_str_word);
                           
  assign prop_req_is_ld = (lsu_expipe_req_op == lsu_op_ld_byte_s)  |  
                           (lsu_expipe_req_op == lsu_op_ld_hword_s) | 
                           (lsu_expipe_req_op == lsu_op_ld_word)    |
                           (lsu_expipe_req_op == lsu_op_ld_byte_u)  |
                           (lsu_expipe_req_op == lsu_op_ld_hword_u) ;                          
                            
  assign prop_resp_is_fence = (req_resp_state == lsu_op_fence) & req_resp_state_valid; 
  
  assign prop_resp_is_dropped = (req_resp_state == lsu_op_none)& req_resp_drop & req_resp_state_valid ;     
  
  assign prop_ld_str_req_align_access_error =  lsu_expipe_resp_ld_addr_misalign |
                                               lsu_expipe_resp_ld_access_fault |
                                               lsu_expipe_resp_str_amo_addr_misalign |
                                               lsu_expipe_resp_str_amo_access_fault; 
                                                                                             
  assign prop_mem_parity_error = lsu_expipe_resp_access_mem_error | 
                                 lsu_expipe_resp_access_parity_error;
  
  
  // when the emi makes a request, must always be able to accept the response
  assert_lsu_req_must_allow_response: assert property (@(posedge clk) disable iff (~resetn)
                                                       lsu_emi_req_valid |->  ##1 lsu_emi_resp_ready);        
  
  // cannot have a response from store_reqerr and load_fence simultaneously
  //assert_lsu_single_response: assert property (@(posedge clk) disable iff (~resetn)
  //                                             $onehot0({lsu_store_reqerr_resp_valid , lsu_resp_valid}));
                                               
  
  // can only have an emi response for a load store or fence request
  assert_lsu_emi_response_ld_fence: assert property (@(posedge clk) disable iff (~resetn)
                                                     lsu_emi_resp_accepted_qual |->  prop_resp_is_ld | prop_resp_is_fence | prop_resp_is_str | prop_resp_is_dropped);     
                                                     
  // must be an emi request or error response when expipe request
  //assert_lsu_req_must_have_emireq_or_err: assert property (@(posedge clk) disable iff (~resetn)
  //                                                         prop_expipe_req_accepted |->  prop_lsu_emi_req_accepted | prop_ld_str_req_align_access_error);  
                                                                                                                                               
  
  // can only have a response if there is a request
  always @*
  begin
    case({prop_expipe_resp_accepted, prop_expipe_req_accepted})
      2'b00 : prop_next_trx_os = prop_trx_os;
      2'b01 : prop_next_trx_os = prop_trx_os + 2'd1;
      2'b10 : prop_next_trx_os = prop_trx_os - 2'd1;
      2'b11 : prop_next_trx_os = prop_trx_os;
      default : prop_next_trx_os = prop_trx_os;
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_trx_os <= 2'd0;
    else
      if(lsu_flush)
        prop_trx_os <= 2'd0;
      else
        prop_trx_os <= prop_next_trx_os;
  end
  
  assert_lsu_resp_only_if_req: assert property (@(posedge clk) disable iff (~resetn)
                                                prop_expipe_resp_accepted |-> (prop_trx_os > 2'd0));    
  
  // only up to REQ_BUFF_DEPTH requests outstanding
  assert_lsu_enough_buff_space: assert property (@(posedge clk) disable iff (~resetn)
                                           prop_expipe_req_accepted |-> (prop_trx_os < REQ_BUFF_DEPTH));
  

// emi response must always be 1 or more cycles after request  
  
// can never write and read the same req buff location at the same time


// if a request is presented to the LSU eventually it must be accepted
  assert_lsu_req_eventually_accepted: assert property (@(posedge clk) disable iff (~resetn)
                                                     (lsu_expipe_req_valid & ~lsu_flush) |-> ##[0:$] (lsu_expipe_req_valid & lsu_emi_req_ready));
                                                     
                                                     
// if a request is presented to the LSU eventually there will be a response
  assert_lsu_req_eventually_response: assert property (@(posedge clk) disable iff (~resetn)
                                                        (lsu_expipe_req_valid & ~lsu_flush) |-> ##[0:$] (lsu_expipe_resp_valid & lsu_expipe_resp_ready)); 
  //-------------                                                              
  // covers
  //------------
  
   sequence seq_any_req_consec(cycles);
      prop_lsu_emi_req_accepted[*cycles] ;
   endsequence
   
   sequence seq_any_req_nonconsec(cycles);
      prop_lsu_emi_req_accepted[->cycles] ;
   endsequence
   
   sequence seq_lb_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0001) |
                               (lsu_emi_req_rd_byte_en == 4'b0010) |  
                               (lsu_emi_req_rd_byte_en == 4'b0100) |
                               (lsu_emi_req_rd_byte_en == 4'b1000)))[*cycles] ;
   endsequence
   
   sequence seq_lb_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0001) |
                               (lsu_emi_req_rd_byte_en == 4'b0010) |  
                               (lsu_emi_req_rd_byte_en == 4'b0100) |
                               (lsu_emi_req_rd_byte_en == 4'b1000)))[->cycles] ;
   endsequence
   
   sequence seq_lh_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0011) |
                               (lsu_emi_req_rd_byte_en == 4'b1100)))[*cycles] ;
   endsequence
   
   sequence seq_lh_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0011) |
                               (lsu_emi_req_rd_byte_en == 4'b1100)))[->cycles] ;
   endsequence

   sequence seq_lw_req_consec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_rd_byte_en == 4'b1111))[*cycles] ;
   endsequence
   
   sequence seq_lw_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_rd_byte_en == 4'b1111))[->cycles] ;
   endsequence
   
   sequence seq_sb_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0001) |
                               (lsu_emi_req_wr_byte_en == 4'b0010) |  
                               (lsu_emi_req_wr_byte_en == 4'b0100) |
                               (lsu_emi_req_wr_byte_en == 4'b1000)))[*cycles] ;
   endsequence
   
   sequence seq_sb_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0001) |
                               (lsu_emi_req_wr_byte_en == 4'b0010) |  
                               (lsu_emi_req_wr_byte_en == 4'b0100) |
                               (lsu_emi_req_wr_byte_en == 4'b1000)))[->cycles] ;
   endsequence
   
   sequence seq_sh_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0011) |
                               (lsu_emi_req_wr_byte_en == 4'b1100)))[*cycles] ;
   endsequence
   
   sequence seq_sh_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0011) |
                               (lsu_emi_req_wr_byte_en == 4'b1100)))[->cycles] ;
   endsequence

   sequence seq_sw_req_consec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_wr_byte_en == 4'b1111))[*cycles] ;
   endsequence
   
   sequence seq_sw_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_wr_byte_en == 4'b1111))[->cycles] ;
   endsequence

   sequence seq_any_resp_consec(cycles);
      lsu_emi_resp_accepted_qual[*cycles] ;
   endsequence
     
   sequence seq_any_resp_nonconsec(cycles);
      lsu_emi_resp_accepted_qual[->cycles] ;
   endsequence
   
   sequence seq_any_resp_consec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & ~lsu_emi_resp_error)[*cycles] ;
   endsequence
     
   sequence seq_any_resp_nonconsec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & ~lsu_emi_resp_error)[->cycles] ;
   endsequence
   
   sequence seq_ld_resp_consec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & prop_resp_is_ld & ~lsu_emi_resp_error)[*cycles] ;
   endsequence
     
   sequence seq_ld_resp_nonconsec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & prop_resp_is_ld & ~lsu_emi_resp_error)[->cycles] ;
   endsequence

  genvar i_req_seq;
  generate  
  for (i_req_seq = 1; i_req_seq < MAX_SEQ_LEN; i_req_seq++) begin : gen_per_req_cover

    cover_req_seq_any_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_req_consec(i_req_seq));
                                                  
    cover_req_seq_any_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_req_nonconsec(i_req_seq));
                                                     
    cover_req_seq_lb_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_lb_req_consec(i_req_seq));
                                                  
    cover_req_seq_lb_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_lb_req_nonconsec(i_req_seq));                                                    
                                                     
    cover_req_seq_lh_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_lh_req_consec(i_req_seq));
                                                  
    cover_req_seq_lh_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_lh_req_nonconsec(i_req_seq));
                                                     
    cover_req_seq_lw_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_lw_req_consec(i_req_seq));
                                                  
    cover_req_seq_lw_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_lw_req_nonconsec(i_req_seq)); 
                                                     
    cover_req_seq_sb_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_sb_req_consec(i_req_seq));
                                                  
    cover_req_seq_sb_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_sb_req_nonconsec(i_req_seq));                                                    
                                                     
    cover_req_seq_sh_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_sh_req_consec(i_req_seq));
                                                  
    cover_req_seq_sh_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_sh_req_nonconsec(i_req_seq));
                                                     
    cover_req_seq_sw_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_sw_req_consec(i_req_seq));
                                                  
    cover_req_seq_sw_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_sw_req_nonconsec(i_req_seq));                                                                                                          
                                                                                                        
    cover_resp_seq_any_resp_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_resp_consec(i_req_seq));
                                                  
    cover_resp_seq_any_resp_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_resp_nonconsec(i_req_seq));   
                                                     
    cover_resp_seq_any_resp_consec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_resp_consec_no_error(i_req_seq));
                                                  
    cover_resp_seq_any_resp_nonconsec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_resp_nonconsec_no_error(i_req_seq));   
                                                                                                                                                      
    cover_resp_seq_ld_resp_consec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_resp_consec_no_error(i_req_seq));
                                                  
    cover_resp_seq_ld_resp_nonconsec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_resp_nonconsec_no_error(i_req_seq));                                                                                                                                                  
  end
  endgenerate 
  
  cover_lsu_alloc_misalign_resp: cover property (@(posedge clk) disable iff (~resetn)  
                                                  (prop_expipe_req_accepted & lsu_expipe_req_addr[0] & lsu_expipe_req_op) ##1
                                                   (prop_expipe_resp_accepted & lsu_expipe_resp_ld_addr_misalign));

`endif

 
endmodule

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements a mux for ram data I/O.  
//
// PARAMETER DESCRIPTION:
//
// DATA_WIDTH          Number of data bits per word.
//
// INPUT PORT DESCRIPTION:
//
// sys_din[]           RAM write data. 
// ram_dout            Data output from ram
//
// OUTPUT PORT DESCRIPTION:
//
// sys_dout[]          RAM read data.
// ram_din[]           Data input to RAM
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdualdata_behav
  #(
    parameter DATA_WIDTH = 8,
    parameter miv_rv32_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_pkg::BIST_TRUE
  )
  (
    input  wire logic                  ram_init_busy_a,
    input  wire logic                  ram_init_busy_b,
    input  wire logic                  ram_init_busy_c,
    // user ram interface
    input  wire logic [DATA_WIDTH-1:0] sys_adin,
    output      logic [DATA_WIDTH-1:0] sys_adout,
	
    input  wire logic [DATA_WIDTH-1:0] sys_bdin,
    output      logic [DATA_WIDTH-1:0] sys_bdout,
	
    input  wire logic [DATA_WIDTH-1:0] sys_cdin,   
    output      logic [DATA_WIDTH-1:0] sys_cdout,  
    // internal ram interface
    input  wire logic [DATA_WIDTH-1:0] ram_adout,
    output      logic [DATA_WIDTH-1:0] ram_adin,
	
    input  wire logic [DATA_WIDTH-1:0] ram_bdout,
    output      logic [DATA_WIDTH-1:0] ram_bdin,
	
    input  wire logic [DATA_WIDTH-1:0] ram_cdout,   
    output      logic [DATA_WIDTH-1:0] ram_cdin     
  );
  
  // implementation
  import miv_rv32_pkg::*;

  localparam logic GRND = 1'b0;

  generate
    genvar i;

    // generate data input mux
    for (i = 0; i < DATA_WIDTH; i++) begin : din_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        adin_mux
        (
          .sigin(sys_adin[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_a),
          .sigout(ram_adin[i])
        ); 
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        bdin_mux
        (
          .sigin(sys_bdin[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(ram_bdin[i])
        ); 
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        cdin_mux
        (
          .sigin(sys_cdin[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_c),
          .sigout(ram_cdin[i])
        ); 
    end : din_gen

    // generate data input mux
    for (i = 0; i < DATA_WIDTH; i++) begin : dout_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        adout_mux
        (
          .sigin(ram_adout[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_a),
          .sigout(sys_adout[i])
        ); 
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        bdout_mux
        (
          .sigin(ram_bdout[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(sys_bdout[i])
        ); 
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        cdout_mux
        (
          .sigin(ram_cdout[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_c),
          .sigout(sys_cdout[i])
        ); 
    end : dout_gen
  endgenerate
  
endmodule : miv_rv32_bistdualdata_behav

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements a mux for ram contrl signals. 
//
// PARAMETER DESCRIPTION:
//
// ADDR_WIDTH          Number of address bits.
// DATA_WIDTH          Number of data bits per word.
// LOW_POWER_WIDTH     Number of low_power bus bits.
//
// INPUT PORT DESCRIPTION:
//
// ram_init_busy       RAM initialization busy signal
// ram_init_clear_q    RAM initialization clear RAM DOUT
// ram_init_aaddr      RAM address for initialization
// sys_lp1             Light sleep mode input
// sys_lp2             Deep sleep mode input
// sys_lp3             Shut down mode input
// sys_addr[]          RAM read/write address.
// sys_ceb             RAM cell enable (active low).
// sys_web             RAM write enable (active low).
// sys_wemb[]          RAM write enable mask (active low).
// pg_override         Override low power mode
//
// OUTPUT PORT DESCRIPTION:
//
// low_power[]         Low power bus
// ram_addr[]          Address to RAM
// ram_ceb             Cell enable to RAM
// ram_web             Write enable to RAM
// ram_wemb[]          Write enable mask to RAM

//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_behav
  #(
    parameter DATA_WIDTH      = 8,
    parameter ADDR_WIDTH      = 4,
    parameter LOW_POWER_WIDTH = 4,
    parameter NUM_LP1_PINS    = 1,
    parameter NUM_LP2_PINS    = 1,
    parameter NUM_LP3_PINS    = 1,
    parameter miv_rv32_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_pkg::BIST_TRUE
  )
  (
    input  wire logic                       ram_init_busy_a,
    input  wire logic                       ram_init_busy_b,
    input  wire logic                       ram_init_busy_c,   
    input  wire logic                       ram_init_start_b,
    input  wire logic                       ram_init_clear_q,
    input  wire logic [ADDR_WIDTH-1:0]      ram_init_aaddr,
    // user ram interface
    input  wire logic                       sys_aceb,
    input  wire logic                       sys_aweb,
    input  wire logic [DATA_WIDTH-1:0]      sys_awemb,
    input  wire logic [ADDR_WIDTH-1:0]      sys_aaddr,
	
    input  wire logic                       sys_bceb,
    input  wire logic                       sys_bweb,
    input  wire logic [DATA_WIDTH-1:0]      sys_bwemb,
    input  wire logic [ADDR_WIDTH-1:0]      sys_baddr,
	
    input  wire logic                       sys_cceb,
    input  wire logic                       sys_cweb,
    input  wire logic [DATA_WIDTH-1:0]      sys_cwemb,
    input  wire logic [ADDR_WIDTH-1:0]      sys_caddr,
	
    input  wire logic [NUM_LP1_PINS-1:0]    sys_lp1,
    input  wire logic [NUM_LP2_PINS-1:0]    sys_lp2,
    input  wire logic [NUM_LP3_PINS-1:0]    sys_lp3,
    input  wire logic                       pg_override,
    // internal ram interface
    output      logic                       ram_aceb,
    output      logic                       ram_aweb,
    output      logic [DATA_WIDTH-1:0]      ram_awemb,
    output      logic [ADDR_WIDTH-1:0]      ram_aaddr,
	
    output      logic                       ram_bceb,
    output      logic                       ram_bweb,
    output      logic [DATA_WIDTH-1:0]      ram_bwemb,
    output      logic [ADDR_WIDTH-1:0]      ram_baddr,
	
    output      logic                       ram_cceb,
    output      logic                       ram_cweb,
    output      logic [DATA_WIDTH-1:0]      ram_cwemb,
    output      logic [ADDR_WIDTH-1:0]      ram_caddr,
	
    output      logic [LOW_POWER_WIDTH-1:0] low_power
  );
  
  // implementation
  import miv_rv32_pkg::*;

  localparam logic GRND = 1'b0;
  localparam logic POWR = 1'b1;

  logic [NUM_LP1_PINS-1:0] lp1;
  logic [NUM_LP2_PINS-1:0] lp2;
  logic [NUM_LP3_PINS-1:0] lp3;
  logic                   ram_init_start;

  assign low_power[0]                                             = pg_override;
  assign low_power[NUM_LP1_PINS:1]                                = lp1;
  assign low_power[NUM_LP2_PINS+NUM_LP1_PINS:NUM_LP1_PINS+1]      = lp2;
  assign low_power[LOW_POWER_WIDTH-1:NUM_LP2_PINS+NUM_LP1_PINS+1] = lp3;

  assign ram_init_start = ~ram_init_start_b;

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    aceb_mux
    (
      .sigin(sys_aceb),
      .tstin(GRND),
      .tstsel(ram_init_busy_a),
      .sigout(ram_aceb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    bceb_mux
    (
      .sigin(sys_bceb),
      .tstin(ram_init_start),
      .tstsel(ram_init_busy_b),
      .sigout(ram_bceb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    cceb_mux
    (
      .sigin(sys_cceb),
      .tstin(ram_init_start),
      .tstsel(ram_init_busy_c),
      .sigout(ram_cceb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    aweb_mux
    (
      .sigin(sys_aweb),
      .tstin(ram_init_clear_q),
      .tstsel(ram_init_busy_a),
      .sigout(ram_aweb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    bweb_mux
    (
      .sigin(sys_bweb),
      .tstin(POWR),
      .tstsel(ram_init_busy_b),
      .sigout(ram_bweb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    cweb_mux
    (
      .sigin(sys_cweb),
      .tstin(POWR),
      .tstsel(ram_init_busy_c),
      .sigout(ram_cweb)
    ); 

  generate
    genvar i;

    for (i = 0; i < NUM_LP1_PINS; i++) begin : lp1_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        lp1_mux
        (
          .sigin(sys_lp1[i]),
          .tstin(BIST_LP1_DEFAULT),
          .tstsel(ram_init_busy_b),
          .sigout(lp1[i])
        ); 
    end : lp1_gen

    for (i = 0; i < NUM_LP2_PINS; i++) begin : lp2_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        lp2_mux
        (
          .sigin(sys_lp2[i]),
          .tstin(BIST_LP2_DEFAULT),
          .tstsel(ram_init_busy_b),
          .sigout(lp2[i])
        ); 
    end : lp2_gen

    for (i = 0; i < NUM_LP3_PINS; i++) begin : lp3_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        lp3_mux
        (
          .sigin(sys_lp3[i]),
          .tstin(BIST_LP3_DEFAULT),
          .tstsel(ram_init_busy_b),
          .sigout(lp3[i])
        ); 
    end : lp3_gen

    for (i = 0; i < DATA_WIDTH; i++) begin : wemb_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        awemb_mux
        (
          .sigin(sys_awemb[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_a),
          .sigout(ram_awemb[i])
        );
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        bwemb_mux
        (
          .sigin(sys_bwemb[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(ram_bwemb[i])
        );
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        cwemb_mux
        (
          .sigin(sys_cwemb[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_c),
          .sigout(ram_cwemb[i])
        );
    end : wemb_gen

    for (i = 0; i < ADDR_WIDTH; i++) begin : addr_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        aaddr_mux
        (
          .sigin(sys_aaddr[i]),
          .tstin(ram_init_aaddr[i]),
          .tstsel(ram_init_busy_a),
          .sigout(ram_aaddr[i])
        );
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        baddr_mux
        (
          .sigin(sys_baddr[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(ram_baddr[i])
        );
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        caddr_mux
        (
          .sigin(sys_caddr[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_c),
          .sigout(ram_caddr[i])
        );
    end : addr_gen
  endgenerate

endmodule : miv_rv32_bistdual_behav

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// This file is a wrapper for ECCs and ECC err mask.
// The RAM in bist wrapper is used to store data and ecc
// parity. The relation between the data width and the
// RAM width (data + parity) is as follows.
//    data in/out width        RAM width
//         5- 11             10- 16 (+5 bits for parity)
//        12- 26             18- 32 (+6 bits for parity)
//        27- 57             34- 64 (+7 bits for parity)
//        58-120             66-128 (+8 bits for parity)
//       121-247            130-256 (+9 bits for parity)
//       248-502            258-512 (+10 bits for parity)
// e.g. if you need dpr128x32 RAM, dpr128x39 bist wrapper will be created.
//      ECC uses 7bits for parity.
// ecc_err is masked during RAM initialization and BIST test
// to suppress ecc_err report on uninitialized RAM read
//
// PARAMETER DESCRIPTION:
//
// FUNC_CLKS_SYNC       A and B clocks are functional same
// ADDR_WIDTH           Number of address bits.
// DATA_WIDTH           Number of data bits per word.
// PARITY_WIDTH         Number of parity bits per word.
// INPUT_PIPELINE       Indicates if input Pipeline flops are used or not
// OUTPUT_PIPELINE      Indicates if output Pipeline flops are used or not
//
// INPUT PORT DESCRIPTION:
//
// rstb                 System reset (active low).
// acscasnb             ACScan mode  (active low).
// aclk                 RAM clock for port A.
// aaddr                RAM read/write address for port A.
// aceb	                RAM cell enable for port A (active low)
// aweb	                RAM read/write for port A (active low)
// awemb_and            And'ed RAM write enable mask (active low)
// sys_adin             RAM write data for port A .
// bistw_adout          RAM read data (data) for port A.
// bistw_apout          RAM read data (parity) for port A.
// bclk                 RAM clock for port B.
// baddr                RAM read/write address for port B.
// bceb	                RAM cell enable for port B (active low)
// bweb	                RAM read/write for port B (active low)
// bwemb_and            And'ed RAM write enable mask (active low)
// sys_bdin	        RAM write data for port B.
// bistw_bdout          RAM read data (data) for port A.
// bistw_bpout          RAM read data (parity) for port A.
// ecc_bypass           ECC bypass. conenct to ECBI register.
// ram_err_inject       Inject error on RAM write data.
//
// OUTPUT PORT DESCRIPTION:
//
// sys_adout            RAM read data for port A.
// sys_bdout            RAM read data for port B.
// bistw_adin           RAM write data (data) for port A.
// bistw_apin           RAM write data (parity) for port A.
// bistw_bdin           RAM write data (data) for port B.
// bistw_bpin           RAM write data (parity) for port B.
// ecc_aerr             ecc error detect/corect.
// ecc_berr             ecc error detect/corect.
// ecc_aerr_int         registered version of ecc_aerr, suitable for edge sensitive interrupts. 
// ecc_berr_int         registered version of ecc_aerr, suitable for edge sensitive interrupts. 
//     
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_eccw
  #(
    parameter BIST_ECC_EMPTY = 0,
    parameter ADDR_WIDTH     = 4,
    parameter DATA_WIDTH     = 8,
    parameter PARITY_WIDTH   = 5,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE
                             = miv_rv32_pkg::BIST_PIPELINE_OFF,

    parameter miv_rv32_pkg::t_bist_pipeline OUTPUT_PIPELINE
                             = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_true_false FUNC_CLKS_SYNC
                             = miv_rv32_pkg::BIST_TRUE
  )
  (
    input  wire logic                     bistb,
    input  wire logic                     ram_init_busy_a,
    input  wire logic                     ram_init_busy_b,
	
    input  wire logic                     ram_init_busy_c,   
	
    input  wire logic                     ecc_bypass,
    input  wire logic [miv_rv32_pkg::ECC_ERR_INJECT_WIDTH-1:0]             
                                          ram_err_inject,
										  
    input  wire logic                     arstb,
    input  wire logic                     aclk,
    input  wire logic [ADDR_WIDTH-1:0]    aaddr,
    input  wire logic                     aceb,
    input  wire logic                     aweb,
    input  wire logic                     awemb_and,
    input  wire logic [DATA_WIDTH-1:0]    sys_adin,
    input  wire logic [DATA_WIDTH-1:0]    bistw_adout,
    input  wire logic [PARITY_WIDTH-1:0]  bistw_apout,
	
    input  wire logic                     brstb,
    input  wire logic                     bclk,
    input  wire logic [ADDR_WIDTH-1:0]    baddr,
    input  wire logic                     bceb,
    input  wire logic                     bweb,
    input  wire logic                     bwemb_and,
    input  wire logic [DATA_WIDTH-1:0]    sys_bdin,
    input  wire logic [DATA_WIDTH-1:0]    bistw_bdout,
    input  wire logic [PARITY_WIDTH-1:0]  bistw_bpout,
	
    input  wire logic                     crstb,          
    input  wire logic                     cclk,           
    input  wire logic [ADDR_WIDTH-1:0]    caddr,          
    input  wire logic                     cceb,           
    input  wire logic                     cweb,           
    input  wire logic                     cwemb_and,      
    input  wire logic [DATA_WIDTH-1:0]    sys_cdin,       
    input  wire logic [DATA_WIDTH-1:0]    bistw_cdout,    
    input  wire logic [PARITY_WIDTH-1:0]  bistw_cpout,    
	
    output      logic [DATA_WIDTH-1:0]    sys_adout,
    output      logic [DATA_WIDTH-1:0]    bistw_adin,
    output      logic [PARITY_WIDTH-1:0]  bistw_apin,
    output      logic [miv_rv32_pkg::ECC_ERR_WIDTH-1:0] ecc_aerr_int,
    output      logic [miv_rv32_pkg::ECC_ERR_WIDTH-1:0] ecc_aerr,
    output      logic [DATA_WIDTH-1:0]    sys_bdout,
    output      logic [DATA_WIDTH-1:0]    bistw_bdin,
    output      logic [PARITY_WIDTH-1:0]  bistw_bpin,
    output      logic [miv_rv32_pkg::ECC_ERR_WIDTH-1:0] ecc_berr_int,
    output      logic [miv_rv32_pkg::ECC_ERR_WIDTH-1:0] ecc_berr,
	
    output      logic [DATA_WIDTH-1:0]    sys_cdout,                                
    output      logic [DATA_WIDTH-1:0]    bistw_cdin,                               
    output      logic [PARITY_WIDTH-1:0]  bistw_cpin,                               
    output      logic [miv_rv32_pkg::ECC_ERR_WIDTH-1:0] ecc_cerr_int,   
    output      logic [miv_rv32_pkg::ECC_ERR_WIDTH-1:0] ecc_cerr        
  );

// IMPLEMENTATION 

  import miv_rv32_pkg::*;

  localparam logic                    GRND            = 1'b 0;
  localparam logic [PARITY_WIDTH-1:0] GRND_PARITY     = {PARITY_WIDTH{1'b0}};

  logic [PARITY_WIDTH-1:0]         parity_adout;
  logic [PARITY_WIDTH-1:0]         parity_bdout;
  logic [PARITY_WIDTH-1:0]         parity_cdout;       
  logic [ECC_ERR_WIDTH-1:0]        ecc_aerr_bist;
  logic [ECC_ERR_WIDTH-1:0]        ecc_aerr_masked;
  logic [ECC_ERR_WIDTH-1:0]        ecc_berr_bist;
  logic [ECC_ERR_WIDTH-1:0]        ecc_berr_masked;
  logic [ECC_ERR_WIDTH-1:0]        ecc_cerr_bist;      
  logic [ECC_ERR_WIDTH-1:0]        ecc_cerr_masked;    
  logic [DATA_WIDTH-1:0]           adin_con;
  logic [DATA_WIDTH-1:0]           bdin_con;
  logic [DATA_WIDTH-1:0]           cdin_con;           

  assign bistw_apin     = parity_adout;
  assign bistw_adin     = adin_con;
  
  assign bistw_bpin     = parity_bdout;
  assign bistw_bdin     = bdin_con;
  
  assign bistw_cpin     = parity_cdout;                     
  assign bistw_cdin     = cdin_con;               
  
  assign ecc_aerr       = ecc_aerr_bist;
  assign ecc_berr       = ecc_berr_bist;
  assign ecc_cerr       = ecc_cerr_bist;

  miv_rv32_bist_err_inject 
    #(
      .ERR_WIDTH(2),
      .DATA_WIDTH(DATA_WIDTH)
    )
    aerr_inject_inst
    (
      .err_inject(ram_err_inject),
      .data_in(sys_adin),
      .data_out(adin_con)
    );

  miv_rv32_bist_err_inject 
    #(
      .ERR_WIDTH(2),
      .DATA_WIDTH(DATA_WIDTH)
    )
    berr_inject_inst
    (
      .err_inject(ram_err_inject),
      .data_in(sys_bdin),
      .data_out(bdin_con)
    );

  miv_rv32_bist_err_inject 
    #(
      .ERR_WIDTH(2),
      .DATA_WIDTH(DATA_WIDTH)
    )
    cerr_inject_inst
    (
      .err_inject(ram_err_inject),
      .data_in(sys_cdin),
      .data_out(cdin_con)
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(0),
      .MEMORY_READ(1)
    )
    ecc_aread
    (
      .ecc_bypass(ecc_bypass),
      .data_in(bistw_adout),
      .parity_in(bistw_apout),
      .err_multpl(ecc_aerr_bist[1]),
      .err_detect(ecc_aerr_bist[0]),
      .data_out(sys_adout),
      .parity_out(),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(0),
      .MEMORY_READ(1)
    )
    ecc_bread
    (
      .ecc_bypass(ecc_bypass),
      .data_in(bistw_bdout),
      .parity_in(bistw_bpout),
      .err_multpl(ecc_berr_bist[1]),
      .err_detect(ecc_berr_bist[0]),
      .data_out(sys_bdout),
      .parity_out(),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(0),
      .MEMORY_READ(1)
    )
    ecc_cread
    (
      .ecc_bypass(ecc_bypass),
      .data_in(bistw_cdout),
      .parity_in(bistw_cpout),
      .err_multpl(ecc_cerr_bist[1]),
      .err_detect(ecc_cerr_bist[0]),
      .data_out(sys_cdout),
      .parity_out(),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(1),
      .MEMORY_READ(0)
    )
    ecc_awrite
    (
      .ecc_bypass(GRND),
      .data_in(sys_adin),
      .parity_in(GRND_PARITY),
      .err_multpl(),
      .err_detect(),
      .data_out(),
      .parity_out(parity_adout),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(1),
      .MEMORY_READ(0)
    )
    ecc_bwrite
    (
      .ecc_bypass(GRND),
      .data_in(sys_bdin),
      .parity_in(GRND_PARITY),
      .err_multpl(),
      .err_detect(),
      .data_out(),
      .parity_out(parity_bdout),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(1),
      .MEMORY_READ(0)
    )
    ecc_cwrite
    (
      .ecc_bypass(GRND),
      .data_in(sys_cdin),
      .parity_in(GRND_PARITY),
      .err_multpl(),
      .err_detect(),
      .data_out(),
      .parity_out(parity_cdout),
      .check_out()
    );

  miv_rv32_bistdual_err_mask 
    #(
      .ADDR_WIDTH(ADDR_WIDTH),
      .ERR_WIDTH(ECC_ERR_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC)
    )
    err_mask
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
	  
      .ram_init_busy_b(ram_init_busy_b),
	  
      .ram_init_busy_c(ram_init_busy_c),   
	  
      .arstb(arstb),
      .ecc_bypass(ecc_bypass),
      .aclk(aclk),
      .aaddr(aaddr),
      .aweb(aweb),
      .aceb(aceb),
      .awemb_and(awemb_and),
	  
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bweb(bweb),
      .bceb(bceb),
      .bwemb_and(bwemb_and),
	  
      .crstb(crstb),                
      .cclk(cclk),                  
      .caddr(caddr),                
      .cweb(cweb),                  
      .cceb(cceb),                  
      .cwemb_and(cwemb_and),        
	  
      .aerr_in(ecc_aerr_bist),
      .berr_in(ecc_berr_bist),
      .cerr_in(ecc_cerr_bist),     
      .aerr_out(ecc_aerr_masked),
      .berr_out(ecc_berr_masked),
      .cerr_out(ecc_cerr_masked)   
    );

  // register the ecc error signals for use as interrupts 
  always @(*) //  always_ff @(negedge arstb or posedge aclk) 
  begin : register_ecc_err_a
    if(arstb != 1'b 1) begin
      ecc_aerr_int <= 2'b 00;
    end 
    else begin
      ecc_aerr_int <= ecc_aerr_bist;
    end
  end : register_ecc_err_a

  always_ff @(negedge brstb or posedge bclk) 
  begin : register_ecc_err_b
    if(brstb != 1'b 1) begin
      ecc_berr_int <= 2'b 00;
    end 
    else begin
      ecc_berr_int <= ecc_berr_bist;
    end
  end : register_ecc_err_b

  always_ff @(negedge crstb or posedge cclk) 
  begin : register_ecc_err_c
    if(crstb != 1'b 1) begin
      ecc_cerr_int <= 2'b 00;
    end 
    else begin
      ecc_cerr_int <= ecc_cerr_bist;
    end
  end : register_ecc_err_c

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
// This block masks ECC and Parity error signal.
// The error signal is masked in following conditions.
// 1) During RAM initialization and BIST test
// 2) Simultaneous read/write for dpr, tpr and trf
// 3) RAM is disabled (ceb = '1') and RAM is being written (ceb = '0' and web = '0')
//
// PARAMETER DESCRIPTION:
//
// ADDR_WIDTH       RAM address width
// ERR_WIDTH        Error signal width
// INPUT_PIPELINE   input pipeline
// OUTPUT_PIPELINE  output pipeline
// FUNC_CLKS_SYNC   A and B clocks are functional same
//
// INPUT PORT DESCRIPTION:
//
// rstb                 Initializes/Resets the BIST block.
// ecc_bypass           ECC bypass signal.
// aclk                 RAM clock
// aaddr                RAM address             
// aweb                 RAM write enable
// aceb                 RAM cell enable
// awemb_and            And'ed RAM write enable mask
// bclk                 RAM clock
// baddr                RAM address             
// bweb                 RAM write enable
// bceb                 RAM cell enable
// bwemb_and            And'ed RAM write enable mask
// aerr_in              error input (DPR A port)
// berr_in              error input (DPR B port)
// ram_init_busy_a_sync synchronized bisti_init_busy (aclk)
// ram_init_busy_b_sync synchronized bisti_init_busy (bclk)
//
// OUTPUT PORT DESCRIPTION:
//
// aerr_out         masked error output (DPR A port)
// berr_in          masked error output (DPR B port)
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_err_mask
  #(
    parameter ADDR_WIDTH = 4,
    parameter ERR_WIDTH  = 2,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE
                             = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline OUTPUT_PIPELINE
                             = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_true_false FUNC_CLKS_SYNC 
                             = miv_rv32_pkg::BIST_TRUE
  )
  (
    input  wire logic                  bistb,
    input  wire logic                  ecc_bypass,
	
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic                  aweb,
    input  wire logic                  aceb,
    input  wire logic                  awemb_and,
	
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic [ADDR_WIDTH-1:0] baddr,
    input  wire logic                  bweb,
    input  wire logic                  bceb,
    input  wire logic                  bwemb_and,
	
    input  wire logic                  crstb,          
    input  wire logic                  cclk,           
    input  wire logic [ADDR_WIDTH-1:0] caddr,          
    input  wire logic                  cweb,           
    input  wire logic                  cceb,           
    input  wire logic                  cwemb_and,      
	
    input  wire logic                  ram_init_busy_a,
    input  wire logic                  ram_init_busy_b,
    input  wire logic                  ram_init_busy_c,   
    input  wire logic [ERR_WIDTH-1:0]  aerr_in,
    input  wire logic [ERR_WIDTH-1:0]  berr_in,
    input  wire logic [ERR_WIDTH-1:0]  cerr_in,   
    output      logic [ERR_WIDTH-1:0]  aerr_out,
    output      logic [ERR_WIDTH-1:0]  berr_out,
    output      logic [ERR_WIDTH-1:0]  cerr_out   
  );

// IMPLEMENTATION

  import miv_rv32_pkg::*;

  localparam logic [ERR_WIDTH-1:0] ERR_GRND  = {ERR_WIDTH{1'b0}};

  logic [ERR_WIDTH-1:0] aerr_out_int;
  logic [ERR_WIDTH-1:0] berr_out_int;
  logic [ERR_WIDTH-1:0] cerr_out_int;   
  logic simul_read_write;
  
  logic ram_ctrl_a_mask0;
  logic ram_ctrl_a_mask1;
  logic ram_ctrl_a_mask;
  
  logic ram_ctrl_b_mask0;
  logic ram_ctrl_b_mask1;
  logic ram_ctrl_b_mask;
  
  logic ram_ctrl_c_mask0;    
  logic ram_ctrl_c_mask1;    
  logic ram_ctrl_c_mask;     
  
  //logic [ADDR_WIDTH - 1:0] aaddr_latch;
  //logic aread_latch;
  //logic assert_a_mask;
  //logic assert_a_mask_tmp_1;
  //logic assert_a_mask_tmp_2;
  //logic [ADDR_WIDTH - 1:0] baddr_latch;
  //logic bread_latch;
  //logic assert_b_mask;
  //logic assert_b_mask_tmp_1;
  //logic assert_b_mask_tmp_2;

  assign aerr_out = aerr_out_int;
  assign berr_out = berr_out_int;
  assign cerr_out = cerr_out_int;   

  // Create ECC err mask for following conditions.
  //  1. RAM is disabled
  //  2. simultaneous read/write (DPR/TPR/TRF) in sychronous clock
  // detect simultaneous read/write 
  generate 
    if (FUNC_CLKS_SYNC == BIST_TRUE) 
    begin : gen_simul_read_write
      always @(*) begin : detect_simul_read_write
        if((aaddr == baddr && aceb == 1'b 0 && bceb == 1'b 0 && 
            ((aweb == 1'b 0 && awemb_and == 1'b 0) || (bweb == 1'b 0 && bwemb_and == 1'b 0))) ||
		    (aaddr == caddr && aceb == 1'b 0 && cceb == 1'b 0 && 
            ((aweb == 1'b 0 && awemb_and == 1'b 0) || (cweb == 1'b 0 && cwemb_and == 1'b 0))) ||
		    (baddr == caddr && bceb == 1'b 0 && cceb == 1'b 0 && 
            ((bweb == 1'b 0 && bwemb_and == 1'b 0) || (cweb == 1'b 0 && cwemb_and == 1'b 0))) 
		    ) begin
          simul_read_write = 1'b 1;
        end
        else begin
          simul_read_write = 1'b 0;
        end
      end : detect_simul_read_write
    end : gen_simul_read_write
  endgenerate

  generate 
    if (FUNC_CLKS_SYNC == BIST_FALSE) 
    begin : gen_no_simul_read_write
      assign simul_read_write = 1'b 0;
    end : gen_no_simul_read_write
  endgenerate

  // insert pipeline flops to adjust timing
  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_ON && OUTPUT_PIPELINE == BIST_PIPELINE_ON) 
    begin : gen_three_pipeline
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask  <= 1'b 1;
          ram_ctrl_a_mask0 <= 1'b 1;
          ram_ctrl_a_mask1 <= 1'b 1;
        end else begin
          ram_ctrl_a_mask1 <= simul_read_write | aceb | ~aweb;
          ram_ctrl_a_mask0 <= ram_ctrl_a_mask1 | ram_init_busy_a;
          ram_ctrl_a_mask  <= ram_ctrl_a_mask0;
        end 
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask  <= 1'b 1;
          ram_ctrl_b_mask0 <= 1'b 1;
          ram_ctrl_b_mask1 <= 1'b 1;
        end else begin
          ram_ctrl_b_mask1 <= simul_read_write | bceb | ~bweb;
          ram_ctrl_b_mask0 <= ram_ctrl_b_mask1 | ram_init_busy_b;
          ram_ctrl_b_mask  <= ram_ctrl_b_mask0;
        end
      end : b_pipeline

      // bc clock flop
      always_ff @(negedge crstb or posedge cclk) begin : c_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_c_mask  <= 1'b 1;
          ram_ctrl_c_mask0 <= 1'b 1;
          ram_ctrl_c_mask1 <= 1'b 1;
        end else begin
          ram_ctrl_c_mask1 <= simul_read_write | cceb | ~cweb;
          ram_ctrl_c_mask0 <= ram_ctrl_c_mask1 | ram_init_busy_c;
          ram_ctrl_c_mask  <= ram_ctrl_c_mask0;
        end
      end : c_pipeline
    end : gen_three_pipeline
  endgenerate

  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_ON && OUTPUT_PIPELINE == BIST_PIPELINE_OFF) 
    begin : gen_one_INPUT_PIPELINE
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask <= 1'b 1;
          ram_ctrl_a_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_a_mask0 <= simul_read_write | aceb | ~aweb;
          ram_ctrl_a_mask <= ram_ctrl_a_mask0 | ram_init_busy_a;
        end
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask <= 1'b 1;
          ram_ctrl_b_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_b_mask0 <= simul_read_write | bceb | ~bweb;
          ram_ctrl_b_mask <= ram_ctrl_b_mask0 | ram_init_busy_b;
        end
      end : b_pipeline

      // c clock flop
      always_ff @(negedge crstb or posedge cclk) begin : c_pipeline
        if(crstb != 1'b 1) begin
          ram_ctrl_c_mask <= 1'b 1;
          ram_ctrl_c_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_c_mask0 <= simul_read_write | cceb | ~cweb;
          ram_ctrl_c_mask <= ram_ctrl_c_mask0 | ram_init_busy_c;
        end
      end : c_pipeline
    end : gen_one_INPUT_PIPELINE
  endgenerate

  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_OFF && OUTPUT_PIPELINE == BIST_PIPELINE_ON) 
    begin : gen_one_OUTPUT_PIPELINE
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask <= 1'b 1;
          ram_ctrl_a_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_a_mask0 <= simul_read_write | ((aceb | ~aweb)) | ram_init_busy_a;
          ram_ctrl_a_mask <= ram_ctrl_a_mask0;
        end
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask <= 1'b 1;
          ram_ctrl_b_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_b_mask0 <= simul_read_write | ((bceb | ~bweb)) | ram_init_busy_b;
          ram_ctrl_b_mask <= ram_ctrl_b_mask0;
        end
      end : b_pipeline
	  
      always_ff @(negedge crstb or posedge cclk) begin : c_pipeline
        if(crstb != 1'b 1) begin
          ram_ctrl_c_mask <= 1'b 1;
          ram_ctrl_c_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_c_mask0 <= simul_read_write | ((cceb | ~cweb)) | ram_init_busy_c;
          ram_ctrl_c_mask <= ram_ctrl_c_mask0;
        end
      end : c_pipeline
    end : gen_one_OUTPUT_PIPELINE
  endgenerate

  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_OFF && OUTPUT_PIPELINE == BIST_PIPELINE_OFF) 
    begin : gen_no_pipeline
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask <= 1'b 1;
        end else begin
          ram_ctrl_a_mask <= simul_read_write | ((aceb | ~aweb)) | ram_init_busy_a;
        end
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask <= 1'b 1;
        end else begin
          ram_ctrl_b_mask <= simul_read_write | ((bceb | ~bweb)) | ram_init_busy_b;
        end
      end : b_pipeline

      // c clock flop
      always_ff @(negedge crstb or posedge cclk) begin : c_pipeline
        if(crstb != 1'b 1) begin
          ram_ctrl_c_mask <= 1'b 1;
        end else begin
          ram_ctrl_c_mask <= simul_read_write | ((cceb | ~cweb)) | ram_init_busy_c;
        end
      end : c_pipeline
    end : gen_no_pipeline
  endgenerate

  // Mask ECC err
  assign aerr_out_int = (ram_ctrl_a_mask == 1'b 1 || bistb == 1'b 0) ? ERR_GRND : aerr_in;
  assign berr_out_int = (ram_ctrl_b_mask == 1'b 1 || bistb == 1'b 0) ? ERR_GRND : berr_in;
  assign cerr_out_int = (ram_ctrl_c_mask == 1'b 1 || bistb == 1'b 0) ? ERR_GRND : cerr_in;

  // pragma translate_off
  logic aerr_latch;
  logic berr_latch;
  logic cerr_latch;
  always @(negedge arstb or posedge aclk) begin 
    if(arstb != 1'b 1) begin
      aerr_latch <= 1'b0;
    end
    else begin
      aerr_latch <= aerr_out_int[0];
      if (aerr_latch == 1'b0 && ram_ctrl_a_mask == 1'b 0 && bistb == 1'b 1 && ecc_bypass == 1'b0) begin
        assert (aerr_out_int[0] == 1'b0) 
        else begin
          $display( "ECC/Parity error is detected.");
          $info;
        end 
      end
    end
  end
  always @(negedge brstb or posedge bclk) begin 
    if(brstb != 1'b 1) begin
      berr_latch <= 1'b0;
    end
    else begin
      berr_latch <= berr_out_int[0];
      if(berr_latch == 1'b0 && ram_ctrl_b_mask == 1'b 0 && bistb == 1'b 1 && ecc_bypass == 1'b0) begin
        assert (berr_out_int[0] != 1'b1) 
        else begin
          $display( "ECC/Parity error is detected.");
          $info;
        end 
      end
    end
  end
  always @(negedge crstb or posedge cclk) begin 
    if(crstb != 1'b 1) begin
      cerr_latch <= 1'b0;
    end
    else begin
      cerr_latch <= cerr_out_int[0];
      if(cerr_latch == 1'b0 && ram_ctrl_c_mask == 1'b 0 && bistb == 1'b 1 && ecc_bypass == 1'b0) begin
        assert (cerr_out_int[0] != 1'b1) 
        else begin
          $display( "ECC/Parity error is detected.");
          $info;
        end 
      end
    end
  end
  // pragma translate_on


endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements enable signals for pipeline flops.
//
// PARAMETER DESCRIPTION:
//
// INPUT_PIPELINE      Indicates if input Pipeline flops are used or not
// INPUT_PIPELINE_LS   Indicates if input Pipeline flops for low power flops 
//                     (ls) is used or not
// INPUT_PIPELINE_LP   Indicates if input Pipeline flops for low power flops 
//                     (ds and sd )are used or not
// OUTPUT_PIPELINE     Indicates if output Pipeline flops are used or not
//
// INPUT PORT DESCRIPTION:
//
// arstb                A System reset (active low). 
// aclk                 A RAM clock.
// aceb                 A RAM cell enable (active low).
// aweb                 A RAM write enable (active low).
// brstb                B System reset (active low). 
// bclk                 B RAM clock.
// bceb                 B RAM cell enable (active low).
// bweb                 B RAM write enable (active low).
//
// OUTPUT PORT DESCRIPTION:
//
// a_input_pl_data_enable  A Enable for data input pipeline flops
// a_input_pl_ctrl_enable  A Enable for contrl input pipeline flops
// a_output_pl_data_enable A Enable for output pipeline flops
// b_input_pl_data_enable  B Enable for data input pipeline flops
// b_input_pl_ctrl_enable  B Enable for contrl input pipeline flops
// b_output_pl_data_enable B Enable for output pipeline flops
// input_pl_pg_enable      Enable for low power input pipeline flops
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_pl_enable
  #(
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE_LS
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE_LP
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline OUTPUT_PIPELINE
                              = miv_rv32_pkg::BIST_PIPELINE_OFF
  )
  (
    input  wire logic arstb,
    input  wire logic aclk,
    input  wire logic aceb,
    input  wire logic aweb,
    output      logic a_input_pl_data_enable,
    output      logic a_input_pl_ctrl_enable,
    output      logic a_output_pl_data_enable,
	
    input  wire logic brstb,
    input  wire logic bclk,
    input  wire logic bceb,
    input  wire logic bweb,
    output      logic b_input_pl_data_enable,
    output      logic b_input_pl_ctrl_enable,
    output      logic b_output_pl_data_enable,
												
    input  wire logic crstb,                      
    input  wire logic cclk,                       
    input  wire logic cceb,                       
    input  wire logic cweb,                       
    output      logic c_input_pl_data_enable,     
    output      logic c_input_pl_ctrl_enable,     
    output      logic c_output_pl_data_enable,    
	
    output      logic input_pl_pg_enable
  );
  
  // implementation
  import miv_rv32_pkg::*;

  logic a_output_pl_data_enable_int;
  logic b_output_pl_data_enable_int;
  logic c_output_pl_data_enable_int;   

  assign a_input_pl_data_enable = ~aceb & ~aweb;
  assign a_input_pl_ctrl_enable = ~aceb;
  assign b_input_pl_data_enable = ~bceb & ~bweb;
  assign b_input_pl_ctrl_enable = ~bceb;
  assign c_input_pl_data_enable = ~cceb & ~cweb;  
  assign c_input_pl_ctrl_enable = ~cceb;          
  assign input_pl_pg_enable     = 1'b1;

  generate
    if (INPUT_PIPELINE == BIST_PIPELINE_ON && OUTPUT_PIPELINE == BIST_PIPELINE_ON) begin : input_on_output_on
      always_ff @(posedge aclk or negedge arstb)
      begin : a_output_pl_enable_two_ff
        if (arstb != 1'b1) begin
          a_output_pl_data_enable     <= 1'b1;
          a_output_pl_data_enable_int <= 1'b1;
        end
        else begin
          a_output_pl_data_enable     <= a_output_pl_data_enable_int;
          a_output_pl_data_enable_int <= ~aceb & aweb;
        end
      end : a_output_pl_enable_two_ff
      always_ff @(posedge bclk or negedge brstb)
      begin : b_output_pl_enable_two_ff
        if (brstb != 1'b1) begin
          b_output_pl_data_enable     <= 1'b1;
          b_output_pl_data_enable_int <= 1'b1;
        end
        else begin
          b_output_pl_data_enable     <= b_output_pl_data_enable_int;
          b_output_pl_data_enable_int <= ~bceb & bweb;
        end
      end : b_output_pl_enable_two_ff
      always_ff @(posedge cclk or negedge crstb)
      begin : c_output_pl_enable_two_ff
        if (crstb != 1'b1) begin
          c_output_pl_data_enable     <= 1'b1;
          c_output_pl_data_enable_int <= 1'b1;
        end
        else begin
          c_output_pl_data_enable     <= c_output_pl_data_enable_int;
          c_output_pl_data_enable_int <= ~cceb & cweb;
        end
      end : c_output_pl_enable_two_ff
    end : input_on_output_on
    else if (INPUT_PIPELINE == BIST_PIPELINE_OFF && OUTPUT_PIPELINE == BIST_PIPELINE_ON) begin : input_off_output_on
      always_ff @(posedge aclk or negedge arstb)
      begin : a_output_pl_enable_one_ff
        if (arstb != 1'b1) begin
          a_output_pl_data_enable <= 1'b1;
        end
        else begin
          a_output_pl_data_enable <= ~aceb & aweb;
        end
      end : a_output_pl_enable_one_ff
      always_ff @(posedge bclk or negedge brstb)
      begin : b_output_pl_enable_one_ff
        if (brstb != 1'b1) begin
          b_output_pl_data_enable <= 1'b1;
        end
        else begin
          b_output_pl_data_enable <= ~bceb & bweb;
        end
      end : b_output_pl_enable_one_ff
      always_ff @(posedge cclk or negedge crstb)
      begin :c_output_pl_enable_one_ff
        if (crstb != 1'b1) begin
          c_output_pl_data_enable <= 1'b1;
        end
        else begin
          c_output_pl_data_enable <= ~bceb & bweb;
        end
      end : c_output_pl_enable_one_ff
    end : input_off_output_on
    else begin : output_off
      assign  a_output_pl_data_enable = ~aceb & aweb;
      assign  b_output_pl_data_enable = ~bceb & bweb;
      assign  c_output_pl_data_enable = ~cceb & cweb;
    end : output_off
  endgenerate
  
endmodule : miv_rv32_bistdual_pl_enable

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// This block is used to initialize RAM.
// The address counter is generated and no BIST sequencer is required to
// generate addresses.
//
//
// PARAMETER DESCRIPTION:
//
// ASYNC_ACLK             asynchronous relationship between aclk and bistclk
// ASYNC_BCLK             asynchronous relationship between bclk and bistclk
// RAM_INIT_GEN           RAM initialization logic is generated when high
// RAM_DEPTH              RAM depth
// ADDR_WIDTH             RAM address bit width
//
//
// INPUT PORT DESCRIPTION:
//
// arstb                  Initializes/Resets BIST block (active low), A side
// brstb                  Initializes/Resets BIST block (active low), B side
// aclk                   System A clock
// bclk                   System B clock
// ram_init_enable        RAM initialization enable (active high)
//
//
// OUTPUT PORT DESCRIPTION:
//
// ram_init_busy_a        RAM initialization busy signal (active high), A side
// ram_init_busy_b        RAM initialization busy signal (active high), B side
// ram_init_start_b       RAM initialization start for B (read) clock domain
// ram_init_clear_q       RAM initialization clear RAM DOUT
// ram_init_aaddr         RAM address for initialization, A (write) side
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_ram_init

  #(
    parameter miv_rv32_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_pkg::BIST_TRUE,
    parameter miv_rv32_pkg::t_bist_true_false RAM_INIT_GEN    
                              = miv_rv32_pkg::BIST_FALSE,
    parameter RAM_DEPTH       = 16,
    parameter ADDR_WIDTH      = 4
  )
  (
    input  wire logic                  arstb,
    input  wire logic                  aclk,
	
    input  wire logic                  brstb,
    input  wire logic                  bclk,
	
    input  wire logic                  crstb,
    input  wire logic                  cclk,
	
    input  wire logic                  ram_init_enable,   
    
    output      logic                  ram_init_busy_a,
    output      logic                  ram_init_busy_b,
    output      logic                  ram_init_busy_c,
    output      logic                  ram_init_start_b,
    output      logic                  ram_init_clear_q, 
    output      logic [ADDR_WIDTH-1:0] ram_init_aaddr
  );
  
  import miv_rv32_pkg::*;
  
  // INTERNAL SIGNALS
  logic ram_init_busy_a_int;
  logic ram_init_busy_b_int;
  logic ram_init_busy_c_int;
  logic ram_init_start_a_int;
  logic ram_init_start_b_int;
  logic ram_init_start_c_int;
  logic init_start;
  logic ram_init_clear_q_int;
  
  // STATE VARIABLE DECLARATIONS
  typedef enum logic [2:0] {
    RESET,
    NOT_INIT,
    START_INIT,
    INCR_ADDR,
    LAST_ADDR,
    CLR_PIPELINE_OUT,
    FINISH_INIT
  } t_gen_ram_state;
  
  t_gen_ram_state state;
  t_gen_ram_state nextstate;
  
  // Assign outputs
  assign ram_init_busy_a    = ram_init_enable   ? ram_init_busy_a_int  : 1'b0;
  assign ram_init_busy_b    = ram_init_enable   ? ram_init_busy_b_int  : 1'b0;
  assign ram_init_busy_c    = ram_init_enable   ? ram_init_busy_c_int  : 1'b0;
  assign ram_init_start_b   = ram_init_enable   ? ram_init_start_b_int : 1'b0;
  assign ram_init_clear_q   = ram_init_enable   ? ram_init_clear_q_int : 1'b0;
  
  generate
    case ( RAM_INIT_GEN ) 
    
      BIST_TRUE :
        begin : gen_ram_init
          
          // sequential logic for state machine
          always_ff @(posedge aclk or negedge arstb)
          begin : ram_init_seq
            if ( arstb != 1'b1 ) begin
              state                <= RESET;

              init_start           <= 1'b1;
              ram_init_busy_a_int  <= 1'b1;
              ram_init_start_a_int <= 1'b0;
              ram_init_clear_q_int <= 1'b0;
              ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
            end
            else begin
              state                <= nextstate;
              init_start           <= ram_init_enable;
              
              // output logic
              unique case ( nextstate )
                RESET: begin
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end              
                  
                NOT_INIT: begin
                  ram_init_busy_a_int  <= 1'b0;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end
                  
                START_INIT: begin // ram_init_enable toggled
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end               
                
                INCR_ADDR: begin
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b1;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= ram_init_aaddr + 1'b1;
                end
                
                LAST_ADDR: begin // clear RAM Q values
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b1;
                  ram_init_clear_q_int <= 1'b1;
                  ram_init_aaddr       <= ram_init_aaddr;
                end
                  
                CLR_PIPELINE_OUT: begin // one cycle to clear output pipeline
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b1;
                  ram_init_aaddr       <= ram_init_aaddr;
                end
                  
                FINISH_INIT: begin
                  ram_init_busy_a_int  <= 1'b0;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b1;
                  ram_init_aaddr       <= ram_init_aaddr;
                end              
                
                default: begin
                  ram_init_busy_a_int  <= 1'b0;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end
              endcase  
            end
          end : ram_init_seq
          
          // Next state combo logic
          always @(*)
          begin : ram_init_nextstate
            
            unique case ( state )
              RESET: begin
                if ( ram_init_enable == 1'b1 ) begin
                  nextstate = INCR_ADDR;
                end
                else begin
                  nextstate = NOT_INIT;
                end
              end              
                
              NOT_INIT: begin
                if ( ram_init_enable == 1'b1 && init_start == 1'b0 ) begin
                  nextstate = START_INIT;
                end
                else begin
                  nextstate = NOT_INIT;
                end
              end
                
              START_INIT: begin // ram_init_enable toggled
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = INCR_ADDR;
                end
              end               
              
              INCR_ADDR: begin
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else if ( RAM_DEPTH - 1 == int'(ram_init_aaddr) ) begin
                  nextstate = LAST_ADDR;
                end
                else begin
                  nextstate = INCR_ADDR;
                end
              end
              
              LAST_ADDR: begin // clear RAM Q values
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = CLR_PIPELINE_OUT;
                end
              end
                
              CLR_PIPELINE_OUT: begin // wait one cycle to clear output pipeline
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = FINISH_INIT;
                end
              end
                
              FINISH_INIT: begin
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = FINISH_INIT;
                end
              end              
              
              default: begin
                nextstate   = NOT_INIT;
              end
            endcase  
          end : ram_init_nextstate

          // pragma translate_off 
          logic init_done;
          always @(posedge cclk or negedge crstb)
          begin
            if ( brstb != 1'b1 ) begin
              init_done <= 1'b1;
            end
            else begin
              init_done <= ram_init_busy_c_int;
              assert(ram_init_busy_c_int == 1'b1 || ram_init_busy_c_int ^ init_done == 1'b0 || ram_init_enable == 1'b0)
              else begin
                $display("ram_init : RAM initialization complete.");
                $info;
              end 
            end
          end
          // pragma translate_on

        end : gen_ram_init
        
      BIST_FALSE:
        begin : gen_no_ram_init
          assign ram_init_aaddr       = {ADDR_WIDTH{1'b0}};
          assign ram_init_busy_a_int  = 1'b0;
          assign ram_init_busy_b_int  = 1'b0;
          assign ram_init_busy_c_int  = 1'b0;
          assign ram_init_start_b_int = 1'b0;
          assign ram_init_clear_q_int = 1'b0;
        end : gen_no_ram_init
      
    endcase
  endgenerate


  // generate sync flops if bclk and aclk are async
  generate
    if ( ( RAM_INIT_GEN == BIST_TRUE ) && ( FUNC_CLKS_SYNC == BIST_FALSE) )
    begin : gen_busy_sync
      pmc_sync_flop_behav_v3
        #(.RETIMING_FLOP_NUM(2),
          .RESET_VALUE(1),
          .MTBF(1))
        pmc_sync_flop_ram_ab_init_busy
        ( .sigin(ram_init_busy_a_int),
          .gray_clk(1'b0),
          .clk(bclk),
          .rstb(brstb),
          .sigout(ram_init_busy_b_int)
        );
      pmc_sync_flop_behav_v3
        #(.RETIMING_FLOP_NUM(2),
          .RESET_VALUE(1),
          .MTBF(1))
        pmc_sync_flop_rambc_init_busy
        ( .sigin(ram_init_busy_b_int),
          .gray_clk(1'b0),
          .clk(bclk),
          .rstb(brstb),
          .sigout(ram_init_busy_c_int)
        );
      pmc_sync_flop_behav_v3
        #(.RETIMING_FLOP_NUM(2),
          .RESET_VALUE(0),
          .MTBF(1))
        pmc_sync_flop_ram_ab_init_start
        ( .sigin(ram_init_start_a_int),
          .gray_clk(1'b0),
          .clk(bclk),
          .rstb(brstb),
          .sigout(ram_init_start_b_int)
        );
      pmc_sync_flop_behav_v3
        #(.RETIMING_FLOP_NUM(2),
          .RESET_VALUE(0),
          .MTBF(1))
        pmc_sync_flop_ram_bc_init_start
        ( .sigin(ram_init_start_b_int),
          .gray_clk(1'b0),
          .clk(bclk),
          .rstb(brstb),
          .sigout(ram_init_start_c_int)
        );
    end : gen_busy_sync
  // no need for sync flops if bclk and aclk are sync
    else if ( ( RAM_INIT_GEN == BIST_TRUE ) && ( FUNC_CLKS_SYNC == BIST_TRUE  ) )
    begin : busy_no_sync
      assign ram_init_busy_b_int  = ram_init_busy_a_int;
      assign ram_init_start_b_int = ram_init_start_a_int;
      assign ram_init_busy_c_int  = ram_init_busy_b_int;
      assign ram_init_start_c_int = ram_init_start_b_int;
    end : busy_no_sync
  endgenerate

endmodule : miv_rv32_bistdual_ram_init

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// This block makes RAM behaviour the same in both ASIC and FPGA.
// There are three different modes in this design:
// 1) ASIC mode:
//      -no FPGA compatible logic is generated
//      -all signals are feed through
//
// 2) FPGA compatible mode with synchronous clocks
//
// 3) FPGA compatible mode with asynchronous clocks
//      -assertions detect simultaneous read/write and simultaneous write/write
//      -error message is displayed if above accesses are detected and 
//       simulation will be aborted
//
//
// PARAMETER DESCRIPTION:
//
// RAM_STABILIZER         FPGA compatible logic selection
// FUNC_CLKS_SYNC         A and B clocks are functionally the same
// ADDR_WIDTH             Number of address bits
// DATA_WIDTH             Number of data bits per word
//
//
// INPUT PORT DESCRIPTION:
//
// arstb                  Active-low reset for port A
// aclk                   RAM clock for port A
// aaddr                  RAM read/write address for port A
// aceb_in                Active-low RAM cell enable for port A
// aweb                   Active-low RAM read/write for port A
// awemb_and              Active-low AND-ed RAM write enable mask
// adin                   RAM write data for port A
// adout_in               RAM write data for port A
// brstb                  Active-low reset for port B
// bclk                   RAM clock for port B
// baddr                  RAM read/write address for port B
// bceb_in                Active-low RAM cell enable for port B
// bweb                   Active-low RAM read/write for port B
// bwemb_and              Active-low AND-ed RAM write enable mask
// bdin                   RAM write data for port B
// bdout_in               RAM write data for port B
//
//
// OUTPUT PORT DESCRIPTION:
//
// aceb_out               Active-low RAM cell enable for port A
// bceb_out               Active-low RAM cell enable for port B
// adout                  RAM read data for port A
// bdout                  RAM read data for port B
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_ram_stabilizer
  #(
    parameter miv_rv32_pkg::t_bist_true_false RAM_STABILIZER
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_pkg::BIST_FALSE,
    parameter ADDR_WIDTH      = 4,
    parameter DATA_WIDTH      = 8
  )
  (
    input  wire logic arstb,
    input  wire logic aclk,
    input  wire logic aceb_in,
    input  wire logic aweb,
    input  wire logic awemb_and,
	
    input  wire logic brstb,
    input  wire logic bclk,
    input  wire logic bceb_in,
    input  wire logic bweb,
    input  wire logic bwemb_and,
	
    input  wire logic crstb,
    input  wire logic cclk,
    input  wire logic cceb_in,
    input  wire logic cweb,
    input  wire logic cwemb_and,
    
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
	
    input  wire logic [ADDR_WIDTH-1:0] baddr,    
	
    input  wire logic [ADDR_WIDTH-1:0] caddr,    
	
    input  wire logic [DATA_WIDTH-1:0] adin,
    input  wire logic [DATA_WIDTH-1:0] adout_in,
	
    input  wire logic [DATA_WIDTH-1:0] bdin,
    input  wire logic [DATA_WIDTH-1:0] bdout_in,
	
    input  wire logic [DATA_WIDTH-1:0] cdin,
    input  wire logic [DATA_WIDTH-1:0] cdout_in,
    
    output      logic aceb_out,
    output      logic bceb_out,
    output      logic cceb_out,
    
    output      logic [DATA_WIDTH-1:0] adout_out,
    output      logic [DATA_WIDTH-1:0] bdout_out,
    output      logic [DATA_WIDTH-1:0] cdout_out
  );
  
  // IMPORT PACKAGE
  import miv_rv32_pkg::*;
  
  // INTERNAL SIGNALS
  logic simul_rw;
  logic simul_ww;
  logic simul_a_mask;
  logic simul_b_mask;
  logic simul_c_mask;
  logic simul_rw_latched;
  logic simul_ww_latched;
  
  logic aceb_latched;
  logic aweb_latched;
  logic awemb_latched;
  
  logic bceb_latched;
  logic bweb_latched;
  logic bwemb_latched;
  
  logic cceb_latched;
  logic cweb_latched;
  logic cwemb_latched;
  
  logic [DATA_WIDTH-1:0] w_data;
  logic [ADDR_WIDTH-1:0] aaddr_latched;
  logic [ADDR_WIDTH-1:0] baddr_latched;
  logic [ADDR_WIDTH-1:0] caddr_latched;
  
  //----------------------------------------------------------------------------
  // No FPGA compatible logic or FPGA compatible logic for asynchronous clocks
  //----------------------------------------------------------------------------
  generate
    if ( RAM_STABILIZER == BIST_FALSE || 
         (RAM_STABILIZER == BIST_TRUE && FUNC_CLKS_SYNC == BIST_FALSE) ) 
    begin : no_ram_stabilizer_logic
      // all signals are feed through
      assign aceb_out = aceb_in;
      assign bceb_out = bceb_in;
      assign cceb_out = cceb_in;
      assign adout_out = adout_in;
      assign bdout_out = bdout_in;
      assign cdout_out = cdout_in;
    end : no_ram_stabilizer_logic
  
  //----------------------------------------------------------------------------
  // FPGA compatible logic for synchronous clocks
  //----------------------------------------------------------------------------
    else if ( RAM_STABILIZER == BIST_TRUE && FUNC_CLKS_SYNC == BIST_TRUE )
    begin : ram_stabilizer_logic_sync
    
      // detect simultaneous accesses (write/write and read/write)
      // also create mask signals (for write/write and read side for read/write)
      always @(*)
      begin : simul_rw_detect
        if ( aaddr == baddr && aceb_in == 1'b0 && bceb_in == 1'b0 ) begin
          if ( (aweb == 1'b0 && awemb_and == 1'b0) && 
               (bweb == 1'b0 && bwemb_and == 1'b0) ) begin
            // simultaneous write/write
            simul_ww     = 1'b1;
            simul_rw     = 1'b0;
            simul_a_mask = 1'b0;
            simul_b_mask = 1'b1;
          end
          else if ( aweb == 1'b0 && awemb_and == 1'b0 ) begin
            // simultaneous A write, B read
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_a_mask = 1'b0;
            simul_b_mask = 1'b1;
          end
          else if ( bweb == 1'b0 && bwemb_and == 1'b0 ) begin
            // simultaneous A read, B write
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_a_mask = 1'b1;
            simul_b_mask = 1'b0;
          end
          else begin
            // simultaneous read/read
            simul_ww     = 1'b0;
            simul_rw     = 1'b0;
            simul_a_mask = 1'b0;
            simul_b_mask = 1'b0;
          end
        end
		
        else if ( aaddr == caddr && aceb_in == 1'b0 && cceb_in == 1'b0 ) begin
          if ( (aweb == 1'b0 && awemb_and == 1'b0) && 
               (cweb == 1'b0 && cwemb_and == 1'b0) ) begin
            // simultaneous write/write
            simul_ww     = 1'b1;
            simul_rw     = 1'b0;
            simul_a_mask = 1'b0;
            simul_c_mask = 1'b1;
          end
          else if ( aweb == 1'b0 && awemb_and == 1'b0 ) begin
            // simultaneous A write, B read
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_a_mask = 1'b0;
            simul_c_mask = 1'b1;
          end
          else if ( cweb == 1'b0 && cwemb_and == 1'b0 ) begin
            // simultaneous A read, B write
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_a_mask = 1'b1;
            simul_c_mask = 1'b0;
          end
          else begin
            // simultaneous read/read
            simul_ww     = 1'b0;
            simul_rw     = 1'b0;
            simul_a_mask = 1'b0;
            simul_c_mask = 1'b0;
          end
        end
		
        else if ( baddr == caddr && bceb_in == 1'b0 && cceb_in == 1'b0 ) begin
          if ( (bweb == 1'b0 && bwemb_and == 1'b0) && 
               (cweb == 1'b0 && cwemb_and == 1'b0) ) begin
            // simultaneous write/write
            simul_ww     = 1'b1;
            simul_rw     = 1'b0;
            simul_b_mask = 1'b0;
            simul_c_mask = 1'b1;
          end
          else if ( bweb == 1'b0 && bwemb_and == 1'b0 ) begin
            // simultaneous A write, B read
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_b_mask = 1'b0;
            simul_c_mask = 1'b1;
          end
          else if ( cweb == 1'b0 && cwemb_and == 1'b0 ) begin
            // simultaneous A read, B write
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_b_mask = 1'b1;
            simul_c_mask = 1'b0;
          end
          else begin
            // simultaneous read/read
            simul_ww     = 1'b0;
            simul_rw     = 1'b0;
            simul_b_mask = 1'b0;
            simul_c_mask = 1'b0;
          end
        end
		
        else begin
          // normal access
          simul_ww     = 1'b0;
          simul_rw     = 1'b0;
          simul_a_mask = 1'b0;
          simul_b_mask = 1'b0;
          simul_c_mask = 1'b0;
        end
      end : simul_rw_detect
      
      // generate simultaneous read/write flop
      always_ff @(posedge aclk or negedge arstb)
      begin : latch_simul_rw
        if ( arstb != 1'b1 ) begin
          simul_rw_latched <= 1'b0;
        end
        else begin
          simul_rw_latched <= simul_rw;
        end
      end : latch_simul_rw
      
      // simultaneous write/write flop
      always_ff @(posedge aclk or negedge arstb)
      begin : latch_simul_ww
        if ( arstb != 1'b1 ) begin
          simul_ww_latched <= 1'b0;
        end
        else begin
          simul_ww_latched <= simul_ww;
        end
      end : latch_simul_ww
      
      // generate write data flops
      // select output data on read/write
      always_ff @(posedge aclk or negedge arstb)
      begin : gen_w_data_flops
        if ( arstb != 1'b1 ) begin
          w_data <= {DATA_WIDTH{1'b0}};
        end
        else begin
          if ( simul_a_mask == 1'b0 ) begin
            w_data <= adin;
          end
          else if ( simul_b_mask == 1'b0 ) begin
            w_data <= bdin;
          end
          else begin
            w_data <= cdin;
          end
        end
      end : gen_w_data_flops
      
      // generate aceb
      // aceb is masked when A read and B write
      always @(*)
      begin : gen_aceb_out
        if ( simul_a_mask == 1'b1 ) begin
          aceb_out = 1'b1;
        end
        else begin
          aceb_out = aceb_in;
        end
      end : gen_aceb_out
      
      // gen bceb
      // bceb is masked if:
      //   1) A write and B read
      //   2) A write and B write
      always @(*)
      begin : gen_bceb_out
        if ( simul_b_mask == 1'b1 ) begin
          bceb_out = 1'b1;
        end
        else begin
          bceb_out = bceb_in;
        end
      end : gen_bceb_out
      
      // gen cceb
      // bceb is masked if:
      //   1) A write or B write and C read
      //   2) A write or B write and C write
      always @(*)
      begin : gen_cceb_out
        if ( simul_c_mask == 1'b1 ) begin
          cceb_out = 1'b1;
        end
        else begin
          cceb_out = cceb_in;
        end
      end : gen_cceb_out
      
      // dout select mux
      // 1) write and write : all 0 for both adout and bdout
      // 2) write and read  : write data is bypassed to outputs
      // 3) other cases     : adout is RAM adout and bdout is RAM bdout
      always @(*)
      begin : dout_sel
        if ( simul_ww_latched == 1'b1 ) begin
          adout_out = {DATA_WIDTH{1'b0}};
          bdout_out = {DATA_WIDTH{1'b0}};
          cdout_out = {DATA_WIDTH{1'b0}};
        end
        else if ( simul_rw_latched == 1'b1 ) begin
          adout_out = w_data;
          bdout_out = w_data;
          cdout_out = w_data;
        end
        else begin
          adout_out = adout_in;
          bdout_out = bdout_in;
          cdout_out = bdout_in;
        end
      end : dout_sel
    end : ram_stabilizer_logic_sync
  endgenerate

  //----------------------------------------------------------------------------
  // Assertion on async clock and simultaneous access
  //----------------------------------------------------------------------------
  // pragma translate_off
  generate
    if (RAM_STABILIZER == BIST_TRUE && FUNC_CLKS_SYNC == BIST_FALSE) 
    begin : async_assert
      always @(negedge arstb or posedge aclk) begin 
        if(arstb != 1'b 1) begin
          aaddr_latched <= {ADDR_WIDTH{1'b0}};
          aceb_latched  <= 1'b1;
          aweb_latched  <= 1'b1;
          awemb_latched <= 1'b1;
        end
        else begin
          aaddr_latched <= aaddr;
          aceb_latched  <= aceb_in;
          aweb_latched  <= aweb;
          awemb_latched <= awemb_and;
        end
      end
      always @(negedge brstb or posedge bclk) begin 
        if(brstb != 1'b 1) begin
          baddr_latched <= {ADDR_WIDTH{1'b0}};
          bceb_latched  <= 1'b1;
          bweb_latched  <= 1'b1;
          bwemb_latched <= 1'b1;
        end
        else begin
          baddr_latched <= baddr;
          bceb_latched  <= bceb_in;
          bweb_latched  <= bweb;
          bwemb_latched <= bwemb_and;
        end
      end
      always @(negedge crstb or posedge cclk) begin 
        if(crstb != 1'b 1) begin
          caddr_latched <= {ADDR_WIDTH{1'b0}};
          cceb_latched  <= 1'b1;
          cweb_latched  <= 1'b1;
          cwemb_latched <= 1'b1;
        end
        else begin
          caddr_latched <= caddr;
          cceb_latched  <= cceb_in;
          cweb_latched  <= cweb;
          cwemb_latched <= cwemb_and;
        end
      end
      always @(aaddr_latched or aceb_latched or aweb_latched or awemb_latched or
               baddr_latched or bceb_latched or bweb_latched or bwemb_latched or
               caddr_latched or cceb_latched or cweb_latched or cwemb_latched) begin
        if (aaddr_latched == baddr_latched && 
            ((aceb_latched == 1'b0 && bceb_latched == 1'b0 && cceb_latched == 1'b0) &&
            ((aweb_latched == 1'b0 && awemb_latched == 1'b0) || (bweb_latched == 1'b0 && bwemb_latched == 1'b0) || (cweb_latched == 1'b0 && cwemb_latched == 1'b0)))) begin
          simul_rw <= 1'b1;
        end
        else begin
          simul_rw <= 1'b0;
        end
      end
      // assertion
      always @(simul_rw) begin
        assert (simul_rw == 1'b0)
        else begin
          $display( "Error: Found Simultaneous access on the same address. (async. clock)");
          $error;
        end
      end 
    end : async_assert
  endgenerate
  // pragma translate_on

endmodule : miv_rv32_bistdual_ram_stabilizer

// Reset default nettype for 3rd Party IP
`default_nettype wire
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements a mux for the RAM BIST blocks.  There is no test out signal
// because the scan data passes through these muxes.
//
//
// INPUT PORT DESCRIPTION:
//
// sigin                  Incoming normal mode signal
// tstin                  Incoming test mode signal
// tstsel                 Selects either incoming or test value
//
//
// OUTPUT PORT DESCRIPTION:
//
// sigout                 Output normal mode signal
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistmux
  #(
    parameter miv_rv32_pkg::t_bist_true_false RTL_MUX
                         = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false LW_MACRO
                         = miv_rv32_pkg::BIST_TRUE
  )
  (
    input  wire logic sigin,
    input  wire logic tstin,
    input  wire logic tstsel,
    output      logic sigout
  );
  
  import miv_rv32_pkg::*;
 
  generate
    if (RTL_MUX == BIST_FALSE) begin : macro_mux
      if (LW_MACRO == BIST_TRUE) begin : lw_mux
        miv_rv32_logic_mux_behav_v2 
          bistmux_inst
          (
            .a(sigin),
            .b(tstin),
            .s0(tstsel),
            .y(sigout)
          );
      end : lw_mux
      else begin : icdc_mux
        pmc_logic_mux_behav
          bistmux_inst
          (
            .A(sigin),
            .B(tstin),
            .S0(tstsel),
            .Y(sigout)
          );
      end : icdc_mux
    end : macro_mux
    else begin : rtl_mux
      assign sigout = tstsel ? tstin : sigin;
    end : rtl_mux
  endgenerate

endmodule : miv_rv32_bistmux

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Provides address decoding for the check bits calculated by the ECC block.
// The input to this block is a bit vector, which represents the binary value
// of the address bit.  The output of this block is a bit vector that has a 0
// in every bit except the address bit.
//
//
// PARAMETER DESCRIPTION:
//
// PARITY_WIDTH_MAX       Maximum width of ecc_parity
// MAX_ADDR_WIDTH         Maximum width of address = 2**(ecc_parity-1)
// ECC_PARITY_WIDTH       Width of the parity bus
//                        (This value is set in the ECC block; it is passed to
//                        the address decoder so that the ECC check bits can be
//                        properly decoded.)
//
//
// INPUT PORT DESCRIPTION:
//
// addr_in                Check bit address bus.  The width of this bus is
//                        defined as the actual width of the parity bus in the
//                        ECC, less the MSB (CT).
//
//
// OUTPUT PORT DESCRIPTION:
//
// addr_out               Decoded address bus (every bit is 0 except for the
//                        bit location in the addr_in position)
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bist_decode
  #(
    parameter CHECK_TOTAL_WIDTH = 10,
    parameter MAX_ADDR_WIDTH    = 16,
    parameter ECC_PARITY_WIDTH  = 5
  )
  (
    input  wire logic [CHECK_TOTAL_WIDTH-1:0] addr_in,
    output      logic [MAX_ADDR_WIDTH-1:0]    addr_out
  );
  
  // Implementation
  localparam logic GRND            = 1'b0;
  localparam       DEC_4_WIDTH     = 4;
  localparam       DEC_8_WIDTH     = 8;
  localparam       DEC_16_WIDTH    = 16;
  localparam       DEC_32_WIDTH    = 32;
  localparam       DEC_64_WIDTH    = 64;
  localparam       DEC_128_WIDTH   = 128;
  localparam       SEL_2_WIDTH     = 2;
  localparam       SEL_3_WIDTH     = 3;
  
  logic [DEC_4_WIDTH-1:0]   dec_enb;
  logic [DEC_32_WIDTH-1:0]  dec8enb;
  
  logic [DEC_8_WIDTH-1:0]   dec_enb_8;
  logic [DEC_16_WIDTH-1:0]  dec_enb_16;
  logic [DEC_64_WIDTH-1:0]  dec_enb_64;
  logic [DEC_128_WIDTH-1:0] dec_enb_128;
  
  logic [MAX_ADDR_WIDTH-1:0] addr_out_int;
  
  // Functions for decoder logic
  function automatic logic [3:0] core_bist_dec4 (
    input  logic                   enb,
    input  logic [SEL_2_WIDTH-1:0] sel
  );  
    if ( enb == 1'b0 ) begin
      // Zero-hot decoder
      unique case ( sel )
        2'b00:  core_bist_dec4 = 4'b1110;
        2'b01:  core_bist_dec4 = 4'b1101;
        2'b10:  core_bist_dec4 = 4'b1011;
        2'b11:  core_bist_dec4 = 4'b0111;
        default: core_bist_dec4 = 4'b1111;
      endcase
    end
    else begin
      core_bist_dec4 = 4'b1111;
    end  
  endfunction : core_bist_dec4  
  
  function automatic logic [7:0] core_bist_dec8 (
    input  logic                   enb,
    input  logic [SEL_3_WIDTH-1:0] sel
  );
    if ( enb == 1'b0 ) begin
      unique case ( sel ) 
        3'b000:  core_bist_dec8 = 8'b1111_1110;
        3'b001:  core_bist_dec8 = 8'b1111_1101;
        3'b010:  core_bist_dec8 = 8'b1111_1011;
        3'b011:  core_bist_dec8 = 8'b1111_0111;
        3'b100:  core_bist_dec8 = 8'b1110_1111;
        3'b101:  core_bist_dec8 = 8'b1101_1111;
        3'b110:  core_bist_dec8 = 8'b1011_1111;
        3'b111:  core_bist_dec8 = 8'b0111_1111;
        default: core_bist_dec8 = 8'b1111_1111;
      endcase
    end
    else begin
      core_bist_dec8 = 8'b1111_1111;
    end  
  endfunction : core_bist_dec8
  
  generate
    case ( ECC_PARITY_WIDTH ) 
      3 : 
        begin : case_1 // 2 check bits: C2, C1
          assign addr_out_int[3:0] = core_bist_dec4(GRND, addr_in[1:0]);
        end : case_1
      4 : 
        begin : case_2 // 3 check bits: C4, C2, C1
          assign addr_out_int[7:0] = core_bist_dec8(GRND, addr_in[2:0]);
        end : case_2
      5 :
        begin : case_3 // 4 check bits: C8, C4, C2, C1
          assign dec_enb[0] = addr_in[3];
          assign dec_enb[1] = !addr_in[3];
          
          genvar i;
          for ( i = 0; i <= 1; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_3
      6 :
        begin : case_4 // 5 check bits: C16, C8, C4, C2, C1
          assign dec8enb[3:0] = core_bist_dec4(GRND, addr_in[4:3]);
          
          genvar i;
          for ( i = 0; i <= 3; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_4
      7 :
        begin : case_5 // 6 check bits: C32, C16, C8, C4, C2, C1
          assign dec8enb[7:0] = core_bist_dec8(GRND, addr_in[5:3]);
          
          genvar i;
          for ( i = 0; i <= 7; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_5
      8 :
        begin : case_6 // 7 check bits: C64, C32, C16, C8, C4, C2, C1
          assign dec_enb[0] = addr_in[6];
          assign dec_enb[1] = !addr_in[6];
          
          genvar i;
          for ( i = 0; i <= 1; i++ ) begin : dec8_enable_gen
            assign dec8enb[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                         addr_in[5:3]);
          end : dec8_enable_gen
          
          for ( i = 0; i <= 15; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_6
      9 :
        begin : case_7 // 8 check bits: C128, C64, C32, C16, C8, C4, C2, C1
          assign dec_enb[3:0] = core_bist_dec4(GRND, addr_in[7:6]);
          
          genvar i;
          for ( i = 0; i <= 3; i++ ) begin : dec8_enable_gen
            assign dec8enb[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                         addr_in[5:3]);
          end : dec8_enable_gen
          
          for ( i = 0; i <= 31; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_7
      10 :
        begin : case_8 // 9 check bits: C256, C128, C64, C32, C16, C8, etc.
          // decode the top 3 address bits
          assign dec_enb_8[7:0] = core_bist_dec8(GRND, addr_in[8:6]);
          
          // decode the middle 3 address bits
          genvar i;
          for ( i = 0; i <= 7; i++ ) begin : middle_8_addr_dec
            assign dec_enb_64[8*i+7:8*i] = core_bist_dec8(dec_enb_8[i], 
                                                            addr_in[5:3]);
          end : middle_8_addr_dec
          
          // decode the bottom 3 address bits
          for ( i = 0; i <= 63; i++ ) begin : bottom_8_addr_dec
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec_enb_64[i], 
                                                              addr_in[2:0]);
          end : bottom_8_addr_dec
        end : case_8
      11 :
        begin : case_9 //10 check bits: C512, C256, C128, C64, C32, C16, etc.
          // decode top address bit
          assign dec_enb[0] = addr_in[9];
          assign dec_enb[1] = !addr_in[9];
          
          // decode address bits 8-6
          genvar i;
          for ( i = 0; i <= 1; i++ ) begin : dec16_enable_gen
            assign dec_enb_16[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                            addr_in[8:6]);
          end : dec16_enable_gen
          
          // decode address bits 5-3
          for ( i = 0; i <= 15; i++ ) begin : dec128_enable_gen
            assign dec_enb_128[8*i+7:8*i] = core_bist_dec8(dec_enb_16[i], 
                                                             addr_in[5:3]);
          end : dec128_enable_gen
          
          // decode address bits 2-0
          for ( i = 0; i <= 127; i++ ) begin : bottom_8_addr_dec
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec_enb_128[i], 
                                                              addr_in[2:0]);
          end : bottom_8_addr_dec
        end : case_9
    endcase
  endgenerate
  
  // Create the register read signals
  always @(*) begin : gen_addr_out
    for ( int j = 0; j < MAX_ADDR_WIDTH; j++ ) begin
      addr_out[j] = !addr_out_int[j];
    end
  end : gen_addr_out

endmodule : miv_rv32_bist_decode

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Error-correction code (ECC) circuitry can be added to SRAM's to
// prevent random single-cell errors.  The ECC circuitry has the 
// ability to detect and correct single-bit errors in a word that
// is read from memory.  Before the word is written to memory, the
// ECC block will generate a parity word that is unique to the data
// word being written to memory.  The parity word will allow the ECC
// circuitry to detect and possibly correct any bit errors in the
// data word, when it is read back out from memory.  The ECC can 
// detect and correct single-bit errors, and detect (but not correct)
// two-bit errors or any even multiple of bit-errors.
// The ECC block is based on a single-error correction, double-error 
// detection method (Hamming ECC Code), which uses enough parity 
// bits to be able to identify and correct any single-bit errors in
// a word.  This method also allows the ECC to identify two 
// bit-errors.  The ECC block uses even parity.
//
// Parameter Description:
//
// MEMORY_WRITE      Set this bit to '1' if you only want to generate
//                   the circuitry required to generate the parity
//                   bits.
//                   When writing data words to RAM, this is all that's 
//                   required (saves power and gates by not generating
//                   extra logic).
// MEMORY_READ       Set this bit to '1' if you only want to generate 
//                   the circuitry required to generate the check
//                   (syndrome) bits, and correct the data word that 
//                   was read from RAM.
//                   When reading data words from RAM, this is all 
//                   that's equired (saves power and gates by not
//                   generating extra logic).
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
//
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
//
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc
  #(
    parameter BIST_ECC_EMPTY   = 0,
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter MEMORY_WRITE     = 0,
    parameter MEMORY_READ      = 1
  )
  (
    input  wire logic                        ecc_bypass,
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    input  wire logic [ECC_PARITY_WIDTH-1:0] parity_in,
    output      logic                        err_multpl,
    output      logic                        err_detect,
    output      logic [DATA_WIDTH-1:0]       data_out,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out
  );

// Start the RTL code:

  generate 
    case (BIST_ECC_EMPTY) 
    1 : 
      begin : ecc_empty_generate
        miv_rv32_bist_ecc_empty
          #(
            .DATA_WIDTH(DATA_WIDTH),
            .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH)
          )
          ecc_emtpy
          (
            .data_in,
            .err_multpl,
            .err_detect,
            .data_out,
            .parity_out,
            .check_out
          );
      end : ecc_empty_generate
    default : 
      begin : ecc_generate
        miv_rv32_bist_ecc_core
          #(
            .DATA_WIDTH(DATA_WIDTH),
            .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH),
            .MEMORY_WRITE(MEMORY_WRITE),
            .MEMORY_READ(MEMORY_READ)
          )
          ecc_core
          (
            .ecc_bypass,
            .data_in,
            .parity_in,
            .err_multpl,
            .err_detect,
            .data_out,
            .parity_out,
            .check_out
          );
      end : ecc_generate
    endcase
  endgenerate

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// ECC core block. Detailed functionality of the ECC block is
// desctibed in miv_rv32_bist_ecc module.
//
// Parameter Description:
// MEMORY_WRITE      Set this bit to '1' if you only want to generate
//                   the circuitry required to generate the parity
//                   bits.
//                   When writing data words to RAM, this is all that's 
//                   required (saves power and gates by not generating
//                   extra logic).
// MEMORY_READ       Set this bit to '1' if you only want to generate 
//                   the circuitry required to generate the check
//                   (syndrome) bits, and correct the data word that 
//                   was read from RAM.
//                   When reading data words from RAM, this is all 
//                   that's equired (saves power and gates by not
//                   generating extra logic).
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_core
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter MEMORY_WRITE     = 0,
    parameter MEMORY_READ      = 1
  )
  (
    input  wire logic                        ecc_bypass,
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    input  wire logic [ECC_PARITY_WIDTH-1:0] parity_in,
    output      logic                        err_multpl,
    output      logic                        err_detect,
    output      logic [DATA_WIDTH-1:0]       data_out,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out
  );

// Implementation
localparam MAX_DATA_WIDTH   = 1013;
localparam PARITY_WIDTH_MAX = 11;

logic [PARITY_WIDTH_MAX-1:0] parity_1_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_2_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_4_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_8_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_16_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_32_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_64_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_128_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_256_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_512_calc;
logic [ECC_PARITY_WIDTH-1:0] parity_out_output;
logic [ECC_PARITY_WIDTH-1:0] parity_out_corrected_output;
logic [ECC_PARITY_WIDTH-1:0] check_out_output;
logic [DATA_WIDTH - 1:0]     data_out_output;
logic                        err_multpl_output;
logic                        err_detect_output;  

// 'data_in' bus zero padded up to the most significant bit (needed for parity bit 
// calculations)
logic [MAX_DATA_WIDTH-1:0] data_in_zero_padded;  

// Start the RTL code:

  // DATA BUS EXTENSION (ALWAYS GENERATED)
  //
  // Extend the data bus to the maximum data width
  // The Parity Generator Block and the Check Bit Generatory
  // and Error-correction Circuitry use this bus.
  generate
    if(MAX_DATA_WIDTH > DATA_WIDTH) begin : data_bus_extension_gen
      assign data_in_zero_padded[MAX_DATA_WIDTH-1:DATA_WIDTH] = {(MAX_DATA_WIDTH-DATA_WIDTH){1'b0}};
    end : data_bus_extension_gen
  endgenerate

  always @(*) 
  begin : data_bus_extansion
    data_in_zero_padded[DATA_WIDTH-1:0] <= data_in;
  end : data_bus_extansion

  // *********************************
  // Temporary Parity Bit Calculations
  // Always generated
  // *********************************
  // Generate all the intermediate parity bits.  These lengthy XOR
  // calculations are used to calculate both the parity bits
  // (RAM write) and the check bits (RAM read).  For this
  // reason, the logic will always be generated (based on the data
  // bus width).  All the processes used to calculate the temporary
  // parity bits are sensitive to the data_in_zero_padded bus.
  always @(*) 
  begin : parity_calcs_0_process
    parity_1_calc[0] = data_in_zero_padded[0];
    parity_2_calc[0] = data_in_zero_padded[0];
  end : parity_calcs_0_process

  generate
    if (DATA_WIDTH >= 2) begin : parity_calcs_1_generate
      always @(*) 
      begin : parity_calcs_1
        parity_1_calc[1] =   data_in_zero_padded[1] ^ data_in_zero_padded[3];
        parity_2_calc[1] =  ^data_in_zero_padded[3:2];
        parity_4_calc[1] =  ^data_in_zero_padded[3:1];
      end : parity_calcs_1
    end : parity_calcs_1_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 5) begin : parity_calcs_2_generate
      always @(*) 
      begin : parity_calcs_2
        parity_1_calc[2] =  data_in_zero_padded[4]   ^  data_in_zero_padded[6] ^ 
                            data_in_zero_padded[8]   ^  data_in_zero_padded[10];
        parity_2_calc[2] = ^data_in_zero_padded[6:5] ^ ^data_in_zero_padded[10:9];
        parity_4_calc[2] = ^data_in_zero_padded[10:7];
        parity_8_calc[2] = ^data_in_zero_padded[10:4];
      end : parity_calcs_2
    end : parity_calcs_2_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 12) begin : parity_calcs_3_generate
      always @(*) 
      begin : parity_calcs_3
        parity_1_calc[3]  =  data_in_zero_padded[11] ^     data_in_zero_padded[13] ^ 
                             data_in_zero_padded[15] ^     data_in_zero_padded[17] ^ 
                             data_in_zero_padded[19] ^     data_in_zero_padded[21] ^ 
                             data_in_zero_padded[23] ^     data_in_zero_padded[25];
        parity_2_calc[3]  = ^data_in_zero_padded[13:12] ^ ^data_in_zero_padded[17:16] ^
                            ^data_in_zero_padded[21:20] ^ ^data_in_zero_padded[25:24];
        parity_4_calc[3]  = ^data_in_zero_padded[17:14] ^ ^data_in_zero_padded[25:22];
        parity_8_calc[3]  = ^data_in_zero_padded[25:18];
        parity_16_calc[3] = ^data_in_zero_padded[25:11];
      end : parity_calcs_3
    end : parity_calcs_3_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 27) begin : parity_calcs_4_generate
      always @(*) 
      begin : parity_calcs_4
        parity_1_calc[4]  =  data_in_zero_padded[26] ^     data_in_zero_padded[28] ^ 
                             data_in_zero_padded[30] ^     data_in_zero_padded[32] ^ 
                             data_in_zero_padded[34] ^     data_in_zero_padded[36] ^ 
                             data_in_zero_padded[38] ^     data_in_zero_padded[40] ^ 
                             data_in_zero_padded[42] ^     data_in_zero_padded[44] ^ 
                             data_in_zero_padded[46] ^     data_in_zero_padded[48] ^ 
                             data_in_zero_padded[50] ^     data_in_zero_padded[52] ^ 
                             data_in_zero_padded[54] ^     data_in_zero_padded[56];
        parity_2_calc[4]  = ^data_in_zero_padded[28:27] ^ ^data_in_zero_padded[32:31] ^  
                            ^data_in_zero_padded[36:35] ^ ^data_in_zero_padded[40:39] ^  
                            ^data_in_zero_padded[44:43] ^ ^data_in_zero_padded[48:47] ^  
                            ^data_in_zero_padded[52:51] ^ ^data_in_zero_padded[56:55];
        parity_4_calc[4]  = ^data_in_zero_padded[32:29] ^ ^data_in_zero_padded[40:37] ^
                            ^data_in_zero_padded[48:45] ^ ^data_in_zero_padded[56:53];
        parity_8_calc[4]  = ^data_in_zero_padded[40:33] ^ ^data_in_zero_padded[56:49];
        parity_16_calc[4] = ^data_in_zero_padded[56:41];
        parity_32_calc[4] = ^data_in_zero_padded[56:26];
      end : parity_calcs_4
    end : parity_calcs_4_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 58) begin : parity_calcs_5_generate
        always @(*)
        begin : parity_calcs_5
          parity_1_calc[5]  =  data_in_zero_padded[57]  ^      data_in_zero_padded[59] ^ 
                               data_in_zero_padded[61]  ^      data_in_zero_padded[63] ^ 
                               data_in_zero_padded[65]  ^      data_in_zero_padded[67] ^ 
                               data_in_zero_padded[69]  ^      data_in_zero_padded[71] ^ 
                               data_in_zero_padded[73]  ^      data_in_zero_padded[75] ^ 
                               data_in_zero_padded[77]  ^      data_in_zero_padded[79] ^ 
                               data_in_zero_padded[81]  ^      data_in_zero_padded[83] ^ 
                               data_in_zero_padded[85]  ^      data_in_zero_padded[87] ^ 
                               data_in_zero_padded[89]  ^      data_in_zero_padded[91] ^ 
                               data_in_zero_padded[93]  ^      data_in_zero_padded[95] ^ 
                               data_in_zero_padded[97]  ^      data_in_zero_padded[99] ^ 
                               data_in_zero_padded[101] ^      data_in_zero_padded[103] ^ 
                               data_in_zero_padded[105] ^      data_in_zero_padded[107] ^ 
                               data_in_zero_padded[109] ^      data_in_zero_padded[111] ^ 
                               data_in_zero_padded[113] ^      data_in_zero_padded[115] ^ 
                               data_in_zero_padded[117] ^      data_in_zero_padded[119];
          parity_2_calc[5]  = ^data_in_zero_padded[59:58]   ^ ^data_in_zero_padded[63:62]  ^ 
                              ^data_in_zero_padded[67:66]   ^ ^data_in_zero_padded[71:70]  ^ 
                              ^data_in_zero_padded[75:74]   ^ ^data_in_zero_padded[79:78]  ^ 
                              ^data_in_zero_padded[83:82]   ^ ^data_in_zero_padded[87:86]  ^ 
                              ^data_in_zero_padded[91:90]   ^ ^data_in_zero_padded[95:94]  ^ 
                              ^data_in_zero_padded[99:98]   ^ ^data_in_zero_padded[103:102] ^ 
                              ^data_in_zero_padded[107:106] ^ ^data_in_zero_padded[111:110] ^ 
                              ^data_in_zero_padded[115:114] ^ ^data_in_zero_padded[119:118];
          parity_4_calc[5]  = ^data_in_zero_padded[63:60]   ^ ^data_in_zero_padded[71:68] ^
                              ^data_in_zero_padded[79:76]   ^ ^data_in_zero_padded[87:84] ^
                              ^data_in_zero_padded[95:92]   ^ ^data_in_zero_padded[103:100] ^
                              ^data_in_zero_padded[111:108] ^ ^data_in_zero_padded[119:116];
          parity_8_calc[5]  = ^data_in_zero_padded[71:64]   ^ ^data_in_zero_padded[87:80] ^
                              ^data_in_zero_padded[103:96]  ^ ^data_in_zero_padded[119:112];
          parity_16_calc[5] = ^data_in_zero_padded[87:72]   ^ ^data_in_zero_padded[119:104];
          parity_32_calc[5] = ^data_in_zero_padded[119:88];
          parity_64_calc[5] = ^data_in_zero_padded[119:57];
      end : parity_calcs_5
    end : parity_calcs_5_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 121) begin : parity_calcs_6_generate
      always @(*) 
      begin : parity_calcs_6
        parity_1_calc[6]   =  data_in_zero_padded[120] ^      data_in_zero_padded[122] ^ 
                              data_in_zero_padded[124] ^      data_in_zero_padded[126] ^ 
                              data_in_zero_padded[128] ^      data_in_zero_padded[130] ^ 
                              data_in_zero_padded[132] ^      data_in_zero_padded[134] ^ 
                              data_in_zero_padded[136] ^      data_in_zero_padded[138] ^ 
                              data_in_zero_padded[140] ^      data_in_zero_padded[142] ^ 
                              data_in_zero_padded[144] ^      data_in_zero_padded[146] ^ 
                              data_in_zero_padded[148] ^      data_in_zero_padded[150] ^ 
                              data_in_zero_padded[152] ^      data_in_zero_padded[154] ^ 
                              data_in_zero_padded[156] ^      data_in_zero_padded[158] ^ 
                              data_in_zero_padded[160] ^      data_in_zero_padded[162] ^ 
                              data_in_zero_padded[164] ^      data_in_zero_padded[166] ^ 
                              data_in_zero_padded[168] ^      data_in_zero_padded[170] ^ 
                              data_in_zero_padded[172] ^      data_in_zero_padded[174] ^ 
                              data_in_zero_padded[176] ^      data_in_zero_padded[178] ^ 
                              data_in_zero_padded[180] ^      data_in_zero_padded[182] ^ 
                              data_in_zero_padded[184] ^      data_in_zero_padded[186] ^ 
                              data_in_zero_padded[188] ^      data_in_zero_padded[190] ^ 
                              data_in_zero_padded[192] ^      data_in_zero_padded[194] ^ 
                              data_in_zero_padded[196] ^      data_in_zero_padded[198] ^ 
                              data_in_zero_padded[200] ^      data_in_zero_padded[202] ^ 
                              data_in_zero_padded[204] ^      data_in_zero_padded[206] ^ 
                              data_in_zero_padded[208] ^      data_in_zero_padded[210] ^ 
                              data_in_zero_padded[212] ^      data_in_zero_padded[214] ^ 
                              data_in_zero_padded[216] ^      data_in_zero_padded[218] ^ 
                              data_in_zero_padded[220] ^      data_in_zero_padded[222] ^ 
                              data_in_zero_padded[224] ^      data_in_zero_padded[226] ^ 
                              data_in_zero_padded[228] ^      data_in_zero_padded[230] ^ 
                              data_in_zero_padded[232] ^      data_in_zero_padded[234] ^ 
                              data_in_zero_padded[236] ^      data_in_zero_padded[238] ^ 
                              data_in_zero_padded[240] ^      data_in_zero_padded[242] ^ 
                              data_in_zero_padded[244] ^      data_in_zero_padded[246];
        parity_2_calc[6]   = ^data_in_zero_padded[122:121] ^ ^data_in_zero_padded[126:125] ^
                             ^data_in_zero_padded[130:129] ^ ^data_in_zero_padded[134:133] ^
                             ^data_in_zero_padded[138:137] ^ ^data_in_zero_padded[142:141] ^
                             ^data_in_zero_padded[146:145] ^ ^data_in_zero_padded[150:149] ^
                             ^data_in_zero_padded[154:153] ^ ^data_in_zero_padded[158:157] ^
                             ^data_in_zero_padded[162:161] ^ ^data_in_zero_padded[166:165] ^
                             ^data_in_zero_padded[170:169] ^ ^data_in_zero_padded[174:173] ^
                             ^data_in_zero_padded[178:177] ^ ^data_in_zero_padded[182:181] ^
                             ^data_in_zero_padded[186:185] ^ ^data_in_zero_padded[190:189] ^
                             ^data_in_zero_padded[194:193] ^ ^data_in_zero_padded[198:197] ^
                             ^data_in_zero_padded[202:201] ^ ^data_in_zero_padded[206:205] ^
                             ^data_in_zero_padded[210:209] ^ ^data_in_zero_padded[214:213] ^
                             ^data_in_zero_padded[218:217] ^ ^data_in_zero_padded[222:221] ^
                             ^data_in_zero_padded[226:225] ^ ^data_in_zero_padded[230:229] ^
                             ^data_in_zero_padded[234:233] ^ ^data_in_zero_padded[238:237] ^
                             ^data_in_zero_padded[242:241] ^ ^data_in_zero_padded[246:245];
        parity_4_calc[6]   = ^data_in_zero_padded[126:123] ^ ^data_in_zero_padded[134:131] ^
                             ^data_in_zero_padded[142:139] ^ ^data_in_zero_padded[150:147] ^
                             ^data_in_zero_padded[158:155] ^ ^data_in_zero_padded[166:163] ^
                             ^data_in_zero_padded[174:171] ^ ^data_in_zero_padded[182:179] ^
                             ^data_in_zero_padded[190:187] ^ ^data_in_zero_padded[198:195] ^
                             ^data_in_zero_padded[206:203] ^ ^data_in_zero_padded[214:211] ^
                             ^data_in_zero_padded[222:219] ^ ^data_in_zero_padded[230:227] ^
                             ^data_in_zero_padded[238:235] ^ ^data_in_zero_padded[246:243];
        parity_8_calc[6]   = ^data_in_zero_padded[134:127] ^ ^data_in_zero_padded[150:143] ^
                             ^data_in_zero_padded[166:159] ^ ^data_in_zero_padded[182:175] ^
                             ^data_in_zero_padded[198:191] ^ ^data_in_zero_padded[214:207] ^
                             ^data_in_zero_padded[230:223] ^ ^data_in_zero_padded[246:239];
        parity_16_calc[6]  = ^data_in_zero_padded[150:135] ^ ^data_in_zero_padded[182:167] ^
                             ^data_in_zero_padded[214:199] ^ ^data_in_zero_padded[246:231];
        parity_32_calc[6]  = ^data_in_zero_padded[182:151] ^ ^data_in_zero_padded[246:215];
        parity_64_calc[6]  = ^data_in_zero_padded[246:183];
        parity_128_calc[6] = ^data_in_zero_padded[246:120];
      end : parity_calcs_6
    end : parity_calcs_6_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 248) begin : parity_calcs_7_generate
      always @(*) 
      begin : parity_calcs_7
        parity_1_calc[7]   =  data_in_zero_padded[247] ^      data_in_zero_padded[249] ^ 
                              data_in_zero_padded[251] ^      data_in_zero_padded[253] ^ 
                              data_in_zero_padded[255] ^      data_in_zero_padded[257] ^ 
                              data_in_zero_padded[259] ^      data_in_zero_padded[261] ^ 
                              data_in_zero_padded[263] ^      data_in_zero_padded[265] ^ 
                              data_in_zero_padded[267] ^      data_in_zero_padded[269] ^ 
                              data_in_zero_padded[271] ^      data_in_zero_padded[273] ^ 
                              data_in_zero_padded[275] ^      data_in_zero_padded[277] ^ 
                              data_in_zero_padded[279] ^      data_in_zero_padded[281] ^ 
                              data_in_zero_padded[283] ^      data_in_zero_padded[285] ^ 
                              data_in_zero_padded[287] ^      data_in_zero_padded[289] ^ 
                              data_in_zero_padded[291] ^      data_in_zero_padded[293] ^ 
                              data_in_zero_padded[295] ^      data_in_zero_padded[297] ^ 
                              data_in_zero_padded[299] ^      data_in_zero_padded[301] ^ 
                              data_in_zero_padded[303] ^      data_in_zero_padded[305] ^ 
                              data_in_zero_padded[307] ^      data_in_zero_padded[309] ^ 
                              data_in_zero_padded[311] ^      data_in_zero_padded[313] ^ 
                              data_in_zero_padded[315] ^      data_in_zero_padded[317] ^ 
                              data_in_zero_padded[319] ^      data_in_zero_padded[321] ^ 
                              data_in_zero_padded[323] ^      data_in_zero_padded[325] ^ 
                              data_in_zero_padded[327] ^      data_in_zero_padded[329] ^ 
                              data_in_zero_padded[331] ^      data_in_zero_padded[333] ^ 
                              data_in_zero_padded[335] ^      data_in_zero_padded[337] ^ 
                              data_in_zero_padded[339] ^      data_in_zero_padded[341] ^ 
                              data_in_zero_padded[343] ^      data_in_zero_padded[345] ^ 
                              data_in_zero_padded[347] ^      data_in_zero_padded[349] ^ 
                              data_in_zero_padded[351] ^      data_in_zero_padded[353] ^ 
                              data_in_zero_padded[355] ^      data_in_zero_padded[357] ^ 
                              data_in_zero_padded[359] ^      data_in_zero_padded[361] ^ 
                              data_in_zero_padded[363] ^      data_in_zero_padded[365] ^ 
                              data_in_zero_padded[367] ^      data_in_zero_padded[369] ^ 
                              data_in_zero_padded[371] ^      data_in_zero_padded[373] ^ 
                              data_in_zero_padded[375] ^      data_in_zero_padded[377] ^ 
                              data_in_zero_padded[379] ^      data_in_zero_padded[381] ^ 
                              data_in_zero_padded[383] ^      data_in_zero_padded[385] ^ 
                              data_in_zero_padded[387] ^      data_in_zero_padded[389] ^ 
                              data_in_zero_padded[391] ^      data_in_zero_padded[393] ^ 
                              data_in_zero_padded[395] ^      data_in_zero_padded[397] ^ 
                              data_in_zero_padded[399] ^      data_in_zero_padded[401] ^ 
                              data_in_zero_padded[403] ^      data_in_zero_padded[405] ^ 
                              data_in_zero_padded[407] ^      data_in_zero_padded[409] ^ 
                              data_in_zero_padded[411] ^      data_in_zero_padded[413] ^ 
                              data_in_zero_padded[415] ^      data_in_zero_padded[417] ^ 
                              data_in_zero_padded[419] ^      data_in_zero_padded[421] ^ 
                              data_in_zero_padded[423] ^      data_in_zero_padded[425] ^ 
                              data_in_zero_padded[427] ^      data_in_zero_padded[429] ^ 
                              data_in_zero_padded[431] ^      data_in_zero_padded[433] ^ 
                              data_in_zero_padded[435] ^      data_in_zero_padded[437] ^ 
                              data_in_zero_padded[439] ^      data_in_zero_padded[441] ^ 
                              data_in_zero_padded[443] ^      data_in_zero_padded[445] ^ 
                              data_in_zero_padded[447] ^      data_in_zero_padded[449] ^ 
                              data_in_zero_padded[451] ^      data_in_zero_padded[453] ^ 
                              data_in_zero_padded[455] ^      data_in_zero_padded[457] ^ 
                              data_in_zero_padded[459] ^      data_in_zero_padded[461] ^ 
                              data_in_zero_padded[463] ^      data_in_zero_padded[465] ^ 
                              data_in_zero_padded[467] ^      data_in_zero_padded[469] ^ 
                              data_in_zero_padded[471] ^      data_in_zero_padded[473] ^ 
                              data_in_zero_padded[475] ^      data_in_zero_padded[477] ^ 
                              data_in_zero_padded[479] ^      data_in_zero_padded[481] ^ 
                              data_in_zero_padded[483] ^      data_in_zero_padded[485] ^ 
                              data_in_zero_padded[487] ^      data_in_zero_padded[489] ^ 
                              data_in_zero_padded[491] ^      data_in_zero_padded[493] ^ 
                              data_in_zero_padded[495] ^      data_in_zero_padded[497] ^ 
                              data_in_zero_padded[499] ^      data_in_zero_padded[501]; 
        parity_2_calc[7]   = ^data_in_zero_padded[249:248] ^ ^data_in_zero_padded[253:252] ^
                             ^data_in_zero_padded[257:256] ^ ^data_in_zero_padded[261:260] ^
                             ^data_in_zero_padded[265:264] ^ ^data_in_zero_padded[269:268] ^
                             ^data_in_zero_padded[273:272] ^ ^data_in_zero_padded[277:276] ^
                             ^data_in_zero_padded[281:280] ^ ^data_in_zero_padded[285:284] ^
                             ^data_in_zero_padded[289:288] ^ ^data_in_zero_padded[293:292] ^
                             ^data_in_zero_padded[297:296] ^ ^data_in_zero_padded[301:300] ^
                             ^data_in_zero_padded[305:304] ^ ^data_in_zero_padded[309:308] ^
                             ^data_in_zero_padded[313:312] ^ ^data_in_zero_padded[317:316] ^
                             ^data_in_zero_padded[321:320] ^ ^data_in_zero_padded[325:324] ^
                             ^data_in_zero_padded[329:328] ^ ^data_in_zero_padded[333:332] ^
                             ^data_in_zero_padded[337:336] ^ ^data_in_zero_padded[341:340] ^
                             ^data_in_zero_padded[345:344] ^ ^data_in_zero_padded[349:348] ^
                             ^data_in_zero_padded[353:352] ^ ^data_in_zero_padded[357:356] ^
                             ^data_in_zero_padded[361:360] ^ ^data_in_zero_padded[365:364] ^
                             ^data_in_zero_padded[369:368] ^ ^data_in_zero_padded[373:372] ^
                             ^data_in_zero_padded[377:376] ^ ^data_in_zero_padded[381:380] ^
                             ^data_in_zero_padded[385:384] ^ ^data_in_zero_padded[389:388] ^
                             ^data_in_zero_padded[393:392] ^ ^data_in_zero_padded[397:396] ^
                             ^data_in_zero_padded[401:400] ^ ^data_in_zero_padded[405:404] ^
                             ^data_in_zero_padded[409:408] ^ ^data_in_zero_padded[413:412] ^
                             ^data_in_zero_padded[417:416] ^ ^data_in_zero_padded[421:420] ^
                             ^data_in_zero_padded[425:424] ^ ^data_in_zero_padded[429:428] ^
                             ^data_in_zero_padded[433:432] ^ ^data_in_zero_padded[437:436] ^
                             ^data_in_zero_padded[441:440] ^ ^data_in_zero_padded[445:444] ^
                             ^data_in_zero_padded[449:448] ^ ^data_in_zero_padded[453:452] ^
                             ^data_in_zero_padded[457:456] ^ ^data_in_zero_padded[461:460] ^
                             ^data_in_zero_padded[465:464] ^ ^data_in_zero_padded[469:468] ^
                             ^data_in_zero_padded[473:472] ^ ^data_in_zero_padded[477:476] ^
                             ^data_in_zero_padded[481:480] ^ ^data_in_zero_padded[485:484] ^
                             ^data_in_zero_padded[489:488] ^ ^data_in_zero_padded[493:492] ^
                             ^data_in_zero_padded[497:496] ^ ^data_in_zero_padded[501:500];
        parity_4_calc[7]   = ^data_in_zero_padded[253:250] ^ ^data_in_zero_padded[261:258] ^
                             ^data_in_zero_padded[269:266] ^ ^data_in_zero_padded[277:274] ^
                             ^data_in_zero_padded[285:282] ^ ^data_in_zero_padded[293:290] ^
                             ^data_in_zero_padded[301:298] ^ ^data_in_zero_padded[309:306] ^
                             ^data_in_zero_padded[317:314] ^ ^data_in_zero_padded[325:322] ^
                             ^data_in_zero_padded[333:330] ^ ^data_in_zero_padded[341:338] ^
                             ^data_in_zero_padded[349:346] ^ ^data_in_zero_padded[357:354]  ^
                             ^data_in_zero_padded[365:362] ^ ^data_in_zero_padded[373:370] ^
                             ^data_in_zero_padded[381:378] ^ ^data_in_zero_padded[389:386] ^
                             ^data_in_zero_padded[397:394] ^ ^data_in_zero_padded[405:402] ^
                             ^data_in_zero_padded[413:410] ^ ^data_in_zero_padded[421:418] ^
                             ^data_in_zero_padded[429:426] ^ ^data_in_zero_padded[437:434] ^
                             ^data_in_zero_padded[445:442] ^ ^data_in_zero_padded[453:450] ^
                             ^data_in_zero_padded[461:458] ^ ^data_in_zero_padded[469:466] ^
                             ^data_in_zero_padded[477:474] ^ ^data_in_zero_padded[485:482] ^
                             ^data_in_zero_padded[493:490] ^ ^data_in_zero_padded[501:498];
        parity_8_calc[7]   = ^data_in_zero_padded[261:254] ^ ^data_in_zero_padded[277:270] ^
                             ^data_in_zero_padded[293:286] ^ ^data_in_zero_padded[309:302] ^
                             ^data_in_zero_padded[325:318] ^ ^data_in_zero_padded[341:334] ^
                             ^data_in_zero_padded[357:350] ^ ^data_in_zero_padded[373:366] ^
                             ^data_in_zero_padded[389:382] ^ ^data_in_zero_padded[405:398] ^
                             ^data_in_zero_padded[421:414] ^ ^data_in_zero_padded[437:430] ^
                             ^data_in_zero_padded[453:446] ^ ^data_in_zero_padded[469:462] ^
                             ^data_in_zero_padded[485:478] ^ ^data_in_zero_padded[501:494];
        parity_16_calc[7]  = ^data_in_zero_padded[277:262] ^ ^data_in_zero_padded[309:294] ^
                             ^data_in_zero_padded[341:326] ^ ^data_in_zero_padded[373:358] ^
                             ^data_in_zero_padded[405:390] ^ ^data_in_zero_padded[437:422] ^
                             ^data_in_zero_padded[469:454] ^ ^data_in_zero_padded[501:486];
        parity_32_calc[7]  = ^data_in_zero_padded[309:278] ^ ^data_in_zero_padded[373:342] ^
                             ^data_in_zero_padded[437:406] ^ ^data_in_zero_padded[501:470];
        parity_64_calc[7]  = ^data_in_zero_padded[373:310] ^ ^data_in_zero_padded[501:438];
        parity_128_calc[7] = ^data_in_zero_padded[501:374];
        parity_256_calc[7] = ^data_in_zero_padded[501:247];
      end : parity_calcs_7
    end : parity_calcs_7_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 503) begin : parity_calcs_8_generate
      always @(*) 
      begin : parity_calcs_8
      parity_1_calc[8]   =  data_in_zero_padded[502]  ^     	data_in_zero_padded[504] ^ 
                            data_in_zero_padded[506]  ^     	data_in_zero_padded[508] ^ 
                            data_in_zero_padded[510]  ^     	data_in_zero_padded[512] ^ 
                            data_in_zero_padded[514]  ^     	data_in_zero_padded[516] ^ 
                            data_in_zero_padded[518]  ^     	data_in_zero_padded[520] ^ 
                            data_in_zero_padded[522]  ^     	data_in_zero_padded[524] ^ 
                            data_in_zero_padded[526]  ^     	data_in_zero_padded[528] ^ 
                            data_in_zero_padded[530]  ^     	data_in_zero_padded[532] ^ 
                            data_in_zero_padded[534]  ^     	data_in_zero_padded[536] ^ 
                            data_in_zero_padded[538]  ^     	data_in_zero_padded[540] ^ 
                            data_in_zero_padded[542]  ^     	data_in_zero_padded[544] ^ 
                            data_in_zero_padded[546]  ^     	data_in_zero_padded[548] ^ 
                            data_in_zero_padded[550]  ^     	data_in_zero_padded[552] ^ 
                            data_in_zero_padded[554]  ^     	data_in_zero_padded[556] ^ 
                            data_in_zero_padded[558]  ^     	data_in_zero_padded[560] ^ 
                            data_in_zero_padded[562]  ^     	data_in_zero_padded[564] ^ 
                            data_in_zero_padded[566]  ^     	data_in_zero_padded[568] ^ 
                            data_in_zero_padded[570]  ^     	data_in_zero_padded[572] ^ 
                            data_in_zero_padded[574]  ^     	data_in_zero_padded[576] ^ 
                            data_in_zero_padded[578]  ^     	data_in_zero_padded[580] ^ 
                            data_in_zero_padded[582]  ^     	data_in_zero_padded[584] ^ 
                            data_in_zero_padded[586]  ^     	data_in_zero_padded[588] ^ 
                            data_in_zero_padded[590]  ^     	data_in_zero_padded[592] ^ 
                            data_in_zero_padded[594]  ^     	data_in_zero_padded[596] ^ 
                            data_in_zero_padded[598]  ^     	data_in_zero_padded[600] ^ 
                            data_in_zero_padded[602]  ^     	data_in_zero_padded[604] ^ 
                            data_in_zero_padded[606]  ^     	data_in_zero_padded[608] ^ 
                            data_in_zero_padded[610]  ^     	data_in_zero_padded[612] ^ 
                            data_in_zero_padded[614]  ^     	data_in_zero_padded[616] ^ 
                            data_in_zero_padded[618]  ^     	data_in_zero_padded[620] ^ 
                            data_in_zero_padded[622]  ^     	data_in_zero_padded[624] ^ 
                            data_in_zero_padded[626]  ^     	data_in_zero_padded[628] ^ 
                            data_in_zero_padded[630]  ^     	data_in_zero_padded[632] ^ 
                            data_in_zero_padded[634]  ^     	data_in_zero_padded[636] ^ 
                            data_in_zero_padded[638]  ^     	data_in_zero_padded[640] ^ 
                            data_in_zero_padded[642]  ^     	data_in_zero_padded[644] ^ 
                            data_in_zero_padded[646]  ^     	data_in_zero_padded[648] ^ 
                            data_in_zero_padded[650]  ^     	data_in_zero_padded[652] ^ 
                            data_in_zero_padded[654]  ^     	data_in_zero_padded[656] ^ 
                            data_in_zero_padded[658]  ^     	data_in_zero_padded[660] ^ 
                            data_in_zero_padded[662]  ^     	data_in_zero_padded[664] ^ 
                            data_in_zero_padded[666]  ^     	data_in_zero_padded[668] ^ 
                            data_in_zero_padded[670]  ^     	data_in_zero_padded[672] ^ 
                            data_in_zero_padded[674]  ^     	data_in_zero_padded[676] ^ 
                            data_in_zero_padded[678]  ^     	data_in_zero_padded[680] ^ 
                            data_in_zero_padded[682]  ^     	data_in_zero_padded[684] ^ 
                            data_in_zero_padded[686]  ^     	data_in_zero_padded[688] ^ 
                            data_in_zero_padded[690]  ^     	data_in_zero_padded[692] ^ 
                            data_in_zero_padded[694]  ^     	data_in_zero_padded[696] ^ 
                            data_in_zero_padded[698]  ^     	data_in_zero_padded[700] ^ 
                            data_in_zero_padded[702]  ^     	data_in_zero_padded[704] ^ 
                            data_in_zero_padded[706]  ^     	data_in_zero_padded[708] ^ 
                            data_in_zero_padded[710]  ^     	data_in_zero_padded[712] ^ 
                            data_in_zero_padded[714]  ^     	data_in_zero_padded[716] ^ 
                            data_in_zero_padded[718]  ^     	data_in_zero_padded[720] ^ 
                            data_in_zero_padded[722]  ^     	data_in_zero_padded[724] ^ 
                            data_in_zero_padded[726]  ^     	data_in_zero_padded[728] ^ 
                            data_in_zero_padded[730]  ^     	data_in_zero_padded[732] ^ 
                            data_in_zero_padded[734]  ^     	data_in_zero_padded[736] ^ 
                            data_in_zero_padded[738]  ^     	data_in_zero_padded[740] ^ 
                            data_in_zero_padded[742]  ^     	data_in_zero_padded[744] ^ 
                            data_in_zero_padded[746]  ^     	data_in_zero_padded[748] ^ 
                            data_in_zero_padded[750]  ^     	data_in_zero_padded[752] ^ 
                            data_in_zero_padded[754]  ^     	data_in_zero_padded[756] ^ 
                            data_in_zero_padded[758]  ^     	data_in_zero_padded[760] ^ 
                            data_in_zero_padded[762]  ^     	data_in_zero_padded[764] ^ 
                            data_in_zero_padded[766]  ^     	data_in_zero_padded[768] ^ 
                            data_in_zero_padded[770]  ^     	data_in_zero_padded[772] ^ 
                            data_in_zero_padded[774]  ^     	data_in_zero_padded[776] ^ 
                            data_in_zero_padded[778]  ^     	data_in_zero_padded[780] ^ 
                            data_in_zero_padded[782]  ^     	data_in_zero_padded[784] ^ 
                            data_in_zero_padded[786]  ^     	data_in_zero_padded[788] ^ 
                            data_in_zero_padded[790]  ^     	data_in_zero_padded[792] ^ 
                            data_in_zero_padded[794]  ^     	data_in_zero_padded[796] ^ 
                            data_in_zero_padded[798]  ^     	data_in_zero_padded[800] ^ 
                            data_in_zero_padded[802]  ^     	data_in_zero_padded[804] ^ 
                            data_in_zero_padded[806]  ^     	data_in_zero_padded[808] ^ 
                            data_in_zero_padded[810]  ^     	data_in_zero_padded[812] ^ 
                            data_in_zero_padded[814]  ^     	data_in_zero_padded[816] ^ 
                            data_in_zero_padded[818]  ^     	data_in_zero_padded[820] ^ 
                            data_in_zero_padded[822]  ^     	data_in_zero_padded[824] ^ 
                            data_in_zero_padded[826]  ^     	data_in_zero_padded[828] ^ 
                            data_in_zero_padded[830]  ^     	data_in_zero_padded[832] ^ 
                            data_in_zero_padded[834]  ^     	data_in_zero_padded[836] ^ 
                            data_in_zero_padded[838]  ^     	data_in_zero_padded[840] ^ 
                            data_in_zero_padded[842]  ^     	data_in_zero_padded[844] ^ 
                            data_in_zero_padded[846]  ^     	data_in_zero_padded[848] ^ 
                            data_in_zero_padded[850]  ^     	data_in_zero_padded[852] ^ 
                            data_in_zero_padded[854]  ^     	data_in_zero_padded[856] ^ 
                            data_in_zero_padded[858]  ^     	data_in_zero_padded[860] ^ 
                            data_in_zero_padded[862]  ^     	data_in_zero_padded[864] ^ 
                            data_in_zero_padded[866]  ^     	data_in_zero_padded[868] ^ 
                            data_in_zero_padded[870]  ^     	data_in_zero_padded[872] ^ 
                            data_in_zero_padded[874]  ^     	data_in_zero_padded[876] ^ 
                            data_in_zero_padded[878]  ^     	data_in_zero_padded[880] ^ 
                            data_in_zero_padded[882]  ^     	data_in_zero_padded[884] ^ 
                            data_in_zero_padded[886]  ^     	data_in_zero_padded[888] ^ 
                            data_in_zero_padded[890]  ^     	data_in_zero_padded[892] ^ 
                            data_in_zero_padded[894]  ^     	data_in_zero_padded[896] ^ 
                            data_in_zero_padded[898]  ^     	data_in_zero_padded[900] ^ 
                            data_in_zero_padded[902]  ^     	data_in_zero_padded[904] ^ 
                            data_in_zero_padded[906]  ^     	data_in_zero_padded[908] ^ 
                            data_in_zero_padded[910]  ^     	data_in_zero_padded[912] ^ 
                            data_in_zero_padded[914]  ^     	data_in_zero_padded[916] ^ 
                            data_in_zero_padded[918]  ^     	data_in_zero_padded[920] ^ 
                            data_in_zero_padded[922]  ^     	data_in_zero_padded[924] ^ 
                            data_in_zero_padded[926]  ^     	data_in_zero_padded[928] ^ 
                            data_in_zero_padded[930]  ^     	data_in_zero_padded[932] ^ 
                            data_in_zero_padded[934]  ^     	data_in_zero_padded[936] ^ 
                            data_in_zero_padded[938]  ^     	data_in_zero_padded[940] ^ 
                            data_in_zero_padded[942]  ^     	data_in_zero_padded[944] ^ 
                            data_in_zero_padded[946]  ^     	data_in_zero_padded[948] ^ 
                            data_in_zero_padded[950]  ^     	data_in_zero_padded[952] ^ 
                            data_in_zero_padded[954]  ^     	data_in_zero_padded[956] ^ 
                            data_in_zero_padded[958]  ^     	data_in_zero_padded[960] ^ 
                            data_in_zero_padded[962]  ^     	data_in_zero_padded[964] ^ 
                            data_in_zero_padded[966]  ^     	data_in_zero_padded[968] ^ 
                            data_in_zero_padded[970]  ^     	data_in_zero_padded[972] ^ 
                            data_in_zero_padded[974]  ^     	data_in_zero_padded[976] ^ 
                            data_in_zero_padded[978]  ^     	data_in_zero_padded[980] ^ 
                            data_in_zero_padded[982]  ^     	data_in_zero_padded[984] ^ 
                            data_in_zero_padded[986]  ^     	data_in_zero_padded[988] ^ 
                            data_in_zero_padded[990]  ^     	data_in_zero_padded[992] ^ 
                            data_in_zero_padded[994]  ^     	data_in_zero_padded[996] ^ 
                            data_in_zero_padded[998]  ^     	data_in_zero_padded[1000] ^ 
                            data_in_zero_padded[1002] ^       data_in_zero_padded[1004] ^ 
                            data_in_zero_padded[1006] ^       data_in_zero_padded[1008] ^ 
                            data_in_zero_padded[1010] ^       data_in_zero_padded[1012];
      parity_2_calc[8]   = ^data_in_zero_padded[504:503]   ^ ^data_in_zero_padded[508:507] ^
                           ^data_in_zero_padded[512:511]   ^ ^data_in_zero_padded[516:515] ^
                           ^data_in_zero_padded[520:519]   ^ ^data_in_zero_padded[524:523] ^
                           ^data_in_zero_padded[528:527]   ^ ^data_in_zero_padded[532:531] ^
                           ^data_in_zero_padded[536:535]   ^ ^data_in_zero_padded[540:539] ^
                           ^data_in_zero_padded[544:543]   ^ ^data_in_zero_padded[548:547] ^
                           ^data_in_zero_padded[552:551]   ^ ^data_in_zero_padded[556:555] ^
                           ^data_in_zero_padded[560:559]   ^ ^data_in_zero_padded[564:563] ^
                           ^data_in_zero_padded[568:567]   ^ ^data_in_zero_padded[572:571] ^
                           ^data_in_zero_padded[576:575]   ^ ^data_in_zero_padded[580:579] ^
                           ^data_in_zero_padded[584:583]   ^ ^data_in_zero_padded[588:587] ^
                           ^data_in_zero_padded[592:591]   ^ ^data_in_zero_padded[596:595] ^
                           ^data_in_zero_padded[600:599]   ^ ^data_in_zero_padded[604:603] ^
                           ^data_in_zero_padded[608:607]   ^ ^data_in_zero_padded[612:611] ^
                           ^data_in_zero_padded[616:615]   ^ ^data_in_zero_padded[620:619] ^
                           ^data_in_zero_padded[624:623]   ^ ^data_in_zero_padded[628:627] ^
                           ^data_in_zero_padded[632:631]   ^ ^data_in_zero_padded[636:635] ^
                           ^data_in_zero_padded[640:639]   ^ ^data_in_zero_padded[644:643] ^
                           ^data_in_zero_padded[648:647]   ^ ^data_in_zero_padded[652:651] ^
                           ^data_in_zero_padded[656:655]   ^ ^data_in_zero_padded[660:659] ^
                           ^data_in_zero_padded[664:663]   ^ ^data_in_zero_padded[668:667] ^
                           ^data_in_zero_padded[672:671]   ^ ^data_in_zero_padded[676:675] ^
                           ^data_in_zero_padded[680:679]   ^ ^data_in_zero_padded[684:683] ^
                           ^data_in_zero_padded[688:687]   ^ ^data_in_zero_padded[692:691] ^
                           ^data_in_zero_padded[696:695]   ^ ^data_in_zero_padded[700:699] ^
                           ^data_in_zero_padded[704:703]   ^ ^data_in_zero_padded[708:707] ^
                           ^data_in_zero_padded[712:711]   ^ ^data_in_zero_padded[716:715] ^
                           ^data_in_zero_padded[720:719]   ^ ^data_in_zero_padded[724:723] ^
                           ^data_in_zero_padded[728:727]   ^ ^data_in_zero_padded[732:731] ^
                           ^data_in_zero_padded[736:735]   ^ ^data_in_zero_padded[740:739] ^
                           ^data_in_zero_padded[744:743]   ^ ^data_in_zero_padded[748:747] ^
                           ^data_in_zero_padded[752:751]   ^ ^data_in_zero_padded[756:755] ^
                           ^data_in_zero_padded[760:759]   ^ ^data_in_zero_padded[764:763] ^
                           ^data_in_zero_padded[768:767]   ^ ^data_in_zero_padded[772:771] ^
                           ^data_in_zero_padded[776:775]   ^ ^data_in_zero_padded[780:779] ^
                           ^data_in_zero_padded[784:783]   ^ ^data_in_zero_padded[788:787] ^
                           ^data_in_zero_padded[792:791]   ^ ^data_in_zero_padded[796:795] ^
                           ^data_in_zero_padded[800:799]   ^ ^data_in_zero_padded[804:803] ^
                           ^data_in_zero_padded[808:807]   ^ ^data_in_zero_padded[812:811] ^
                           ^data_in_zero_padded[816:815]   ^ ^data_in_zero_padded[820:819] ^
                           ^data_in_zero_padded[824:823]   ^ ^data_in_zero_padded[828:827] ^
                           ^data_in_zero_padded[832:831]   ^ ^data_in_zero_padded[836:835] ^
                           ^data_in_zero_padded[840:839]   ^ ^data_in_zero_padded[844:843] ^
                           ^data_in_zero_padded[848:847]   ^ ^data_in_zero_padded[852:851] ^
                           ^data_in_zero_padded[856:855]   ^ ^data_in_zero_padded[860:859] ^
                           ^data_in_zero_padded[864:863]   ^ ^data_in_zero_padded[868:867] ^
                           ^data_in_zero_padded[872:871]   ^ ^data_in_zero_padded[876:875] ^
                           ^data_in_zero_padded[880:879]   ^ ^data_in_zero_padded[884:883] ^
                           ^data_in_zero_padded[888:887]   ^ ^data_in_zero_padded[892:891] ^
                           ^data_in_zero_padded[896:895]   ^ ^data_in_zero_padded[900:899] ^
                           ^data_in_zero_padded[904:903]   ^ ^data_in_zero_padded[908:907] ^
                           ^data_in_zero_padded[912:911]   ^ ^data_in_zero_padded[916:915] ^
                           ^data_in_zero_padded[920:919]   ^ ^data_in_zero_padded[924:923] ^
                           ^data_in_zero_padded[928:927]   ^ ^data_in_zero_padded[932:931] ^
                           ^data_in_zero_padded[936:935]   ^ ^data_in_zero_padded[940:939] ^
                           ^data_in_zero_padded[944:943]   ^ ^data_in_zero_padded[948:947] ^
                           ^data_in_zero_padded[952:951]   ^ ^data_in_zero_padded[956:955] ^
                           ^data_in_zero_padded[960:959]   ^ ^data_in_zero_padded[964:963] ^
                           ^data_in_zero_padded[968:967]   ^ ^data_in_zero_padded[972:971] ^
                           ^data_in_zero_padded[976:975]   ^ ^data_in_zero_padded[980:979] ^
                           ^data_in_zero_padded[984:983]   ^ ^data_in_zero_padded[988:987] ^
                           ^data_in_zero_padded[992:991]   ^ ^data_in_zero_padded[996:995] ^
                           ^data_in_zero_padded[1000:999]  ^ ^data_in_zero_padded[1004:1003] ^ 
                           ^data_in_zero_padded[1008:1007] ^ ^data_in_zero_padded[1012:1011];
      parity_4_calc[8]   = ^data_in_zero_padded[508:505]   ^ ^data_in_zero_padded[516:513] ^
                           ^data_in_zero_padded[524:521]   ^ ^data_in_zero_padded[532:529] ^
                           ^data_in_zero_padded[540:537]   ^ ^data_in_zero_padded[548:545] ^
                           ^data_in_zero_padded[556:553]   ^ ^data_in_zero_padded[564:561] ^
                           ^data_in_zero_padded[572:569]   ^ ^data_in_zero_padded[580:577] ^
                           ^data_in_zero_padded[588:585]   ^ ^data_in_zero_padded[596:593] ^
                           ^data_in_zero_padded[604:601]   ^ ^data_in_zero_padded[612:609] ^
                           ^data_in_zero_padded[620:617]   ^ ^data_in_zero_padded[628:625] ^
                           ^data_in_zero_padded[636:633]   ^ ^data_in_zero_padded[644:641] ^
                           ^data_in_zero_padded[652:649]   ^ ^data_in_zero_padded[660:657] ^
                           ^data_in_zero_padded[668:665]   ^ ^data_in_zero_padded[676:673] ^
                           ^data_in_zero_padded[684:681]   ^ ^data_in_zero_padded[692:689] ^
                           ^data_in_zero_padded[700:697]   ^ ^data_in_zero_padded[708:705] ^
                           ^data_in_zero_padded[716:713]   ^ ^data_in_zero_padded[724:721] ^
                           ^data_in_zero_padded[732:729]   ^ ^data_in_zero_padded[740:737] ^
                           ^data_in_zero_padded[748:745]   ^ ^data_in_zero_padded[756:753] ^
                           ^data_in_zero_padded[764:761]   ^ ^data_in_zero_padded[772:769] ^
                           ^data_in_zero_padded[780:777]   ^ ^data_in_zero_padded[788:785] ^
                           ^data_in_zero_padded[796:793]   ^ ^data_in_zero_padded[804:801] ^
                           ^data_in_zero_padded[812:809]   ^ ^data_in_zero_padded[820:817] ^
                           ^data_in_zero_padded[828:825]   ^ ^data_in_zero_padded[836:833] ^
                           ^data_in_zero_padded[844:841]   ^ ^data_in_zero_padded[852:849] ^
                           ^data_in_zero_padded[860:857]   ^ ^data_in_zero_padded[868:865] ^
                           ^data_in_zero_padded[876:873]   ^ ^data_in_zero_padded[884:881] ^
                           ^data_in_zero_padded[892:889]   ^ ^data_in_zero_padded[900:897] ^
                           ^data_in_zero_padded[908:905]   ^ ^data_in_zero_padded[916:913] ^
                           ^data_in_zero_padded[924:921]   ^ ^data_in_zero_padded[932:929] ^
                           ^data_in_zero_padded[940:937]   ^ ^data_in_zero_padded[948:945] ^
                           ^data_in_zero_padded[956:953]   ^ ^data_in_zero_padded[964:961] ^
                           ^data_in_zero_padded[972:969]   ^ ^data_in_zero_padded[980:977] ^
                           ^data_in_zero_padded[988:985]   ^ ^data_in_zero_padded[996:993] ^
                           ^data_in_zero_padded[1004:1001] ^ ^data_in_zero_padded[1012:1009];
      parity_8_calc[8]   = ^data_in_zero_padded[516:509]   ^ ^data_in_zero_padded[532:525] ^
                           ^data_in_zero_padded[548:541]   ^ ^data_in_zero_padded[564:557] ^
                           ^data_in_zero_padded[580:573]   ^ ^data_in_zero_padded[596:589] ^
                           ^data_in_zero_padded[612:605]   ^ ^data_in_zero_padded[628:621] ^
                           ^data_in_zero_padded[644:637]   ^ ^data_in_zero_padded[660:653] ^
                           ^data_in_zero_padded[676:669]   ^ ^data_in_zero_padded[692:685] ^
                           ^data_in_zero_padded[708:701]   ^ ^data_in_zero_padded[724:717] ^
                           ^data_in_zero_padded[740:733]   ^ ^data_in_zero_padded[756:749] ^
                           ^data_in_zero_padded[772:765]   ^ ^data_in_zero_padded[788:781] ^
                           ^data_in_zero_padded[804:797]   ^ ^data_in_zero_padded[820:813] ^
                           ^data_in_zero_padded[836:829]   ^ ^data_in_zero_padded[852:845] ^
                           ^data_in_zero_padded[868:861]   ^ ^data_in_zero_padded[884:877] ^
                           ^data_in_zero_padded[900:893]   ^ ^data_in_zero_padded[916:909] ^
                           ^data_in_zero_padded[932:925]   ^ ^data_in_zero_padded[948:941] ^
                           ^data_in_zero_padded[964:957]   ^ ^data_in_zero_padded[980:973] ^
                           ^data_in_zero_padded[996:989]   ^ ^data_in_zero_padded[1012:1005];
      parity_16_calc[8]  = ^data_in_zero_padded[532:517]   ^ ^data_in_zero_padded[564:549] ^
                           ^data_in_zero_padded[596:581]   ^ ^data_in_zero_padded[628:613] ^
                           ^data_in_zero_padded[660:645]   ^ ^data_in_zero_padded[692:677] ^
                           ^data_in_zero_padded[724:709]   ^ ^data_in_zero_padded[756:741] ^
                           ^data_in_zero_padded[788:773]   ^ ^data_in_zero_padded[820:805] ^
                           ^data_in_zero_padded[852:837]   ^ ^data_in_zero_padded[884:869] ^
                           ^data_in_zero_padded[916:901]   ^ ^data_in_zero_padded[948:933] ^
                           ^data_in_zero_padded[980:965]   ^ ^data_in_zero_padded[1012:997];
      parity_32_calc[8]  = ^data_in_zero_padded[564:533]   ^ ^data_in_zero_padded[628:597] ^
                           ^data_in_zero_padded[692:661]   ^ ^data_in_zero_padded[756:725] ^
                           ^data_in_zero_padded[820:789]   ^ ^data_in_zero_padded[884:853] ^
                           ^data_in_zero_padded[948:917]   ^ ^data_in_zero_padded[1012:981];
      parity_64_calc[8]  = ^data_in_zero_padded[628:565]   ^ ^data_in_zero_padded[756:693] ^
                           ^data_in_zero_padded[884:821]   ^ ^data_in_zero_padded[1012:949];
      parity_128_calc[8] = ^data_in_zero_padded[756:629]   ^ ^data_in_zero_padded[1012:885];
      parity_256_calc[8] = ^data_in_zero_padded[1012:757];
      parity_512_calc[8] = ^data_in_zero_padded[1012:502];
      end : parity_calcs_8
    end : parity_calcs_8_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 3) begin : parity_zero_padded_0_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_0
        parity_1_calc[PARITY_WIDTH_MAX-1:1]   = {(PARITY_WIDTH_MAX-1){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:1]   = {(PARITY_WIDTH_MAX-1){1'b0}};
        parity_4_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_0
    end : parity_zero_padded_0_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 4) begin : parity_zero_padded_1_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_1
        parity_1_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_1
    end : parity_zero_padded_1_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 5) begin : parity_zero_padded_2_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_2
        parity_1_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_2
    end : parity_zero_padded_2_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 6) begin : parity_zero_padded_3_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_3
        parity_1_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:4]  = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_3
    end : parity_zero_padded_3_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 7) begin : parity_zero_padded_4_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_4
        parity_1_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_4
    end : parity_zero_padded_4_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 8) begin : parity_zero_padded_5_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_5
        parity_1_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_5
    end : parity_zero_padded_5_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 9) begin : parity_zero_padded_6_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_6
        parity_1_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_16_calc[2:0]                   = {4{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_128_calc[5:0]                  = {6{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:7] = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_6
    end : parity_zero_padded_6_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 10) begin : parity_zero_padded_7_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_7
        parity_1_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_128_calc[5:0]                  = {6{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_256_calc[6:0]                  = {7{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_7
    end : parity_zero_padded_7_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 11) begin : parity_zero_padded_8_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_8
        parity_1_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_128_calc[5:0]                  = {6{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_256_calc[6:0]                  = {7{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_512_calc[7:0]                  = {8{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
      end : parity_zero_padded_8
    end : parity_zero_padded_8_generate
  endgenerate

  // *************************************************
  // Parity Generator Block
  // Only generate the parity generator circuitry when
  // performing a RAM write
  // *************************************************
  generate 
    if (MEMORY_WRITE == 1) begin : ram_write_generate
      miv_rv32_bist_ecc_write
        #(
          .DATA_WIDTH(DATA_WIDTH),
          .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH),
          .PARITY_WIDTH_MAX(PARITY_WIDTH_MAX),
          .MAX_DATA_WIDTH(MAX_DATA_WIDTH)
        )
        ecc_wirte
        (
          .parity_1_calc,
          .parity_2_calc,
          .parity_4_calc,
          .parity_8_calc,
          .parity_16_calc,
          .parity_32_calc,
          .parity_64_calc,
          .parity_128_calc,
          .parity_256_calc,
          .parity_512_calc,
          .data_in_zero_padded,
          .parity_out_output
        );
    end : ram_write_generate
  endgenerate

  // *************************************************
  // Check Bit Generator & Error-correction Circuitry
  // Only generate the parity generator circuitry when
  // performing a RAM read
  // *************************************************
  
  generate 
    if (MEMORY_READ == 1) begin : ram_read_generate
      miv_rv32_bist_ecc_read
        #(
          .DATA_WIDTH(DATA_WIDTH),
          .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH),
          .PARITY_WIDTH_MAX(PARITY_WIDTH_MAX),
          .MAX_DATA_WIDTH(MAX_DATA_WIDTH)
        )
        ecc_read
        (
          .ecc_bypass,
          .data_in,
          .parity_in,
          .parity_1_calc,
          .parity_2_calc,
          .parity_4_calc,
          .parity_8_calc,
          .parity_16_calc,
          .parity_32_calc,
          .parity_64_calc,
          .parity_128_calc,
          .parity_256_calc,
          .parity_512_calc,
          .data_in_zero_padded, 
          .parity_out_corrected_output,
          .check_out_output,
          .data_out_output,
          .err_multpl_output,
          .err_detect_output
        );
    end : ram_read_generate
  endgenerate

  // Assign appropriate signals to the output ports, based on the values chosen
  // for the read & write circuitry generics
  //
  // By default, all signals that are assigned to the output ports are initialized
  // to all 0's.  The output signals are assigned as follows:
  //
  // MEMORY_READ = '1':
  //
  //   parity_out_output  : assigned the parity bits
  //
  // MEMORY_WRITE = '1'
  //
  //   check_out_output   : assigned the check bits
  //   err_multpl_output  : assigned the multiple error detection flag
  //   err_detect_output  : assigned the error detection flag
  //   data_out_output    : assigned either the corrected data, or original data
  //                        (depending on the value of ecc_bypass)
  //
  // All un-used inputs must be connected to un-used outputs.
  // When this block is used at a higher level, the un-used ports
  // will be removed anyway.
  //
  // Three possible cases:
  //  1) write = 1, read = 0
  //
  //  un-used inputs:  parity_in and ecc_bypass
  //  un-used outputs: data_out, check_out, err_multpl,
  //                   and err_detect must
  //
  //  2) write = 0, read = 1
  //
  //  un-used inputs:  none
  //  un-used outputs: parity_out
  //
  //  3) write = 1, read = 1
  //
  //  un-used inputs:  none
  //  un-used outputs: none
  //
  // Case 1)
  generate 
    if ((MEMORY_WRITE == 1 && MEMORY_READ == 0)) begin : assign_all_outputs_1_generate
      
      // Connect the un-used inputs to the un-used outputs
      assign check_out  = parity_in;
      assign err_multpl = ecc_bypass;
      assign err_detect = ecc_bypass;
      assign data_out   = data_in;
      
      // Connect used outputs
      assign parity_out = parity_out_output;
          
      // No un-used outputs

    end : assign_all_outputs_1_generate
  endgenerate

  // Case 2)
  generate 
    if ((MEMORY_WRITE == 0 && MEMORY_READ == 1)) begin : assign_all_outputs_2_generate

      // No un-used inputs
      
      // Connect used outputs
      assign check_out  = check_out_output;
      assign data_out   = data_out_output;
      assign err_multpl = err_multpl_output;
      assign err_detect = err_detect_output;

      // Connect the corrected parity bits
      assign parity_out = parity_out_corrected_output;

    end : assign_all_outputs_2_generate
  endgenerate

  // Case 3)
  generate 
    if ((MEMORY_WRITE == 1 && MEMORY_READ == 1)) begin : assign_all_outputs_3_generate

      // No un-used inputs
      
      // Connect used outputs
      assign parity_out = parity_out_output;
      assign check_out  = check_out_output;
      assign err_multpl = err_multpl_output;
      assign err_detect = err_detect_output;
      assign data_out   = data_out_output;

      // No un-used outputs
      
    end : assign_all_outputs_3_generate
  endgenerate

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// Empty ECC module
//
// Parameter Descriptions:
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_empty
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5
  )
  (
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    output      logic                        err_multpl,
    output      logic                        err_detect,
    output      logic [DATA_WIDTH-1:0]       data_out,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out
  );

// Start the RTL code:

      assign err_multpl = 1'b 0;
      assign err_detect = 1'b 0;
      assign data_out   = data_in;
      assign parity_out = {ECC_PARITY_WIDTH{1'b0}};
      assign check_out  = {ECC_PARITY_WIDTH{1'b0}};

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// ECC read side module
//
// Parameter Description:
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_read
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter PARITY_WIDTH_MAX = 11,
    parameter MAX_DATA_WIDTH   = 1013
  )
  (
    input  wire logic                        ecc_bypass,
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    input  wire logic [ECC_PARITY_WIDTH-1:0] parity_in,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_1_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_2_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_4_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_8_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_16_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_32_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_64_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_128_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_256_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_512_calc,
    input  wire logic [MAX_DATA_WIDTH-1:0]   data_in_zero_padded, 
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out_corrected_output,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out_output,
    output      logic [DATA_WIDTH - 1:0]     data_out_output,
    output      logic                        err_multpl_output,
    output      logic                        err_detect_output  
  );

// Implementation
localparam MAX_ADDR_WIDTH    = 1024;  
localparam MAX_TEMP_WIDTH    =  2 ** (ECC_PARITY_WIDTH-1);
localparam CHECK_TOTAL_WIDTH =  PARITY_WIDTH_MAX-1;
localparam ECC_FLAG_WIDTH    =  3;

logic [PARITY_WIDTH_MAX-1:0]  check_1_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_2_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_4_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_8_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_16_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_32_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_64_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_128_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_256_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_512_calc;
logic [CHECK_TOTAL_WIDTH-1:0] check_total;
logic                         ct_check_bit;

// Signal used to determine if a single or multiple bit error occurred.
logic check_bits_all_zero;  

// 'data_in_zero_padded' bus assembled with the 'parity_in' bus.
// This bus is the data input (zero padded) mixed with the parity bits, to form
// the parity + data word (according to the Hamming SEC-DED ECC code).  Mixing
// the data input and parity bits together, allows one to address a single-bit
// error in the data word directly (and then correct it).
logic [MAX_TEMP_WIDTH-1:0] data_plus_parity;  

// Bus used to index into the specific data bit in error.  Used in the RAM Read
// circuitry.  The addr_index is all 0's, except for a '1' in the bit position
// where there is an error (in the 'data_plus_parity' bus).  Since the ECC 
// refers to the first bit position as bit one (not bit zero), the addr_index must
// be left-shifted by one bit.  The resulting bus is addr_index_corrected.
logic [MAX_TEMP_WIDTH-1:0] addr_index;
logic [MAX_TEMP_WIDTH-1:0] addr_index_corrected;
logic                      addr_index0_and_ct;  

// Bus used to store the corrected data output (the data_plus_parity after
// the problematic bit has been corrected).
logic [MAX_TEMP_WIDTH-1:0] data_plus_parity_corrected;  

// Bus used to re-assemble the 'data_plus_parity_corrected' bus onto.  This bus will
// then be output on the data_out bus, during a RAM read (provided ecc_bypass = '0').
logic [DATA_WIDTH-1:0] data_out_corrected;  

// Bus used to re-assemble the 'data_plus_parity_corrected' bus onto.  This bus will
// then be output on the parity_out bus, during a RAM read.
logic [ECC_PARITY_WIDTH-1:0] parity_out_corrected;  

// Start the RTL code:
  
  // Generate the individual check bits (excluding CT -- check total)
  // Generate all the intermediate check bits.
  // The same results that were used in calculating
  // the parity bits are used here.  The only difference
  // is that in some cases, a parity_in() bit may be
  // used.

  always @(*) begin : check_calcs_0_process
    check_1_calc[0] = parity_in[0] ^ parity_1_calc[0];
    check_2_calc[0] = parity_in[1] ^ parity_2_calc[0];
  end : check_calcs_0_process

  generate 
    if (DATA_WIDTH >= 2) begin : check_calcs_1_generate
      always @(*) begin : check_calcs_1_process
        check_1_calc[1] = parity_1_calc[1];
        check_2_calc[1] = parity_2_calc[1];
        check_4_calc[1] = parity_in[2] ^ parity_4_calc[1];
      end : check_calcs_1_process
    end : check_calcs_1_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 5) begin : check_calcs_2_generate
      always @(*) begin : check_calcs_2_process
        check_1_calc[2] = parity_1_calc[2];
        check_2_calc[2] = parity_2_calc[2];
        check_4_calc[2] = parity_4_calc[2];
        check_8_calc[2] = parity_in[3] ^ parity_8_calc[2];
      end : check_calcs_2_process
    end : check_calcs_2_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 12) begin : check_calcs_3_generate
      always @(*) begin : check_calcs_3_process
        check_1_calc[3]  = parity_1_calc[3];
        check_2_calc[3]  = parity_2_calc[3];
        check_4_calc[3]  = parity_4_calc[3];
        check_8_calc[3]  = parity_8_calc[3];
        check_16_calc[3] = parity_in[4] ^ parity_16_calc[3];
      end : check_calcs_3_process
    end : check_calcs_3_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 27) begin : check_calcs_4_generate
      always @(*) begin : check_calcs_4_process
        check_1_calc[4]  = parity_1_calc[4];
        check_2_calc[4]  = parity_2_calc[4];
        check_4_calc[4]  = parity_4_calc[4];
        check_8_calc[4]  = parity_8_calc[4];
        check_16_calc[4] = parity_16_calc[4];
        check_32_calc[4] = parity_in[5] ^ parity_32_calc[4];
      end : check_calcs_4_process
    end : check_calcs_4_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 58) begin : check_calcs_5_generate
      always @(*)  begin : check_calcs_5_process
        check_1_calc[5]  = parity_1_calc[5];
        check_2_calc[5]  = parity_2_calc[5];
        check_4_calc[5]  = parity_4_calc[5];
        check_8_calc[5]  = parity_8_calc[5];
        check_16_calc[5] = parity_16_calc[5];
        check_32_calc[5] = parity_32_calc[5];
        check_64_calc[5] = parity_in[6] ^ parity_64_calc[5];
      end : check_calcs_5_process
    end : check_calcs_5_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 121) begin : check_calcs_6_generate
      always @(*) begin : check_calcs_6_process
        check_1_calc[6]   = parity_1_calc[6];
        check_2_calc[6]   = parity_2_calc[6];
        check_4_calc[6]   = parity_4_calc[6];
        check_8_calc[6]   = parity_8_calc[6];
        check_16_calc[6]  = parity_16_calc[6];
        check_32_calc[6]  = parity_32_calc[6];
        check_64_calc[6]  = parity_64_calc[6];
        check_128_calc[6] = parity_in[7] ^ parity_128_calc[6];
      end : check_calcs_6_process
    end : check_calcs_6_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 248) begin : check_calcs_7_generate
      always @(*) begin : check_calcs_7_process
        check_1_calc[7]   = parity_1_calc[7];
        check_2_calc[7]   = parity_2_calc[7];
        check_4_calc[7]   = parity_4_calc[7];
        check_8_calc[7]   = parity_8_calc[7];
        check_16_calc[7]  = parity_16_calc[7];
        check_32_calc[7]  = parity_32_calc[7];
        check_64_calc[7]  = parity_64_calc[7];
        check_128_calc[7] = parity_128_calc[7];
        check_256_calc[7] = parity_in[8] ^ parity_256_calc[7];
      end : check_calcs_7_process
    end : check_calcs_7_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 503) begin : check_calcs_8_generate
      always @(*) begin : check_calcs_8_process
        check_1_calc[8]   = parity_1_calc[8];
        check_2_calc[8]   = parity_2_calc[8];
        check_4_calc[8]   = parity_4_calc[8];
        check_8_calc[8]   = parity_8_calc[8];
        check_16_calc[8]  = parity_16_calc[8];
        check_32_calc[8]  = parity_32_calc[8];
        check_64_calc[8]  = parity_64_calc[8];
        check_128_calc[8] = parity_128_calc[8];
        check_256_calc[8] = parity_256_calc[8];
        check_512_calc[8] = parity_in[9] ^ parity_512_calc[8];
      end : check_calcs_8_process
    end : check_calcs_8_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 3) begin : check_zero_padded_0_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc) 
      begin : check_zero_padded_0_process
        check_1_calc[PARITY_WIDTH_MAX-1:1]   = {PARITY_WIDTH_MAX{1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:1]   = {PARITY_WIDTH_MAX{1'b0}};
        check_4_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_0_process
    end : check_zero_padded_0_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 4) begin : check_zero_padded_1_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc)
      begin : check_zero_padded_1_process
        check_1_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_1_process
    end : check_zero_padded_1_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 5) begin : check_zero_padded_2_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, parity_8_calc)
      begin : check_zero_padded_2_process
        check_1_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_2_process
    end : check_zero_padded_2_generate
  endgenerate

  generate if (ECC_PARITY_WIDTH == 6) begin : check_zero_padded_3_generate
    always@(parity_in, parity_1_calc, parity_2_calc,
            parity_4_calc, parity_8_calc, parity_16_calc) 
    begin : check_zero_padded_3_process
        check_1_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:4]  = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_3_process
    end : check_zero_padded_3_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 7) begin : check_zero_padded_4_generate
      always@(parity_in, parity_1_calc, parity_2_calc,
              parity_4_calc, parity_8_calc, parity_16_calc, parity_32_calc)
      begin : check_zero_padded_4_process
        check_1_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_4_process
    end : check_zero_padded_4_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 8) begin : check_zero_padded_5_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc)
      begin : check_zero_padded_5_process
        check_1_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_5_process
    end : check_zero_padded_5_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 9) begin : check_zero_padded_6_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc, 
              parity_128_calc)
      begin : check_zero_padded_6_process
        check_1_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_128_calc[5:0]                  = {6{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:7] = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_6_process
    end : check_zero_padded_6_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 10) begin : check_zero_padded_7_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc, 
              parity_128_calc, parity_256_calc)
      begin : check_zero_padded_7_process
        check_1_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_128_calc[5:0]                  = {6{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_256_calc[6:0]                  = {7{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_7_process
    end : check_zero_padded_7_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 11) begin : check_zero_padded_8_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc, 
              parity_128_calc, parity_256_calc, parity_512_calc)
      begin : check_zero_padded_8_process
        check_1_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_128_calc[5:0]                  = {6{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_256_calc[6:0]                  = {7{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_512_calc[7:0]                  = {8{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
      end : check_zero_padded_8_process
    end : check_zero_padded_8_generate
  endgenerate

  // Calculate the total check bits, excluding check total (CT)
  always @(*) begin : calc_check_out_bits_process

    check_total[0] = ^check_1_calc;
    check_total[1] = ^check_2_calc;
    check_total[2] = ^check_4_calc;
    check_total[3] = ^check_8_calc;
    check_total[4] = ^check_16_calc;
    check_total[5] = ^check_32_calc;
    check_total[6] = ^check_64_calc;
    check_total[7] = ^check_128_calc;
    check_total[8] = ^check_256_calc;
    check_total[9] = ^check_512_calc;

  end : calc_check_out_bits_process

  // Generate the check total (CT) bit
  //
  // The total check bit is the XOR of every data bit, and
  // every parity bit.  Since this will take the longest time
  // to calculate, it's in its own process (sensitive to changes
  // on parity_in and data_in_zero_padded).

  always @(*) begin : gen_ct

    // XOR every true data bit and every true parity bit to create check total bit
    ct_check_bit = (^parity_in) ^ (^data_in_zero_padded[DATA_WIDTH-1:0]);

  end : gen_ct

  // Assign the check bits to the check_out_output bus
  //
  // Now assign the total check bits, including CT, to
  // the correct check_out bits.  This is dependant upon
  // how many check bits are required (as CT always takes
  // the last bit position), therefore separate generate
  // statements are required.

  always @(*) begin : check_out_assignment_process

    check_out_output[ECC_PARITY_WIDTH-2:0] = check_total[ECC_PARITY_WIDTH-2:0];
    check_out_output[ECC_PARITY_WIDTH-1]   = ct_check_bit;

  end : check_out_assignment_process

  // Determine if the check bits (excluding CT) are all zeros.
  always @(*) begin : check_bits_all_zero_process

    // If all the check bits are '0', check_bits_all_zero = '0',
    // otherwise check_bits_all_zero = '1'.
    // This signal must be initialized to '0' -- default is to
    // assume there are no errors
    
    check_bits_all_zero = |check_total;

  end : check_bits_all_zero_process

  // Determine the value of the err_detect and err_multpl output
  // ports. 
  
  always @(*) begin : determine_err_conditions_process
    // err_flag_selector is a temporary signal, used to determine
    // what values to assign to err_detect and err_multpl
    // check_bits_all_zero = '0' indicates that all of the check
    // bits are 0.  This means the data word read contains
    // no error (regardless of the value of CT).
    // check_bits_all_zero = '1' indicates that at least one check
    // bit is zero.  In this case, if CT = 1, there is a single
    // bit error (or odd number of bit errors).  Data correction
    // should take place.  If CT = 0, there is a double-bit (or
    // even multiple of bit errors), and no error correction should
    // take place.
    // if ecc_bypass is active ('1') err_detect and err_multpl output
    // should report error ("11").
    // err_flag_selector(2) = check_bits_all_zero
    // err_flag_selector(1) = ct_check_bit
    // err_flag_selector(0) = ecc_bypass
    logic [ECC_FLAG_WIDTH-1:0] err_flag_selector;

    err_flag_selector = {check_bits_all_zero,ct_check_bit,ecc_bypass};
    case(err_flag_selector)
    3'b 100 : begin
      // double-bit error
      err_multpl_output = 1'b 1;
      err_detect_output = 1'b 1;
    end
    3'b 110 : begin
      // single-bit error
      err_multpl_output = 1'b 0;
      err_detect_output = 1'b 1;
    end
    3'b 000 : begin
      // check bits are all zero's (no errors)
      err_multpl_output = 1'b 0;
      err_detect_output = 1'b 0;
    end
    3'b 010 : begin
      // check bits are all zero's, check total is 1
      // odd number of error
      err_multpl_output = 1'b 0;
      err_detect_output = 1'b 1;
    end
    default : begin
      // Unknown input or ecc_bypass, generate a double bit error
      err_multpl_output = 1'b 1;
      err_detect_output = 1'b 1;
    end
    endcase
  end : determine_err_conditions_process

  // Fix the input data, if there is an error. 
  // Assemble a temporary bus, with data_in and parity_in
  // bits.  This bus is required to fix bit errors.
  //
  // Note (superceded): The PT bit is not included in this bus; we
  //       don't need it to fix any single-bit errors.
  // NEW Note2: The PT bit is now included! It is needed for SFM team to output 
  //       corrected parity bits on ECC read side
  
  always @(*) begin : assemble_bus_1_process
    data_plus_parity[0] = parity_in[0]; // P1
    data_plus_parity[1] = parity_in[1]; // P2
    data_plus_parity[2] = data_in_zero_padded[0]; // D0
  end : assemble_bus_1_process

  generate 
    if (DATA_WIDTH >= 2) begin : assemble_bus_2_generate
      always @(*) begin : assemble_bus_2_process
        data_plus_parity[3]   = parity_in[2]; // P4
        data_plus_parity[6:4] = data_in_zero_padded[3:1]; // D3-D1
      end : assemble_bus_2_process
    end : assemble_bus_2_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 5) begin : assemble_bus_3_generate
      always @(*) begin : assemble_bus_3_process
        data_plus_parity[7] = parity_in[3]; // P8
        data_plus_parity[14:8] = data_in_zero_padded[10:4]; // D10-D4
      end : assemble_bus_3_process
    end : assemble_bus_3_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 12) begin : assemble_bus_4_generate
      always @(*) begin : assemble_bus_4_process
        data_plus_parity[15] = parity_in[4]; // P16
        data_plus_parity[30:16] = data_in_zero_padded[25:11]; // D25-D11
      end : assemble_bus_4_process
    end : assemble_bus_4_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 27) begin : assemble_bus_5_generate
      always @(*) begin : assemble_bus_5_process
        data_plus_parity[31] = parity_in[5]; // P32
        data_plus_parity[62:32] = data_in_zero_padded[56:26]; // D56-D26
      end : assemble_bus_5_process
    end : assemble_bus_5_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 58) begin : assemble_bus_6_generate
      always @(*) begin  : assemble_bus_6_process
        data_plus_parity[63] = parity_in[6]; // P64
        data_plus_parity[126:64] = data_in_zero_padded[119:57]; // D119-D57
      end : assemble_bus_6_process
    end : assemble_bus_6_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 121) begin : assemble_bus_7_generate
      always @(*) begin : assemble_bus_7_process
        data_plus_parity[127] = parity_in[7]; // P128
        data_plus_parity[254:128] = data_in_zero_padded[246:120]; // D246-D120
      end : assemble_bus_7_process
    end : assemble_bus_7_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 248) begin : assemble_bus_8_generate
      always @(*) begin : assemble_bus_8_process
        data_plus_parity[255] = parity_in[8]; // P256
        data_plus_parity[510:256] = data_in_zero_padded[501:247]; // D247-D501
      end : assemble_bus_8_process
    end : assemble_bus_8_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 503) begin : assemble_bus_9_generate
      always @(*) begin : assemble_bus_9_process
        data_plus_parity[511] = parity_in[9]; // P512
        data_plus_parity[1022:512] = data_in_zero_padded[1012:502]; // D-D
      end : assemble_bus_9_process
    end : assemble_bus_9_generate
  endgenerate

  always @(*) begin : assemble_bus_pt_process
    data_plus_parity[MAX_TEMP_WIDTH-1] = parity_in[ECC_PARITY_WIDTH-1]; // PT
    //   data_plus_parity(MAX_TEMP_WIDTH-1) = '0'; -- PT
  end : assemble_bus_pt_process

  // Generate the bit address index into the data_plus_parity bus
  miv_rv32_bist_decode 
    #(
      .CHECK_TOTAL_WIDTH(CHECK_TOTAL_WIDTH),
      .MAX_ADDR_WIDTH(MAX_TEMP_WIDTH),
      .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH)
    )
    addr_dec
    (
      .addr_in(check_total),
      .addr_out(addr_index)
    );

  // The address bus returned references the first bit position
  // as position '0'.  The ECC block uses bit position '1'.
  // The address index bus must be shifted left by 1 bit.
  
  always @(*) begin : left_shift_addr_index_process
    addr_index0_and_ct = addr_index[0] & ct_check_bit;
    //   addr_index_corrected( MAX_TEMP_WIDTH-1 DOWNTO 0 ) = 
    //     '0' & addr_index( MAX_TEMP_WIDTH-1 DOWNTO 1);
    addr_index_corrected[MAX_TEMP_WIDTH - 1:0] = 
      {addr_index0_and_ct,addr_index[MAX_TEMP_WIDTH - 1:1]};
  end : left_shift_addr_index_process

  // Correct the bit error
  always @(*) begin : data_in_correction_process
    for (int i = 0; i < MAX_TEMP_WIDTH; i++) begin : data_in_correction_loop 
        data_plus_parity_corrected[i] = data_plus_parity[i] ^ addr_index_corrected[i];
    end : data_in_correction_loop
  end : data_in_correction_process

  // Dis-assemble the temporary corrected data bus.
  //
  // When re-creating the corrected output data bus,
  // need to filter out the parity bit locations (as
  // the parity bits were included in the originally
  // created temporary data bus).
  
  generate 
    if (ECC_PARITY_WIDTH == 3) begin : data_out_1_generate
      always @(*) begin : data_out_1_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH-1)];
      end : data_out_1_process
    end : data_out_1_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 4) begin : data_out_2_generate
      always @(*) begin : data_out_2_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3), and offset by 3 for P1,
        // P2, and P4
        data_out_corrected[DATA_WIDTH - 1:1] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 3:4];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_2_process
    end : data_out_2_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 5) begin : data_out_3_generate
      always @(*) begin : data_out_3_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0) 
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7), and offset by 4 for P1, P2,
        // P4, and P8
        data_out_corrected[DATA_WIDTH - 1:4] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 4:8];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_3_process
    end : data_out_3_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 6) begin : data_out_4_generate
      always @(*) begin : data_out_4_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15), and offset by 5 for P1,
        // P2, P4, P8, and P16
        data_out_corrected[DATA_WIDTH - 1:11] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 5:16];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_4_process
    end : data_out_4_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 7) begin : data_out_5_generate
      always @(*) begin : data_out_5_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31), and offset by 6 for P1,
        // P2, P4, P8, P16, and P32
        data_out_corrected[DATA_WIDTH - 1:26] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 6:32];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_5_process
    end : data_out_5_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 8) begin : data_out_6_generate
      always @(*) begin : data_out_6_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63), and offset by 7 for P1,
        // P2, P4, P8, P16, P32, and P64
        data_out_corrected[DATA_WIDTH - 1:57] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 7:64];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_6_process
    end : data_out_6_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 9) begin : data_out_7_generate
      always @(*) begin : data_out_7_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63)
        data_out_corrected[119:57] = data_plus_parity_corrected[126:64];

        // Filter out P64 (skip data_plus_parity_corrected(127), and offset by 8 for P1,
        // P2, P4, P8, P16, P32, P64, and P128
        data_out_corrected[DATA_WIDTH - 1:120] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 8:128];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include P128
        parity_out_corrected[7] = data_plus_parity_corrected[127];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_7_process
    end : data_out_7_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 10) begin : data_out_8_generate
      always @(*) begin : data_out_8_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63)
        data_out_corrected[119:57] = data_plus_parity_corrected[126:64];

        // Filter out P128 (skip data_plus_parity_corrected(127)
        data_out_corrected[246:120] = data_plus_parity_corrected[254:128];

        // Filter out P256 (skip data_plus_parity_corrected(255), and offset by 9 for P1,
        // P2, P4, P8, P16, P32, P64, P128, and P256
        data_out_corrected[DATA_WIDTH - 1:247] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 9:256];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include P128
        parity_out_corrected[7] = data_plus_parity_corrected[127];
        // Include P256
        parity_out_corrected[8] = data_plus_parity_corrected[255];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_8_process
    end : data_out_8_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 11) begin : data_out_9_generate
      always @(*) begin : data_out_9_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63)
        data_out_corrected[119:57] = data_plus_parity_corrected[126:64];

        // Filter out P128 (skip data_plus_parity_corrected(127)
        data_out_corrected[246:120] = data_plus_parity_corrected[254:128];

        // Filter out P256 (skip data_plus_parity_corrected(255)
        data_out_corrected[501:247] = data_plus_parity_corrected[510:256];

        // Filter out P512 (skip data_plus_parity_corrected(511), and offset by 10 for P1,
        // P2, P4, P8, P16, P32, P64, P128, P256, and P512
        data_out_corrected[DATA_WIDTH - 1:502] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 10:512];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include P128
        parity_out_corrected[7] = data_plus_parity_corrected[127];
        // Include P256
        parity_out_corrected[8] = data_plus_parity_corrected[255];
        // Include P512
        parity_out_corrected[9] = data_plus_parity_corrected[511];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_9_process
    end : data_out_9_generate
  endgenerate

  // Assign either data_out_corrected or data_in to data_out, based on
  // the value of ecc_bypass
  
  always @(*) begin : data_out_assignment_process
    if(ecc_bypass == 1'b 1) begin
      data_out_output             = data_in;
      parity_out_corrected_output = parity_in;
    end
    else begin
      data_out_output             = data_out_corrected;
      parity_out_corrected_output = parity_out_corrected;
    end
  end : data_out_assignment_process

  // pragma translate_off
  always @(ecc_bypass) begin
    assert(ecc_bypass != 1'b1) 
    else begin
      $display( "ECC is bypassed. This mode is used for device test only.");
      $warning;
    end
  end
  // pragma translate_on
  
  // Finished the parity bit generator logic.
  
endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// ECC write side module
//
// Parameter Description:
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_write
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter PARITY_WIDTH_MAX = 11,
    parameter MAX_DATA_WIDTH   = 1013
  )
  (
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_1_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_2_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_4_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_8_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_16_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_32_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_64_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_128_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_256_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_512_calc,
    input  wire logic [MAX_DATA_WIDTH-1:0]   data_in_zero_padded,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out_output
  );

localparam    PARITY_TOTAL_WIDTH = PARITY_WIDTH_MAX-1;

logic [PARITY_TOTAL_WIDTH-1:0] parity_total;
logic                          pt_parity_bit;

// Start the RTL code:

  // Final Parity Bit Calculations (Excluding the PT parity bit)
  // Now generate the output parity bits, excluding the parity
  // total (PT) bit.  The PT bit must be calculated in a
  // separate process, sensitive to the individual parity bit
  // totals.
  // All the output parity bits will be the same, regardless
  // of how many parity bits are required for the RAM word
  // being written.
  always @(*) begin : calc_parity_output_bits_process

    parity_total[0] = ^parity_1_calc;
    parity_total[1] = ^parity_2_calc;
    parity_total[2] = ^parity_4_calc;
    parity_total[3] = ^parity_8_calc;
    parity_total[4] = ^parity_16_calc;
    parity_total[5] = ^parity_32_calc;
    parity_total[6] = ^parity_64_calc;
    parity_total[7] = ^parity_128_calc;
    parity_total[8] = ^parity_256_calc;
    parity_total[9] = ^parity_512_calc;
    
  end : calc_parity_output_bits_process

  // PT (Parity Total) bit calculation
  //
  // Now generate the total parity (PT) bit.  This calculation
  // requires a process that is sensitive to the individual
  // parity bit totals, as well as the data_in_zero_padded vector.

  always @(*) begin : calc_parity_total_bit_process
    // PT is the XOR of ALL parity bits (parity_total[X]),
    // as well as ALL the true data bits
    // (data_in_zero_padded[DATA_WIDTH-1 DOWNTO 0])
    //
    // XOR all the parity total bits

    pt_parity_bit = (^data_in_zero_padded[DATA_WIDTH-1:0]) ^ (^parity_total);

  end : calc_parity_total_bit_process

  // Assign the parity bits to the parity_out_output signal bus
  //
  // Now assign the total parity bits, including PT, to
  // the correct parity_out bits.  This is dependant upon
  // how many parity bits are required (as PT always takes
  // the last bit position).  For this reason, separate generate
  // statements are required.
  
  always @(*) begin : parity_out_assignment_process
    for (int i = 0; i < ECC_PARITY_WIDTH-1; i++) begin
      parity_out_output[i] = parity_total[i];
    end
    parity_out_output[ECC_PARITY_WIDTH-1] = pt_parity_bit;
  end : parity_out_assignment_process

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// FUNCTION:
// inject error in sys data.
// 1) err_inject = "00"
//     no error is injected
// 2) err_inject = "01"
//     one bit error is injected on bit 0
// 3) err_inject = "10"
//     one bit error is injected on bit 1
// 4) err_inject = "11"
//     two bits error is injected on bit 1 and 0 
// GENERIC PORT DESCRIPTION:
// DATA_WIDTH     RAM data width
// INPUT PORT DESCRIPTION:
// err_inject     error injection bus
// data_in        data input
// OUTPUT PORT DESCRIPTION:
// data_out       data output
// CONNECTIVITY DEFINITION

`default_nettype none

module miv_rv32_bist_err_inject
  #(
    parameter ERR_WIDTH  = 2,
    parameter DATA_WIDTH = 8
  )
  (
    input  wire logic [ERR_WIDTH-1:0]  err_inject,
    input  wire logic [DATA_WIDTH-1:0] data_in,
    output      logic [DATA_WIDTH-1:0] data_out
  );

// IMPLEMENTATION

  always @(*) begin : data_err
    logic [ERR_WIDTH-1:0] data_out_val;

    for (int i=0; i <= ERR_WIDTH - 1; i++) begin 
      if(err_inject[i] != 1'b 1) begin
        data_out_val[i] = data_in[i];
      end
      else begin
        data_out_val[i] =  ~data_in[i];
      end
    end
    data_out[ERR_WIDTH-1:0] = data_out_val;
  end : data_err

  generate 
    if (DATA_WIDTH > ERR_WIDTH) begin : no_data_err
      assign data_out[DATA_WIDTH - 1:ERR_WIDTH] = data_in[DATA_WIDTH - 1:ERR_WIDTH];
    end : no_data_err
  endgenerate

  // pragma translate_off
  always @(err_inject) begin
    assert(|err_inject != 1'b1)
    else begin
      $display("RAM Err Injection is activated");
      $info;
    end
  end
  // pragma translate_on
// END OF CODE

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Contains pipeline flip flops if needed, otherwise data bus passes through
// module
//
//
// PARAMETER DESCRIPTION:
//
// DATA_WIDTH             number of data bits per word
// DATA_INIT              FF reset value
// DATA_PIPELINE          use pipelining or not
//
//
// INPUT PORT DESCRIPTION:
//
// din                    RAM read data
// clk                    RAM clock
// rstb                   system reset (active low)
// enable                 RAM enable
//
//
// OUTPUT PORT DESCRIPTION:
//
// dout                   RAM data to ECC wrapper
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bist_pipeline

  #(
    parameter DATA_WIDTH      = 8,
    parameter DATA_INIT       = 0,
    parameter miv_rv32_pkg::t_bist_pipeline DATA_PIPELINE 
                              = miv_rv32_pkg::BIST_PIPELINE_OFF
  )
  (
    input  wire logic                  clk,
    input  wire logic                  rstb,
    input  wire logic                  enable,    
    input  wire logic [DATA_WIDTH-1:0] din,
    
    output      logic [DATA_WIDTH-1:0] dout
  );
  
  import miv_rv32_pkg::*;
  
  generate   
    case ( DATA_PIPELINE ) 
      BIST_PIPELINE_ON : 
 
        begin : gen_pipeline
          always_ff @(posedge clk or negedge rstb)
          begin : pipeline_ff
            if ( rstb != 1'b1 ) begin
              if ( DATA_INIT == 0 ) begin
                dout <= {DATA_WIDTH{1'b0}};
              end
              else begin
                dout <= {DATA_WIDTH{1'b1}};
              end
            end
            else begin
              if ( enable == 1'b1 ) begin
                dout <= din;
              end
            end
          end : pipeline_ff
        end : gen_pipeline
      
      BIST_PIPELINE_OFF :
 
        begin : no_pipeline
          assign dout = din;
        end : no_pipeline

    endcase    
  endgenerate

endmodule : miv_rv32_bist_pipeline

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// RAM and BIST bist_template which can be used to drop in and replace a RAM
// instance.
//
// PARAMETER DESCRIPTION:
//
// RAM_DEPTH           Number of words in the RAM (<= 2^ADDR_WIDTH) 
// ADDR_WIDTH          Number of address bits.
// DATA_WIDTH          Number of data bits per word.
// LOW_POWER_WIDTH     Number of low_power bus bits.
// INPUT_PIPELINE      Indicates if input Pipeline flops are used or not
// INPUT_PIPELINE_LS   Indicates if input Pipeline flops for low power flops (ls)
// INPUT_PIPELINE_LP   Indicates if input Pipeline flops for low power flops (ds and sd)
//                     (ds and sd )are used or not
// OUTPUT_PIPELINE     Indicates if output Pipeline flops are used or not
// BWE_RAM             Indicates if this is bwe ram
// RAM_INIT_GEN        Indicates if ram init is generated
//
// INPUT PORT DESCRIPTION:
//
// rstb                System reset (active low). 
// clk                 RAM clock.
// lp1                 Light sleep mode input
// lp2                 Deep sleep mode input
// lp3                 Shut down mode input
// addr[]              RAM read/write address.
// ceb                 RAM cell enable (active low).
// web                 RAM write enable (active low).
// wemb[]              RAM write enable mask (active low).
// din[]               RAM write data. 
// ram_dout            Data output from ram
// pg_override         Override low power mode
// ram_init_enable     Enable for RAM initialization
//
// OUTPUT PORT DESCRIPTION:
//
// dout[]              RAM read data.
// low_power[]         Low power bus
// ram_addr[]          Address to RAM
// ram_ceb             Cell enable to RAM
// ram_web             Write enable to RAM
// ram_wemb[]          Write enable mask to RAM
// ram_din[]           Data input to RAM
// ram_init_busy       RAM initialization busy signal

`default_nettype none

module miv_rv32_bist_template_dual_behav
  #(
    parameter RAM_DEPTH       = 16,
    parameter DATA_WIDTH      = 8,
    parameter ADDR_WIDTH      = 4,
    parameter BIST_ADDR_WIDTH = 4,
    parameter LOW_POWER_WIDTH = 4,
    parameter NUM_LP1_PINS     = 1,
    parameter NUM_LP2_PINS     = 1,
    parameter NUM_LP3_PINS     = 1,
    parameter miv_rv32_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false RAM_STABILIZER
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false BWE_RAM
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_pkg::BIST_TRUE,
    parameter miv_rv32_pkg::t_bist_true_false RAM_INIT_GEN
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE_LS
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE_LP
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline OUTPUT_PIPELINE
                              = miv_rv32_pkg::BIST_PIPELINE_OFF

  )
  (
    input  wire logic                       arstb,
    input  wire logic                       aclk,
    input  wire logic                       brstb,
    input  wire logic                       bclk,
    // user ram interface
    input  wire logic [ADDR_WIDTH-1:0]      aaddr,
    input  wire logic                       aceb,
    input  wire logic                       aweb,
    input  wire logic [DATA_WIDTH-1:0]      awemb,
    input  wire logic [DATA_WIDTH-1:0]      adin,
    output      logic [DATA_WIDTH-1:0]      adout,
    input  wire logic [ADDR_WIDTH-1:0]      baddr,
    input  wire logic                       bceb,
    input  wire logic                       bweb,
    input  wire logic [DATA_WIDTH-1:0]      bwemb,
    input  wire logic [DATA_WIDTH-1:0]      bdin,
    output      logic [DATA_WIDTH-1:0]      bdout,
    // internal ram interfac
    output      logic                       ram_aceb,
    output      logic [DATA_WIDTH-1:0]      ram_awemb,
    output      logic                       ram_aweb,
    output      logic [ADDR_WIDTH-1:0]      ram_aaddr,
    output      logic [DATA_WIDTH-1:0]      ram_adin,
    input  wire logic [DATA_WIDTH-1:0]      ram_adout,
    output      logic                       ram_bceb,
    output      logic [DATA_WIDTH-1:0]      ram_bwemb,
    output      logic                       ram_bweb,
    output      logic [ADDR_WIDTH-1:0]      ram_baddr,
    output      logic [DATA_WIDTH-1:0]      ram_bdin,
    input  wire logic [DATA_WIDTH-1:0]      ram_bdout,
    // low power interface
    input  wire logic                       pg_clk,
    input  wire logic                       pg_rstb,
    input  wire logic                       pg_override,
    input  wire logic [NUM_LP1_PINS-1:0]     lp1,
    input  wire logic [NUM_LP2_PINS-1:0]     lp2,
    input  wire logic [NUM_LP3_PINS-1:0]     lp3,
    output      logic [LOW_POWER_WIDTH-1:0] low_power,
    // ram init interface
    input  wire logic                       ram_init_enable,
    output      logic                       ram_init_busy_a,
    output      logic                       ram_init_busy_b
  );

  import miv_rv32_pkg::*;

  // LOCAL PARAMETER
  localparam logic           POWR = 1'b1;
  localparam t_bist_pipeline BWE_PIPELINE = 
                           (BWE_RAM == BIST_TRUE && INPUT_PIPELINE == BIST_PIPELINE_ON) ? 
                           BIST_PIPELINE_ON : BIST_PIPELINE_OFF;

  // INTERNAL SIGNALS
  logic                   ram_init_clear_q;
  logic [ADDR_WIDTH-1:0]  ram_init_aaddr;
  logic                   ram_init_start_b;
  logic [DATA_WIDTH-1:0]  sys_adin;
  logic [DATA_WIDTH-1:0]  sys_adout;
  logic [ADDR_WIDTH-1:0]  sys_aaddr;
  logic                   sys_aceb;
  logic                   sys_aweb;
  logic [DATA_WIDTH-1:0]  sys_awemb;
  logic [DATA_WIDTH-1:0]  sys_bdin;
  logic [DATA_WIDTH-1:0]  sys_bdout;
  logic [ADDR_WIDTH-1:0]  sys_baddr;
  logic                   sys_bceb;
  logic                   sys_bweb;
  logic [DATA_WIDTH-1:0]  sys_bwemb;
  logic [NUM_LP1_PINS-1:0] sys_lp1;
  logic [NUM_LP2_PINS-1:0] sys_lp2;
  logic [NUM_LP3_PINS-1:0] sys_lp3;
  logic                   a_input_pl_data_enable;
  logic                   a_input_pl_ctrl_enable;
  logic                   a_output_pl_data_enable;
  logic                   b_input_pl_data_enable;
  logic                   b_input_pl_ctrl_enable;
  logic                   b_output_pl_data_enable;
  logic                   input_pl_pg_enable;
  logic                   sys_aceb_fpga;
  logic                   sys_bceb_fpga;
  logic [DATA_WIDTH-1:0]  sys_adout_fpga;
  logic [DATA_WIDTH-1:0]  sys_bdout_fpga;
  logic                   sys_awemb_and;
  logic                   sys_bwemb_and;

  assign sys_awemb_and = &sys_awemb;
  assign sys_bwemb_and = &sys_bwemb;

  // Pipeline enable logic
  miv_rv32_bistdual_pl_enable
    #(
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    pl_enable_inst
    (
      .arstb,
      .aclk,
      .aceb,
      .aweb,
      .a_input_pl_data_enable,
      .a_input_pl_ctrl_enable,
      .a_output_pl_data_enable,
      .brstb,
      .bclk,
      .bceb,
      .bweb,
      .b_input_pl_data_enable,
      .b_input_pl_ctrl_enable,
      .b_output_pl_data_enable,
      .input_pl_pg_enable
     );

  // RAM Control wrapper
  miv_rv32_bistdual_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .RTL_MUX(RTL_MUX),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS)
    )
    ctrl_inst
    (
      .ram_init_busy_a,
      .ram_init_busy_b,
      .ram_init_start_b,
      .ram_init_clear_q,
      .ram_init_aaddr,
      .sys_aceb(sys_aceb_fpga),
      .sys_aweb,
      .sys_awemb,
      .sys_aaddr,
      .ram_aceb,
      .ram_aweb,
      .ram_awemb,
      .ram_aaddr,
      .sys_bceb(sys_bceb_fpga),
      .sys_bweb,
      .sys_bwemb,
      .sys_baddr,
      .ram_bceb,
      .ram_bweb,
      .ram_bwemb,
      .ram_baddr,
      .sys_lp1,
      .sys_lp2,
      .sys_lp3,
      .pg_override,
      .low_power
    );

  // RAM Data Analyzer
  miv_rv32_bistdualdata_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .RTL_MUX(RTL_MUX)
    )
    check_inst
    (
      .ram_init_busy_a,
      .sys_adin,
      .sys_adout,
      .ram_adin,
      .ram_adout,
      .ram_init_busy_b,
      .sys_bdin,
      .sys_bdout,
      .ram_bdin,
      .ram_bdout
    );

  // RAM initialization block
  miv_rv32_bistdual_ram_init 
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .RAM_DEPTH(RAM_DEPTH),
      .ADDR_WIDTH(ADDR_WIDTH)
    )
    ram_init_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .brstb(brstb),
      .bclk(bclk),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ram_init_start_b(ram_init_start_b),
      .ram_init_clear_q(ram_init_clear_q),
      .ram_init_aaddr(ram_init_aaddr)
    );

  // FPGA compaticle logic
  miv_rv32_bistdual_ram_stabilizer 
    #(
      .RAM_STABILIZER(RAM_STABILIZER),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH)
    )
    ram_stabilizer_enable_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(sys_aaddr),
      .aceb_in(sys_aceb),
      .aceb_out(sys_aceb_fpga),
      .aweb(sys_aweb),
      .awemb_and(sys_awemb_and),
      .adin(sys_adin),
      .adout_in(sys_adout),
      .adout_out(sys_adout_fpga),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(sys_baddr),
      .bceb_in(sys_bceb),
      .bceb_out(sys_bceb_fpga),
      .bweb(sys_bweb),
      .bwemb_and(sys_bwemb_and),
      .bdin(sys_bdin),
      .bdout_in(sys_bdout),
      .bdout_out(sys_bdout_fpga)
    );

  // INPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aceb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(POWR),
      .din(aceb),
      .dout(sys_aceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    awemb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(awemb),
      .dout(sys_awemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aweb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aweb),
      .dout(sys_aweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE))
    aaddr_pipeline_inst(
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aaddr),
      .dout(sys_aaddr));

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    adin_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_data_enable),
      .din(adin),
      .dout(sys_adin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bceb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(POWR),
      .din(bceb),
      .dout(sys_bceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    bwemb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bwemb),
      .dout(sys_bwemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bweb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bweb),
      .dout(sys_bweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    baddr_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(baddr),
      .dout(sys_baddr)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bdin_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_data_enable),
      .din(bdin),
      .dout(sys_bdin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP1_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LS)
    )
    lp1_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp1),
      .dout(sys_lp1)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP2_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp2_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp2),
      .dout(sys_lp2)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP3_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp3_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp3),
      .dout(sys_lp3)
    );

  // OUTPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    adout_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_output_pl_data_enable),
      .din(sys_adout_fpga),
      .dout(adout)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    bdout_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_output_pl_data_enable),
      .din(sys_bdout_fpga),
      .dout(bdout)
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_ram_dport_reg(data0,data1,waddr0, waddr1,we0,we1,clk,q0,q1);
    parameter d_width = 32;
    parameter addr_width = 32;
    parameter mem_depth = 65536;

    input [d_width-1:0] data0, data1;
    input [addr_width-1:0] waddr0, waddr1;
    input we0, we1, clk;

    output [d_width-1:0] q0;
    output [d_width-1:0] q1;

    reg [d_width-1:0] mem [mem_depth:0];

    reg [d_width-1:0] q0, q1;

    always @(posedge clk) begin 
        if (we0) begin
            mem[waddr0] <= data0;
			q0 <= {d_width{1'b0}};
		end else begin
		    q0 <= mem[waddr0];
		end
		
        if (we1) begin
            mem[waddr1] <= data1;
			q1 <= {d_width{1'b0}};
		end else begin
		    q1 <= mem[waddr1];
		end
			
    end 
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_dpr_hqa_dual_storage_bistw_behav
  #(
    parameter DATA_WIDTH       = 16,
    parameter ADDR_WIDTH       = 4,
    parameter RAM_DEPTH        = 65536
  )
  (
    input  wire logic                  ecc_bypass,
    input  wire logic [2-1:0]          ram_err_inject,
    output      logic [2-1:0]          ecc_aerr,
    output      logic [2-1:0]          ecc_berr,
    output      logic [2-1:0]          ecc_aerr_int,
    output      logic [2-1:0]          ecc_berr_int,

    input  wire logic                  pg_override,
    input  wire logic                  lp1,


    input  wire logic [DATA_WIDTH-1:0] adin,
    input  wire logic [DATA_WIDTH-1:0] bdin,
    output      logic [DATA_WIDTH-1:0] adout,
    output      logic [DATA_WIDTH-1:0] bdout,
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic                  aceb,
    input  wire logic                  aweb,
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic [ADDR_WIDTH-1:0] baddr,
    input  wire logic                  bceb,
    input  wire logic                  bweb
  );

  // IMPLEMENTATION 

  import miv_rv32_pkg::*;

  localparam PARITY_WIDTH      = parity_num(DATA_WIDTH);
  localparam logic             GRND              = 1'b0;
  localparam                   BISTW_WIDTH       = PARITY_WIDTH + DATA_WIDTH;
  localparam                   LOW_POWER_WIDTH   = 4;
  localparam                   NUM_LP1_PINS      = 1;
  localparam                   NUM_LP2_PINS      = 1;
  localparam                   NUM_LP3_PINS      = 1;
  localparam t_bist_true_false LP1_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP2_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP3_ACTIVE_LOW    = BIST_FALSE;
  localparam t_bist_true_false FUNC_CLKS_SYNC    = BIST_TRUE;
  localparam t_bist_true_false RAM_STABILIZER    = BIST_FALSE;
  localparam t_bist_true_false BWE_RAM           = BIST_FALSE;
  localparam t_bist_true_false RAM_INIT_GEN      = BIST_FALSE;
  localparam t_bist_true_false RTL_MUX           = BIST_TRUE;
  localparam t_bist_pipeline   INPUT_PIPELINE    = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LS = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LP = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   OUTPUT_PIPELINE   = BIST_PIPELINE_OFF;

  logic [BISTW_WIDTH-1:0]     bistw_adin_all;
  logic [BISTW_WIDTH-1:0]     bistw_adout_all;
  logic [BISTW_WIDTH-1:0]     bistw_awemb;
  logic [BISTW_WIDTH-1:0]     bistw_bdin_all;
  logic [BISTW_WIDTH-1:0]     bistw_bdout_all;
  logic [BISTW_WIDTH-1:0]     bistw_bwemb;
  logic [ADDR_WIDTH-1:0]      ram_aaddr;
  logic                       ram_aceb;
  logic [BISTW_WIDTH-1:0]     ram_awemb;
  logic                       ram_aweb;
  logic [BISTW_WIDTH-1:0]     ram_adin;
  logic [BISTW_WIDTH-1:0]     ram_adout;
  logic [ADDR_WIDTH-1:0]      ram_baddr;
  logic                       ram_bceb;
  logic [BISTW_WIDTH-1:0]     ram_bwemb;
  logic                       ram_bweb;
  logic [BISTW_WIDTH-1:0]     ram_bdin;
  logic [BISTW_WIDTH-1:0]     ram_bdout;
  logic [LOW_POWER_WIDTH-1:0] low_power;
  logic                 lp2;
  logic                 lp3;
  logic                 ram_init_enable;
  logic                 ram_init_busy_a;
  logic                 ram_init_busy_b;
  logic                 pg_rstb;
  logic                 pg_clk;
  logic                 awemb_and;
  logic                 bwemb_and;
  logic                 bist_ramscanb;
  logic                 bistb;
  logic [PARITY_WIDTH-1:0] bistw_apin;
  logic [PARITY_WIDTH-1:0] bistw_bpin;
  logic [DATA_WIDTH-1:0] bistw_adin;
  logic [DATA_WIDTH-1:0] bistw_bdin;
  logic [PARITY_WIDTH-1:0] bistw_apout;
  logic [PARITY_WIDTH-1:0] bistw_bpout;
  logic [DATA_WIDTH-1:0] bistw_adout;
  logic [DATA_WIDTH-1:0] bistw_bdout;

  assign ram_init_enable = 1'b0;
  assign pg_rstb         = 1'b0;
  assign pg_clk          = 1'b0;
  assign bist_ramscanb   = 1'b1;
  assign bistb           = 1'b1;
  assign awemb_and       = 1'b0;
  assign bwemb_and       = 1'b0;
  assign bistw_awemb     = {BISTW_WIDTH{1'b0}};
  assign bistw_bwemb     = {BISTW_WIDTH{1'b0}};
  assign lp2             = 1'b0;
  assign lp3             = 1'b0;
  assign bistw_adin_all  = {bistw_apin, bistw_adin};
  assign bistw_bdin_all  = {bistw_bpin, bistw_bdin};
  assign {bistw_apout, bistw_adout} = bistw_adout_all;
  assign {bistw_bpout, bistw_bdout} = bistw_bdout_all;

  // ECC wrapper
  miv_rv32_bistdual_eccw
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH),
      .PARITY_WIDTH(PARITY_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    ecc_inst
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ecc_bypass(ecc_bypass),
      .ram_err_inject(ram_err_inject),
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(aweb),
      .awemb_and(awemb_and),
      .sys_adin(adin),
      .bistw_adout(bistw_adout),
      .bistw_apout(bistw_apout),
      .sys_adout(adout),
      .bistw_adin(bistw_adin),
      .bistw_apin(bistw_apin),
      .ecc_aerr(ecc_aerr),
      .ecc_aerr_int(ecc_aerr_int),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(bweb),
      .bwemb_and(bwemb_and),
      .sys_bdin(bdin),
      .bistw_bdout(bistw_bdout),
      .bistw_bpout(bistw_bpout),
      .sys_bdout(bdout),
      .bistw_bdin(bistw_bdin),
      .bistw_bpin(bistw_bpin),
      .ecc_berr(ecc_berr),
      .ecc_berr_int(ecc_berr_int)
    );


  // RAM wrapper
  //miv_rv32_dpr_behav_ramw_arm28
    //#(
      //.DATA_WIDTH(BISTW_WIDTH),
      //.ADDR_WIDTH(ADDR_WIDTH),
      //.RAM_DEPTH(RAM_DEPTH),
      //.LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      //.NUM_LP1_PINS(NUM_LP1_PINS),
      //.NUM_LP2_PINS(NUM_LP2_PINS),
      //.NUM_LP3_PINS(NUM_LP3_PINS)
    //)
    //ram_inst
    //(
      //.aclk(aclk),
      //.aaddr(ram_aaddr),
      //.aceb(ram_aceb),
      //.aweb(ram_aweb),
      //.awemb(ram_awemb),
      //.adin(ram_adin),
      //.adout(ram_adout),
      //.bclk(bclk),
      //.baddr(ram_baddr),
      //.bceb(ram_bceb),
      //.bweb(ram_bweb),
      //.bwemb(ram_bwemb),
      //.bdin(ram_bdin),
      //.bdout(ram_bdout),
      //.low_power(low_power)
    //);


  miv_rv32_ram_dport_reg
    #(
      .d_width(BISTW_WIDTH),
      .addr_width(ADDR_WIDTH-2),
      .mem_depth(RAM_DEPTH)
    )
    ram_inst
    (
      .clk(aclk),
      .waddr0(ram_aaddr[ADDR_WIDTH-1:2]),
      .we0(ram_aweb),
      .data0(ram_adin),
      .q0(ram_adout),
      .waddr1(ram_baddr[ADDR_WIDTH-1:2]),
      .we1(ram_bweb),
      .data1(ram_bdin),
      .q1(ram_bdout)
    );



 // BIST wrapper
  miv_rv32_bist_template_dual_behav
    #(
      .RAM_DEPTH(RAM_DEPTH),
      .DATA_WIDTH(BISTW_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_STABILIZER(RAM_STABILIZER),
      .BWE_RAM(BWE_RAM),
      .RTL_MUX(RTL_MUX),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    dual_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(aweb),
      .awemb(bistw_awemb),
      .adin(bistw_adin_all),
      .adout(bistw_adout_all),
      .ram_aaddr(ram_aaddr),
      .ram_aceb(ram_aceb),
      .ram_aweb(ram_aweb),
      .ram_awemb(ram_awemb),
      .ram_adin(ram_adin),
      .ram_adout(ram_adout),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(bweb),
      .bwemb(bistw_bwemb),
      .bdin(bistw_bdin_all),
      .bdout(bistw_bdout_all),
      .ram_baddr(ram_baddr),
      .ram_bceb(ram_bceb),
      .ram_bweb(ram_bweb),
      .ram_bwemb(ram_bwemb),
      .ram_bdin(ram_bdin),
      .ram_bdout(ram_bdout),
      .pg_clk(pg_clk),
      .pg_rstb(pg_rstb),
      .pg_override(pg_override),
      .lp1(lp1),
      .lp2(lp2),
      .lp3(lp3),
      .low_power(low_power),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b)
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none
`undef RAM_BIST_VIEW_BEHAV
`undef RAM_BIST_VIEW
`define RAM_BIST_VIEW_BEHAV

`ifdef RAM_BIST_VIEW_BEHAV
`define RAM_BIST_VIEW 1
`elsif RAM_BIST_VIEW_FPGA
`define RAM_BIST_VIEW 2
`elsif RAM_BIST_VIEW_DFT
`define RAM_BIST_VIEW 3
`else
`define RAM_BIST_VIEW 0
`endif

module miv_rv32_dpr_hqa_dual_storage_rbcw
  #(
    parameter RAM_DEPTH            = 65536 ,
    parameter ADDR_WIDTH           = 28   ,
    parameter DATA_WIDTH           = 32  ,
    parameter PMC_RAM_BIST_VIEW    = `RAM_BIST_VIEW
  )
  (
    input  wire logic                    arstb,
    input  wire logic                    aclk,
    input  wire logic [ADDR_WIDTH-1:0]   aaddr,
    input  wire logic                    aceb,
    input  wire logic                    aweb,
    input  wire logic                    brstb,
    input  wire logic                    bclk,
    input  wire logic [ADDR_WIDTH-1:0]   baddr,
    input  wire logic                    bceb,
    input  wire logic                    bweb,
    input  wire logic                    ret1n,
    input  wire logic                    pg_override,
    input  wire logic                    ecc_bypass,
    input  wire logic [2-1:0]            ram_err_inject,
    input  wire logic [DATA_WIDTH-1:0]   adin,
    output      logic [DATA_WIDTH-1:0]   adout,
    input  wire logic [DATA_WIDTH-1:0]   bdin,
    output      logic [DATA_WIDTH-1:0]   bdout,
    output      logic [2-1:0]            ecc_aerr,
    output      logic [2-1:0]            ecc_aerr_int,
    output      logic [2-1:0]            ecc_berr,
    output      logic [2-1:0]            ecc_berr_int
  );

  // IMPLEMENTATION
  import miv_rv32_pkg::*;

  typedef enum {
    ASIC  = 0,
    BEHAV = 1,
    FPGA  = 2,
    DFT   = 3
  } t_bist_view;

  logic [BISTCTL_WIDTH-1:0]  bistctl;
  logic            scanb;
  logic            bist_scanb;
  logic            bist_ramscanb;
  logic            bistrstb;
  logic            bistclk;
  logic            scan_en;
  logic            scan_en_o;
  logic            ram_iddq_en;
  logic            fll_clk;

  assign bistctl              = {1'b1,{BISTCTL_WIDTH-1{1'b0}}};
  assign scanb                = 1'b1;
  assign bist_scanb           = 1'b1;
  assign bist_ramscanb        = 1'b1;
  assign fll_clk              = 1'b1;
  assign bistrstb             = 1'b0;
  assign bistclk              = 1'b0;
  assign scan_en              = 1'b0;
  assign scan_en_o            = 1'b0;
  assign ram_iddq_en          = 1'b0;

  generate
    case (PMC_RAM_BIST_VIEW)
      ASIC :
        begin : asic_gen
          miv_rv32_dpr256x32_hqa_dual_storage_bistw
            miv_rv32_dpr256x32_hqa_dual_storage_bistw_inst
            (
              .scanb(scanb),
              .bist_scanb(bist_scanb),
              .bist_ramscanb(bist_ramscanb),
              .scan_en(scan_en),
              .scan_en_o(scan_en_o),
              .ram_iddq_en(ram_iddq_en),
              .bistrstb(bistrstb),
              .bistclk(bistclk),
              .bistctl(bistctl),
              .fll_clk(fll_clk),
              .bistackecc(),
              .bistackmult(),
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : asic_gen
      BEHAV :
        begin : behav_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_behav
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_behav_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : behav_gen
      FPGA :
        begin : fpga_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_fpga
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_fpga_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : fpga_gen
      DFT :
        begin : dft_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_dft
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_dft_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : dft_gen
      default :
        begin : default_gen
          // Instantiates non-existing module to fail elaboration when no VIEW is sepcified
          // for behaviour RBCW (prep 283434)
          // pragma translate_off
          \RAM_BIST_ERROR:ASIC_view_does_not_exist_in_miv_rv32_dpr_hqa_dual_storage_rbcw See_ICDC_KB_1481_for_details
          ();
          // pragma translate_on

          // Abort synthesis if AISC view is not available.
          // cadence script_begin
            // puts "PMC Error: Couldn't find RAM BIST ASIC view."
            // puts "PMC Error: Please run do_gen_bist.prl and create ASIC VIEW."
            // puts "PMC Error: quitting RC."
            // ::dc::exit_old
          // cadence script_end

          // pragma translate_off
          // if specified VIEW is not implemented, the simulation
          // prints error message and exits with fatal error.
          initial begin
            assert(0)
            else begin
              $display("ERROR : %s is not a valid VIEW", PMC_RAM_BIST_VIEW);
              $fatal;
            end
          end
          // pragma translate_on
        end : default_gen
    endcase
  endgenerate

  // pragma translate_off
  task gen_audit_report;
    input integer ram_num;
    begin : audit_task
      string  file_name;
      integer f_handle;
      string  selected_view;
      case (PMC_RAM_BIST_VIEW)
        ASIC :
          begin : asic_view_sel
            selected_view = "ASIC";
          end : asic_view_sel
        BEHAV :
          begin : behav_view_sel
            selected_view = "BEHAV";
          end : behav_view_sel
        FPGA :
          begin : fpga_view_sel
            selected_view = "FPGA";
          end : fpga_view_sel
        default :
          begin : default_view_sel
            selected_view = "WRONG_VIEW";
          end : default_view_sel
      endcase
      //file_name = $sformatf("../scripts/ram_bist/audit_logs/miv_rv32_dpr_hqa_dual_storage_rbcw%0d", ram_num);
      //f_handle = $fopen (file_name, "w+");
      $fdisplay (f_handle, "design:module_name:miv_rv32_dpr_hqa_dual_storage_rbcw");
      $fdisplay (f_handle, "design:instance_path:%m");
      $fdisplay (f_handle, "design:PMC_RAM_BIST_VIEW:%s", selected_view);
      $fdisplay (f_handle, "design:available_view:ASIC BEHAV FPGA DFT");
      $fdisplay (f_handle, "design:DATA_WIDTH:32");
      $fdisplay (f_handle, "design:RAM_DEPTH:256");
      $fdisplay (f_handle, "design:ADDR_WIDTH:8");
      $fdisplay (f_handle, "parameter:DATA_WIDTH:%1d", DATA_WIDTH);
      $fdisplay (f_handle, "parameter:ADDR_WIDTH:%1d", ADDR_WIDTH);
      $fdisplay (f_handle, "parameter:RAM_DEPTH:%1d", RAM_DEPTH);
      $fdisplay (f_handle, "bist_arg:01_mark_number:pm88_60_250");
      $fdisplay (f_handle, "bist_arg:02_ram_suffix:hqa_dual_storage");
      $fdisplay (f_handle, "bist_arg:03_ram_type:dpr");
      $fdisplay (f_handle, "bist_arg:04_ram_size:256x32");
      $fdisplay (f_handle, "bist_arg:05_addr_split:no_addr_split");
      $fdisplay (f_handle, "bist_arg:06_data_split:no_data_split");
      $fdisplay (f_handle, "bist_arg:07_func_clks:func_clks_sync");
      $fdisplay (f_handle, "bist_arg:08_bist_clks:a_sync_b_sync");
      $fdisplay (f_handle, "bist_arg:09_bypass_ff:bypass_all_off");
      $fdisplay (f_handle, "bist_arg:10_ram_err_check:ecc_on");
      $fdisplay (f_handle, "bist_arg:11_input_pipeline:input_pipeline_off");
      $fdisplay (f_handle, "bist_arg:12_output_pipeline:output_pipeline_off");
      $fdisplay (f_handle, "bist_arg:13_ram_init:false");
      $fdisplay (f_handle, "bist_arg:14_fpga_ecc:false");
      $fdisplay (f_handle, "bist_arg:15_rtl_mux:false");
      $fdisplay (f_handle, "bist_arg:16_stabilizer:false");
      $fdisplay (f_handle, "bist_arg:17_bit_write_en:false");
      $fdisplay (f_handle, "bist_arg:18_number_of_rbcw:20");
      $fclose (f_handle);
    end : audit_task
  endtask
  // pragma translate_on


endmodule

// Reset default nettype for 3rd Party IP

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// RAM and BIST bist_template which can be used to drop in and replace a RAM
// instance.
//
// PARAMETER DESCRIPTION:
//
// RAM_DEPTH           Number of words in the RAM (<= 2^ADDR_WIDTH) 
// ADDR_WIDTH          Number of address bits.
// DATA_WIDTH          Number of data bits per word.
// LOW_POWER_WIDTH     Number of low_power bus bits.
// INPUT_PIPELINE      Indicates if input Pipeline flops are used or not
// INPUT_PIPELINE_LS   Indicates if input Pipeline flops for low power flops (ls)
// INPUT_PIPELINE_LP   Indicates if input Pipeline flops for low power flops (ds and sd)
//                     (ds and sd )are used or not
// OUTPUT_PIPELINE     Indicates if output Pipeline flops are used or not
// BWE_RAM             Indicates if this is bwe ram
// RAM_INIT_GEN        Indicates if ram init is generated
//
// INPUT PORT DESCRIPTION:
//
// rstb                System reset (active low). 
// clk                 RAM clock.
// lp1                 Light sleep mode input
// lp2                 Deep sleep mode input
// lp3                 Shut down mode input
// addr[]              RAM read/write address.
// ceb                 RAM cell enable (active low).
// web                 RAM write enable (active low).
// wemb[]              RAM write enable mask (active low).
// din[]               RAM write data. 
// ram_dout            Data output from ram
// pg_override         Override low power mode
// ram_init_enable     Enable for RAM initialization
//
// OUTPUT PORT DESCRIPTION:
//
// dout[]              RAM read data.
// low_power[]         Low power bus
// ram_addr[]          Address to RAM
// ram_ceb             Cell enable to RAM
// ram_web             Write enable to RAM
// ram_wemb[]          Write enable mask to RAM
// ram_din[]           Data input to RAM
// ram_init_busy       RAM initialization busy signal

`default_nettype none

module miv_rv32_gpr_ecc_bist_template
  #(
    parameter RAM_DEPTH       = 16,
    parameter DATA_WIDTH      = 8,
    parameter ADDR_WIDTH      = 4,
    parameter BIST_ADDR_WIDTH = 4,
    parameter LOW_POWER_WIDTH = 4,
    parameter NUM_LP1_PINS     = 1,
    parameter NUM_LP2_PINS     = 1,
    parameter NUM_LP3_PINS     = 1,
    parameter miv_rv32_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false RAM_STABILIZER
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false BWE_RAM
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_pkg::BIST_TRUE,
    parameter miv_rv32_pkg::t_bist_true_false RAM_INIT_GEN
                              = miv_rv32_pkg::BIST_FALSE,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE_LS
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline INPUT_PIPELINE_LP
                              = miv_rv32_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_pkg::t_bist_pipeline OUTPUT_PIPELINE
                              = miv_rv32_pkg::BIST_PIPELINE_OFF

  )
  (
    input  wire logic                       arstb,
    input  wire logic                       aclk,
	
    input  wire logic                       brstb,
    input  wire logic                       bclk,
	
    input  wire logic                       crstb,   
    input  wire logic                       cclk,    
    // user ram interface
    input  wire logic [ADDR_WIDTH-1:0]      aaddr,
    input  wire logic                       aceb,
    input  wire logic                       aweb,
    input  wire logic [DATA_WIDTH-1:0]      awemb,
    input  wire logic [DATA_WIDTH-1:0]      adin,
    output      logic [DATA_WIDTH-1:0]      adout,
	
    input  wire logic [ADDR_WIDTH-1:0]      baddr,
    input  wire logic                       bceb,
    input  wire logic                       bweb,
    input  wire logic [DATA_WIDTH-1:0]      bwemb,
    input  wire logic [DATA_WIDTH-1:0]      bdin,
    output      logic [DATA_WIDTH-1:0]      bdout,
	
    input  wire logic [ADDR_WIDTH-1:0]      caddr,
    input  wire logic                       cceb,
    input  wire logic                       cweb,
    input  wire logic [DATA_WIDTH-1:0]      cwemb,
    input  wire logic [DATA_WIDTH-1:0]      cdin,
    output      logic [DATA_WIDTH-1:0]      cdout,
    // internal ram interfac
    output      logic                       ram_aceb,
    output      logic [DATA_WIDTH-1:0]      ram_awemb,
    output      logic                       ram_aweb,
    output      logic [ADDR_WIDTH-1:0]      ram_aaddr,
    output      logic [DATA_WIDTH-1:0]      ram_adin,
    input  wire logic [DATA_WIDTH-1:0]      ram_adout,
	
    output      logic                       ram_bceb,
    output      logic [DATA_WIDTH-1:0]      ram_bwemb,
    output      logic                       ram_bweb,
    output      logic [ADDR_WIDTH-1:0]      ram_baddr,
    output      logic [DATA_WIDTH-1:0]      ram_bdin,
    input  wire logic [DATA_WIDTH-1:0]      ram_bdout,
	
    output      logic                       ram_cceb,
    output      logic [DATA_WIDTH-1:0]      ram_cwemb,
    output      logic                       ram_cweb,
    output      logic [ADDR_WIDTH-1:0]      ram_caddr,
    output      logic [DATA_WIDTH-1:0]      ram_cdin,
    input  wire logic [DATA_WIDTH-1:0]      ram_cdout,
    // low power interface
    input  wire logic                       pg_clk,
    input  wire logic                       pg_rstb,
    input  wire logic                       pg_override,
    input  wire logic [NUM_LP1_PINS-1:0]     lp1,
    input  wire logic [NUM_LP2_PINS-1:0]     lp2,
    input  wire logic [NUM_LP3_PINS-1:0]     lp3,
    output      logic [LOW_POWER_WIDTH-1:0] low_power,
    // ram init interface
    input  wire logic                       ram_init_enable,
    output      logic                       ram_init_busy_a,
    output      logic                       ram_init_busy_b,
    output      logic                       ram_init_busy_c
  );

  import miv_rv32_pkg::*;

  // LOCAL PARAMETER
  localparam logic           POWR = 1'b1;
  localparam t_bist_pipeline BWE_PIPELINE = 
                           (BWE_RAM == BIST_TRUE && INPUT_PIPELINE == BIST_PIPELINE_ON) ? 
                           BIST_PIPELINE_ON : BIST_PIPELINE_OFF;

  // INTERNAL SIGNALS
  logic                   ram_init_clear_q;
  logic [ADDR_WIDTH-1:0]  ram_init_aaddr;
  logic                   ram_init_start_b;
  
  logic [DATA_WIDTH-1:0]  sys_adin;
  logic [DATA_WIDTH-1:0]  sys_adout;
  logic [ADDR_WIDTH-1:0]  sys_aaddr;
  logic                   sys_aceb;
  logic                   sys_aweb;
  logic [DATA_WIDTH-1:0]  sys_awemb;
  
  logic [DATA_WIDTH-1:0]  sys_bdin;
  logic [DATA_WIDTH-1:0]  sys_bdout;
  logic [ADDR_WIDTH-1:0]  sys_baddr;
  logic                   sys_bceb;
  logic                   sys_bweb;
  logic [DATA_WIDTH-1:0]  sys_bwemb;
  
  logic [DATA_WIDTH-1:0]  sys_cdin;      
  logic [DATA_WIDTH-1:0]  sys_cdout;     
  logic [ADDR_WIDTH-1:0]  sys_caddr;     
  logic                   sys_cceb;      
  logic                   sys_cweb;      
  logic [DATA_WIDTH-1:0]  sys_cwemb;     
  
  logic [NUM_LP1_PINS-1:0] sys_lp1;
  logic [NUM_LP2_PINS-1:0] sys_lp2;
  logic [NUM_LP3_PINS-1:0] sys_lp3;
  logic                   a_input_pl_data_enable;
  logic                   a_input_pl_ctrl_enable;
  logic                   a_output_pl_data_enable;
  
  logic                   b_input_pl_data_enable;
  logic                   b_input_pl_ctrl_enable;
  logic                   b_output_pl_data_enable;
  
  logic                   c_input_pl_data_enable;      
  logic                   c_input_pl_ctrl_enable;      
  logic                   c_output_pl_data_enable;     
  
  logic                   input_pl_pg_enable;
  logic                   sys_aceb_fpga;
  logic                   sys_bceb_fpga;
  logic                   sys_cceb_fpga;     
  logic [DATA_WIDTH-1:0]  sys_adout_fpga;
  logic [DATA_WIDTH-1:0]  sys_bdout_fpga;
  logic [DATA_WIDTH-1:0]  sys_cdout_fpga;   
  logic                   sys_awemb_and;
  logic                   sys_bwemb_and;
  logic                   sys_cwemb_and;    

  assign sys_awemb_and = &sys_awemb;
  assign sys_bwemb_and = &sys_bwemb;
  assign sys_cwemb_and = &sys_cwemb;   

  // Pipeline enable logic
  miv_rv32_bistdual_pl_enable
    #(
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    pl_enable_inst
    (
      .arstb,
      .aclk,
      .aceb,
      .aweb,
      .a_input_pl_data_enable,
      .a_input_pl_ctrl_enable,
      .a_output_pl_data_enable,
	  
      .brstb,
      .bclk,
      .bceb,
      .bweb,
      .b_input_pl_data_enable,
      .b_input_pl_ctrl_enable,
      .b_output_pl_data_enable,
	  
      .crstb,                      
      .cclk,                       
      .cceb,                       
      .cweb,                       
      .c_input_pl_data_enable,     
      .c_input_pl_ctrl_enable,     
      .c_output_pl_data_enable,    
	  
      .input_pl_pg_enable
     );

  // RAM Control wrapper
  miv_rv32_bistdual_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .RTL_MUX(RTL_MUX),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS)
    )
    ctrl_inst
    (
      .ram_init_busy_a,
      .ram_init_busy_b,
      .ram_init_busy_c,    
      .ram_init_start_b,
      .ram_init_clear_q,
      .ram_init_aaddr,
	  
      .sys_aceb(sys_aceb_fpga),
      .sys_aweb,
      .sys_awemb,
      .sys_aaddr,
      .ram_aceb,
      .ram_aweb,
      .ram_awemb,
      .ram_aaddr,
	  
      .sys_bceb(sys_bceb_fpga),
      .sys_bweb,
      .sys_bwemb,
      .sys_baddr,
      .ram_bceb,
      .ram_bweb,
      .ram_bwemb,
      .ram_baddr,
	  
      .sys_cceb(sys_cceb_fpga),     
      .sys_cweb,                    
      .sys_cwemb,                   
      .sys_caddr,                   
      .ram_cceb,                    
      .ram_cweb,                    
      .ram_cwemb,                   
      .ram_caddr,                   
	  
      .sys_lp1,
      .sys_lp2,
      .sys_lp3,
      .pg_override,
      .low_power
    );

  // RAM Data Analyzer
  miv_rv32_bistdualdata_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .RTL_MUX(RTL_MUX)
    )
    check_inst
    (
      .ram_init_busy_a,
      .sys_adin,
      .sys_adout,
      .ram_adin,
      .ram_adout,
	  
      .ram_init_busy_b,
      .sys_bdin,
      .sys_bdout,
      .ram_bdin,
      .ram_bdout,
	  
      .ram_init_busy_c,           
      .sys_cdin,                  
      .sys_cdout,                 
      .ram_cdin,                  
      .ram_cdout                  
    );

  // RAM initialization block
  miv_rv32_bistdual_ram_init 
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .RAM_DEPTH(RAM_DEPTH),
      .ADDR_WIDTH(ADDR_WIDTH)
    )
    ram_init_inst
    (
      .arstb(arstb),
      .aclk(aclk),
	  
      .brstb(brstb),
      .bclk(bclk),
	  
      .crstb(crstb),    
      .cclk(cclk),      
	  
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
	  
      .ram_init_busy_b(ram_init_busy_b),
	  
      .ram_init_busy_c(ram_init_busy_c),   
	  
      .ram_init_start_b(ram_init_start_b),
      .ram_init_clear_q(ram_init_clear_q),
      .ram_init_aaddr(ram_init_aaddr)
    );

  // FPGA compaticle logic
  miv_rv32_bistdual_ram_stabilizer 
    #(
      .RAM_STABILIZER(RAM_STABILIZER),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH)
    )
    ram_stabilizer_enable_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(sys_aaddr),
      .aceb_in(sys_aceb),
      .aceb_out(sys_aceb_fpga),
      .aweb(sys_aweb),
      .awemb_and(sys_awemb_and),
      .adin(sys_adin),
      .adout_in(sys_adout),
      .adout_out(sys_adout_fpga),
	  
      .brstb(brstb),
      .bclk(bclk),
      .baddr(sys_baddr),
      .bceb_in(sys_bceb),
      .bceb_out(sys_bceb_fpga),
      .bweb(sys_bweb),
      .bwemb_and(sys_bwemb_and),
      .bdin(sys_bdin),
      .bdout_in(sys_bdout),
      .bdout_out(sys_bdout_fpga),
	  
      .crstb(crstb),                  
      .cclk(cclk),                    
      .caddr(sys_caddr),              
      .cceb_in(sys_cceb),             
      .cceb_out(sys_cceb_fpga),       
      .cweb(sys_cweb),                
      .cwemb_and(sys_cwemb_and),      
      .cdin(sys_cdin),                
      .cdout_in(sys_cdout),           
      .cdout_out(sys_cdout_fpga)      
	  
	  
    );

  // INPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aceb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(POWR),
      .din(aceb),
      .dout(sys_aceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    awemb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(awemb),
      .dout(sys_awemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aweb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aweb),
      .dout(sys_aweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE))
    aaddr_pipeline_inst(
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aaddr),
      .dout(sys_aaddr));

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    adin_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_data_enable),
      .din(adin),
      .dout(sys_adin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bceb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(POWR),
      .din(bceb),
      .dout(sys_bceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    bwemb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bwemb),
      .dout(sys_bwemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bweb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bweb),
      .dout(sys_bweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    baddr_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(baddr),
      .dout(sys_baddr)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bdin_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_data_enable),
      .din(bdin),
      .dout(sys_bdin)
    );

 

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    cceb_pipeline_inst
    (
      .clk(cclk),
      .rstb(crstb),
      .enable(POWR),
      .din(cceb),
      .dout(sys_cceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    cwemb_pipeline_inst
    (
      .clk(cclk),
      .rstb(crstb),
      .enable(c_input_pl_ctrl_enable),
      .din(cwemb),
      .dout(sys_cwemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    cweb_pipeline_inst
    (
      .clk(cclk),
      .rstb(crstb),
      .enable(c_input_pl_ctrl_enable),
      .din(cweb),
      .dout(sys_cweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    caddr_pipeline_inst
    (
      .clk(cclk),
      .rstb(crstb),
      .enable(c_input_pl_ctrl_enable),
      .din(caddr),
      .dout(sys_caddr)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    cdin_pipeline_inst
    (
      .clk(cclk),
      .rstb(crstb),
      .enable(c_input_pl_data_enable),
      .din(cdin),
      .dout(sys_cdin)
    );



  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP1_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LS)
    )
    lp1_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp1),
      .dout(sys_lp1)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP2_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp2_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp2),
      .dout(sys_lp2)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP3_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp3_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp3),
      .dout(sys_lp3)
    );

  // OUTPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    adout_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_output_pl_data_enable),
      .din(sys_adout_fpga),
      .dout(adout)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    bdout_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_output_pl_data_enable),
      .din(sys_bdout_fpga),
      .dout(bdout)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    cdout_pipeline_inst
    (
      .clk(cclk),
      .rstb(crstb),
      .enable(c_output_pl_data_enable),
      .din(sys_cdout_fpga),
      .dout(cdout)
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
`default_nettype none
`undef RAM_BIST_VIEW_BEHAV
`undef RAM_BIST_VIEW
`define RAM_BIST_VIEW_BEHAV

`ifdef RAM_BIST_VIEW_BEHAV
`define RAM_BIST_VIEW 1
`elsif RAM_BIST_VIEW_FPGA
`define RAM_BIST_VIEW 2
`elsif RAM_BIST_VIEW_DFT
`define RAM_BIST_VIEW 3
`else
`define RAM_BIST_VIEW 0
`endif

module miv_rv32_gpr_ecc_enc_dec
  #(
    parameter RAM_DEPTH            = 65536 ,
    parameter ADDR_WIDTH           = 28   ,
    parameter DATA_WIDTH           = 32  ,
    parameter PMC_RAM_BIST_VIEW    = `RAM_BIST_VIEW
  )
  (
    input  wire logic                    arstb,
    input  wire logic                    aclk,
    input  wire logic [ADDR_WIDTH-1:0]   aaddr,
    input  wire logic                    aceb,
    input  wire logic                    brstb,
    input  wire logic                    bclk,
    input  wire logic [ADDR_WIDTH-1:0]   baddr,
    input  wire logic                    bceb,
    input  wire logic                    crstb,
    input  wire logic                    cclk,
    input  wire logic [ADDR_WIDTH-1:0]   caddr,
    input  wire logic                    cceb,
    input  wire logic                    ret1n,
    input  wire logic                    pg_override,
    input  wire logic                    ecc_bypass,
    input  wire logic [1:0]              ram_err_inject,
    output  wire logic [DATA_WIDTH-1:0]  adout,
    output  wire logic [DATA_WIDTH-1:0]  bdout,
    output  wire logic [DATA_WIDTH-1:0]  cdout,
    output      logic [1:0]              ecc_aerr,
    output      logic [1:0]              ecc_aerr_int,
    output      logic [1:0]              ecc_berr,
    output      logic [1:0]              ecc_berr_int,
    output      logic [1:0]              ecc_cerr,
    output      logic [1:0]              ecc_cerr_int,
    input  wire logic [ADDR_WIDTH-1:0]   waddr,
    input  wire logic [DATA_WIDTH-1:0]   wdin,
    input  wire logic                    wen
  );

  // IMPLEMENTATION
  import miv_rv32_pkg::*;

  typedef enum {
    ASIC  = 0,
    BEHAV = 1,
    FPGA  = 2,
    DFT   = 3
  } t_bist_view;

  logic [BISTCTL_WIDTH-1:0]  bistctl;
  logic            scanb;
  logic            bist_scanb;
  logic            bist_ramscanb;
  logic            bistrstb;
  logic            bistclk;
  logic            scan_en;
  logic            scan_en_o;
  logic            ram_iddq_en;
  logic            fll_clk;

  assign bistctl              = {1'b1,{BISTCTL_WIDTH-1{1'b0}}};
  assign scanb                = 1'b1;
  assign bist_scanb           = 1'b1;
  assign bist_ramscanb        = 1'b1;
  assign fll_clk              = 1'b1;
  assign bistrstb             = 1'b0;
  assign bistclk              = 1'b0;
  assign scan_en              = 1'b0;
  assign scan_en_o            = 1'b0;
  assign ram_iddq_en          = 1'b0;

  generate
    case (PMC_RAM_BIST_VIEW)
      ASIC :
        begin : asic_gen
          miv_rv32_dpr256x32_hqa_dual_storage_bistw
            miv_rv32_dpr256x32_hqa_dual_storage_bistw_inst
            (
              .scanb(scanb),
              .bist_scanb(bist_scanb),
              .bist_ramscanb(bist_ramscanb),
              .scan_en(scan_en),
              .scan_en_o(scan_en_o),
              .ram_iddq_en(ram_iddq_en),
              .bistrstb(bistrstb),
              .bistclk(bistclk),
              .bistctl(bistctl),
              .fll_clk(fll_clk),
              .bistackecc(),
              .bistackmult(),
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(0),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(0),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(0),
              .adout(adout),
              .bdin(0),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : asic_gen
      BEHAV :
        begin : behav_gen // using this :)
          miv_rv32_gpr_ecc_enc_dec_bistw_behav
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_behav_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .crstb(crstb),
              .cclk(cclk),
              .caddr(caddr),
              .cceb(cceb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adout(adout),
              .bdout(bdout),
              .cdout(cdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int),
              .ecc_cerr(ecc_cerr),
              .ecc_cerr_int(ecc_cerr_int),
              .waddr(waddr),
              .wdin(wdin),
              .wen(wen)
            );
        end : behav_gen
      FPGA :
        begin : fpga_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_fpga
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_fpga_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(0),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(0),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(0),
              .adout(adout),
              .bdin(0),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : fpga_gen
      DFT :
        begin : dft_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_dft
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_dft_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(0),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(0),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(0),
              .adout(adout),
              .bdin(0),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : dft_gen
      default :
        begin : default_gen
          // Instantiates non-existing module to fail elaboration when no VIEW is sepcified
          // for behaviour RBCW (prep 283434)
          // pragma translate_off
          \RAM_BIST_ERROR:ASIC_view_does_not_exist_in_miv_rv32_dpr_hqa_dual_storage_rbcw See_ICDC_KB_1481_for_details
          ();
          // pragma translate_on

          // Abort synthesis if AISC view is not available.
          // cadence script_begin
            // puts "PMC Error: Couldn't find RAM BIST ASIC view."
            // puts "PMC Error: Please run do_gen_bist.prl and create ASIC VIEW."
            // puts "PMC Error: quitting RC."
            // ::dc::exit_old
          // cadence script_end

          // pragma translate_off
          // if specified VIEW is not implemented, the simulation
          // prints error message and exits with fatal error.
          initial begin
            assert(0)
            else begin
              $display("ERROR : %s is not a valid VIEW", PMC_RAM_BIST_VIEW);
              $fatal;
            end
          end
          // pragma translate_on
        end : default_gen
    endcase
  endgenerate

  // pragma translate_off
  task gen_audit_report;
    input integer ram_num;
    begin : audit_task
      string  file_name;
      integer f_handle;
      string  selected_view;
      case (PMC_RAM_BIST_VIEW)
        ASIC :
          begin : asic_view_sel
            selected_view = "ASIC";
          end : asic_view_sel
        BEHAV :
          begin : behav_view_sel
            selected_view = "BEHAV";
          end : behav_view_sel
        FPGA :
          begin : fpga_view_sel
            selected_view = "FPGA";
          end : fpga_view_sel
        default :
          begin : default_view_sel
            selected_view = "WRONG_VIEW";
          end : default_view_sel
      endcase
      //file_name = $sformatf("../scripts/ram_bist/audit_logs/miv_rv32_dpr_hqa_dual_storage_rbcw%0d", ram_num);
      //f_handle = $fopen (file_name, "w+");
      $fdisplay (f_handle, "design:module_name:miv_rv32_dpr_hqa_dual_storage_rbcw");
      $fdisplay (f_handle, "design:instance_path:%m");
      $fdisplay (f_handle, "design:PMC_RAM_BIST_VIEW:%s", selected_view);
      $fdisplay (f_handle, "design:available_view:ASIC BEHAV FPGA DFT");
      $fdisplay (f_handle, "design:DATA_WIDTH:32");
      $fdisplay (f_handle, "design:RAM_DEPTH:256");
      $fdisplay (f_handle, "design:ADDR_WIDTH:8");
      $fdisplay (f_handle, "parameter:DATA_WIDTH:%1d", DATA_WIDTH);
      $fdisplay (f_handle, "parameter:ADDR_WIDTH:%1d", ADDR_WIDTH);
      $fdisplay (f_handle, "parameter:RAM_DEPTH:%1d", RAM_DEPTH);
      $fdisplay (f_handle, "bist_arg:01_mark_number:pm88_60_250");
      $fdisplay (f_handle, "bist_arg:02_ram_suffix:hqa_dual_storage");
      $fdisplay (f_handle, "bist_arg:03_ram_type:dpr");
      $fdisplay (f_handle, "bist_arg:04_ram_size:256x32");
      $fdisplay (f_handle, "bist_arg:05_addr_split:no_addr_split");
      $fdisplay (f_handle, "bist_arg:06_data_split:no_data_split");
      $fdisplay (f_handle, "bist_arg:07_func_clks:func_clks_sync");
      $fdisplay (f_handle, "bist_arg:08_bist_clks:a_sync_b_sync");
      $fdisplay (f_handle, "bist_arg:09_bypass_ff:bypass_all_off");
      $fdisplay (f_handle, "bist_arg:10_ram_err_check:ecc_on");
      $fdisplay (f_handle, "bist_arg:11_input_pipeline:input_pipeline_off");
      $fdisplay (f_handle, "bist_arg:12_output_pipeline:output_pipeline_off");
      $fdisplay (f_handle, "bist_arg:13_ram_init:false");
      $fdisplay (f_handle, "bist_arg:14_fpga_ecc:false");
      $fdisplay (f_handle, "bist_arg:15_rtl_mux:false");
      $fdisplay (f_handle, "bist_arg:16_stabilizer:false");
      $fdisplay (f_handle, "bist_arg:17_bit_write_en:false");
      $fdisplay (f_handle, "bist_arg:18_number_of_rbcw:20");
      $fclose (f_handle);
    end : audit_task
  endtask
  // pragma translate_on


endmodule

// Reset default nettype for 3rd Party IP

`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
`default_nettype none

module miv_rv32_gpr_ecc_enc_dec_bistw_behav
  #(
    parameter DATA_WIDTH       = 16,
    parameter ADDR_WIDTH       = 4,
    parameter RAM_DEPTH        = 65536
  )
  (
    input  wire logic                  ecc_bypass,
    input  wire logic [2-1:0]          ram_err_inject,
    output      logic [2-1:0]          ecc_aerr,
    output      logic [2-1:0]          ecc_berr,
    output      logic [2-1:0]          ecc_cerr,
    output      logic [2-1:0]          ecc_aerr_int,
    output      logic [2-1:0]          ecc_berr_int,
    output      logic [2-1:0]          ecc_cerr_int,

    input  wire logic                  pg_override,
    input  wire logic                  lp1,

    output      logic [DATA_WIDTH-1:0] adout,
    output      logic [DATA_WIDTH-1:0] bdout,
    output      logic [DATA_WIDTH-1:0] cdout,
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic                  aceb,
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic [ADDR_WIDTH-1:0] baddr,
    input  wire logic                  bceb,
    input  wire logic                  crstb,
    input  wire logic                  cclk,
    input  wire logic [ADDR_WIDTH-1:0] caddr,
    input  wire logic                  cceb,
    input  wire logic                  wen,
    input  wire logic [DATA_WIDTH-1:0] wdin,
    input  wire logic [ADDR_WIDTH-1:0] waddr
  );

  // IMPLEMENTATION 

  import miv_rv32_pkg::*;

  localparam PARITY_WIDTH      = parity_num(DATA_WIDTH);
  localparam logic             GRND              = 1'b0;
  localparam                   BISTW_WIDTH       = PARITY_WIDTH + DATA_WIDTH;
  localparam                   LOW_POWER_WIDTH   = 4;
  localparam                   NUM_LP1_PINS      = 1;
  localparam                   NUM_LP2_PINS      = 1;
  localparam                   NUM_LP3_PINS      = 1;
  localparam t_bist_true_false LP1_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP2_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP3_ACTIVE_LOW    = BIST_FALSE;
  localparam t_bist_true_false FUNC_CLKS_SYNC    = BIST_TRUE;
  localparam t_bist_true_false RAM_STABILIZER    = BIST_FALSE;
  localparam t_bist_true_false BWE_RAM           = BIST_FALSE;
  localparam t_bist_true_false RAM_INIT_GEN      = BIST_FALSE;
  localparam t_bist_true_false RTL_MUX           = BIST_TRUE;
  localparam t_bist_pipeline   INPUT_PIPELINE    = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LS = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LP = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   OUTPUT_PIPELINE   = BIST_PIPELINE_OFF;

  logic [BISTW_WIDTH-1:0]     bistw_adin_all;
  logic [BISTW_WIDTH-1:0]     bistw_adout_all;
  logic [BISTW_WIDTH-1:0]     bistw_awemb;
  logic [BISTW_WIDTH-1:0]     bistw_bdin_all;
  logic [BISTW_WIDTH-1:0]     bistw_bdout_all;
  logic [BISTW_WIDTH-1:0]     bistw_bwemb;
  
  logic [BISTW_WIDTH-1:0]     bistw_cdin_all;    //
  logic [BISTW_WIDTH-1:0]     bistw_cdout_all;   //
  logic [BISTW_WIDTH-1:0]     bistw_cwemb;       //
  
  logic [ADDR_WIDTH-1:0]      ram_aaddr;
  logic                       ram_aceb;
  logic [BISTW_WIDTH-1:0]     ram_awemb;
  logic                       ram_aweb;
  logic [BISTW_WIDTH-1:0]     ram_adin;
  logic [BISTW_WIDTH-1:0]     ram_adout;
  logic [ADDR_WIDTH-1:0]      ram_baddr;
  logic                       ram_bceb;
  logic [BISTW_WIDTH-1:0]     ram_bwemb;
  logic                       ram_bweb;
  logic [BISTW_WIDTH-1:0]     ram_bdin;
  logic [BISTW_WIDTH-1:0]     ram_bdout;
  
  logic [ADDR_WIDTH-1:0]      ram_caddr;   
  logic                       ram_cceb;    
  logic [BISTW_WIDTH-1:0]     ram_cwemb;   
  logic                       ram_cweb;    
  logic [BISTW_WIDTH-1:0]     ram_cdin;    
  logic [BISTW_WIDTH-1:0]     ram_cdout;   
  
  logic [LOW_POWER_WIDTH-1:0] low_power;
  logic                 lp2;
  logic                 lp3;
  logic                 ram_init_enable;
  logic                 ram_init_busy_a;
  logic                 ram_init_busy_b;
  logic                 ram_init_busy_c;   
  logic                 pg_rstb;
  logic                 pg_clk;
  logic                 awemb_and;
  logic                 bwemb_and;
  logic                 cwemb_and;        
  logic                 bist_ramscanb;
  logic                 bistb;
  logic [PARITY_WIDTH-1:0] bistw_apin;
  logic [PARITY_WIDTH-1:0] bistw_bpin;
  logic [PARITY_WIDTH-1:0] bistw_cpin;    
  logic [DATA_WIDTH-1:0] bistw_adin;
  logic [DATA_WIDTH-1:0] bistw_bdin;
  logic [DATA_WIDTH-1:0] bistw_cdin;      
  logic [PARITY_WIDTH-1:0] bistw_apout;
  logic [PARITY_WIDTH-1:0] bistw_bpout;
  logic [PARITY_WIDTH-1:0] bistw_cpout;   
  logic [DATA_WIDTH-1:0] bistw_adout;
  logic [DATA_WIDTH-1:0] bistw_bdout;
  logic [DATA_WIDTH-1:0] bistw_cdout;     
  logic [BISTW_WIDTH-1:0]     ram_wdin;
  logic      ram_web;
  logic [ADDR_WIDTH-1:0]      ram_waddr;

  assign ram_init_enable = 1'b0;
  assign pg_rstb         = 1'b0;
  assign pg_clk          = 1'b0;
  assign bist_ramscanb   = 1'b1;
  assign bistb           = 1'b1;
  assign awemb_and       = 1'b0;
  assign bwemb_and       = 1'b0;
  assign cwemb_and       = 1'b0;     
  assign bistw_awemb     = 1'b0;
  assign bistw_bwemb     = 1'b0;
  assign bistw_cwemb     = 1'b0;       
  assign lp2             = 1'b0;
  assign lp3             = 1'b0;
  assign bistw_adin_all  = {bistw_apin, bistw_adin};
  assign bistw_bdin_all  = {bistw_bpin, bistw_bdin};
  assign bistw_cdin_all  = {bistw_cpin, bistw_cdin};       
  assign {bistw_apout, bistw_adout} = bistw_adout_all;
  assign {bistw_bpout, bistw_bdout} = bistw_bdout_all;
  assign {bistw_cpout, bistw_cdout} = bistw_cdout_all;   

  // ECC wrapper
  miv_rv32_bistdual_eccw
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH),
      .PARITY_WIDTH(PARITY_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    ecc_dec_inst
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
	  
      .ram_init_busy_b(ram_init_busy_b),
	  
      .ram_init_busy_c(ram_init_busy_c),      
	  
      .ecc_bypass(ecc_bypass),
      .ram_err_inject(ram_err_inject),
	  
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(1'b0),
      .awemb_and(1'b0),
      .sys_adin({DATA_WIDTH{1'b0}}), // write data in
      .bistw_adout(bistw_adout), // data out
      .bistw_apout(bistw_apout), // parity out
      .sys_adout(adout),
      .bistw_adin(), // write data port a
      .bistw_apin(), // write parity port a
      .ecc_aerr(ecc_aerr),
      .ecc_aerr_int(ecc_aerr_int),
	  
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(1'b0),
      .bwemb_and(1'b0),
      .sys_bdin({DATA_WIDTH{1'b0}}), // write data in
      .bistw_bdout(bistw_bdout),
      .bistw_bpout(bistw_bpout),
      .sys_bdout(bdout),
      .bistw_bdin(), // write data port b
      .bistw_bpin(), // write parity port b
      .ecc_berr(ecc_berr),
      .ecc_berr_int(ecc_berr_int),
	  
      .crstb(crstb),                                           
      .cclk(cclk),                                             
      .caddr(caddr),                                           
      .cceb(cceb),                                             
      .cweb(1'b0),                                             
      .cwemb_and(1'b0),                                        
      .sys_cdin({DATA_WIDTH{1'b0}}), // write data in          
      .bistw_cdout(bistw_cdout),                               
      .bistw_cpout(bistw_cpout),                               
      .sys_cdout(cdout),                                       
      .bistw_cdin(), // write data port c                      
      .bistw_cpin(), // write parity port c                    
      .ecc_cerr(ecc_cerr),
      .ecc_cerr_int(ecc_cerr_int)
    );
    
    miv_rv32_bistdual_eccw
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH),
      .PARITY_WIDTH(PARITY_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    ecc_enc_inst
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
	  
      .ram_init_busy_b(ram_init_busy_b),
	  
      .ram_init_busy_c(ram_init_busy_c),    
	  
      .ecc_bypass(ecc_bypass),
      .ram_err_inject(ram_err_inject),
	  
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(waddr),
      .aceb(aceb),
      .aweb(wen),
      .awemb_and(awemb_and),
      .sys_adin(wdin),
      .bistw_adout({DATA_WIDTH{1'b0}}),
      .bistw_apout({PARITY_WIDTH{1'b0}}),
      .sys_adout(),
      .bistw_adin(bistw_adin),
      .bistw_apin(bistw_apin),
      .ecc_aerr(),
      .ecc_aerr_int(),
	  
      .brstb(1'b0),
      .bclk(1'b0),
      .baddr({ADDR_WIDTH{1'b0}}),
      .bceb(1'b0),
      .bweb(1'b0),
      .bwemb_and(1'b0),
      .sys_bdin({DATA_WIDTH{1'b0}}),
      .bistw_bdout({DATA_WIDTH{1'b0}}),
      .bistw_bpout({PARITY_WIDTH{1'b0}}),
      .sys_bdout(),
      .bistw_bdin(),
      .bistw_bpin(),
      .ecc_berr(),
      .ecc_berr_int(),
	  
      .crstb(1'b0),                                  
      .cclk(1'b0),                                
      .caddr({ADDR_WIDTH{1'b0}}),                 
      .cceb(1'b0),                                
      .cweb(1'b0),                                
      .cwemb_and(1'b0),                           
      .sys_cdin(0),                               
      .bistw_cdout({DATA_WIDTH{1'b0}}),           
      .bistw_cpout({PARITY_WIDTH{1'b0}}),         
      .sys_cdout(),                               
      .bistw_cdin(),                              
      .bistw_cpin(),                              
      .ecc_cerr(),                                
      .ecc_cerr_int()
    );

  
    miv_rv32_gpr_ram_array
  //******************************************************************
  // Parameter description
  #(
    .mem_depth                     (RAM_DEPTH),
    .addr_width_gpr                (ADDR_WIDTH),
    .d_width                       (BISTW_WIDTH)
   )
  u_gpr_0
  //******************************************************************
  // Signal description
  (
        // Inputs
        .clk           ( aclk ),
        .raddr0        ( ram_aaddr ),
        .raddr1        ( ram_baddr ),
        .raddr2        ( ram_caddr ),
        .waddr0        ( ram_waddr ),
        .we0           ( ram_web ),
        .data0         ( ram_wdin ),
        // Outputs
        .q0          ( ram_adout ),
        .q1          ( ram_bdout ),
        .q2          ( ram_cdout )
        );



 // BIST wrapper
  miv_rv32_gpr_ecc_bist_template
    #(
      .RAM_DEPTH(RAM_DEPTH),
      .DATA_WIDTH(BISTW_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_STABILIZER(RAM_STABILIZER),
      .BWE_RAM(BWE_RAM),
      .RTL_MUX(RTL_MUX),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    dual_inst_dec
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(1'b0),
      .awemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}), 
      .adin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .adout(bistw_adout_all),
      .ram_aaddr(ram_aaddr),
      .ram_aceb(ram_aceb),
      .ram_aweb(),
      .ram_awemb(),
      .ram_adin(),
      .ram_adout(ram_adout),
	  
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(1'b0),
      .bwemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdout(bistw_bdout_all),
      .ram_baddr(ram_baddr),
      .ram_bceb(ram_bceb),
      .ram_bweb(),
      .ram_bwemb(),
      .ram_bdin(),
      .ram_bdout(ram_bdout),
	  
	  
      .crstb(crstb),                                   
      .cclk(cclk),                                     
      .caddr(caddr),                                   
      .cceb(cceb),                                     
      .cweb(1'b0),                                     
      .cwemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),     
      .cdin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),      
      .cdout(bistw_cdout_all),                         
      .ram_caddr(ram_caddr),                           
      .ram_cceb(ram_cceb),                             
      .ram_cweb(),                                     
      .ram_cwemb(),                                    
      .ram_cdin(),                                     
      .ram_cdout(ram_cdout),                           
	  
      .pg_clk(pg_clk),
      .pg_rstb(pg_rstb),
      .pg_override(pg_override),
      .lp1(lp1),
      .lp2(lp2),
      .lp3(lp3),
      .low_power(low_power),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
	  
      .ram_init_busy_b(ram_init_busy_b),
	  
      .ram_init_busy_c(ram_init_busy_c)               
    );
    
     // BIST wrapper
  miv_rv32_gpr_ecc_bist_template
    #(
      .RAM_DEPTH(RAM_DEPTH),
      .DATA_WIDTH(BISTW_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_STABILIZER(RAM_STABILIZER),
      .BWE_RAM(BWE_RAM),
      .RTL_MUX(RTL_MUX),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    dual_inst_enc
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(waddr),
      .aceb(aceb),
      .aweb(wen),
      .awemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .adin(bistw_adin_all),
      .adout(),
      .ram_aaddr(ram_waddr),
      .ram_aceb(),
      .ram_aweb(ram_web),
      .ram_awemb(),
      .ram_adin(ram_wdin),
      .ram_adout(),
	  
      .brstb(1'b0),
      .bclk(1'b0),
      .baddr({ADDR_WIDTH{1'b0}}),
      .bceb(1'b0),
      .bweb(1'b0),
      .bwemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdout(),
      .ram_baddr(),
      .ram_bceb(),
      .ram_bweb(),
      .ram_bwemb(),
      .ram_bdin(),
      .ram_bdout({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
	  
      .crstb(1'b0),                                       
      .cclk(1'b0),                                        
      .caddr({ADDR_WIDTH{1'b0}}),                         
      .cceb(1'b0),                                        
      .cweb(1'b0),                                        
      .cwemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),        
      .cdin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),         
      .cdout(),                                           
      .ram_caddr(),                                       
      .ram_cceb(),                                        
      .ram_cweb(),                                        
      .ram_cwemb(),                                       
      .ram_cdin(),                                        
      .ram_cdout({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),    
	  
      .pg_clk(pg_clk),
      .pg_rstb(pg_rstb),
      .pg_override(pg_override),
      .lp1(lp1),
      .lp2(lp2),
      .lp3(lp3),
      .low_power(),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(),
	  
      .ram_init_busy_b(),
	  
      .ram_init_busy_c()                                  
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// 1) This module defines the behavioural model of the PMC logic mux.
//    It can be used only for RTL simulation and formal verification.
//    It is a hard macro, so during synthesis this block is not going to be
//    synthesized.
//    The schematic is as follows:
//    
//                    +-----+
//              a >---|0    |
//                    | Mux |----->y     
//              b >---|1    |
//                    +--+--+
//                       |
//                 s0 >--+
//
// 2) output_delay_ps is declared at instantiation in ps.  This value is then
//    converted to ns to comply with the local timescale directive.
//
//
// PARAMETER DESCRIPTION:
//
// output_delay_ps          delay of the input to output signals, 
//                          expressed in ps
//
//
// INPUT PORT DESCRIPTION:
//
// a                    data input
// b                    data input
// s0                   select signal (selects a when 0)
//
//
// OUTPUT PORT DESCRIPTION:
//
// y                   mux output
//
//
// NOTES:
// 
// 1. If this file is changed in any way by the user, the module name must be
//    changed to prevent simulation mismatches with other designs at device
//    integration.
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_logic_mux_behav_v2
  #(
    parameter output_delay_ps = 0 // changed to lowercase as per CAD_PREP 97943
                                  // must remain lowercase to support legacy RTL
                                  // and match case in /home/liblib files
  )
  (
    input  wire logic a,
    input  wire logic b,
    input  wire logic s0,
    
    output wire  y  //changed to wire as per CAD_PREP 96834
  );
  
  // Following dc_script_begin dc_script_end pragmas are used to prevent DC
  // from reading this model
  // synopsys dc_script_begin
  // echo "Error: You cannot read miv_rv32_logic_mux_behav_v2 into dc_shell"
  // exit
  // synopsys dc_script_end
  
  // FUNCTIONS
  function automatic logic muxoutput
  (
    input  logic a_input,
    input  logic b_input,
    input  logic s0_select
  );
    unique case ( s0_select )
      1'b0    : muxoutput = a_input; // a select
      1'b1    : muxoutput = b_input; // b select
      default : muxoutput = 1'bX;
    endcase 
  endfunction : muxoutput
  
  assign y = muxoutput(a, b, s0);
  
endmodule : miv_rv32_logic_mux_behav_v2

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_top.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

import miv_rv32_pkg::*;
module miv_rv32_fpnew_top #(
  // FPU configuration
  parameter miv_rv32_pkg::fpu_features_t  Features  = miv_rv32_pkg::RV32F,
  parameter                                 NO_MACC_BLK   = 0,
  parameter type                            TagType       = logic,
  // Do not change
  localparam int unsigned WIDTH        = Features.Width,
  localparam int unsigned NUM_OPERANDS = 3
) (
  input logic                               clk_i,
  input logic                               rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][WIDTH-1:0] operands_i,
  input miv_rv32_pkg::roundmode_e              rnd_mode_i,
  input miv_rv32_pkg::operation_e              op_i,
  input logic                               op_mod_i,
  input miv_rv32_pkg::fp_format_e              src_fmt_i,
  input miv_rv32_pkg::fp_format_e              dst_fmt_i,
  input miv_rv32_pkg::int_format_e             int_fmt_i,
  input logic                               vectorial_op_i,
  input TagType                             tag_i,
  // Input Handshake
  input  logic                              in_valid_i,
  output logic                              in_ready_o,
  input  logic                              flush_i,
  // Output signals
  output logic [WIDTH-1:0]                  result_o,
  output miv_rv32_pkg::status_t                status_o,
  output TagType                            tag_o,
  // Output handshake
  output logic                              out_valid_o,
  input  logic                              out_ready_i,
  // Indication of valid data in flight
  output logic                              busy_o
);
  localparam int unsigned NUM_OPGROUPS = miv_rv32_pkg::NUM_OPGROUPS;
  localparam int unsigned NUM_FORMATS  = miv_rv32_pkg::NUM_FP_FORMATS;
  localparam fpu_implementation_t Implementation = '{
    PipeRegs:   '{default: 1}, 
    UnitTypes:  '{'{default: PARALLEL}, // ADDMUL
                  '{default: MERGED},   // DIVSQRT
                  '{default: PARALLEL}, // NONCOMP
                  '{default: MERGED},   // CONV
                  '{default: MERGED}},  // DOTP
    PipeConfig: INSIDE
  };
  // ----------------
  // Type Definition
  // ----------------
  typedef struct packed {
    logic [WIDTH-1:0]   result;
    miv_rv32_pkg::status_t status;
    TagType             tag;
  } output_t;

  // Handshake signals for the blocks
  logic [NUM_OPGROUPS-1:0] opgrp_in_ready, opgrp_out_valid, opgrp_out_ready, opgrp_ext, opgrp_busy;
  output_t [NUM_OPGROUPS-1:0] opgrp_outputs;

  logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o = in_valid_i & opgrp_in_ready[miv_rv32_pkg::get_opgroup(op_i)];

  // NaN-boxing check
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_nanbox_check
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    // NaN boxing is only generated if it's enabled and needed
    if (Features.EnableNanBox && (FP_WIDTH < WIDTH)) begin : check
      for (genvar op = 0; op < int'(NUM_OPERANDS); op++) begin : operands
        assign is_boxed[fmt][op] = (!vectorial_op_i)
                                   ? operands_i[op][WIDTH-1:FP_WIDTH] == '1
                                   : 1'b1;
      end
    end else begin : no_check
      assign is_boxed[fmt] = '1;
    end
  end

  // -------------------------
  // Generate Operation Blocks
  // -------------------------
  for (genvar opgrp = 0; opgrp < int'(NUM_OPGROUPS); opgrp++) begin : gen_operation_groups
    localparam int unsigned NUM_OPS = miv_rv32_pkg::num_operands(miv_rv32_pkg::opgroup_e'(opgrp));

    logic in_valid;
    logic [NUM_FORMATS-1:0][NUM_OPS-1:0] input_boxed;

    assign in_valid = in_valid_i & (miv_rv32_pkg::get_opgroup(op_i) == miv_rv32_pkg::opgroup_e'(opgrp));

    // slice out input boxing
    always_comb begin : slice_inputs
      for (int unsigned fmt = 0; fmt < NUM_FORMATS; fmt++)
        input_boxed[fmt] = is_boxed[fmt][NUM_OPS-1:0];
    end

    miv_rv32_fpnew_opgroup_block #(
      .OpGroup       ( miv_rv32_pkg::opgroup_e'(opgrp)    ),
      .Width         ( WIDTH                           ),
      .EnableVectors ( Features.EnableVectors          ),
      .FpFmtMask     ( Features.FpFmtMask              ),
      .IntFmtMask    ( Features.IntFmtMask             ),
      .FmtPipeRegs   ( Implementation.PipeRegs[opgrp]  ),
      .FmtUnitTypes  ( Implementation.UnitTypes[opgrp] ),
      .PipeConfig    ( Implementation.PipeConfig       ),
      .TagType       ( TagType                         ),
	  .NO_MACC_BLK   (NO_MACC_BLK                      )
    ) i_opgroup_block (
      .clk_i,
      .rst_ni,
      .operands_i      ( operands_i[NUM_OPS-1:0] ),
      .is_boxed_i      ( input_boxed             ),
      .rnd_mode_i,
      .op_i,
      .op_mod_i,
      .src_fmt_i,
      .dst_fmt_i,
      .int_fmt_i,
      .vectorial_op_i,
      .tag_i,
      .in_valid_i      ( in_valid              ),
      .in_ready_o      ( opgrp_in_ready[opgrp] ),
      .flush_i,
      .result_o        ( opgrp_outputs[opgrp].result ),
      .status_o        ( opgrp_outputs[opgrp].status ),
      .extension_bit_o ( opgrp_ext[opgrp]            ),
      .tag_o           ( opgrp_outputs[opgrp].tag    ),
      .out_valid_o     ( opgrp_out_valid[opgrp]      ),
      .out_ready_i     ( opgrp_out_ready[opgrp]      ),
      .busy_o          ( opgrp_busy[opgrp]           )
    );
  end

  // ------------------
  // Arbitrate Outputs
  // ------------------
  output_t arbiter_output;

  // Round-Robin arbiter to decide which result to use
  miv_rv32_rr_arb_tree #(
    .NumIn     ( NUM_OPGROUPS ),
    .DataType  ( output_t     ),
    .AxiVldRdy ( 1'b1         )
  ) i_arbiter (
    .clk_i,
    .rst_ni,
    .flush_i,
    .rr_i   ( '0             ),
    .req_i  ( opgrp_out_valid ),
    .gnt_o  ( opgrp_out_ready ),
    .data_i ( opgrp_outputs   ),
    .gnt_i  ( out_ready_i     ),
    .req_o  ( out_valid_o     ),
    .data_o ( arbiter_output  ),
    .idx_o  ( /* unused */    )
  );
 
  // Unpack output
  assign result_o        = arbiter_output.result;
  assign status_o        = arbiter_output.status;
  assign tag_o           = arbiter_output.tag;

  assign busy_o = (| opgrp_busy);

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_control_mvp.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

////////////////////////////////////////////////////////////////////////////////
// Company:        IIS @ ETHZ - Federal Institute of Technology               //
//                                                                            //
// Engineers:      Lei Li                    lile@iis.ee.ethz.ch              //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    04/03/2018                                                 //
// Design Name:    FPU                                                        //
// Module Name:    miv_rv32_control_mvp.sv                                             //
// Project Name:   Private FPU                                                //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:    the control logic  of div and sqrt                         //
//                                                                            //
// Revision Date:  12/04/2018                                                 //
//                 Lei Li                                                     //
//                 To address some requirements by Stefan and add low power   //
//                 control for special cases                                  //
// Revision Date:  13/04/2018                                                 //
//                 Lei Li                                                     //
//                 To fix some bug found in Control FSM                       //
//                 when Iteration_unit_num_S  = 2'b10                         //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_control_mvp import miv_rv32_pkg::*;

  (//Input
   input logic                                        Clk_CI,
   input logic                                        Rst_RBI,
   input logic                                        Div_start_SI ,
   input logic                                        Sqrt_start_SI,
   input logic                                        Start_SI,
   input logic                                        Kill_SI,
   input logic                                        Special_case_SBI,
   input logic                                        Special_case_dly_SBI,
   input logic [C_PC-1:0]                             Precision_ctl_SI,
   input logic [1:0]                                  Format_sel_SI,
   input logic [C_MANT_FP64:0]                        Numerator_DI,
   input logic [C_EXP_FP64:0]                         Exp_num_DI,
   input logic [C_MANT_FP64:0]                        Denominator_DI,
   input logic [C_EXP_FP64:0]                         Exp_den_DI,


   output logic                                       Div_start_dly_SO ,
   output logic                                       Sqrt_start_dly_SO,
   output logic                                       Div_enable_SO,
   output logic                                       Sqrt_enable_SO,


   //To next stage
   output logic                                       Full_precision_SO,
   output logic                                       FP32_SO,
   output logic                                       FP64_SO,
   output logic                                       FP16_SO,
   output logic                                       FP16ALT_SO,

   output logic                                       Ready_SO,
   output logic                                       Done_SO,

   output logic [C_MANT_FP64+4:0]                     Mant_result_prenorm_DO,
 //  output logic [3:0]                                 Round_bit_DO,
   output logic [C_EXP_FP64+1:0]                      Exp_result_prenorm_DO
 );

   logic  [C_MANT_FP64+1+4:0]                         Partial_remainder_DN,Partial_remainder_DP; //58bits,r=q+2
   logic  [C_MANT_FP64+4:0]                           Quotient_DP; //57bits
   /////////////////////////////////////////////////////////////////////////////
   // Assign Inputs                                                          //
   /////////////////////////////////////////////////////////////////////////////
   logic [C_MANT_FP64+1:0]                            Numerator_se_D;  //sign extension and hidden bit
   logic [C_MANT_FP64+1:0]                            Denominator_se_D; //signa extension and hidden bit
   logic [C_MANT_FP64+1:0]                            Denominator_se_DB;  //1's complement

   assign  Numerator_se_D={1'b0,Numerator_DI};

   assign  Denominator_se_D={1'b0,Denominator_DI};

  always_comb
   begin
     if(FP32_SO)
       begin
         Denominator_se_DB={~Denominator_se_D[C_MANT_FP64+1:C_MANT_FP64-C_MANT_FP32], {(C_MANT_FP64-C_MANT_FP32){1'b0}} };
       end
     else if(FP64_SO) begin
         Denominator_se_DB=~Denominator_se_D;
     end
     else if(FP16_SO) begin
         Denominator_se_DB={~Denominator_se_D[C_MANT_FP64+1:C_MANT_FP64-C_MANT_FP16], {(C_MANT_FP64-C_MANT_FP16){1'b0}} };
     end
     else begin
         Denominator_se_DB={~Denominator_se_D[C_MANT_FP64+1:C_MANT_FP64-C_MANT_FP16ALT], {(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} };
     end
   end


   logic [C_MANT_FP64+1:0]                            Mant_D_sqrt_Norm;

   assign Mant_D_sqrt_Norm=Exp_num_DI[0]?{1'b0,Numerator_DI}:{Numerator_DI,1'b0}; //for sqrt

   /////////////////////////////////////////////////////////////////////////////
   // Format Selection                                                       //
   /////////////////////////////////////////////////////////////////////////////
   logic [1:0]                                      Format_sel_S;

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Format_sel_S<='b0;
          end
        else if(Start_SI&&Ready_SO)
          begin
            Format_sel_S<=Format_sel_SI;
          end
        else
          begin
            Format_sel_S<=Format_sel_S;
          end
    end

   assign FP32_SO = (Format_sel_S==2'b00);
   assign FP64_SO = (Format_sel_S==2'b01);
   assign FP16_SO = (Format_sel_S==2'b10);
   assign FP16ALT_SO = (Format_sel_S==2'b11);



   /////////////////////////////////////////////////////////////////////////////
   // Precision Control                                                       //
   /////////////////////////////////////////////////////////////////////////////

   logic [C_PC-1:0]                                   Precision_ctl_S;
   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Precision_ctl_S<='b0;
          end
        else if(Start_SI&&Ready_SO)
          begin
            Precision_ctl_S<=Precision_ctl_SI;
          end
        else
          begin
            Precision_ctl_S<=Precision_ctl_S;
          end
    end
  assign Full_precision_SO = (Precision_ctl_S==6'h00);



     logic [5:0]                                     State_ctl_S;
     logic [5:0]                                     State_Two_iteration_unit_S;
     logic [5:0]                                     State_Four_iteration_unit_S;

    assign State_Two_iteration_unit_S = Precision_ctl_S[C_PC-1:1];  //Two iteration units
    assign State_Four_iteration_unit_S = Precision_ctl_S[C_PC-1:2];  //Four iteration units
     always_comb
       begin
         case(Iteration_unit_num_S)
//////////////////////one iteration unit, start///////////////////////////////////////
           2'b00:  //one iteration unit
             begin
               case(Format_sel_S)
                 2'b00: //FP32
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h1b;  //24+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = Precision_ctl_S;
                       end
                   end
                 2'b01: //FP64
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h38;  //53+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = Precision_ctl_S;
                       end
                   end
                 2'b10: //FP16
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h0e;  //11+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = Precision_ctl_S;
                       end
                   end
                 2'b11: //FP16ALT
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h0b;  //8+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = Precision_ctl_S;
                       end
                  end
                endcase
              end
//////////////////////one iteration unit, end///////////////////////////////////////

//////////////////////two iteration units, start///////////////////////////////////////
           2'b01:  //two iteration units
             begin
               case(Format_sel_S)
                 2'b00: //FP32
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h0d;  //24+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Two_iteration_unit_S;
                       end
                   end
                 2'b01: //FP64
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h1b;  //53+3 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Two_iteration_unit_S;
                       end
                   end
                 2'b10: //FP16
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h06;  //11+3 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Two_iteration_unit_S;
                       end
                   end
                 2'b11: //FP16ALT
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h05;  //8+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Two_iteration_unit_S;
                       end
                  end
                endcase
              end
//////////////////////two iteration units, end///////////////////////////////////////

//////////////////////three iteration units, start///////////////////////////////////////
           2'b10:  //three iteration units
             begin
               case(Format_sel_S)
                 2'b00: //FP32
                   begin
                     case(Precision_ctl_S)
                       6'h00:
                         begin
                           State_ctl_S = 6'h08;  //24+3 more iterations for rounding bits
                         end
                       6'h06,6'h07,6'h08:
                         begin
                           State_ctl_S = 6'h02;
                         end
                       6'h09,6'h0a,6'h0b:
                         begin
                           State_ctl_S = 6'h03;
                         end
                       6'h0c,6'h0d,6'h0e:
                         begin
                           State_ctl_S = 6'h04;
                         end
                       6'h0f,6'h10,6'h11:
                         begin
                           State_ctl_S = 6'h05;
                         end
                       6'h12,6'h13,6'h14:
                         begin
                           State_ctl_S = 6'h06;
                         end
                       6'h15,6'h16,6'h17:
                         begin
                           State_ctl_S = 6'h07;
                         end
                       default:
                         begin
                           State_ctl_S = 6'h08;  //24+3 more iterations for rounding bits
                         end
                     endcase
                   end
                 2'b01: //FP64
                   begin
                     case(Precision_ctl_S)
                       6'h00:
                         begin
                           State_ctl_S = 6'h12;  //53+4 more iterations for rounding bits
                         end
                       6'h06,6'h07,6'h08:
                         begin
                           State_ctl_S = 6'h02;
                         end
                       6'h09,6'h0a,6'h0b:
                         begin
                           State_ctl_S = 6'h03;
                         end
                       6'h0c,6'h0d,6'h0e:
                         begin
                           State_ctl_S = 6'h04;
                         end
                       6'h0f,6'h10,6'h11:
                         begin
                           State_ctl_S = 6'h05;
                         end
                       6'h12,6'h13,6'h14:
                         begin
                           State_ctl_S = 6'h06;
                         end
                       6'h15,6'h16,6'h17:
                         begin
                           State_ctl_S = 6'h07;
                         end
                       6'h18,6'h19,6'h1a:
                         begin
                           State_ctl_S = 6'h08;
                         end
                       6'h1b,6'h1c,6'h1d:
                         begin
                           State_ctl_S = 6'h09;
                         end
                       6'h1e,6'h1f,6'h20:
                         begin
                           State_ctl_S = 6'h0a;
                         end
                       6'h21,6'h22,6'h23:
                         begin
                           State_ctl_S = 6'h0b;
                         end
                       6'h24,6'h25,6'h26:
                         begin
                           State_ctl_S = 6'h0c;
                         end
                       6'h27,6'h28,6'h29:
                         begin
                           State_ctl_S = 6'h0d;
                         end
                       6'h2a,6'h2b,6'h2c:
                         begin
                           State_ctl_S = 6'h0e;
                         end
                       6'h2d,6'h2e,6'h2f:
                         begin
                           State_ctl_S = 6'h0f;
                         end
                       6'h30,6'h31,6'h32:
                         begin
                           State_ctl_S = 6'h10;
                         end
                       6'h33,6'h34,6'h35:
                         begin
                           State_ctl_S = 6'h11;
                         end
                       default:
                         begin
                           State_ctl_S = 6'h12;  //53+4 more iterations for rounding bits
                         end
                     endcase
                   end
                 2'b10: //FP16
                   begin
                     case(Precision_ctl_S)
                       6'h00:
                         begin
                           State_ctl_S = 6'h04;  //12+3 more iterations for rounding bits
                         end
                       6'h06,6'h07,6'h08:
                         begin
                           State_ctl_S = 6'h02;
                         end
                       6'h09,6'h0a,6'h0b:
                         begin
                           State_ctl_S = 6'h03;
                         end
                       default:
                         begin
                           State_ctl_S = 6'h04;  //12+3 more iterations for rounding bits
                         end
                     endcase
                   end
                 2'b11: //FP16ALT
                   begin
                     case(Precision_ctl_S)
                       6'h00:
                         begin
                           State_ctl_S = 6'h03;  //8+4 more iterations for rounding bits
                         end
                       6'h06,6'h07,6'h08:
                         begin
                           State_ctl_S = 6'h02;
                         end
                       default:
                         begin
                           State_ctl_S = 6'h03;  //8+4 more iterations for rounding bits
                         end
                     endcase
                  end
                endcase
              end
//////////////////////three iteration units, end///////////////////////////////////////

//////////////////////four iteration units, start///////////////////////////////////////
           2'b11:  //four iteration units
             begin
               case(Format_sel_S)
                 2'b00: //FP32
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h06;  //24+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Four_iteration_unit_S;
                       end
                   end
                 2'b01: //FP64
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h0d;  //53+3 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Four_iteration_unit_S;
                       end
                   end
                 2'b10: //FP16
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h03;  //11+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Four_iteration_unit_S;
                       end
                   end
                 2'b11: //FP16ALT
                   begin
                     if(Full_precision_SO)
                       begin
                         State_ctl_S = 6'h02;  //8+4 more iterations for rounding bits
                       end
                     else
                       begin
                         State_ctl_S = State_Four_iteration_unit_S;
                       end
                  end
                endcase
              end
//////////////////////four iteration units, end///////////////////////////////////////

           endcase
        end


   /////////////////////////////////////////////////////////////////////////////
   // control logic                                                           //
   /////////////////////////////////////////////////////////////////////////////

   logic                                               Div_start_dly_S;

   always_ff @(posedge Clk_CI, negedge Rst_RBI)   //  generate Div_start_dly_S signal
     begin
        if(~Rst_RBI)
          begin
            Div_start_dly_S<=1'b0;
          end
        else if(Div_start_SI&&Ready_SO)
         begin
           Div_start_dly_S<=1'b1;
         end
        else
          begin
            Div_start_dly_S<=1'b0;
          end
    end

   assign Div_start_dly_SO=Div_start_dly_S;

  always_ff @(posedge Clk_CI, negedge Rst_RBI) begin  //  generate Div_enable_SO signal
    if(~Rst_RBI)
      Div_enable_SO<=1'b0;
    // Synchronous reset with Flush
    else if (Kill_SI)
      Div_enable_SO <= 1'b0;
    else if(Div_start_SI&&Ready_SO)
      Div_enable_SO<=1'b1;
    else if(Done_SO)
      Div_enable_SO<=1'b0;
    else
      Div_enable_SO<=Div_enable_SO;
  end

   logic                                                Sqrt_start_dly_S;

   always_ff @(posedge Clk_CI, negedge Rst_RBI)   //  generate Sqrt_start_dly_SI signal
     begin
        if(~Rst_RBI)
          begin
            Sqrt_start_dly_S<=1'b0;
          end
        else if(Sqrt_start_SI&&Ready_SO)
         begin
           Sqrt_start_dly_S<=1'b1;
         end
        else
          begin
            Sqrt_start_dly_S<=1'b0;
          end
      end
    assign Sqrt_start_dly_SO=Sqrt_start_dly_S;

   always_ff @(posedge Clk_CI, negedge Rst_RBI) begin   //  generate Sqrt_enable_SO signal
    if(~Rst_RBI)
      Sqrt_enable_SO<=1'b0;
    else if (Kill_SI)
      Sqrt_enable_SO <= 1'b0;
    else if(Sqrt_start_SI&&Ready_SO)
      Sqrt_enable_SO<=1'b1;
    else if(Done_SO)
      Sqrt_enable_SO<=1'b0;
    else
      Sqrt_enable_SO<=Sqrt_enable_SO;
  end

   logic [5:0]                                                  Crtl_cnt_S;
   logic                                                        Start_dly_S;

   assign   Start_dly_S=Div_start_dly_S |Sqrt_start_dly_S;

   logic       Fsm_enable_S;
   assign      Fsm_enable_S=( (Start_dly_S | (| Crtl_cnt_S)) && (~Kill_SI) && Special_case_dly_SBI);

   logic                                                        Final_state_S;
   assign     Final_state_S= (Crtl_cnt_S==State_ctl_S);


   always_ff @(posedge Clk_CI, negedge Rst_RBI) //control_FSM
     begin
        if (~Rst_RBI)
          begin
             Crtl_cnt_S    <= '0;
          end
          else if (Final_state_S | Kill_SI)
            begin
              Crtl_cnt_S    <= '0;
            end
          else if(Fsm_enable_S) // one cycle Start_SI
            begin
              Crtl_cnt_S    <= Crtl_cnt_S+1;
            end
          else
            begin
              Crtl_cnt_S    <= '0;
            end
     end // always_ff



    always_ff @(posedge Clk_CI, negedge Rst_RBI) //Generate  Done_SO,  they can share this Done_SO.
      begin
        if(~Rst_RBI)
          begin
            Done_SO<=1'b0;
          end
        else if(Start_SI&&Ready_SO)
          begin
            if(~Special_case_SBI)
              begin
                Done_SO<=1'b1;
              end
            else
              begin
                Done_SO<=1'b0;
              end
          end
        else if(Final_state_S)
          begin
            Done_SO<=1'b1;
          end
        else
          begin
            Done_SO<=1'b0;
          end
       end




   always_ff @(posedge Clk_CI, negedge Rst_RBI) //Generate  Ready_SO
     begin
       if(~Rst_RBI)
         begin
           Ready_SO<=1'b1;
         end

       else if(Start_SI&&Ready_SO)
         begin
            if(~Special_case_SBI)
              begin
                Ready_SO<=1'b1;
              end
            else
              begin
                Ready_SO<=1'b0;
              end
         end
       else if(Final_state_S | Kill_SI)
         begin
           Ready_SO<=1'b1;
         end
       else
         begin
           Ready_SO<=Ready_SO;
         end
     end


  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b00, start  //
   ////////////////////////////////////////////////////////////////////////////

  logic                                    Qcnt_one_0;
  logic                                    Qcnt_one_1;
  logic [1:0]                              Qcnt_one_2;
  logic [2:0]                              Qcnt_one_3;
  logic [3:0]                              Qcnt_one_4;
  logic [4:0]                              Qcnt_one_5;
  logic [5:0]                              Qcnt_one_6;
  logic [6:0]                              Qcnt_one_7;
  logic [7:0]                              Qcnt_one_8;
  logic [8:0]                              Qcnt_one_9;
  logic [9:0]                              Qcnt_one_10;
  logic [10:0]                             Qcnt_one_11;
  logic [11:0]                             Qcnt_one_12;
  logic [12:0]                             Qcnt_one_13;
  logic [13:0]                             Qcnt_one_14;
  logic [14:0]                             Qcnt_one_15;
  logic [15:0]                             Qcnt_one_16;
  logic [16:0]                             Qcnt_one_17;
  logic [17:0]                             Qcnt_one_18;
  logic [18:0]                             Qcnt_one_19;
  logic [19:0]                             Qcnt_one_20;
  logic [20:0]                             Qcnt_one_21;
  logic [21:0]                             Qcnt_one_22;
  logic [22:0]                             Qcnt_one_23;
  logic [23:0]                             Qcnt_one_24;
  logic [24:0]                             Qcnt_one_25;
  logic [25:0]                             Qcnt_one_26;
  logic [26:0]                             Qcnt_one_27;
  logic [27:0]                             Qcnt_one_28;
  logic [28:0]                             Qcnt_one_29;
  logic [29:0]                             Qcnt_one_30;
  logic [30:0]                             Qcnt_one_31;
  logic [31:0]                             Qcnt_one_32;
  logic [32:0]                             Qcnt_one_33;
  logic [33:0]                             Qcnt_one_34;
  logic [34:0]                             Qcnt_one_35;
  logic [35:0]                             Qcnt_one_36;
  logic [36:0]                             Qcnt_one_37;
  logic [37:0]                             Qcnt_one_38;
  logic [38:0]                             Qcnt_one_39;
  logic [39:0]                             Qcnt_one_40;
  logic [40:0]                             Qcnt_one_41;
  logic [41:0]                             Qcnt_one_42;
  logic [42:0]                             Qcnt_one_43;
  logic [43:0]                             Qcnt_one_44;
  logic [44:0]                             Qcnt_one_45;
  logic [45:0]                             Qcnt_one_46;
  logic [46:0]                             Qcnt_one_47;
  logic [47:0]                             Qcnt_one_48;
  logic [48:0]                             Qcnt_one_49;
  logic [49:0]                             Qcnt_one_50;
  logic [50:0]                             Qcnt_one_51;
  logic [51:0]                             Qcnt_one_52;
  logic [52:0]                             Qcnt_one_53;
  logic [53:0]                             Qcnt_one_54;
  logic [54:0]                             Qcnt_one_55;
  logic [55:0]                             Qcnt_one_56;
  logic [56:0]                             Qcnt_one_57;
  logic [57:0]                             Qcnt_one_58;
  logic [58:0]                             Qcnt_one_59;
  logic [59:0]                             Qcnt_one_60;

  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b00, end    //
   ////////////////////////////////////////////////////////////////////////////



  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b01, start  //
   ////////////////////////////////////////////////////////////////////////////
  logic [1:0]                              Qcnt_two_0;
  logic [2:0]                              Qcnt_two_1;
  logic [4:0]                              Qcnt_two_2;
  logic [6:0]                              Qcnt_two_3;
  logic [8:0]                              Qcnt_two_4;
  logic [10:0]                             Qcnt_two_5;
  logic [12:0]                             Qcnt_two_6;
  logic [14:0]                             Qcnt_two_7;
  logic [16:0]                             Qcnt_two_8;
  logic [18:0]                             Qcnt_two_9;
  logic [20:0]                             Qcnt_two_10;
  logic [22:0]                             Qcnt_two_11;
  logic [24:0]                             Qcnt_two_12;
  logic [26:0]                             Qcnt_two_13;
  logic [28:0]                             Qcnt_two_14;
  logic [30:0]                             Qcnt_two_15;
  logic [32:0]                             Qcnt_two_16;
  logic [34:0]                             Qcnt_two_17;
  logic [36:0]                             Qcnt_two_18;
  logic [38:0]                             Qcnt_two_19;
  logic [40:0]                             Qcnt_two_20;
  logic [42:0]                             Qcnt_two_21;
  logic [44:0]                             Qcnt_two_22;
  logic [46:0]                             Qcnt_two_23;
  logic [48:0]                             Qcnt_two_24;
  logic [50:0]                             Qcnt_two_25;
  logic [52:0]                             Qcnt_two_26;
  logic [54:0]                             Qcnt_two_27;
  logic [56:0]                             Qcnt_two_28;
  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b01, end    //
   ////////////////////////////////////////////////////////////////////////////


  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b10, start  //
   ////////////////////////////////////////////////////////////////////////////
  logic [2:0]                              Qcnt_three_0;
  logic [4:0]                              Qcnt_three_1;
  logic [7:0]                              Qcnt_three_2;
  logic [10:0]                             Qcnt_three_3;
  logic [13:0]                             Qcnt_three_4;
  logic [16:0]                             Qcnt_three_5;
  logic [19:0]                             Qcnt_three_6;
  logic [22:0]                             Qcnt_three_7;
  logic [25:0]                             Qcnt_three_8;
  logic [28:0]                             Qcnt_three_9;
  logic [31:0]                             Qcnt_three_10;
  logic [34:0]                             Qcnt_three_11;
  logic [37:0]                             Qcnt_three_12;
  logic [40:0]                             Qcnt_three_13;
  logic [43:0]                             Qcnt_three_14;
  logic [46:0]                             Qcnt_three_15;
  logic [49:0]                             Qcnt_three_16;
  logic [52:0]                             Qcnt_three_17;
  logic [55:0]                             Qcnt_three_18;
  logic [58:0]                             Qcnt_three_19;
  logic [61:0]                             Qcnt_three_20;
  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b10, end    //
   ////////////////////////////////////////////////////////////////////////////


  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b11, start  //
   ////////////////////////////////////////////////////////////////////////////
  logic [3:0]                              Qcnt_four_0;
  logic [6:0]                              Qcnt_four_1;
  logic [10:0]                             Qcnt_four_2;
  logic [14:0]                             Qcnt_four_3;
  logic [18:0]                             Qcnt_four_4;
  logic [22:0]                             Qcnt_four_5;
  logic [26:0]                             Qcnt_four_6;
  logic [30:0]                             Qcnt_four_7;
  logic [34:0]                             Qcnt_four_8;
  logic [38:0]                             Qcnt_four_9;
  logic [42:0]                             Qcnt_four_10;
  logic [46:0]                             Qcnt_four_11;
  logic [50:0]                             Qcnt_four_12;
  logic [54:0]                             Qcnt_four_13;
  logic [58:0]                             Qcnt_four_14;

  /////////////////////////////////////////////////////////////////////////////
   // Declarations for square root when Iteration_unit_num_S = 2'b11, end    //
   ////////////////////////////////////////////////////////////////////////////



   logic [C_MANT_FP64+1+4:0]                                      Sqrt_R0,Sqrt_Q0,Q_sqrt0,Q_sqrt_com_0;
   logic [C_MANT_FP64+1+4:0]                                      Sqrt_R1,Sqrt_Q1,Q_sqrt1,Q_sqrt_com_1;
   logic [C_MANT_FP64+1+4:0]                                      Sqrt_R2,Sqrt_Q2,Q_sqrt2,Q_sqrt_com_2;
   logic [C_MANT_FP64+1+4:0]                                      Sqrt_R3,Sqrt_Q3,Q_sqrt3,Q_sqrt_com_3,Sqrt_R4; //Sqrt_Q4;


   logic [1:0]                                                    Sqrt_DI  [3:0];
   logic [1:0]                                                    Sqrt_DO  [3:0];
   logic                                                          Sqrt_carry_DO;


  logic  [C_MANT_FP64+1+4:0]                                      Iteration_cell_a_D [3:0];
  logic  [C_MANT_FP64+1+4:0]                                      Iteration_cell_b_D [3:0];
  logic  [C_MANT_FP64+1+4:0]                                      Iteration_cell_a_BMASK_D [3:0];
  logic  [C_MANT_FP64+1+4:0]                                      Iteration_cell_b_BMASK_D [3:0];
  logic                                                           Iteration_cell_carry_D [3:0];
  logic  [C_MANT_FP64+1+4:0]                                      Iteration_cell_sum_D [3:0];
  logic  [C_MANT_FP64+1+4:0]                                      Iteration_cell_sum_AMASK_D [3:0];


  logic [3:0]                                                     Sqrt_quotinent_S;


   always_comb
    begin  //
      case (Format_sel_S)
        2'b00:
          begin
            Sqrt_quotinent_S = {(~Iteration_cell_sum_AMASK_D[0][C_MANT_FP32+5]),(~Iteration_cell_sum_AMASK_D[1][C_MANT_FP32+5]),(~Iteration_cell_sum_AMASK_D[2][C_MANT_FP32+5]),(~Iteration_cell_sum_AMASK_D[3][C_MANT_FP32+5])};
            Q_sqrt_com_0 ={ {(C_MANT_FP64-C_MANT_FP32){1'b0}},~Q_sqrt0[C_MANT_FP32+5:0] };
            Q_sqrt_com_1 ={ {(C_MANT_FP64-C_MANT_FP32){1'b0}},~Q_sqrt1[C_MANT_FP32+5:0] };
            Q_sqrt_com_2 ={ {(C_MANT_FP64-C_MANT_FP32){1'b0}},~Q_sqrt2[C_MANT_FP32+5:0] };
            Q_sqrt_com_3 ={ {(C_MANT_FP64-C_MANT_FP32){1'b0}},~Q_sqrt3[C_MANT_FP32+5:0] };
          end
        2'b01:
          begin
            Sqrt_quotinent_S = {Iteration_cell_carry_D[0],Iteration_cell_carry_D[1],Iteration_cell_carry_D[2],Iteration_cell_carry_D[3]};
            Q_sqrt_com_0=~Q_sqrt0;
            Q_sqrt_com_1=~Q_sqrt1;
            Q_sqrt_com_2=~Q_sqrt2;
            Q_sqrt_com_3=~Q_sqrt3;
          end
        2'b10:
          begin
            Sqrt_quotinent_S = {(~Iteration_cell_sum_AMASK_D[0][C_MANT_FP16+5]),(~Iteration_cell_sum_AMASK_D[1][C_MANT_FP16+5]),(~Iteration_cell_sum_AMASK_D[2][C_MANT_FP16+5]),(~Iteration_cell_sum_AMASK_D[3][C_MANT_FP16+5])};
            Q_sqrt_com_0 ={ {(C_MANT_FP64-C_MANT_FP16){1'b0}},~Q_sqrt0[C_MANT_FP16+5:0] };
            Q_sqrt_com_1 ={ {(C_MANT_FP64-C_MANT_FP16){1'b0}},~Q_sqrt1[C_MANT_FP16+5:0] };
            Q_sqrt_com_2 ={ {(C_MANT_FP64-C_MANT_FP16){1'b0}},~Q_sqrt2[C_MANT_FP16+5:0] };
            Q_sqrt_com_3 ={ {(C_MANT_FP64-C_MANT_FP16){1'b0}},~Q_sqrt3[C_MANT_FP16+5:0] };
          end
        2'b11:
          begin
            Sqrt_quotinent_S = {(~Iteration_cell_sum_AMASK_D[0][C_MANT_FP16ALT+5]),(~Iteration_cell_sum_AMASK_D[1][C_MANT_FP16ALT+5]),(~Iteration_cell_sum_AMASK_D[2][C_MANT_FP16ALT+5]),(~Iteration_cell_sum_AMASK_D[3][C_MANT_FP16ALT+5])};
            Q_sqrt_com_0 ={ {(C_MANT_FP64-C_MANT_FP16ALT){1'b0}},~Q_sqrt0[C_MANT_FP16ALT+5:0] };
            Q_sqrt_com_1 ={ {(C_MANT_FP64-C_MANT_FP16ALT){1'b0}},~Q_sqrt1[C_MANT_FP16ALT+5:0] };
            Q_sqrt_com_2 ={ {(C_MANT_FP64-C_MANT_FP16ALT){1'b0}},~Q_sqrt2[C_MANT_FP16ALT+5:0] };
            Q_sqrt_com_3 ={ {(C_MANT_FP64-C_MANT_FP16ALT){1'b0}},~Q_sqrt3[C_MANT_FP16ALT+5:0] };
          end
        endcase
    end



  assign  Qcnt_one_0=    {1'b0};  //qk for each feedback
  assign  Qcnt_one_1=    {Quotient_DP[0]};
  assign  Qcnt_one_2=    {Quotient_DP[1:0]};
  assign  Qcnt_one_3=    {Quotient_DP[2:0]};
  assign  Qcnt_one_4=    {Quotient_DP[3:0]};
  assign  Qcnt_one_5=    {Quotient_DP[4:0]};
  assign  Qcnt_one_6=    {Quotient_DP[5:0]};
  assign  Qcnt_one_7=    {Quotient_DP[6:0]};
  assign  Qcnt_one_8=    {Quotient_DP[7:0]};
  assign  Qcnt_one_9=    {Quotient_DP[8:0]};
  assign  Qcnt_one_10=    {Quotient_DP[9:0]};
  assign  Qcnt_one_11=    {Quotient_DP[10:0]};
  assign  Qcnt_one_12=    {Quotient_DP[11:0]};
  assign  Qcnt_one_13=    {Quotient_DP[12:0]};
  assign  Qcnt_one_14=    {Quotient_DP[13:0]};
  assign  Qcnt_one_15=    {Quotient_DP[14:0]};
  assign  Qcnt_one_16=    {Quotient_DP[15:0]};
  assign  Qcnt_one_17=    {Quotient_DP[16:0]};
  assign  Qcnt_one_18=    {Quotient_DP[17:0]};
  assign  Qcnt_one_19=    {Quotient_DP[18:0]};
  assign  Qcnt_one_20=    {Quotient_DP[19:0]};
  assign  Qcnt_one_21=    {Quotient_DP[20:0]};
  assign  Qcnt_one_22=    {Quotient_DP[21:0]};
  assign  Qcnt_one_23=    {Quotient_DP[22:0]};
  assign  Qcnt_one_24=    {Quotient_DP[23:0]};
  assign  Qcnt_one_25=    {Quotient_DP[24:0]};
  assign  Qcnt_one_26=    {Quotient_DP[25:0]};
  assign  Qcnt_one_27=    {Quotient_DP[26:0]};
  assign  Qcnt_one_28=    {Quotient_DP[27:0]};
  assign  Qcnt_one_29=    {Quotient_DP[28:0]};
  assign  Qcnt_one_30=    {Quotient_DP[29:0]};
  assign  Qcnt_one_31=    {Quotient_DP[30:0]};
  assign  Qcnt_one_32=    {Quotient_DP[31:0]};
  assign  Qcnt_one_33=    {Quotient_DP[32:0]};
  assign  Qcnt_one_34=    {Quotient_DP[33:0]};
  assign  Qcnt_one_35=    {Quotient_DP[34:0]};
  assign  Qcnt_one_36=    {Quotient_DP[35:0]};
  assign  Qcnt_one_37=    {Quotient_DP[36:0]};
  assign  Qcnt_one_38=    {Quotient_DP[37:0]};
  assign  Qcnt_one_39=    {Quotient_DP[38:0]};
  assign  Qcnt_one_40=    {Quotient_DP[39:0]};
  assign  Qcnt_one_41=    {Quotient_DP[40:0]};
  assign  Qcnt_one_42=    {Quotient_DP[41:0]};
  assign  Qcnt_one_43=    {Quotient_DP[42:0]};
  assign  Qcnt_one_44=    {Quotient_DP[43:0]};
  assign  Qcnt_one_45=    {Quotient_DP[44:0]};
  assign  Qcnt_one_46=    {Quotient_DP[45:0]};
  assign  Qcnt_one_47=    {Quotient_DP[46:0]};
  assign  Qcnt_one_48=    {Quotient_DP[47:0]};
  assign  Qcnt_one_49=    {Quotient_DP[48:0]};
  assign  Qcnt_one_50=    {Quotient_DP[49:0]};
  assign  Qcnt_one_51=    {Quotient_DP[50:0]};
  assign  Qcnt_one_52=    {Quotient_DP[51:0]};
  assign  Qcnt_one_53=    {Quotient_DP[52:0]};
  assign  Qcnt_one_54=    {Quotient_DP[53:0]};
  assign  Qcnt_one_55=    {Quotient_DP[54:0]};
  assign  Qcnt_one_56=    {Quotient_DP[55:0]};
  assign  Qcnt_one_57=    {Quotient_DP[56:0]};


  assign  Qcnt_two_0 =    {1'b0,            Sqrt_quotinent_S[3]};  //qk for each feedback
  assign  Qcnt_two_1 =    {Quotient_DP[1:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_2 =    {Quotient_DP[3:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_3 =    {Quotient_DP[5:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_4 =    {Quotient_DP[7:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_5 =    {Quotient_DP[9:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_6 =    {Quotient_DP[11:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_7 =    {Quotient_DP[13:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_8 =    {Quotient_DP[15:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_9 =    {Quotient_DP[17:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_10 =    {Quotient_DP[19:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_11 =    {Quotient_DP[21:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_12 =    {Quotient_DP[23:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_13 =    {Quotient_DP[25:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_14 =    {Quotient_DP[27:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_15 =    {Quotient_DP[29:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_16 =    {Quotient_DP[31:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_17 =    {Quotient_DP[33:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_18 =    {Quotient_DP[35:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_19 =    {Quotient_DP[37:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_20 =    {Quotient_DP[39:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_21 =    {Quotient_DP[41:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_22 =    {Quotient_DP[43:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_23 =    {Quotient_DP[45:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_24 =    {Quotient_DP[47:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_25 =    {Quotient_DP[49:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_26 =    {Quotient_DP[51:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_27 =    {Quotient_DP[53:0],Sqrt_quotinent_S[3]};
  assign  Qcnt_two_28 =    {Quotient_DP[55:0],Sqrt_quotinent_S[3]};


  assign  Qcnt_three_0 =    {1'b0,            Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};  //qk for each feedback
  assign  Qcnt_three_1 =    {Quotient_DP[2:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_2 =    {Quotient_DP[5:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_3 =    {Quotient_DP[8:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_4 =    {Quotient_DP[11:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_5 =    {Quotient_DP[14:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_6 =    {Quotient_DP[17:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_7 =    {Quotient_DP[20:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_8 =    {Quotient_DP[23:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_9 =    {Quotient_DP[26:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_10 =    {Quotient_DP[29:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_11 =    {Quotient_DP[32:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_12 =    {Quotient_DP[35:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_13 =    {Quotient_DP[38:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_14 =    {Quotient_DP[41:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_15 =    {Quotient_DP[44:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_16 =    {Quotient_DP[47:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_17 =    {Quotient_DP[50:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_18 =    {Quotient_DP[53:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};
  assign  Qcnt_three_19 =    {Quotient_DP[56:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2]};


  assign      Qcnt_four_0 =    {1'b0,            Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_1 =    {Quotient_DP[3:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_2 =    {Quotient_DP[7:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_3 =    {Quotient_DP[11:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_4 =    {Quotient_DP[15:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_5 =    {Quotient_DP[19:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_6 =    {Quotient_DP[23:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_7 =    {Quotient_DP[27:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_8 =    {Quotient_DP[31:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_9 =    {Quotient_DP[35:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_10 =    {Quotient_DP[39:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_11 =    {Quotient_DP[43:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_12 =    {Quotient_DP[47:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_13 =    {Quotient_DP[51:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};
  assign      Qcnt_four_14 =    {Quotient_DP[55:0],Sqrt_quotinent_S[3],Sqrt_quotinent_S[2],Sqrt_quotinent_S[1]};




  always_comb begin  // the intermediate operands for sqrt

  case(Iteration_unit_num_S)
    2'b00:
      begin

  /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b00, start       //
   /////////////////////////////////////////////////////////////////////////////




        case(Crtl_cnt_S)

          6'b000000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
              Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_one_0};
              Sqrt_Q0=Q_sqrt_com_0;
            end
          6'b000001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
              Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_one_1};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b000010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-3:C_MANT_FP64-4];
              Q_sqrt0={{(C_MANT_FP64+4){1'b0}},Qcnt_one_2};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b000011:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-5:C_MANT_FP64-6];
              Q_sqrt0={{(C_MANT_FP64+3){1'b0}},Qcnt_one_3};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b000100:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-7:C_MANT_FP64-8];
              Q_sqrt0={{(C_MANT_FP64+2){1'b0}},Qcnt_one_4};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b000101:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-9:C_MANT_FP64-10];
              Q_sqrt0={{(C_MANT_FP64+1){1'b0}},Qcnt_one_5};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b000110:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-11:C_MANT_FP64-12];
              Q_sqrt0={{(C_MANT_FP64){1'b0}},Qcnt_one_6};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b000111:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-13:C_MANT_FP64-14];
              Q_sqrt0={{(C_MANT_FP64-1){1'b0}},Qcnt_one_7};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-15:C_MANT_FP64-16];
              Q_sqrt0={{(C_MANT_FP64-2){1'b0}},Qcnt_one_8};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-17:C_MANT_FP64-18];
              Q_sqrt0={{(C_MANT_FP64-3){1'b0}},Qcnt_one_9};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-19:C_MANT_FP64-20];
              Q_sqrt0={{(C_MANT_FP64-4){1'b0}},Qcnt_one_10};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001011:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-21:C_MANT_FP64-22];
              Q_sqrt0={{(C_MANT_FP64-5){1'b0}},Qcnt_one_11};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001100:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-23:C_MANT_FP64-24];
              Q_sqrt0={{(C_MANT_FP64-6){1'b0}},Qcnt_one_12};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001101:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-25:C_MANT_FP64-26];
              Q_sqrt0={{(C_MANT_FP64-7){1'b0}},Qcnt_one_13};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001110:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-27:C_MANT_FP64-28];
              Q_sqrt0={{(C_MANT_FP64-8){1'b0}},Qcnt_one_14};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b001111:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-29:C_MANT_FP64-30];
              Q_sqrt0={{(C_MANT_FP64-9){1'b0}},Qcnt_one_15};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-31:C_MANT_FP64-32];
              Q_sqrt0={{(C_MANT_FP64-10){1'b0}},Qcnt_one_16};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-33:C_MANT_FP64-34];
              Q_sqrt0={{(C_MANT_FP64-11){1'b0}},Qcnt_one_17};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-35:C_MANT_FP64-36];
              Q_sqrt0={{(C_MANT_FP64-12){1'b0}},Qcnt_one_18};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010011:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-37:C_MANT_FP64-38];
              Q_sqrt0={{(C_MANT_FP64-13){1'b0}},Qcnt_one_19};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010100:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-39:C_MANT_FP64-40];
              Q_sqrt0={{(C_MANT_FP64-14){1'b0}},Qcnt_one_20};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010101:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-41:C_MANT_FP64-42];
              Q_sqrt0={{(C_MANT_FP64-15){1'b0}},Qcnt_one_21};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010110:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-43:C_MANT_FP64-44];
              Q_sqrt0={{(C_MANT_FP64-16){1'b0}},Qcnt_one_22};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b010111:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-45:C_MANT_FP64-46];
              Q_sqrt0={{(C_MANT_FP64-17){1'b0}},Qcnt_one_23};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-47:C_MANT_FP64-48];
              Q_sqrt0={{(C_MANT_FP64-18){1'b0}},Qcnt_one_24};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-49:C_MANT_FP64-50];
              Q_sqrt0={{(C_MANT_FP64-19){1'b0}},Qcnt_one_25};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-51:C_MANT_FP64-52];
              Q_sqrt0={{(C_MANT_FP64-20){1'b0}},Qcnt_one_26};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-21){1'b0}},Qcnt_one_27};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-22){1'b0}},Qcnt_one_28};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011101:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-23){1'b0}},Qcnt_one_29};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-24){1'b0}},Qcnt_one_30};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b011111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-25){1'b0}},Qcnt_one_31};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-26){1'b0}},Qcnt_one_32};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-27){1'b0}},Qcnt_one_33};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-28){1'b0}},Qcnt_one_34};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-29){1'b0}},Qcnt_one_35};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-30){1'b0}},Qcnt_one_36};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100101:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-31){1'b0}},Qcnt_one_37};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-32){1'b0}},Qcnt_one_38};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b100111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-33){1'b0}},Qcnt_one_39};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-34){1'b0}},Qcnt_one_40};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-35){1'b0}},Qcnt_one_41};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-36){1'b0}},Qcnt_one_42};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-37){1'b0}},Qcnt_one_43};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-38){1'b0}},Qcnt_one_44};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101101:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-39){1'b0}},Qcnt_one_45};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-40){1'b0}},Qcnt_one_46};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b101111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-41){1'b0}},Qcnt_one_47};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-42){1'b0}},Qcnt_one_48};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-43){1'b0}},Qcnt_one_49};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-44){1'b0}},Qcnt_one_50};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-45){1'b0}},Qcnt_one_51};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-46){1'b0}},Qcnt_one_52};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110101:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-47){1'b0}},Qcnt_one_53};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-48){1'b0}},Qcnt_one_54};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b110111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-49){1'b0}},Qcnt_one_55};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end
          6'b111000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-50){1'b0}},Qcnt_one_56};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
            end

          default:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0='0;
              Sqrt_Q0='0;
            end
        endcase
      end


   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b00, end         //
   /////////////////////////////////////////////////////////////////////////////


    2'b01:
      begin
   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b01, start       //
   /////////////////////////////////////////////////////////////////////////////
        case(Crtl_cnt_S)

          6'b000000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
              Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_two_0[1]};
              Sqrt_Q0=Q_sqrt_com_0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
              Q_sqrt1={{(C_MANT_FP64+4){1'b0}},Qcnt_two_0[1:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b000001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-3:C_MANT_FP64-4];
              Q_sqrt0={{(C_MANT_FP64+4){1'b0}},Qcnt_two_1[2:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-5:C_MANT_FP64-6];
              Q_sqrt1={{(C_MANT_FP64+3){1'b0}},Qcnt_two_1[2:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b000010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-7:C_MANT_FP64-8];
              Q_sqrt0={{(C_MANT_FP64+2){1'b0}},Qcnt_two_2[4:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-9:C_MANT_FP64-10];
              Q_sqrt1={{(C_MANT_FP64+1){1'b0}},Qcnt_two_2[4:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b000011:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-11:C_MANT_FP64-12];
              Q_sqrt0={{(C_MANT_FP64){1'b0}},Qcnt_two_3[6:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-13:C_MANT_FP64-14];
              Q_sqrt1={{(C_MANT_FP64-1){1'b0}},Qcnt_two_3[6:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b000100:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-15:C_MANT_FP64-16];
              Q_sqrt0={{(C_MANT_FP64-2){1'b0}},Qcnt_two_4[8:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-17:C_MANT_FP64-18];
              Q_sqrt1={{(C_MANT_FP64-3){1'b0}},Qcnt_two_4[8:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

            6'b000101:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-19:C_MANT_FP64-20];
              Q_sqrt0={{(C_MANT_FP64-4){1'b0}},Qcnt_two_5[10:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-21:C_MANT_FP64-22];
              Q_sqrt1={{(C_MANT_FP64-5){1'b0}},Qcnt_two_5[10:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b000110:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-23:C_MANT_FP64-24];
              Q_sqrt0={{(C_MANT_FP64-6){1'b0}},Qcnt_two_6[12:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-25:C_MANT_FP64-26];
              Q_sqrt1={{(C_MANT_FP64-7){1'b0}},Qcnt_two_6[12:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b000111:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-27:C_MANT_FP64-28];
              Q_sqrt0={{(C_MANT_FP64-8){1'b0}},Qcnt_two_7[14:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-29:C_MANT_FP64-30];
              Q_sqrt1={{(C_MANT_FP64-9){1'b0}},Qcnt_two_7[14:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-31:C_MANT_FP64-32];
              Q_sqrt0={{(C_MANT_FP64-10){1'b0}},Qcnt_two_8[16:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-33:C_MANT_FP64-34];
              Q_sqrt1={{(C_MANT_FP64-11){1'b0}},Qcnt_two_8[16:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-35:C_MANT_FP64-36];
              Q_sqrt0={{(C_MANT_FP64-12){1'b0}},Qcnt_two_9[18:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-37:C_MANT_FP64-38];
              Q_sqrt1={{(C_MANT_FP64-13){1'b0}},Qcnt_two_9[18:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-39:C_MANT_FP64-40];
              Q_sqrt0={{(C_MANT_FP64-14){1'b0}},Qcnt_two_10[20:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-41:C_MANT_FP64-42];
              Q_sqrt1={{(C_MANT_FP64-15){1'b0}},Qcnt_two_10[20:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001011:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-43:C_MANT_FP64-44];
              Q_sqrt0={{(C_MANT_FP64-16){1'b0}},Qcnt_two_11[22:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-45:C_MANT_FP64-46];
              Q_sqrt1={{(C_MANT_FP64-17){1'b0}},Qcnt_two_11[22:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001100:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-47:C_MANT_FP64-48];
              Q_sqrt0={{(C_MANT_FP64-18){1'b0}},Qcnt_two_12[24:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-49:C_MANT_FP64-50];
              Q_sqrt1={{(C_MANT_FP64-19){1'b0}},Qcnt_two_12[24:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001101:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-51:C_MANT_FP64-52];
              Q_sqrt0={{(C_MANT_FP64-20){1'b0}},Qcnt_two_13[26:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-21){1'b0}},Qcnt_two_13[26:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-22){1'b0}},Qcnt_two_14[28:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-23){1'b0}},Qcnt_two_14[28:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b001111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-24){1'b0}},Qcnt_two_15[30:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-25){1'b0}},Qcnt_two_15[30:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-26){1'b0}},Qcnt_two_16[32:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-27){1'b0}},Qcnt_two_16[32:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-28){1'b0}},Qcnt_two_17[34:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-29){1'b0}},Qcnt_two_17[34:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-30){1'b0}},Qcnt_two_18[36:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-31){1'b0}},Qcnt_two_18[36:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-32){1'b0}},Qcnt_two_19[38:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-33){1'b0}},Qcnt_two_19[38:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-34){1'b0}},Qcnt_two_20[40:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-35){1'b0}},Qcnt_two_20[40:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010101:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-36){1'b0}},Qcnt_two_21[42:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-37){1'b0}},Qcnt_two_21[42:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-38){1'b0}},Qcnt_two_22[44:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-39){1'b0}},Qcnt_two_22[44:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b010111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-40){1'b0}},Qcnt_two_23[46:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-41){1'b0}},Qcnt_two_23[46:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b011000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-42){1'b0}},Qcnt_two_24[48:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-43){1'b0}},Qcnt_two_24[48:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b011001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-44){1'b0}},Qcnt_two_25[50:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-45){1'b0}},Qcnt_two_25[50:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b011010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-46){1'b0}},Qcnt_two_26[52:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-47){1'b0}},Qcnt_two_26[52:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b011011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-48){1'b0}},Qcnt_two_27[54:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-49){1'b0}},Qcnt_two_27[54:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          6'b011100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-50){1'b0}},Qcnt_two_28[56:1]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-51){1'b0}},Qcnt_two_28[56:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

          default:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
              Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_two_0[1]};
              Sqrt_Q0=Q_sqrt_com_0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
              Q_sqrt1={{(C_MANT_FP64+4){1'b0}},Qcnt_two_0[1:0]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
            end

        endcase
      end

   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b01, end       //
   /////////////////////////////////////////////////////////////////////////////


    2'b10:
      begin
   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b10, start       //
   /////////////////////////////////////////////////////////////////////////////

        case(Crtl_cnt_S)
          6'b000000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
              Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_three_0[2]};
              Sqrt_Q0=Q_sqrt_com_0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
              Q_sqrt1={{(C_MANT_FP64+4){1'b0}},Qcnt_three_0[2:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-3:C_MANT_FP64-4];
              Q_sqrt2={{(C_MANT_FP64+3){1'b0}},Qcnt_three_0[2:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000001:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-5:C_MANT_FP64-6];
              Q_sqrt0={{(C_MANT_FP64+2){1'b0}},Qcnt_three_1[4:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-7:C_MANT_FP64-8];
              Q_sqrt1={{(C_MANT_FP64+1){1'b0}},Qcnt_three_1[4:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-9:C_MANT_FP64-10];
              Q_sqrt2={{(C_MANT_FP64){1'b0}},Qcnt_three_1[4:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000010:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-11:C_MANT_FP64-12];
              Q_sqrt0={{(C_MANT_FP64-1){1'b0}},Qcnt_three_2[7:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-13:C_MANT_FP64-14];
              Q_sqrt1={{(C_MANT_FP64-2){1'b0}},Qcnt_three_2[7:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-15:C_MANT_FP64-16];
              Q_sqrt2={{(C_MANT_FP64-3){1'b0}},Qcnt_three_2[7:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000011:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-17:C_MANT_FP64-18];
              Q_sqrt0={{(C_MANT_FP64-4){1'b0}},Qcnt_three_3[10:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-19:C_MANT_FP64-20];
              Q_sqrt1={{(C_MANT_FP64-5){1'b0}},Qcnt_three_3[10:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-21:C_MANT_FP64-22];
              Q_sqrt2={{(C_MANT_FP64-6){1'b0}},Qcnt_three_3[10:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000100:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-23:C_MANT_FP64-24];
              Q_sqrt0={{(C_MANT_FP64-7){1'b0}},Qcnt_three_4[13:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-25:C_MANT_FP64-26];
              Q_sqrt1={{(C_MANT_FP64-8){1'b0}},Qcnt_three_4[13:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-27:C_MANT_FP64-28];
              Q_sqrt2={{(C_MANT_FP64-9){1'b0}},Qcnt_three_4[13:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000101:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-29:C_MANT_FP64-30];
              Q_sqrt0={{(C_MANT_FP64-10){1'b0}},Qcnt_three_5[16:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-31:C_MANT_FP64-32];
              Q_sqrt1={{(C_MANT_FP64-11){1'b0}},Qcnt_three_5[16:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-33:C_MANT_FP64-34];
              Q_sqrt2={{(C_MANT_FP64-12){1'b0}},Qcnt_three_5[16:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000110:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-35:C_MANT_FP64-36];
              Q_sqrt0={{(C_MANT_FP64-13){1'b0}},Qcnt_three_6[19:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-37:C_MANT_FP64-38];
              Q_sqrt1={{(C_MANT_FP64-14){1'b0}},Qcnt_three_6[19:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-39:C_MANT_FP64-40];
              Q_sqrt2={{(C_MANT_FP64-15){1'b0}},Qcnt_three_6[19:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b000111:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-41:C_MANT_FP64-42];
              Q_sqrt0={{(C_MANT_FP64-16){1'b0}},Qcnt_three_7[22:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-43:C_MANT_FP64-44];
              Q_sqrt1={{(C_MANT_FP64-17){1'b0}},Qcnt_three_7[22:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-45:C_MANT_FP64-46];
              Q_sqrt2={{(C_MANT_FP64-18){1'b0}},Qcnt_three_7[22:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001000:
            begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-47:C_MANT_FP64-48];
              Q_sqrt0={{(C_MANT_FP64-19){1'b0}},Qcnt_three_8[25:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-49:C_MANT_FP64-50];
              Q_sqrt1={{(C_MANT_FP64-20){1'b0}},Qcnt_three_8[25:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-51:C_MANT_FP64-52];
              Q_sqrt2={{(C_MANT_FP64-21){1'b0}},Qcnt_three_8[25:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-22){1'b0}},Qcnt_three_9[28:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-23){1'b0}},Qcnt_three_9[28:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-24){1'b0}},Qcnt_three_9[28:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-25){1'b0}},Qcnt_three_10[31:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-26){1'b0}},Qcnt_three_10[31:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-27){1'b0}},Qcnt_three_10[31:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001011:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-28){1'b0}},Qcnt_three_11[34:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-29){1'b0}},Qcnt_three_11[34:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-30){1'b0}},Qcnt_three_11[34:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001100:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-31){1'b0}},Qcnt_three_12[37:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-32){1'b0}},Qcnt_three_12[37:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-33){1'b0}},Qcnt_three_12[37:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001101:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-34){1'b0}},Qcnt_three_13[40:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-35){1'b0}},Qcnt_three_13[40:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-36){1'b0}},Qcnt_three_13[40:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001110:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-37){1'b0}},Qcnt_three_14[43:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-38){1'b0}},Qcnt_three_14[43:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-39){1'b0}},Qcnt_three_14[43:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b001111:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-40){1'b0}},Qcnt_three_15[46:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-41){1'b0}},Qcnt_three_15[46:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-42){1'b0}},Qcnt_three_15[46:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b010000:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-43){1'b0}},Qcnt_three_16[49:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-44){1'b0}},Qcnt_three_16[49:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-45){1'b0}},Qcnt_three_16[49:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b010001:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-46){1'b0}},Qcnt_three_17[52:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-47){1'b0}},Qcnt_three_17[52:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-48){1'b0}},Qcnt_three_17[52:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          6'b010010:
            begin
              Sqrt_DI[0]=2'b00;
              Q_sqrt0={{(C_MANT_FP64-49){1'b0}},Qcnt_three_18[55:2]};
              Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
              Sqrt_DI[1]=2'b00;
              Q_sqrt1={{(C_MANT_FP64-50){1'b0}},Qcnt_three_18[55:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=2'b00;
              Q_sqrt2={{(C_MANT_FP64-51){1'b0}},Qcnt_three_18[55:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end

          default :
              begin
              Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
              Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_three_0[2]};
              Sqrt_Q0=Q_sqrt_com_0;
              Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
              Q_sqrt1={{(C_MANT_FP64+4){1'b0}},Qcnt_three_0[2:1]};
              Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
              Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-3:C_MANT_FP64-4];
              Q_sqrt2={{(C_MANT_FP64+3){1'b0}},Qcnt_three_0[2:0]};
              Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
            end
        endcase

      end
   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b10, end       //
   /////////////////////////////////////////////////////////////////////////////


    2'b11:
      begin
   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b11, start       //
   /////////////////////////////////////////////////////////////////////////////

              case(Crtl_cnt_S)

                6'b000000:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
                    Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_four_0[3]};
                    Sqrt_Q0=Q_sqrt_com_0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
                    Q_sqrt1={{(C_MANT_FP64+4){1'b0}},Qcnt_four_0[3:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-3:C_MANT_FP64-4];
                    Q_sqrt2={{(C_MANT_FP64+3){1'b0}},Qcnt_four_0[3:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-5:C_MANT_FP64-6];
                    Q_sqrt3={{(C_MANT_FP64+2){1'b0}},Qcnt_four_0[3:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000001:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-7:C_MANT_FP64-8];
                    Q_sqrt0={{(C_MANT_FP64+1){1'b0}},Qcnt_four_1[6:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-9:C_MANT_FP64-10];
                    Q_sqrt1={{(C_MANT_FP64){1'b0}},Qcnt_four_1[6:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-11:C_MANT_FP64-12];
                    Q_sqrt2={{(C_MANT_FP64-1){1'b0}},Qcnt_four_1[6:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-13:C_MANT_FP64-14];
                    Q_sqrt3={{(C_MANT_FP64-2){1'b0}},Qcnt_four_1[6:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000010:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-15:C_MANT_FP64-16];
                    Q_sqrt0={{(C_MANT_FP64-3){1'b0}},Qcnt_four_2[10:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-17:C_MANT_FP64-18];
                    Q_sqrt1={{(C_MANT_FP64-4){1'b0}},Qcnt_four_2[10:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-19:C_MANT_FP64-20];
                    Q_sqrt2={{(C_MANT_FP64-5){1'b0}},Qcnt_four_2[10:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-21:C_MANT_FP64-22];
                    Q_sqrt3={{(C_MANT_FP64-6){1'b0}},Qcnt_four_2[10:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000011:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-23:C_MANT_FP64-24];
                    Q_sqrt0={{(C_MANT_FP64-7){1'b0}},Qcnt_four_3[14:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-25:C_MANT_FP64-26];
                    Q_sqrt1={{(C_MANT_FP64-8){1'b0}},Qcnt_four_3[14:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-27:C_MANT_FP64-28];
                    Q_sqrt2={{(C_MANT_FP64-9){1'b0}},Qcnt_four_3[14:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-29:C_MANT_FP64-30];
                    Q_sqrt3={{(C_MANT_FP64-10){1'b0}},Qcnt_four_3[14:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000100:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-31:C_MANT_FP64-32];
                    Q_sqrt0={{(C_MANT_FP64-11){1'b0}},Qcnt_four_4[18:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-33:C_MANT_FP64-34];
                    Q_sqrt1={{(C_MANT_FP64-12){1'b0}},Qcnt_four_4[18:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-35:C_MANT_FP64-36];
                    Q_sqrt2={{(C_MANT_FP64-13){1'b0}},Qcnt_four_4[18:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-37:C_MANT_FP64-38];
                    Q_sqrt3={{(C_MANT_FP64-14){1'b0}},Qcnt_four_4[18:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000101:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-39:C_MANT_FP64-40];
                    Q_sqrt0={{(C_MANT_FP64-15){1'b0}},Qcnt_four_5[22:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-41:C_MANT_FP64-42];
                    Q_sqrt1={{(C_MANT_FP64-16){1'b0}},Qcnt_four_5[22:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-43:C_MANT_FP64-44];
                    Q_sqrt2={{(C_MANT_FP64-17){1'b0}},Qcnt_four_5[22:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-45:C_MANT_FP64-46];
                    Q_sqrt3={{(C_MANT_FP64-18){1'b0}},Qcnt_four_5[22:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000110:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64-47:C_MANT_FP64-48];
                    Q_sqrt0={{(C_MANT_FP64-19){1'b0}},Qcnt_four_6[26:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-49:C_MANT_FP64-50];
                    Q_sqrt1={{(C_MANT_FP64-20){1'b0}},Qcnt_four_6[26:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-51:C_MANT_FP64-52];
                    Q_sqrt2={{(C_MANT_FP64-21){1'b0}},Qcnt_four_6[26:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-22){1'b0}},Qcnt_four_6[26:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b000111:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-23){1'b0}},Qcnt_four_7[30:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-24){1'b0}},Qcnt_four_7[30:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-25){1'b0}},Qcnt_four_7[30:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-26){1'b0}},Qcnt_four_7[30:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b001000:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-27){1'b0}},Qcnt_four_8[34:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-28){1'b0}},Qcnt_four_8[34:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-29){1'b0}},Qcnt_four_8[34:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-30){1'b0}},Qcnt_four_8[34:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b001001:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-31){1'b0}},Qcnt_four_9[38:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-32){1'b0}},Qcnt_four_9[38:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-33){1'b0}},Qcnt_four_9[38:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-34){1'b0}},Qcnt_four_9[38:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b001010:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-35){1'b0}},Qcnt_four_10[42:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-36){1'b0}},Qcnt_four_10[42:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-37){1'b0}},Qcnt_four_10[42:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-38){1'b0}},Qcnt_four_10[42:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b001011:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-39){1'b0}},Qcnt_four_11[46:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-40){1'b0}},Qcnt_four_11[46:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-41){1'b0}},Qcnt_four_11[46:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-42){1'b0}},Qcnt_four_11[46:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b001100:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-43){1'b0}},Qcnt_four_12[50:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-44){1'b0}},Qcnt_four_12[50:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-45){1'b0}},Qcnt_four_12[50:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-46){1'b0}},Qcnt_four_12[50:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                6'b001101:
                  begin
                    Sqrt_DI[0]=2'b00;
                    Q_sqrt0={{(C_MANT_FP64-47){1'b0}},Qcnt_four_13[54:3]};
                    Sqrt_Q0=Quotient_DP[0]?Q_sqrt_com_0:Q_sqrt0;
                    Sqrt_DI[1]=2'b00;
                    Q_sqrt1={{(C_MANT_FP64-48){1'b0}},Qcnt_four_13[54:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=2'b00;
                    Q_sqrt2={{(C_MANT_FP64-49){1'b0}},Qcnt_four_13[54:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=2'b00;
                    Q_sqrt3={{(C_MANT_FP64-50){1'b0}},Qcnt_four_13[54:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end

                default:
                  begin
                    Sqrt_DI[0]=Mant_D_sqrt_Norm[C_MANT_FP64+1:C_MANT_FP64];
                    Q_sqrt0={{(C_MANT_FP64+5){1'b0}},Qcnt_four_0[3]};
                    Sqrt_Q0=Q_sqrt_com_0;
                    Sqrt_DI[1]=Mant_D_sqrt_Norm[C_MANT_FP64-1:C_MANT_FP64-2];
                    Q_sqrt1={{(C_MANT_FP64+4){1'b0}},Qcnt_four_0[3:2]};
                    Sqrt_Q1=Sqrt_quotinent_S[3]?Q_sqrt_com_1:Q_sqrt1;
                    Sqrt_DI[2]=Mant_D_sqrt_Norm[C_MANT_FP64-3:C_MANT_FP64-4];
                    Q_sqrt2={{(C_MANT_FP64+3){1'b0}},Qcnt_four_0[3:1]};
                    Sqrt_Q2=Sqrt_quotinent_S[2]?Q_sqrt_com_2:Q_sqrt2;
                    Sqrt_DI[3]=Mant_D_sqrt_Norm[C_MANT_FP64-5:C_MANT_FP64-6];
                    Q_sqrt3={{(C_MANT_FP64+2){1'b0}},Qcnt_four_0[3:0]};
                    Sqrt_Q3=Sqrt_quotinent_S[1]?Q_sqrt_com_3:Q_sqrt3;
                  end
              endcase
            end
      endcase
   /////////////////////////////////////////////////////////////////////////////
   // Operands for square root when Iteration_unit_num_S = 2'b11, end         //
   /////////////////////////////////////////////////////////////////////////////
 end



  assign Sqrt_R0= ((Sqrt_start_dly_S)?'0:{Partial_remainder_DP[C_MANT_FP64+5:0]});
  assign Sqrt_R1= {Iteration_cell_sum_AMASK_D[0][C_MANT_FP64+5],Iteration_cell_sum_AMASK_D[0][C_MANT_FP64+2:0],Sqrt_DO[0]} ;
  assign Sqrt_R2= {Iteration_cell_sum_AMASK_D[1][C_MANT_FP64+5],Iteration_cell_sum_AMASK_D[1][C_MANT_FP64+2:0],Sqrt_DO[1]};
  assign Sqrt_R3= {Iteration_cell_sum_AMASK_D[2][C_MANT_FP64+5],Iteration_cell_sum_AMASK_D[2][C_MANT_FP64+2:0],Sqrt_DO[2]};
  assign Sqrt_R4= {Iteration_cell_sum_AMASK_D[3][C_MANT_FP64+5],Iteration_cell_sum_AMASK_D[3][C_MANT_FP64+2:0],Sqrt_DO[3]};

  logic [C_MANT_FP64+5:0]                               Denominator_se_format_DB;  //

  assign Denominator_se_format_DB={Denominator_se_DB[C_MANT_FP64+1:C_MANT_FP64-C_MANT_FP16ALT],{FP16ALT_SO?FP16ALT_SO:Denominator_se_DB[C_MANT_FP64-C_MANT_FP16ALT-1]},
                                                         Denominator_se_DB[C_MANT_FP64-C_MANT_FP16ALT-2:C_MANT_FP64-C_MANT_FP16],{FP16_SO?FP16_SO:Denominator_se_DB[C_MANT_FP64-C_MANT_FP16-1]},
                                                         Denominator_se_DB[C_MANT_FP64-C_MANT_FP16-2:C_MANT_FP64-C_MANT_FP32],{FP32_SO?FP32_SO:Denominator_se_DB[C_MANT_FP64-C_MANT_FP32-1]},
                                                         Denominator_se_DB[C_MANT_FP64-C_MANT_FP32-2:C_MANT_FP64-C_MANT_FP64],FP64_SO,3'b0} ;
  //                   for           iteration cell_U0
  logic [C_MANT_FP64+5:0]                           First_iteration_cell_div_a_D,First_iteration_cell_div_b_D;
  logic                                             Sel_b_for_first_S;


  assign First_iteration_cell_div_a_D=(Div_start_dly_S)?{Numerator_se_D[C_MANT_FP64+1:C_MANT_FP64-C_MANT_FP16ALT],{FP16ALT_SO?FP16ALT_SO:Numerator_se_D[C_MANT_FP64-C_MANT_FP16ALT-1]},
                                                         Numerator_se_D[C_MANT_FP64-C_MANT_FP16ALT-2:C_MANT_FP64-C_MANT_FP16],{FP16_SO?FP16_SO:Numerator_se_D[C_MANT_FP64-C_MANT_FP16-1]},
                                                         Numerator_se_D[C_MANT_FP64-C_MANT_FP16-2:C_MANT_FP64-C_MANT_FP32],{FP32_SO?FP32_SO:Numerator_se_D[C_MANT_FP64-C_MANT_FP32-1]},
                                                         Numerator_se_D[C_MANT_FP64-C_MANT_FP32-2:C_MANT_FP64-C_MANT_FP64],FP64_SO,3'b0}
                                                        :{Partial_remainder_DP[C_MANT_FP64+4:C_MANT_FP64-C_MANT_FP16ALT+3],{FP16ALT_SO?Quotient_DP[0]:Partial_remainder_DP[C_MANT_FP64-C_MANT_FP16ALT+2]},
                                                         Partial_remainder_DP[C_MANT_FP64-C_MANT_FP16ALT+1:C_MANT_FP64-C_MANT_FP16+3],{FP16_SO?Quotient_DP[0]:Partial_remainder_DP[C_MANT_FP64-C_MANT_FP16+2]},
                                                         Partial_remainder_DP[C_MANT_FP64-C_MANT_FP16+1:C_MANT_FP64-C_MANT_FP32+3],{FP32_SO?Quotient_DP[0]:Partial_remainder_DP[C_MANT_FP64-C_MANT_FP32+2]},
                                                         Partial_remainder_DP[C_MANT_FP64-C_MANT_FP32+1:C_MANT_FP64-C_MANT_FP64+3],FP64_SO&&Quotient_DP[0],3'b0};
  assign Sel_b_for_first_S=(Div_start_dly_S)?1:Quotient_DP[0];
  assign First_iteration_cell_div_b_D=Sel_b_for_first_S?Denominator_se_format_DB:{Denominator_se_D,4'b0};
  assign Iteration_cell_a_BMASK_D[0]=Sqrt_enable_SO?Sqrt_R0:{First_iteration_cell_div_a_D};
  assign Iteration_cell_b_BMASK_D[0]=Sqrt_enable_SO?Sqrt_Q0:{First_iteration_cell_div_b_D};



  //                   for           iteration cell_U1
  logic [C_MANT_FP64+5:0]                          Sec_iteration_cell_div_a_D,Sec_iteration_cell_div_b_D;
  logic                                            Sel_b_for_sec_S;
  generate
    if(|Iteration_unit_num_S)
      begin
        assign Sel_b_for_sec_S=~Iteration_cell_sum_AMASK_D[0][C_MANT_FP64+5];
        assign Sec_iteration_cell_div_a_D={Iteration_cell_sum_AMASK_D[0][C_MANT_FP64+4:C_MANT_FP64-C_MANT_FP16ALT+3],{FP16ALT_SO?Sel_b_for_sec_S:Iteration_cell_sum_AMASK_D[0][C_MANT_FP64-C_MANT_FP16ALT+2]},
                                           Iteration_cell_sum_AMASK_D[0][C_MANT_FP64-C_MANT_FP16ALT+1:C_MANT_FP64-C_MANT_FP16+3],{FP16_SO?Sel_b_for_sec_S:Iteration_cell_sum_AMASK_D[0][C_MANT_FP64-C_MANT_FP16+2]},
                                           Iteration_cell_sum_AMASK_D[0][C_MANT_FP64-C_MANT_FP16+1:C_MANT_FP64-C_MANT_FP32+3],{FP32_SO?Sel_b_for_sec_S:Iteration_cell_sum_AMASK_D[0][C_MANT_FP64-C_MANT_FP32+2]},
                                           Iteration_cell_sum_AMASK_D[0][C_MANT_FP64-C_MANT_FP32+1:C_MANT_FP64-C_MANT_FP64+3],FP64_SO&&Sel_b_for_sec_S,3'b0};
        assign Sec_iteration_cell_div_b_D=Sel_b_for_sec_S?Denominator_se_format_DB:{Denominator_se_D,4'b0};
        assign Iteration_cell_a_BMASK_D[1]=Sqrt_enable_SO?Sqrt_R1:{Sec_iteration_cell_div_a_D};
        assign Iteration_cell_b_BMASK_D[1]=Sqrt_enable_SO?Sqrt_Q1:{Sec_iteration_cell_div_b_D};
      end
    endgenerate

  //                   for           iteration cell_U2
  logic [C_MANT_FP64+5:0]                          Thi_iteration_cell_div_a_D,Thi_iteration_cell_div_b_D;
  logic                                            Sel_b_for_thi_S;
  generate
    if((Iteration_unit_num_S==2'b10) | (Iteration_unit_num_S==2'b11))
      begin
        assign Sel_b_for_thi_S=~Iteration_cell_sum_AMASK_D[1][C_MANT_FP64+5];
        assign Thi_iteration_cell_div_a_D={Iteration_cell_sum_AMASK_D[1][C_MANT_FP64+4:C_MANT_FP64-C_MANT_FP16ALT+3],{FP16ALT_SO?Sel_b_for_thi_S:Iteration_cell_sum_AMASK_D[1][C_MANT_FP64-C_MANT_FP16ALT+2]},
                                           Iteration_cell_sum_AMASK_D[1][C_MANT_FP64-C_MANT_FP16ALT+1:C_MANT_FP64-C_MANT_FP16+3],{FP16_SO?Sel_b_for_thi_S:Iteration_cell_sum_AMASK_D[1][C_MANT_FP64-C_MANT_FP16+2]},
                                           Iteration_cell_sum_AMASK_D[1][C_MANT_FP64-C_MANT_FP16+1:C_MANT_FP64-C_MANT_FP32+3],{FP32_SO?Sel_b_for_thi_S:Iteration_cell_sum_AMASK_D[1][C_MANT_FP64-C_MANT_FP32+2]},
                                           Iteration_cell_sum_AMASK_D[1][C_MANT_FP64-C_MANT_FP32+1:C_MANT_FP64-C_MANT_FP64+3],FP64_SO&&Sel_b_for_thi_S,3'b0};
        assign Thi_iteration_cell_div_b_D=Sel_b_for_thi_S?Denominator_se_format_DB:{Denominator_se_D,4'b0};
        assign Iteration_cell_a_BMASK_D[2]=Sqrt_enable_SO?Sqrt_R2:{Thi_iteration_cell_div_a_D};
        assign Iteration_cell_b_BMASK_D[2]=Sqrt_enable_SO?Sqrt_Q2:{Thi_iteration_cell_div_b_D};
      end
  endgenerate

  //                   for           iteration cell_U3
  logic [C_MANT_FP64+5:0]                          Fou_iteration_cell_div_a_D,Fou_iteration_cell_div_b_D;
  logic                                            Sel_b_for_fou_S;

  generate
    if(Iteration_unit_num_S==2'b11)
      begin
        assign Sel_b_for_fou_S=~Iteration_cell_sum_AMASK_D[2][C_MANT_FP64+5];
        assign Fou_iteration_cell_div_a_D={Iteration_cell_sum_AMASK_D[2][C_MANT_FP64+4:C_MANT_FP64-C_MANT_FP16ALT+3],{FP16ALT_SO?Sel_b_for_fou_S:Iteration_cell_sum_AMASK_D[2][C_MANT_FP64-C_MANT_FP16ALT+2]},
                                           Iteration_cell_sum_AMASK_D[2][C_MANT_FP64-C_MANT_FP16ALT+1:C_MANT_FP64-C_MANT_FP16+3],{FP16_SO?Sel_b_for_fou_S:Iteration_cell_sum_AMASK_D[2][C_MANT_FP64-C_MANT_FP16+2]},
                                           Iteration_cell_sum_AMASK_D[2][C_MANT_FP64-C_MANT_FP16+1:C_MANT_FP64-C_MANT_FP32+3],{FP32_SO?Sel_b_for_fou_S:Iteration_cell_sum_AMASK_D[2][C_MANT_FP64-C_MANT_FP32+2]},
                                           Iteration_cell_sum_AMASK_D[2][C_MANT_FP64-C_MANT_FP32+1:C_MANT_FP64-C_MANT_FP64+3],FP64_SO&&Sel_b_for_fou_S,3'b0};
        assign Fou_iteration_cell_div_b_D=Sel_b_for_fou_S?Denominator_se_format_DB:{Denominator_se_D,4'b0};
        assign Iteration_cell_a_BMASK_D[3]=Sqrt_enable_SO?Sqrt_R3:{Fou_iteration_cell_div_a_D};
        assign Iteration_cell_b_BMASK_D[3]=Sqrt_enable_SO?Sqrt_Q3:{Fou_iteration_cell_div_b_D};
      end
  endgenerate

   /////////////////////////////////////////////////////////////////////////////
   // Masking Contrl                                                          //
   /////////////////////////////////////////////////////////////////////////////


  logic [C_MANT_FP64+1+4:0]                          Mask_bits_ctl_S;  //For extension

  assign Mask_bits_ctl_S =58'h3ff_ffff_ffff_ffff;   //It is not needed. The corresponding process is handled the above codes

   /////////////////////////////////////////////////////////////////////////////
   // Iteration Instances  with masking control                               //
   /////////////////////////////////////////////////////////////////////////////


  logic                                             Div_enable_SI   [3:0];
  logic                                             Div_start_dly_SI   [3:0];
  logic                                             Sqrt_enable_SI   [3:0];
  generate
    genvar i,j;
      for (i=0; i <= Iteration_unit_num_S ; i++)
        begin
          for (j = 0; j <= C_MANT_FP64+5; j++) begin
              assign Iteration_cell_a_D[i][j] = Mask_bits_ctl_S[j] && Iteration_cell_a_BMASK_D[i][j];
              assign Iteration_cell_b_D[i][j] = Mask_bits_ctl_S[j] && Iteration_cell_b_BMASK_D[i][j];
              assign Iteration_cell_sum_AMASK_D[i][j] = Mask_bits_ctl_S[j] && Iteration_cell_sum_D[i][j];
          end

          assign  Div_enable_SI[i] = Div_enable_SO;
          assign  Div_start_dly_SI[i] = Div_start_dly_S;
          assign  Sqrt_enable_SI[i] = Sqrt_enable_SO;
          miv_rv32_iteration_div_sqrt_mvp #(C_MANT_FP64+6) iteration_div_sqrt
          (
          .A_DI                                    (Iteration_cell_a_D[i]            ),
          .B_DI                                    (Iteration_cell_b_D[i]            ),
          .Div_enable_SI                           (Div_enable_SI[i]                 ),
          .Div_start_dly_SI                        (Div_start_dly_SI[i]              ),
          .Sqrt_enable_SI                          (Sqrt_enable_SI[i]                ),
          .D_DI                                    (Sqrt_DI[i]                       ),
          .D_DO                                    (Sqrt_DO[i]                       ),
          .Sum_DO                                  (Iteration_cell_sum_D[i]          ),
          .Carry_out_DO                            (Iteration_cell_carry_D[i]        )
         );

        end

  endgenerate



  always_comb
    begin
      case (Iteration_unit_num_S)
        2'b00:
          begin
            if(Fsm_enable_S)
               Partial_remainder_DN = Sqrt_enable_SO?Sqrt_R1:Iteration_cell_sum_AMASK_D[0];
            else
               Partial_remainder_DN = Partial_remainder_DP;
          end
        2'b01:
          begin
            if(Fsm_enable_S)
               Partial_remainder_DN = Sqrt_enable_SO?Sqrt_R2:Iteration_cell_sum_AMASK_D[1];
            else
               Partial_remainder_DN = Partial_remainder_DP;
          end
        2'b10:
          begin
            if(Fsm_enable_S)
               Partial_remainder_DN = Sqrt_enable_SO?Sqrt_R3:Iteration_cell_sum_AMASK_D[2];
            else
               Partial_remainder_DN = Partial_remainder_DP;
          end
        2'b11:
          begin
            if(Fsm_enable_S)
               Partial_remainder_DN = Sqrt_enable_SO?Sqrt_R4:Iteration_cell_sum_AMASK_D[3];
            else
               Partial_remainder_DN = Partial_remainder_DP;
          end
        endcase
     end



   always_ff @(posedge Clk_CI, negedge Rst_RBI)   // partial_remainder
     begin
        if(~Rst_RBI)
          begin
             Partial_remainder_DP <= '0;
          end
        else
          begin
             Partial_remainder_DP <= Partial_remainder_DN;
          end
    end

   logic [C_MANT_FP64+4:0] Quotient_DN;

  always_comb                                                      // Can choosen the different carry-outs based on different operations
    begin
      case (Iteration_unit_num_S)
        2'b00:
          begin
            if(Fsm_enable_S)
               Quotient_DN= Sqrt_enable_SO ? {Quotient_DP[C_MANT_FP64+3:0],Sqrt_quotinent_S[3]} :{Quotient_DP[C_MANT_FP64+3:0],Iteration_cell_carry_D[0]};
            else
               Quotient_DN= Quotient_DP;
          end
        2'b01:
          begin
            if(Fsm_enable_S)
               Quotient_DN= Sqrt_enable_SO ? {Quotient_DP[C_MANT_FP64+2:0],Sqrt_quotinent_S[3:2]} :{Quotient_DP[C_MANT_FP64+2:0],Iteration_cell_carry_D[0],Iteration_cell_carry_D[1]};
            else
               Quotient_DN= Quotient_DP;
          end
        2'b10:
          begin
            if(Fsm_enable_S)
               Quotient_DN= Sqrt_enable_SO ? {Quotient_DP[C_MANT_FP64+1:0],Sqrt_quotinent_S[3:1]} : {Quotient_DP[C_MANT_FP64+1:0],Iteration_cell_carry_D[0],Iteration_cell_carry_D[1],Iteration_cell_carry_D[2]};
            else
               Quotient_DN= Quotient_DP;
          end
        2'b11:
          begin
            if(Fsm_enable_S)
               Quotient_DN= Sqrt_enable_SO ? {Quotient_DP[C_MANT_FP64:0],Sqrt_quotinent_S } : {Quotient_DP[C_MANT_FP64:0],Iteration_cell_carry_D[0],Iteration_cell_carry_D[1],Iteration_cell_carry_D[2],Iteration_cell_carry_D[3]};
            else
               Quotient_DN= Quotient_DP;
          end
        endcase
     end

   always_ff @(posedge Clk_CI, negedge Rst_RBI)   // Quotient
     begin
        if(~Rst_RBI)
          begin
          Quotient_DP <= '0;
          end
        else
          Quotient_DP <= Quotient_DN;
    end


   /////////////////////////////////////////////////////////////////////////////
   // Precision Control for outputs                                          //
   /////////////////////////////////////////////////////////////////////////////


//////////////////////one iteration unit, start///////////////////////////////////////
   generate
     if(Iteration_unit_num_S==2'b00)
       begin
        always_comb
          begin
            case (Format_sel_S)
              2'b00:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+4:0],{(C_MANT_FP64-C_MANT_FP32){1'b0}}}; //+4
                      end
                    6'h17:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32:0],{(C_MANT_FP64-C_MANT_FP32+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h16:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-1:0],{(C_MANT_FP64-C_MANT_FP32+4+1){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h15:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-2:0],{(C_MANT_FP64-C_MANT_FP32+4+2){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h14:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-3:0],{(C_MANT_FP64-C_MANT_FP32+4+3){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h13:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-4:0],{(C_MANT_FP64-C_MANT_FP32+4+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h12:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-5:0],{(C_MANT_FP64-C_MANT_FP32+4+5){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h11:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-6:0],{(C_MANT_FP64-C_MANT_FP32+4+6){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h10:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-7:0],{(C_MANT_FP64-C_MANT_FP32+4+7){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0f:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-8:0],{(C_MANT_FP64-C_MANT_FP32+4+8){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-9:0],{(C_MANT_FP64-C_MANT_FP32+4+9){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0d:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-10:0],{(C_MANT_FP64-C_MANT_FP32+4+10){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-11:0],{(C_MANT_FP64-C_MANT_FP32+4+11){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0b:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-12:0],{(C_MANT_FP64-C_MANT_FP32+4+12){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-13:0],{(C_MANT_FP64-C_MANT_FP32+4+13){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h09:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-14:0],{(C_MANT_FP64-C_MANT_FP32+4+14){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-15:0],{(C_MANT_FP64-C_MANT_FP32+4+15){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-16:0],{(C_MANT_FP64-C_MANT_FP32+4+16){1'b0}}}; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+4:0],{(C_MANT_FP64-C_MANT_FP32){1'b0}}}; //+4
                      end
                  endcase
                end

              2'b01:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = Quotient_DP[C_MANT_FP64+4:0]; //+4
                      end
                    6'h34:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64:0],{(4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h33:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-1:0],{(4+1){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h32:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-2:0],{(4+2){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h31:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-3:0],{(4+3){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h30:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-4:0],{(4+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h2f:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-5:0],{(4+5){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h2e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-6:0],{(4+6){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h2d:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-7:0],{(4+7){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h2c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-8:0],{(4+8){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h2b:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-9:0],{(4+9){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h2a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-10:0],{(4+10){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h29:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-11:0],{(4+11){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h28:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-12:0],{(4+12){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h27:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-13:0],{(4+13){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h26:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-14:0],{(4+14){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h25:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-15:0],{(4+15){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h24:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-16:0],{(4+16){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h23:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-17:0],{(4+17){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h22:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-18:0],{(4+18){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h21:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-19:0],{(4+19){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h20:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-20:0],{(4+20){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h1f:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-21:0],{(4+21){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h1e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-22:0],{(4+22){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h1d:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-23:0],{(4+23){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h1c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-24:0],{(4+24){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h1b:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-25:0],{(4+25){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h1a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-26:0],{(4+26){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h19:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-27:0],{(4+27){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h18:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-28:0],{(4+28){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h17:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-29:0],{(4+29){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h16:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-30:0],{(4+30){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h15:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-31:0],{(4+31){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h14:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-32:0],{(4+32){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h13:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-33:0],{(4+33){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h12:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-34:0],{(4+34){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h11:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-35:0],{(4+35){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h10:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-36:0],{(4+36){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0f:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-37:0],{(4+37){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-38:0],{(4+38){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0d:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-39:0],{(4+39){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-40:0],{(4+40){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0b:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-41:0],{(4+41){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-42:0],{(4+42){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h09:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-43:0],{(4+43){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-44:0],{(4+44){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-45:0],{(4+45){1'b0}}}; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = Quotient_DP[C_MANT_FP64+4:0]; //+4
                      end
                  endcase
                end

              2'b10:
                begin
                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+4:0],{(C_MANT_FP64-C_MANT_FP16){1'b0}}}; //+4
                      end
                    6'h0a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16:0],{(C_MANT_FP64-C_MANT_FP16+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h09:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16-1:0],{(C_MANT_FP64-C_MANT_FP16+4+1){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16-2:0],{(C_MANT_FP64-C_MANT_FP16+4+2){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16-3:0],{(C_MANT_FP64-C_MANT_FP16+4+3){1'b0}}}; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+4:0],{(C_MANT_FP64-C_MANT_FP16){1'b0}}}; //+4
                      end
                  endcase
                end

              2'b11:
                begin

                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}}}; //+4
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT:0],{(C_MANT_FP64-C_MANT_FP16ALT+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}}}; //+4
                      end
                  endcase
                end
            endcase
          end
        end
      endgenerate
//////////////////////one iteration unit, end//////////////////////////////////////////

//////////////////////two iteration units, start///////////////////////////////////////
   generate
     if(Iteration_unit_num_S==2'b01)
       begin
        always_comb
          begin
            case (Format_sel_S)
              2'b00:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+4:0],{(C_MANT_FP64-C_MANT_FP32){1'b0}}}; //+4
                      end
                    6'h17,6'h16:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32:0],{(C_MANT_FP64-C_MANT_FP32+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h15,6'h14:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-2:0],{(C_MANT_FP64-C_MANT_FP32+4+2){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h13,6'h12:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-4:0],{(C_MANT_FP64-C_MANT_FP32+4+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h11,6'h10:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-6:0],{(C_MANT_FP64-C_MANT_FP32+4+6){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0f,6'h0e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-8:0],{(C_MANT_FP64-C_MANT_FP32+4+8){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0d,6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-10:0],{(C_MANT_FP64-C_MANT_FP32+4+10){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0b,6'h0a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-12:0],{(C_MANT_FP64-C_MANT_FP32+4+12){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h09,6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-14:0],{(C_MANT_FP64-C_MANT_FP32+4+14){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-16:0],{(C_MANT_FP64-C_MANT_FP32+4+16){1'b0}}}; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+4:0],{(C_MANT_FP64-C_MANT_FP32){1'b0}}}; //+4
                      end
                  endcase
                end
              2'b01:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+3:0],1'b0}; //+3
                      end
                    6'h34:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+1:1],{(4){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h33,6'h32:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-1:0],{(4+1){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h31,6'h30:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-3:0],{(4+3){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2f,6'h2e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-5:0],{(4+5){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2d,6'h2c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-7:0],{(4+7){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2b,6'h2a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-9:0],{(4+9){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h29,6'h28:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-11:0],{(4+11){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h27,6'h26:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-13:0],{(4+13){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h25,6'h24:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-15:0],{(4+15){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h23,6'h22:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-17:0],{(4+17){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h21,6'h20:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-19:0],{(4+19){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1f,6'h1e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-21:0],{(4+21){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1d,6'h1c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-23:0],{(4+23){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1b,6'h1a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-25:0],{(4+25){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h19,6'h18:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-27:0],{(4+27){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h17,6'h16:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-29:0],{(4+29){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h15,6'h14:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-31:0],{(4+31){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h13,6'h12:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-33:0],{(4+33){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h11,6'h10:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-35:0],{(4+35){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0f,6'h0e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-37:0],{(4+37){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0d,6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-39:0],{(4+39){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0b,6'h0a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-41:0],{(4+41){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h09,6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-43:0],{(4+43){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-45:0],{(4+45){1'b0}} }; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+3:0],1'b0}; //+3
                      end
                  endcase
                end

              2'b10:
                begin
                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+3:0],{(C_MANT_FP64-C_MANT_FP16+1){1'b0}} }; //+3
                      end
                    6'h0a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+1:1],{(C_MANT_FP64-C_MANT_FP16+4){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h09,6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16-1:0],{(C_MANT_FP64-C_MANT_FP16+4+1){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16-3:0],{(C_MANT_FP64-C_MANT_FP16+4+3){1'b0}} }; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+4:0],{(C_MANT_FP64-C_MANT_FP16){1'b0}} }; //+4
                      end
                  endcase
                end

              2'b11:
                begin

                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} }; //+4
                      end
                    6'h07:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT:0],{(C_MANT_FP64-C_MANT_FP16ALT+4){1'b0}} }; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} }; //+4
                      end
                  endcase
                end
            endcase
          end
       end
     endgenerate
//////////////////////two iteration units, end//////////////////////////////////////////

//////////////////////three iteration units, start///////////////////////////////////////
   generate
     if(Iteration_unit_num_S==2'b10)
       begin
        always_comb
          begin
            case (Format_sel_S)
              2'b00:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+3:0],{(C_MANT_FP64-C_MANT_FP32+1){1'b0}}}; //+3
                      end
                    6'h17,6'h16,6'h15:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32:0],{(C_MANT_FP64-C_MANT_FP32+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h14,6'h13,6'h12:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-3:0],{(C_MANT_FP64-C_MANT_FP32+4+3){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h11,6'h10,6'h0f:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-6:0],{(C_MANT_FP64-C_MANT_FP32+4+6){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0e,6'h0d,6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-9:0],{(C_MANT_FP64-C_MANT_FP32+4+9){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0b,6'h0a,6'h09:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-12:0],{(C_MANT_FP64-C_MANT_FP32+4+12){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h08,6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-15:0],{(C_MANT_FP64-C_MANT_FP32+4+15){1'b0}}}; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+3:0],{(C_MANT_FP64-C_MANT_FP32+1){1'b0}}}; //+3
                      end
                  endcase
                end

              2'b01:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = Quotient_DP[C_MANT_FP64+4:0]; //+4
                      end
                    6'h34,6'h33:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+1:1],{(4){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h32,6'h31,6'h30:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-2:0],{(4+2){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2f,6'h2e,6'h2d:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-5:0],{(4+5){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2c,6'h2b,6'h2a:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-8:0],{(4+8){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h29,6'h28,6'h27:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-11:0],{(4+11){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h26,6'h25,6'h24:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-14:0],{(4+14){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h23,6'h22,6'h21:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-17:0],{(4+17){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h20,6'h1f,6'h1e:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-20:0],{(4+20){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1d,6'h1c,6'h1b:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-23:0],{(4+23){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1a,6'h19,6'h18:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-26:0],{(4+26){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h17,6'h16,6'h15:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-29:0],{(4+29){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h14,6'h13,6'h12:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-32:0],{(4+32){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h11,6'h10,6'h0f:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-35:0],{(4+35){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0e,6'h0d,6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-38:0],{(4+38){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0b,6'h0a,6'h09:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-41:0],{(4+41){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h08,6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-44:0],{(4+44){1'b0}} }; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = Quotient_DP[C_MANT_FP64+4:0]; //+4
                      end
                  endcase
                end

              2'b10:
                begin
                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+4:0],{(C_MANT_FP64-C_MANT_FP16){1'b0}} }; //+4
                      end
                    6'h0a,6'h09:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+1:1],{(C_MANT_FP64-C_MANT_FP16+4){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h08,6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16-2:0],{(C_MANT_FP64-C_MANT_FP16+4+2){1'b0}} }; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+4:0],{(C_MANT_FP64-C_MANT_FP16){1'b0}} }; //+4
                      end
                  endcase
                end

              2'b11:
                begin

                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} }; //+4
                      end
                    6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+1:1],{(C_MANT_FP64-C_MANT_FP16ALT+4){1'b0}} }; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} }; //+4
                      end
                  endcase
                end
            endcase
          end
        end
      endgenerate
//////////////////////three iteration units, end//////////////////////////////////////////

//////////////////////four iteration units, start///////////////////////////////////////
   generate
     if(Iteration_unit_num_S==2'b11)
       begin
        always_comb
          begin
            case (Format_sel_S)
              2'b00:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+4:0],{(C_MANT_FP64-C_MANT_FP32){1'b0}}}; //+4
                      end
                    6'h17,6'h16,6'h15,6'h14:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32:0],{(C_MANT_FP64-C_MANT_FP32+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h13,6'h12,6'h11,6'h10:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-4:0],{(C_MANT_FP64-C_MANT_FP32+4+4){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0f,6'h0e,6'h0d,6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-8:0],{(C_MANT_FP64-C_MANT_FP32+4+8){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h0b,6'h0a,6'h09,6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-12:0],{(C_MANT_FP64-C_MANT_FP32+4+12){1'b0}}}; //Precision_ctl_S+1
                      end
                    6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32-16:0],{(C_MANT_FP64-C_MANT_FP32+4+16){1'b0}}}; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP32+4:0],{(C_MANT_FP64-C_MANT_FP32){1'b0}}}; //+4
                      end
                  endcase
                end

              2'b01:
                begin
                  case (Precision_ctl_S)
                    6'h00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+3:0],{(1){1'b0}}}; //+3
                      end
                    6'h34:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+3:0],{(1){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h33,6'h32,6'h31,6'h30:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-1:0],{(5){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2f,6'h2e,6'h2d,6'h2c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-5:0],{(9){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h2b,6'h2a,6'h29,6'h28:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-9:0],{(13){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h27,6'h26,6'h25,6'h24:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-13:0],{(17){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h23,6'h22,6'h21,6'h20:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-17:0],{(21){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1f,6'h1e,6'h1d,6'h1c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-21:0],{(25){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h1b,6'h1a,6'h19,6'h18:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-25:0],{(29){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h17,6'h16,6'h15,6'h14:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-29:0],{(33){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h13,6'h12,6'h11,6'h10:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-33:0],{(37){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0f,6'h0e,6'h0d,6'h0c:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-37:0],{(41){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h0b,6'h0a,6'h09,6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-41:0],{(45){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64-45:0],{(49){1'b0}} }; //Precision_ctl_S+1
                      end
                    default:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP64+3:0],{(1){1'b0}}}; //+3
                      end
                  endcase
                end

              2'b10:
                begin
                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+5:0],{(C_MANT_FP64-C_MANT_FP16-1){1'b0}} }; //+5
                      end
                    6'h0a,6'h09,6'h08:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+1:1],{(C_MANT_FP64-C_MANT_FP16+4){1'b0}} }; //Precision_ctl_S+1
                      end
                    6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+1-4:0],{(C_MANT_FP64-C_MANT_FP16+4+3){1'b0}} }; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16+5:0],{(C_MANT_FP64-C_MANT_FP16-1){1'b0}} }; //+5
                      end
                  endcase
                end

              2'b11:
                begin

                  case (Precision_ctl_S)
                    6'b00:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} }; //+4
                      end
                    6'h07,6'h06:
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT:0],{(C_MANT_FP64-C_MANT_FP16ALT+4){1'b0}} }; //Precision_ctl_S+1
                      end
                    default :
                      begin
                        Mant_result_prenorm_DO = {Quotient_DP[C_MANT_FP16ALT+4:0],{(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} }; //+4
                      end
                  endcase
                end
            endcase
          end
        end
      endgenerate
//////////////////////four iteration units, end///////////////////////////////////////





// resultant exponent
   logic   [C_EXP_FP64+1:0]    Exp_result_prenorm_DN,Exp_result_prenorm_DP;

   logic   [C_EXP_FP64+1:0]                                Exp_add_a_D;
   logic   [C_EXP_FP64+1:0]                                Exp_add_b_D;
   logic   [C_EXP_FP64+1:0]                                Exp_add_c_D;

  integer                                                 C_BIAS_AONE, C_HALF_BIAS;
  always_comb
    begin  //
      case (Format_sel_S)
        2'b00:
          begin
            C_BIAS_AONE =C_BIAS_AONE_FP32;
            C_HALF_BIAS =C_HALF_BIAS_FP32;
          end
        2'b01:
          begin
            C_BIAS_AONE =C_BIAS_AONE_FP64;
            C_HALF_BIAS =C_HALF_BIAS_FP64;
          end
        2'b10:
          begin
            C_BIAS_AONE =C_BIAS_AONE_FP16;
            C_HALF_BIAS =C_HALF_BIAS_FP16;
          end
        2'b11:
          begin
            C_BIAS_AONE =C_BIAS_AONE_FP16ALT;
            C_HALF_BIAS =C_HALF_BIAS_FP16ALT;
          end
        endcase
    end

//For division, exponent=(Exp_a_D-LZ1)-(Exp_b_D-LZ2)+BIAS
//For square root, exponent=(Exp_a_D-LZ1)/2+(Exp_a_D-LZ1)%2+C_HALF_BIAS
//For exponent, in preprorces module, (Exp_a_D-LZ1) and (Exp_b_D-LZ2) have been processed with the corresponding process for denormal numbers.

  assign Exp_add_a_D = {Sqrt_start_dly_S?{Exp_num_DI[C_EXP_FP64],Exp_num_DI[C_EXP_FP64],Exp_num_DI[C_EXP_FP64],Exp_num_DI[C_EXP_FP64:1]}:{Exp_num_DI[C_EXP_FP64],Exp_num_DI[C_EXP_FP64],Exp_num_DI}};
  assign Exp_add_b_D = {Sqrt_start_dly_S?{1'b0,{C_EXP_ZERO_FP64},Exp_num_DI[0]}:{~Exp_den_DI[C_EXP_FP64],~Exp_den_DI[C_EXP_FP64],~Exp_den_DI}};
  assign Exp_add_c_D = {Div_start_dly_S?{{C_BIAS_AONE}}:{{C_HALF_BIAS}}};
  assign Exp_result_prenorm_DN  = (Start_dly_S)?{Exp_add_a_D + Exp_add_b_D + Exp_add_c_D}:Exp_result_prenorm_DP;


  always_ff @(posedge Clk_CI, negedge Rst_RBI)
   begin
      if(~Rst_RBI)
        begin
          Exp_result_prenorm_DP <= '0;
        end
      else
        begin
          Exp_result_prenorm_DP<=  Exp_result_prenorm_DN;
        end
   end

  assign Exp_result_prenorm_DO = Exp_result_prenorm_DP;

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_div_sqrt_top_mvp.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

////////////////////////////////////////////////////////////////////////////////
// Company:        IIS @ ETHZ - Federal Institute of Technology               //
//                                                                            //
// Engineers:      Lei Li -- lile@iis.ee.ethz.ch                              //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    03/03/2018                                                 //
// Design Name:    miv_rv32_div_sqrt_top_mvp                                           //
// Module Name:    miv_rv32_div_sqrt_top_mvp.sv                                        //
// Project Name:   The shared divisor and square root                         //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:    The top of div and sqrt                                    //
//                                                                            //
//                                                                            //
// Revision Date:  12/04/2018                                                 //
//                 Lei Li                                                     //
//                 To address some requirements by Stefan and add low power   //
//                 control for special cases                                  //
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_div_sqrt_top_mvp import miv_rv32_pkg::*;

  (//Input
   input logic                            Clk_CI,
   input logic                            Rst_RBI,
   input logic                            Div_start_SI,
   input logic                            Sqrt_start_SI,

   //Input Operands
   input logic [C_OP_FP64-1:0]            Operand_a_DI,
   input logic [C_OP_FP64-1:0]            Operand_b_DI,

   // Input Control
   input logic [C_RM-1:0]                 RM_SI,    //Rounding Mode
   input logic [C_PC-1:0]                 Precision_ctl_SI, // Precision Control
   input logic [C_FS-1:0]                 Format_sel_SI,  // Format Selection,
   input logic                            Kill_SI,

   //Output Result
   output logic [C_OP_FP64-1:0]           Result_DO,

   //Output-Flags
   output logic [4:0]                     Fflags_SO,
   output logic                           Ready_SO,
   output logic                           Done_SO
 );





   //Operand components
   logic [C_EXP_FP64:0]                 Exp_a_D;
   logic [C_EXP_FP64:0]                 Exp_b_D;
   logic [C_MANT_FP64:0]                Mant_a_D;
   logic [C_MANT_FP64:0]                Mant_b_D;

   logic [C_EXP_FP64+1:0]               Exp_z_D;
   logic [C_MANT_FP64+4:0]              Mant_z_D;
   logic                                Sign_z_D;
   logic                                Start_S;
   logic [C_RM-1:0]                     RM_dly_S;
   logic                                Div_enable_S;
   logic                                Sqrt_enable_S;
   logic                                Inf_a_S;
   logic                                Inf_b_S;
   logic                                Zero_a_S;
   logic                                Zero_b_S;
   logic                                NaN_a_S;
   logic                                NaN_b_S;
   logic                                SNaN_S;
   logic                                Special_case_SB,Special_case_dly_SB;

   logic Full_precision_S;
   logic FP32_S;
   logic FP64_S;
   logic FP16_S;
   logic FP16ALT_S;


 miv_rv32_preprocess_mvp  preprocess_U0
 (
   .Clk_CI                (Clk_CI             ),
   .Rst_RBI               (Rst_RBI            ),
   .Div_start_SI          (Div_start_SI       ),
   .Sqrt_start_SI         (Sqrt_start_SI      ),
   .Ready_SI              (Ready_SO           ),
   .Operand_a_DI          (Operand_a_DI       ),
   .Operand_b_DI          (Operand_b_DI       ),
   .RM_SI                 (RM_SI              ),
   .Format_sel_SI         (Format_sel_SI      ),
   .Start_SO              (Start_S            ),
   .Exp_a_DO_norm         (Exp_a_D            ),
   .Exp_b_DO_norm         (Exp_b_D            ),
   .Mant_a_DO_norm        (Mant_a_D           ),
   .Mant_b_DO_norm        (Mant_b_D           ),
   .RM_dly_SO             (RM_dly_S           ),
   .Sign_z_DO             (Sign_z_D           ),
   .Inf_a_SO              (Inf_a_S            ),
   .Inf_b_SO              (Inf_b_S            ),
   .Zero_a_SO             (Zero_a_S           ),
   .Zero_b_SO             (Zero_b_S           ),
   .NaN_a_SO              (NaN_a_S            ),
   .NaN_b_SO              (NaN_b_S            ),
   .SNaN_SO               (SNaN_S             ),
   .Special_case_SBO      (Special_case_SB    ),
   .Special_case_dly_SBO  (Special_case_dly_SB)
   );

 miv_rv32_nrbd_nrsc_mvp   nrbd_nrsc_U0
  (
   .Clk_CI                (Clk_CI             ),
   .Rst_RBI               (Rst_RBI            ),
   .Div_start_SI          (Div_start_SI       ) ,
   .Sqrt_start_SI         (Sqrt_start_SI      ),
   .Start_SI              (Start_S            ),
   .Kill_SI               (Kill_SI            ),
   .Special_case_SBI      (Special_case_SB    ),
   .Special_case_dly_SBI  (Special_case_dly_SB),
   .Div_enable_SO         (Div_enable_S       ),
   .Sqrt_enable_SO        (Sqrt_enable_S      ),
   .Precision_ctl_SI      (Precision_ctl_SI   ),
   .Format_sel_SI         (Format_sel_SI      ),
   .Exp_a_DI              (Exp_a_D            ),
   .Exp_b_DI              (Exp_b_D            ),
   .Mant_a_DI             (Mant_a_D           ),
   .Mant_b_DI             (Mant_b_D           ),
   .Full_precision_SO     (Full_precision_S   ),
   .FP32_SO               (FP32_S             ),
   .FP64_SO               (FP64_S             ),
   .FP16_SO               (FP16_S             ),
   .FP16ALT_SO            (FP16ALT_S          ),
   .Ready_SO              (Ready_SO           ),
   .Done_SO               (Done_SO            ),
   .Exp_z_DO              (Exp_z_D            ),
   .Mant_z_DO             (Mant_z_D           )
    );


 miv_rv32_norm_div_sqrt_mvp  fpu_norm_U0
  (
   .Mant_in_DI            (Mant_z_D           ),
   .Exp_in_DI             (Exp_z_D            ),
   .Sign_in_DI            (Sign_z_D           ),
   .Div_enable_SI         (Div_enable_S       ),
   .Sqrt_enable_SI        (Sqrt_enable_S      ),
   .Inf_a_SI              (Inf_a_S            ),
   .Inf_b_SI              (Inf_b_S            ),
   .Zero_a_SI             (Zero_a_S           ),
   .Zero_b_SI             (Zero_b_S           ),
   .NaN_a_SI              (NaN_a_S            ),
   .NaN_b_SI              (NaN_b_S            ),
   .SNaN_SI               (SNaN_S             ),
   .RM_SI                 (RM_dly_S           ),
   .Full_precision_SI     (Full_precision_S   ),
   .FP32_SI               (FP32_S             ),
   .FP64_SI               (FP64_S             ),
   .FP16_SI               (FP16_S             ),
   .FP16ALT_SI            (FP16ALT_S          ),
   .Result_DO             (Result_DO          ),
   .Fflags_SO             (Fflags_SO          ) //{NV,DZ,OF,UF,NX}
   );

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_registers.v
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Common register defines for RTL designs
`ifndef COMMON_CELLS_REGISTERS_SVH_
`define COMMON_CELLS_REGISTERS_SVH_

// Abridged Summary of available FF macros:
// `FF:      asynchronous active-low reset (implicit clock and reset)
// `FFAR:    asynchronous active-high reset
// `FFARN:   asynchronous active-low reset
// `FFSR:    synchronous active-high reset
// `FFSRN:   synchronous active-low reset
// `FFNR:    without reset
// `FFL:     load-enable and asynchronous active-low reset (implicit clock and reset)
// `FFLAR:   load-enable and asynchronous active-high reset
// `FFLARN:  load-enable and asynchronous active-low reset
// `FFLARNC: load-enable and asynchronous active-low reset and synchronous active-high clear
// `FFLSR:   load-enable and synchronous active-high reset
// `FFLSRN:  load-enable and synchronous active-low reset
// `FFLNR:   load-enable without reset


// Flip-Flop with asynchronous active-low reset (implicit clock and reset)
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// Implicit:
// clk_i: clock input
// rst_ni: reset input (asynchronous, active low)
`define FF(__q, __d, __reset_value)                  \
  always_ff @(posedge clk_i or negedge rst_ni) begin \
    if (!rst_ni) begin                               \
      __q <= (__reset_value);                        \
    end else begin                                   \
      __q <= (__d);                                  \
    end                                              \
  end

// Flip-Flop with asynchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst: asynchronous reset
`define FFAR(__q, __d, __reset_value, __clk, __arst)     \
  always_ff @(posedge (__clk) or posedge (__arst)) begin \
    if (__arst) begin                                    \
      __q <= (__reset_value);                            \
    end else begin                                       \
      __q <= (__d);                                      \
    end                                                  \
  end

// Flip-Flop with asynchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFARN(__q, __d, __reset_value, __clk, __arst_n)    \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin \
    if (!__arst_n) begin                                   \
      __q <= (__reset_value);                              \
    end else begin                                         \
      __q <= (__d);                                        \
    end                                                    \
  end

// Flip-Flop with synchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_clk: reset input
`define FFSR(__q, __d, __reset_value, __clk, __reset_clk) \
  `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_clk`" *``/       \
    `endif                        \
  always_ff @(posedge (__clk)) begin                      \
    __q <= (__reset_clk) ? (__reset_value) : (__d);       \
  end

// Flip-Flop with synchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_n_clk: reset input
`define FFSRN(__q, __d, __reset_value, __clk, __reset_n_clk) \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_n_clk`" *``/        \
    `endif                        \
  always_ff @(posedge (__clk)) begin                         \
    __q <= (!__reset_n_clk) ? (__reset_value) : (__d);       \
  end

// Always-enable Flip-Flop without reset
// __q: Q output of FF
// __d: D input of FF
// __clk: clock input
`define FFNR(__q, __d, __clk)        \
  always_ff @(posedge (__clk)) begin \
    __q <= (__d);                    \
  end

// Flip-Flop with load-enable and asynchronous active-low reset (implicit clock and reset)
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// Implicit:
// clk_i: clock input
// rst_ni: reset input (asynchronous, active low)
`define FFL(__q, __d, __load, __reset_value)         \
  always_ff @(posedge clk_i or negedge rst_ni) begin \
    if (!rst_ni) begin                               \
      __q <= (__reset_value);                        \
    end else begin                                   \
      __q <= (__load) ? (__d) : (__q);               \
    end                                              \
  end

// Flip-Flop with load-enable and asynchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst: asynchronous reset
`define FFLAR(__q, __d, __load, __reset_value, __clk, __arst) \
  always_ff @(posedge (__clk) or posedge (__arst)) begin      \
    if (__arst) begin                                         \
      __q <= (__reset_value);                                 \
    end else begin                                            \
      __q <= (__load) ? (__d) : (__q);                        \
    end                                                       \
  end

// Flip-Flop with load-enable and asynchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFLARN(__q, __d, __load, __reset_value, __clk, __arst_n) \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin       \
    if (!__arst_n) begin                                         \
      __q <= (__reset_value);                                    \
    end else begin                                               \
      __q <= (__load) ? (__d) : (__q);                           \
    end                                                          \
  end

// Flip-Flop with load-enable and synchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_clk: reset input
`define FFLSR(__q, __d, __load, __reset_value, __clk, __reset_clk)       \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_clk`" *``/                      \
    `endif                        \
  always_ff @(posedge (__clk)) begin                                     \
    __q <= (__reset_clk) ? (__reset_value) : ((__load) ? (__d) : (__q)); \
  end

// Flip-Flop with load-enable and synchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_n_clk: reset input
`define FFLSRN(__q, __d, __load, __reset_value, __clk, __reset_n_clk)       \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_n_clk`" *``/                       \
    `endif                        \
  always_ff @(posedge (__clk)) begin                                        \
    __q <= (!__reset_n_clk) ? (__reset_value) : ((__load) ? (__d) : (__q)); \
  end

// Flip-Flop with load-enable and asynchronous active-low reset and synchronous clear
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __clear: assign reset value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFLARNC(__q, __d, __load, __clear, __reset_value, __clk, __arst_n) \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__clear`" *``/                       \
    `endif                        \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin                 \
    if (!__arst_n) begin                                                   \
      __q <= (__reset_value);                                              \
    end else begin                                                         \
      __q <= (__clear) ? (__reset_value) : (__load) ? (__d) : (__q);       \
    end                                                                    \
  end

// Load-enable Flip-Flop without reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __clk: clock input
`define FFLNR(__q, __d, __load, __clk) \
  always_ff @(posedge (__clk)) begin   \
    __q <= (__load) ? (__d) : (__q);   \
  end

`endif

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_sdotp_multi_wrapper.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019-2022 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Gianna Paulin <pauling@iis.ee.ethz.ch>
// Author: Luca Bertaccini <lbertaccini@iis.ee.ethz.ch>
// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_sdotp_multi_wrapper #(
  parameter miv_rv32_pkg::fmt_logic_t   FpFmtConfig = '1,
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,

  // Do not change
  localparam miv_rv32_pkg::fmt_logic_t FpSrcFmtConfig = FpFmtConfig[0] ? (FpFmtConfig & 6'b001111) : (FpFmtConfig & 6'b000101),
  localparam miv_rv32_pkg::fmt_logic_t FpDstFmtConfig = miv_rv32_pkg::get_dotp_dst_fmts(FpSrcFmtConfig),
  localparam int                     SRC_WIDTH     = miv_rv32_pkg::max_fp_width(FpSrcFmtConfig),
  localparam int                     DST_WIDTH     = 2*miv_rv32_pkg::max_fp_width(FpSrcFmtConfig), // do not change, current assumption of sdotpex_multi
  localparam int                     OPERAND_WIDTH = 4*miv_rv32_pkg::max_fp_width(FpSrcFmtConfig), // do not change, current assumption of sdotpex_multi
  localparam int unsigned NUM_FORMATS              = miv_rv32_pkg::NUM_FP_FORMATS
) (
  input logic                      clk_i,
  input logic                      rst_ni,
  // Input signals
  input logic [2:0][OPERAND_WIDTH-1:0] operands_i, // 3 operands
  input logic [NUM_FORMATS-1:0][2:0]   is_boxed_i, // 3 operands
  input miv_rv32_pkg::roundmode_e         rnd_mode_i,
  input miv_rv32_pkg::operation_e         op_i,
  input logic                          op_mod_i,
  input miv_rv32_pkg::fp_format_e         src_fmt_i,
  input miv_rv32_pkg::fp_format_e         dst_fmt_i,
  input TagType                        tag_i,
  input AuxType                        aux_i,
  // Input Handshake
  input  logic                         in_valid_i,
  output logic                         in_ready_o,
  input  logic                         flush_i,
  // Output signals
  output logic [OPERAND_WIDTH-1:0]     result_o,
  output miv_rv32_pkg::status_t           status_o,
  output logic                         extension_bit_o,
  output TagType                       tag_o,
  output AuxType                       aux_o,
  // Output handshake
  output logic                         out_valid_o,
  input  logic                         out_ready_i,
  // Indication of valid data in flight
  output logic                         busy_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned N_SRC_FMT_OPERANDS = 4;
  localparam int unsigned N_DST_FMT_OPERANDS = 1;

  // -----------------
  // Input processing
  // -----------------
  logic                             [NUM_FORMATS-1:0][DST_WIDTH-1:0] local_src_fmt_operand_a;  // lane-local operands
  logic                             [NUM_FORMATS-1:0][SRC_WIDTH-1:0] local_src_fmt_operand_b;  // lane-local operands
  logic                             [NUM_FORMATS-1:0][DST_WIDTH-1:0] local_src_fmt_operand_c;  // lane-local operands
  logic                             [NUM_FORMATS-1:0][SRC_WIDTH-1:0] local_src_fmt_operand_d;  // lane-local operands
  logic                                              [DST_WIDTH-1:0] local_dst_fmt_operands;  // lane-local operands
  logic [NUM_FORMATS-1:0][N_SRC_FMT_OPERANDS+N_DST_FMT_OPERANDS-1:0] local_is_boxed;  // lane-local operands
  logic                                          [OPERAND_WIDTH-1:0] local_result;  // lane-local operands


  // ----------------------------------
  // assign operands with dst format
  // ----------------------------------
  assign local_dst_fmt_operands = operands_i[2][DST_WIDTH-1:0];


  // ----------------------------------
  // assign operands with src format
  // ----------------------------------
  // NaN-boxing check
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_nanbox

    localparam int unsigned FP_WIDTH         = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned FP_WIDTH_MIN     = miv_rv32_pkg::minimum(SRC_WIDTH, FP_WIDTH);
    localparam int unsigned FP_WIDTH_DST_MIN = miv_rv32_pkg::minimum(DST_WIDTH, FP_WIDTH);

    logic [N_SRC_FMT_OPERANDS-1:0][FP_WIDTH_DST_MIN-1:0] tmp_operands;     // lane-local operands

    always_comb begin : nanbox
      // shift operands to correct position
      tmp_operands[0] = operands_i[0] >> 0*FP_WIDTH;
      tmp_operands[1] = operands_i[1] >> 0*FP_WIDTH;
      tmp_operands[2] = operands_i[0] >> 1*FP_WIDTH;
      tmp_operands[3] = operands_i[1] >> 1*FP_WIDTH;
      // nan-box if needed
      local_src_fmt_operand_a[fmt] = '1;
      local_src_fmt_operand_b[fmt] = '1;
      local_src_fmt_operand_c[fmt] = '1;
      local_src_fmt_operand_d[fmt] = '1;
      if (op_i == miv_rv32_pkg::VSUM) begin
        local_src_fmt_operand_a[fmt][FP_WIDTH_DST_MIN-1:0] = tmp_operands[0][FP_WIDTH_DST_MIN-1:0];
        local_src_fmt_operand_b[fmt][FP_WIDTH_MIN-1:0]     = '1;
        local_src_fmt_operand_c[fmt][FP_WIDTH_DST_MIN-1:0] = tmp_operands[2][FP_WIDTH_DST_MIN-1:0];
        local_src_fmt_operand_d[fmt][FP_WIDTH_MIN-1:0]     = '1;
      end else begin
        local_src_fmt_operand_a[fmt][FP_WIDTH_MIN-1:0] = tmp_operands[0][FP_WIDTH_MIN-1:0];
        local_src_fmt_operand_b[fmt][FP_WIDTH_MIN-1:0] = tmp_operands[1][FP_WIDTH_MIN-1:0];
        local_src_fmt_operand_c[fmt][FP_WIDTH_MIN-1:0] = tmp_operands[2][FP_WIDTH_MIN-1:0];
        local_src_fmt_operand_d[fmt][FP_WIDTH_MIN-1:0] = tmp_operands[3][FP_WIDTH_MIN-1:0];
      end
      // take is_boxed info from external or set to 1 if boxed for dotp operation
      local_is_boxed[fmt][0] = is_boxed_i[fmt][0];
      local_is_boxed[fmt][1] = is_boxed_i[fmt][1];
      local_is_boxed[fmt][2] = is_boxed_i[fmt][0];
      local_is_boxed[fmt][3] = is_boxed_i[fmt][1];
      if(FP_WIDTH <= SRC_WIDTH) begin
        local_is_boxed[fmt][0] = '1;
        local_is_boxed[fmt][1] = '1;
        local_is_boxed[fmt][2] = '1;
        local_is_boxed[fmt][3] = '1;
      end
      // for dst format sized operand keep is_boxed input
      local_is_boxed[fmt][4] = is_boxed_i[src_fmt_i][2];
    end
  end

  miv_rv32_fpnew_sdotp_multi #(
    .SrcDotpFpFmtConfig ( FpSrcFmtConfig ), // FP8, FP8ALT, FP16, FP16ALT
    .DstDotpFpFmtConfig ( FpDstFmtConfig ), // FP32, FP16, FP16ALT
    .NumPipeRegs        ( NumPipeRegs    ),
    .PipeConfig         ( PipeConfig     ),
    .TagType            ( TagType        ),
    .AuxType            ( AuxType        )
  ) i_fpnew_sdotp_multi (
    .clk_i,
    .rst_ni,
    .operand_a_i     ( local_src_fmt_operand_a[src_fmt_i] ),
    .operand_b_i     ( local_src_fmt_operand_b[src_fmt_i] ),
    .operand_c_i     ( local_src_fmt_operand_c[src_fmt_i] ),
    .operand_d_i     ( local_src_fmt_operand_d[src_fmt_i] ),
    .dst_operands_i  ( local_dst_fmt_operands             ), // 1 operand
    .is_boxed_i      ( local_is_boxed                     ),
    .rnd_mode_i,
    .op_i,
    .op_mod_i,
    .src_fmt_i, // format of the multiplicands
    .dst_fmt_i, // format of the addend and result
    .tag_i,
    .aux_i,
    .in_valid_i,
    .in_ready_o ,
    .flush_i,
    .result_o        ( local_result[DST_WIDTH-1:0] ),
    .status_o,
    .extension_bit_o,
    .tag_o,
    .aux_o,
    .out_valid_o,
    .out_ready_i,
    .busy_o
  );

  //assign local_result[2*DST_WIDTH-1:DST_WIDTH] = '1;
  assign result_o                              = local_result;

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_sdotp_multi.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019-2022 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Authors: Luca Bertaccini <lbertaccini@iis.ee.ethz.ch>
//          Stefan Mach <smach@iis.ee.ethz.ch>
//          Gianna Paulin <pauling@iis.ee.ethz.ch>

// This unit can be used to compute the following operations:
// - EXSDOTP: expanding dot product with accumulation
//             (op_a * op_b) + (op_c * op_d) + op_e
//             where op_e and the result are expressed with twice as many bits as op_a, op_b, op_c, op_d
// - EXVSUM: expanding vector inner sum
//             (op_a + op_c + op_e)
//             where op_e and the result are expressed with twice as many bits as op_a, op_c
//             EXVSUM is computed setting op_b and op_d to 1
// - VSUM:   non-expanding vector inner sum
//             (op_a + op_c + op_e)
//             where op_e and the result are expressed with as many bits as op_a, op_c
//             The bit-width can be as large as the maximum allowed destination width
//             VSUM is computed by-passing the two multiplications, thus neglecting op_b and op_d

// All the supported operations require a three-term addend (X + Y + Z). The unit first computes
// W = X + Y and then result = W + Z, where X is the maximum addend, Y is the intermediate addend
// and Z is the minimum addend.

// The unit requires two one-hot config strings to select the allowed input and output formats.
// The maximum output format should be twice as large as the maximum input format (for non-expanding
// VSUM the maximum input format is set by the maximum output format (op_a and op_c are as large
// as the accumulator and the result), then the input format is selected at run-time by the signal
// src_fmt_i.

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_sdotp_multi #(
  // One-hot config string: | FP32 | FP64 | FP16 | FP8 | FP16ALT | FP8ALT |
  parameter miv_rv32_pkg::fmt_logic_t   SrcDotpFpFmtConfig = '1, // FP32 and wider formats are not allowed
                                                              // Supported source formats (FP8, FP8ALT, FP16, FP16ALT)
  parameter miv_rv32_pkg::fmt_logic_t   DstDotpFpFmtConfig = '1, // FP8 and FP8alt are not supported
                                                              // Supported destination formats (FP16, FP16ALTt, FP32)
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
// Do not change
  localparam int unsigned SRC_WIDTH = miv_rv32_pkg::max_fp_width(SrcDotpFpFmtConfig),
  localparam int unsigned DST_WIDTH = miv_rv32_pkg::max_fp_width(DstDotpFpFmtConfig), // must be 2*SRC_WIDTH (expanding SDOTP)
  localparam int unsigned NUM_FORMATS = miv_rv32_pkg::NUM_FP_FORMATS
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  // op_a and op_c will contain useful bits in [SRC_WIDTH-1:0] for EXSDOTP, EXVSUM
  // op_a and op_c will contain useful bits in [DST_WIDTH-1:0] for VSUM (non-expanding)
  // op_b and op_d are neglected for non-expanding VSUM
  input  logic [DST_WIDTH-1:0]        operand_a_i,
  input  logic [SRC_WIDTH-1:0]        operand_b_i,
  input  logic [DST_WIDTH-1:0]        operand_c_i,
  input  logic [SRC_WIDTH-1:0]        operand_d_i,
  input  logic [DST_WIDTH-1:0]        dst_operands_i, // accumulator
  input  logic [NUM_FORMATS-1:0][4:0] is_boxed_i,     // 5 operands
  input  miv_rv32_pkg::roundmode_e       rnd_mode_i,
  input  miv_rv32_pkg::operation_e       op_i,
  input  logic                        op_mod_i,
  input  miv_rv32_pkg::fp_format_e       src_fmt_i, // format of op_a, op_b, op_c, op_d
  input  miv_rv32_pkg::fp_format_e       dst_fmt_i, // format of the accumulator (op_e) and result
  input  TagType                      tag_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [DST_WIDTH-1:0]        result_o,
  output miv_rv32_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o
);

  // ----------
  // Constants
  // ----------
  // The super-format that can hold all formats
  localparam miv_rv32_pkg::fp_encoding_t SUPER_FORMAT = miv_rv32_pkg::super_format(SrcDotpFpFmtConfig);
  localparam miv_rv32_pkg::fp_encoding_t SUPER_DST_FORMAT = miv_rv32_pkg::super_format(DstDotpFpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;
  localparam int unsigned SUPER_DST_EXP_BITS = SUPER_DST_FORMAT.exp_bits;
  localparam int unsigned SUPER_DST_MAN_BITS = miv_rv32_pkg::maximum(SUPER_DST_FORMAT.man_bits, 2*SUPER_MAN_BITS + 1);

  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = SUPER_MAN_BITS + 1;
  // Destination precision bits 'p_dst' include the implicit bit
  localparam int unsigned DST_PRECISION_BITS = SUPER_DST_MAN_BITS + 1;
  localparam int unsigned ADDITIONAL_PRECISION_BITS = miv_rv32_pkg::maximum(DST_PRECISION_BITS - 2 * PRECISION_BITS, 0);
  // The leading-zero counter operates on LZC_SUM_WIDTH bits
  localparam int unsigned LZC_SUM_WIDTH  = 2*DST_PRECISION_BITS + PRECISION_BITS + 5;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LZC_SUM_WIDTH);

  // Internal exponent width must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the miv_rv32_lzc result.
  localparam int unsigned EXP_WIDTH = (miv_rv32_pkg::maximum(SUPER_EXP_BITS + 2, LZC_RESULT_WIDTH));
  localparam int unsigned DST_EXP_WIDTH = (miv_rv32_pkg::maximum(SUPER_DST_EXP_BITS + 2, LZC_RESULT_WIDTH));
  // Shift amount width: maximum internal mantissa size is 2*DST_PRECISION_BITS+3 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(2*DST_PRECISION_BITS+PRECISION_BITS+4);
  localparam int unsigned DST_SHIFT_AMOUNT_WIDTH = $clog2(2*DST_PRECISION_BITS+PRECISION_BITS+5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == miv_rv32_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == miv_rv32_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == miv_rv32_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                      sign;
    logic [SUPER_EXP_BITS-1:0] exponent;
    logic [SUPER_MAN_BITS-1:0] mantissa;
  } fp_src_t;
  typedef struct packed {
    logic                          sign;
    logic [SUPER_DST_EXP_BITS-1:0] exponent;
    logic [SUPER_DST_MAN_BITS-1:0] mantissa;
  } fp_dst_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [DST_WIDTH-1:0]  operand_a_q;
  logic [SRC_WIDTH-1:0]  operand_b_q;
  logic [DST_WIDTH-1:0]  operand_c_q;
  logic [SRC_WIDTH-1:0]  operand_d_q;
  logic [DST_WIDTH-1:0]  dst_operands_q;
  miv_rv32_pkg::fp_format_e src_fmt_q;
  miv_rv32_pkg::fp_format_e dst_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][DST_WIDTH-1:0]        inp_pipe_operand_a_q;
  logic                  [0:NUM_INP_REGS][SRC_WIDTH-1:0]        inp_pipe_operand_b_q;
  logic                  [0:NUM_INP_REGS][DST_WIDTH-1:0]        inp_pipe_operand_c_q;
  logic                  [0:NUM_INP_REGS][SRC_WIDTH-1:0]        inp_pipe_operand_d_q;
  logic                  [0:NUM_INP_REGS][DST_WIDTH-1:0]        inp_pipe_dst_operands_q;
  logic                  [0:NUM_INP_REGS][NUM_FORMATS-1:0][4:0] inp_pipe_is_boxed_q;
  miv_rv32_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_op_mod_q;
  miv_rv32_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_src_fmt_q;
  miv_rv32_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_dst_fmt_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operand_a_q[0]    = operand_a_i;
  assign inp_pipe_operand_b_q[0]    = operand_b_i;
  assign inp_pipe_operand_c_q[0]    = operand_c_i;
  assign inp_pipe_operand_d_q[0]    = operand_d_i;
  assign inp_pipe_dst_operands_q[0] = dst_operands_i;
  assign inp_pipe_is_boxed_q[0]     = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0]     = rnd_mode_i;
  assign inp_pipe_op_q[0]           = op_i;
  assign inp_pipe_op_mod_q[0]       = op_mod_i;
  assign inp_pipe_src_fmt_q[0]      = src_fmt_i;
  assign inp_pipe_dst_fmt_q[0]      = dst_fmt_i;
  assign inp_pipe_tag_q[0]          = tag_i;
  assign inp_pipe_aux_q[0]          = aux_i;
  assign inp_pipe_valid_q[0]        = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = inp_pipe_ready[i] & inp_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operand_a_q[i+1],    inp_pipe_operand_a_q[i],    reg_ena, '0)
    `FFL(inp_pipe_operand_b_q[i+1],    inp_pipe_operand_b_q[i],    reg_ena, '0)
    `FFL(inp_pipe_operand_c_q[i+1],    inp_pipe_operand_c_q[i],    reg_ena, '0)
    `FFL(inp_pipe_operand_d_q[i+1],    inp_pipe_operand_d_q[i],    reg_ena, '0)
    `FFL(inp_pipe_dst_operands_q[i+1], inp_pipe_dst_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1],     inp_pipe_is_boxed_q[i],     reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1],     inp_pipe_rnd_mode_q[i],     reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],           inp_pipe_op_q[i],           reg_ena, miv_rv32_pkg::SDOTP)
    `FFL(inp_pipe_op_mod_q[i+1],       inp_pipe_op_mod_q[i],       reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],      inp_pipe_src_fmt_q[i],      reg_ena, miv_rv32_pkg::FP8)
    `FFL(inp_pipe_dst_fmt_q[i+1],      inp_pipe_dst_fmt_q[i],      reg_ena, miv_rv32_pkg::FP16)
    `FFL(inp_pipe_tag_q[i+1],          inp_pipe_tag_q[i],          reg_ena, TagType'('0))
    `FFL(inp_pipe_aux_q[i+1],          inp_pipe_aux_q[i],          reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operand_a_q    = inp_pipe_operand_a_q[NUM_INP_REGS];
  assign operand_b_q    = inp_pipe_operand_b_q[NUM_INP_REGS];
  assign operand_c_q    = inp_pipe_operand_c_q[NUM_INP_REGS];
  assign operand_d_q    = inp_pipe_operand_d_q[NUM_INP_REGS];
  assign dst_operands_q = inp_pipe_dst_operands_q[NUM_INP_REGS];
  assign src_fmt_q      = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q      = inp_pipe_dst_fmt_q[NUM_INP_REGS];

  logic [3:0][SRC_WIDTH-1:0] operands_post_inp_pipe;
  // vivado fix: loop is here to make it work on vivado
  for (genvar i = 0; i < SRC_WIDTH; i++) begin : gen_op_assign
    assign operands_post_inp_pipe[3][i] = operand_d_q[i];
    assign operands_post_inp_pipe[2][i] = operand_c_q[i];
    assign operands_post_inp_pipe[1][i] = operand_b_q[i];
    assign operands_post_inp_pipe[0][i] = operand_a_q[i];
  end

  // -----------------
  // Input processing
  // -----------------

  // -----------------
  // Source operands
  // -----------------
  logic        [NUM_FORMATS-1:0][3:0]                     fmt_sign;
  logic signed [NUM_FORMATS-1:0][3:0][SUPER_EXP_BITS-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][3:0][SUPER_MAN_BITS-1:0] fmt_mantissa;

  miv_rv32_pkg::fp_info_t [NUM_FORMATS-1:0][4:0] info_q;
  miv_rv32_pkg::fp_info_t [NUM_FORMATS-1:0][1:0] info_vsum_q;

  // FP Input initialization (Src)
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_src_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (SrcDotpFpFmtConfig[fmt]) begin : active_src_format
      logic [3:0][FP_WIDTH-1:0] trimmed_ops;

      // Classify input
      miv_rv32_fpnew_classifier #(
        .FpFormat    ( miv_rv32_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 4                            )
      ) i_fpnew_classifier (
        .operands_i  ( trimmed_ops                                 ),
        .is_boxed_i  ( inp_pipe_is_boxed_q[NUM_INP_REGS][fmt][3:0] ),
        .info_o      ( info_q[fmt][3:0]                            )
      );
      for (genvar op = 0; op < 4; op++) begin : gen_operands
        assign trimmed_ops[op]       = operands_post_inp_pipe[op][FP_WIDTH-1:0];
        assign fmt_sign[fmt][op]     = operands_post_inp_pipe[op][FP_WIDTH-1];
        assign fmt_exponent[fmt][op] = signed'({1'b0, operands_post_inp_pipe[op][MAN_BITS+:EXP_BITS]});
        assign fmt_mantissa[fmt][op] = {info_q[fmt][op].is_normal, operands_post_inp_pipe[op][MAN_BITS-1:0]} <<
                                       (SUPER_MAN_BITS - MAN_BITS); // move to left of mantissa
      end
    end else begin : inactive_src_format
      assign info_q[fmt][3:0]  = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]     = miv_rv32_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
    end
  end

  // ----------------------------
  // Non-expanding VSUM operands
  // ----------------------------
  logic        [NUM_FORMATS-1:0][1:0]                         fmt_vsum_sign;
  logic signed [NUM_FORMATS-1:0][1:0][SUPER_DST_EXP_BITS-1:0] fmt_vsum_exponent;
  logic        [NUM_FORMATS-1:0][1:0][SUPER_DST_MAN_BITS-1:0] fmt_vsum_mantissa;

  // FP Input initialization (Src)
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_vsum_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (DstDotpFpFmtConfig[fmt]) begin : active_vsum_format
      logic [1:0][FP_WIDTH-1:0] trimmed_vsum_ops;
      logic [1:0]               vsum_ops_is_boxed;

      assign vsum_ops_is_boxed = {inp_pipe_is_boxed_q[NUM_INP_REGS][fmt][2],
                                  inp_pipe_is_boxed_q[NUM_INP_REGS][fmt][0]};

      // Classify input
      miv_rv32_fpnew_classifier #(
        .FpFormat    ( miv_rv32_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 2                            )
      ) i_fpnew_classifier (
        .operands_i  ( trimmed_vsum_ops  ),
        .is_boxed_i  ( vsum_ops_is_boxed ),
        .info_o      ( info_vsum_q[fmt]  )
      );
      assign trimmed_vsum_ops          = {operand_c_q[FP_WIDTH-1:0], operand_a_q[FP_WIDTH-1:0]};
      assign fmt_vsum_sign[fmt]        = {operand_c_q[FP_WIDTH-1], operand_a_q[FP_WIDTH-1]};
      assign fmt_vsum_exponent[fmt][1] = signed'({1'b0, operand_c_q[MAN_BITS+:EXP_BITS]});
      assign fmt_vsum_exponent[fmt][0] = signed'({1'b0, operand_a_q[MAN_BITS+:EXP_BITS]});
      assign fmt_vsum_mantissa[fmt][1] = {info_vsum_q[fmt][1].is_normal, operand_c_q[MAN_BITS-1:0]}
                                         << (SUPER_DST_MAN_BITS - MAN_BITS);
      assign fmt_vsum_mantissa[fmt][0] = {info_vsum_q[fmt][0].is_normal, operand_a_q[MAN_BITS-1:0]}
                                         << (SUPER_DST_MAN_BITS - MAN_BITS);
    end else begin : inactive_dst_format
      assign info_vsum_q[fmt]       = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_vsum_sign[fmt]     = miv_rv32_pkg::DONT_CARE;             // format disabled
      assign fmt_vsum_exponent[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_vsum_mantissa[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
    end
  end

  // -------------------
  // Destination operand
  // -------------------
  logic        [NUM_FORMATS-1:0]                         fmt_dst_sign;
  logic signed [NUM_FORMATS-1:0][SUPER_DST_EXP_BITS-1:0] fmt_dst_exponent;
  logic        [NUM_FORMATS-1:0][SUPER_DST_MAN_BITS-1:0] fmt_dst_mantissa;

  // FP Input initialization (Src)
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_dst_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (DstDotpFpFmtConfig[fmt]) begin : active_dst_format
      logic [FP_WIDTH-1:0] trimmed_dst_ops;

      // Classify input
      miv_rv32_fpnew_classifier #(
        .FpFormat    ( miv_rv32_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 1                            )
      ) i_fpnew_classifier (
        .operands_i ( trimmed_dst_ops                           ),
        .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS][fmt][4] ),
        .info_o     ( info_q[fmt][4]                            )
      );
      assign trimmed_dst_ops       = dst_operands_q[FP_WIDTH-1:0];
      assign fmt_dst_sign[fmt]     = dst_operands_q[FP_WIDTH-1];
      assign fmt_dst_exponent[fmt] = signed'({1'b0, dst_operands_q[MAN_BITS+:EXP_BITS]});
      assign fmt_dst_mantissa[fmt] = {info_q[fmt][4].is_normal, dst_operands_q[MAN_BITS-1:0]}
                                      << (SUPER_DST_MAN_BITS - MAN_BITS); // move to left of mantissa
    end else begin : inactive_dst_format
      assign info_q[fmt][4]        = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_dst_sign[fmt]     = miv_rv32_pkg::DONT_CARE;             // format disabled
      assign fmt_dst_exponent[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_dst_mantissa[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
    end
  end

  fp_src_t             operand_a, operand_b, operand_c, operand_d;
  fp_dst_t             operand_e;
  fp_dst_t             operand_a_vsum, operand_c_vsum;
  miv_rv32_pkg::fp_info_t info_a, info_b, info_c, info_d, info_e;
  logic                a_sign, c_sign;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | SDOTP    | \c 0        | SDOTP:  none
  // | SDOTP    | \c 1        | SDOTPN: Invert the sign of the first and second products (accumulator - dotp)
  // | EXVSUM   | \c 0        | EXVSUM: none
  // | EXVSUM   | \c 1        | EXVSUM: Invert the sign of the first and second addends
  // | VSUM     | \c 0        | VSUM:   none
  // | VSUM     | \c 1        | VSUM:   Invert the sign of the first and second addends
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select
    // Default assignments - packing-order-agnostic
    operand_a = {fmt_sign[src_fmt_q][0], fmt_exponent[src_fmt_q][0], fmt_mantissa[src_fmt_q][0]};
    operand_b = {fmt_sign[src_fmt_q][1], fmt_exponent[src_fmt_q][1], fmt_mantissa[src_fmt_q][1]};
    operand_c = {fmt_sign[src_fmt_q][2], fmt_exponent[src_fmt_q][2], fmt_mantissa[src_fmt_q][2]};
    operand_d = {fmt_sign[src_fmt_q][3], fmt_exponent[src_fmt_q][3], fmt_mantissa[src_fmt_q][3]};
    operand_e = {fmt_dst_sign[dst_fmt_q], fmt_dst_exponent[dst_fmt_q], fmt_dst_mantissa[dst_fmt_q]};
    operand_a_vsum = {fmt_vsum_sign[src_fmt_q][0], fmt_vsum_exponent[src_fmt_q][0], fmt_vsum_mantissa[src_fmt_q][0]};
    operand_c_vsum = {fmt_vsum_sign[src_fmt_q][1], fmt_vsum_exponent[src_fmt_q][1], fmt_vsum_mantissa[src_fmt_q][1]};
    info_a    = info_q[src_fmt_q][0];
    info_b    = info_q[src_fmt_q][1];
    info_c    = info_q[src_fmt_q][2];
    info_d    = info_q[src_fmt_q][3];
    info_e    = info_q[dst_fmt_q][4];

    // op_mod_q inverts sign of operand A and C, thus inverting the sign of the dot product
    operand_a.sign = operand_a.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];
    a_sign    = operand_a.sign;
    c_sign    = operand_c.sign;
    // op_mod_q inverts sign of operand A and C, thus inverting the sign of the vsum
    operand_a_vsum.sign = operand_a_vsum.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];
    operand_c_vsum.sign = operand_c_vsum.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      miv_rv32_pkg::SDOTP:  ; // do nothing
      miv_rv32_pkg::VSUM: begin // Set multiplicands coming from rs1 to +1
        operand_b = '{sign: 1'b0, exponent: miv_rv32_pkg::bias(src_fmt_q), mantissa: '0};
        operand_d = '{sign: 1'b0, exponent: miv_rv32_pkg::bias(src_fmt_q), mantissa: '0};
        info_b    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
        info_d    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
        info_a    = info_vsum_q[dst_fmt_q][0];
        info_c    = info_vsum_q[dst_fmt_q][1];
        a_sign    = operand_a_vsum.sign;
        c_sign    = operand_c_vsum.sign;
      end
      miv_rv32_pkg::EXVSUM: begin // Set multiplicands coming from rs1 to +1
        operand_b = '{sign: 1'b0, exponent: miv_rv32_pkg::bias(src_fmt_q), mantissa: '0};
        operand_d = '{sign: 1'b0, exponent: miv_rv32_pkg::bias(src_fmt_q), mantissa: '0};
        info_b    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
        info_d    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: miv_rv32_pkg::DONT_CARE};
        operand_b  = '{default: miv_rv32_pkg::DONT_CARE};
        operand_c  = '{default: miv_rv32_pkg::DONT_CARE};
        info_a     = '{default: miv_rv32_pkg::DONT_CARE};
        info_b     = '{default: miv_rv32_pkg::DONT_CARE};
        info_c     = '{default: miv_rv32_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic       any_operand_inf;
  logic       any_operand_nan;
  logic       signalling_nan;
  logic [2:0] effective_subtraction;
  logic       tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf, info_b.is_inf, info_c.is_inf, info_d.is_inf, info_e.is_inf});
  assign any_operand_nan = (| {info_a.is_nan, info_b.is_nan, info_c.is_nan, info_d.is_nan, info_e.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling,
                               info_d.is_signalling, info_e.is_signalling});
  // Effective subtractions in the three-term addition
  assign effective_subtraction[0] = (a_sign ^ operand_b.sign) ^ operand_e.sign;
  assign effective_subtraction[1] = (c_sign ^ operand_d.sign) ^ operand_e.sign;
  assign effective_subtraction[2] = (a_sign ^ operand_b.sign) ^ (c_sign ^ operand_d.sign);

  // ----------------------
  // Special case handling
  // ----------------------
  logic [DST_WIDTH-1:0] special_result;
  miv_rv32_pkg::status_t   special_status;
  logic                 result_is_special;

  logic               [NUM_FORMATS-1:0][DST_WIDTH-1:0] fmt_special_result;
  miv_rv32_pkg::status_t [NUM_FORMATS-1:0]                fmt_special_status;
  logic               [NUM_FORMATS-1:0]                fmt_result_is_special;

  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);
    localparam logic [MAN_BITS-1:0] ZERO_MANTISSA = '0;

    if (DstDotpFpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_cases
        logic [FP_WIDTH-1:0] special_res;

        // Default assignment
        special_res                = {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN
        fmt_special_status[fmt]    = '0;
        fmt_result_is_special[fmt] = 1'b0;

        // Handle potentially mixed nan & infinity input => important for the case where infinity and
        // zero are multiplied and added to a qNaN.
        // RISC-V mandates raising the NV exception in these cases:
        // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
        if (  ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf))
           || ((info_c.is_inf && info_d.is_zero) || (info_c.is_zero && info_d.is_inf)) ) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass DOTP, output is the canonical qNaN
          fmt_special_status[fmt].NV = 1'b1; // invalid operation
        // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
        end else if (any_operand_nan) begin
          fmt_result_is_special[fmt] = 1'b1;           // bypass DOTP, output is the canonical qNaN
          fmt_special_status[fmt].NV = signalling_nan; // raise the invalid operation flag if signalling
        // Special cases involving infinity
        end else if (any_operand_inf) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass DOTP
          // Effective addition of opposite infinities (±inf - ±inf) is invalid!
          if ((info_a.is_inf || info_b.is_inf) && (info_c.is_inf || info_d.is_inf) && effective_subtraction[2]) begin
            fmt_special_status[fmt].NV = 1'b1; // invalid operation
          end else if (((info_a.is_inf || info_b.is_inf) && info_e.is_inf && effective_subtraction[0])
             || ((info_c.is_inf || info_d.is_inf) && info_e.is_inf && effective_subtraction[1])) begin
            fmt_special_status[fmt].NV = 1'b1; // invalid operation
          // Handle cases where output will be inf because of inf product input
          end else if (info_a.is_inf || info_b.is_inf) begin
            // Result is infinity with the sign of the first product
            special_res = {a_sign ^ operand_b.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          // Handle cases where the second product is inf
          end else if (info_c.is_inf || info_d.is_inf) begin
            // Result is infinity with sign of the second product
            special_res    = {c_sign ^ operand_d.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          end else if (info_e.is_inf) begin
            // Result is infinity with sign of the accumulator
            special_res    = {operand_e.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          end
        end
        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_special_status[fmt] = '0;
      assign fmt_result_is_special[fmt] = 1'b0;
    end
  end

  // Detect special case from source format
  assign result_is_special = fmt_result_is_special[dst_fmt_q];
  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign special_status = fmt_special_status[dst_fmt_q];
  // Assemble result according to destination format
  assign special_result = fmt_special_result[dst_fmt_q];

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0]     exponent_a, exponent_b, exponent_c, exponent_d;
  logic signed [DST_EXP_WIDTH-1:0] exponent_e;
  logic signed [DST_EXP_WIDTH-1:0] exponent_a_vsum, exponent_c_vsum;
  logic signed [DST_EXP_WIDTH-1:0] exponent_addend_x, exponent_addend_y, exponent_addend_z;
  logic signed [DST_EXP_WIDTH-1:0] exponent_product_x, exponent_product_y, exponent_difference;
  logic signed [DST_EXP_WIDTH-1:0] exponent_max, exponent_int, exponent_min;
  logic signed [DST_EXP_WIDTH-1:0] tentative_exponent;
  logic [2:0]                      exponent_cmp;
  logic                            effective_subtraction_first;
  logic                            info_min_is_zero;
  logic                            info_int_is_zero;
  logic                            info_max_is_zero;
  logic                            addend_min_sign;
  logic                            addend_int_sign;
  logic                            addend_max_sign;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_a_vsum = signed'({1'b0, operand_a_vsum.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});
  assign exponent_c_vsum = signed'({1'b0, operand_c_vsum.exponent});
  assign exponent_d = signed'({1'b0, operand_d.exponent});
  assign exponent_e = signed'({1'b0, operand_e.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents stay biased.
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product_y = (info_c.is_zero || info_d.is_zero)
                              ? 2 - signed'(miv_rv32_pkg::bias(dst_fmt_q)) // in case the product is zero, set minimum exp.
                              : signed'(exponent_c + info_c.is_subnormal
                                        + exponent_d + info_d.is_subnormal
                                        - 2*signed'(miv_rv32_pkg::bias(src_fmt_q))  // rebias for dst fmt
                                        + signed'(miv_rv32_pkg::bias(dst_fmt_q)) + 1); // adding +1 to keep into account following shifts
  assign exponent_product_x = (info_a.is_zero || info_b.is_zero)
                              ? 2 - signed'(miv_rv32_pkg::bias(dst_fmt_q)) // in case the product is zero, set minimum exp.
                              : signed'(exponent_a + info_a.is_subnormal
                                        + exponent_b + info_b.is_subnormal
                                        - 2*signed'(miv_rv32_pkg::bias(src_fmt_q))  // rebias for dst fmt
                                        + signed'(miv_rv32_pkg::bias(dst_fmt_q)) + 1); // adding +1 to keep into account following shift
  assign exponent_addend_y = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::VSUM)
                             ? signed'(exponent_c_vsum + $signed({1'b0, ~info_c.is_normal}))
                             : exponent_product_y;
  assign exponent_addend_x = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::VSUM)
                             ? signed'(exponent_a_vsum + $signed({1'b0, ~info_a.is_normal}))
                             : exponent_product_x;
  assign exponent_addend_z = signed'(exponent_e + $signed({1'b0, ~info_e.is_normal})); // 0 as subnorm

  // Find maximum, intermediate and minimum exponents
  assign exponent_cmp[2] = (exponent_addend_x >= exponent_addend_y) ? 1'b1 : 1'b0;
  assign exponent_cmp[1] = (exponent_addend_x >= exponent_addend_z) ? 1'b1 : 1'b0;
  assign exponent_cmp[0] = (exponent_addend_y >= exponent_addend_z) ? 1'b1 : 1'b0;

  // The three-term addition is performed in two steps with only a final normalization and round step
  // To prevent precision loss, first the two largest addends are summed, then the minimum addend is
  // added to the result of the first addition.

  // Find maximum, intermediate and minimum exponent
  always_comb begin : compare_exponents
    case (exponent_cmp)
      // (x < y), (x < z), (y < z)
      3'b000  : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_z, exponent_addend_y, exponent_addend_x};
        tentative_sign   = operand_e.sign; // The tentative sign of the DOTP shall be the sign of the maximum addend
        effective_subtraction_first = effective_subtraction[1];
        info_min_is_zero = info_a.is_zero || info_b.is_zero;
        info_int_is_zero = info_c.is_zero || info_d.is_zero;
        info_max_is_zero = info_e.is_zero;
        addend_min_sign  = a_sign ^ operand_b.sign;
        addend_int_sign  = c_sign ^ operand_d.sign;
        addend_max_sign  = operand_e.sign;
      end
      // // (x < y), (x < z), (y >= z) --> y >= z > x
      3'b001  : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_y, exponent_addend_z, exponent_addend_x};
        tentative_sign   = (c_sign ^ operand_d.sign);
        effective_subtraction_first = effective_subtraction[1];
        info_min_is_zero = info_a.is_zero || info_b.is_zero;
        info_int_is_zero = info_e.is_zero;
        info_max_is_zero = info_c.is_zero || info_d.is_zero;
        addend_min_sign  = a_sign ^ operand_b.sign;
        addend_int_sign  = operand_e.sign;
        addend_max_sign  = c_sign ^ operand_d.sign;
      end
      // // (x < y), (x >= z), (y < z)
      // 3'b010  : IMPOSSIBLE
      // (x < y), (x >= z), (y >= z)
      3'b011  : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_y, exponent_addend_x, exponent_addend_z};
        tentative_sign   =  (c_sign ^ operand_d.sign);
        effective_subtraction_first = effective_subtraction[2];
        info_min_is_zero = info_e.is_zero;
        info_int_is_zero = info_a.is_zero || info_b.is_zero;
        info_max_is_zero = info_c.is_zero || info_d.is_zero;
        addend_min_sign  = operand_e.sign;
        addend_int_sign  = a_sign ^ operand_b.sign;
        addend_max_sign  = c_sign ^ operand_d.sign;
      end
      // (x >= y), (x < z), (y < z)
      3'b100  : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_z, exponent_addend_x, exponent_addend_y};
        tentative_sign   = operand_e.sign;
        effective_subtraction_first = effective_subtraction[0];
        info_min_is_zero = info_c.is_zero || info_d.is_zero;
        info_int_is_zero = info_a.is_zero || info_b.is_zero;
        info_max_is_zero = info_e.is_zero;
        addend_min_sign  = c_sign ^ operand_d.sign;
        addend_int_sign  = a_sign ^ operand_b.sign;
        addend_max_sign  = operand_e.sign;
      end
      // // (x >= y), (x < z), (y >= z)
      // 3'b101  : IMPOSSIBLE
      3'b110  : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_x, exponent_addend_z, exponent_addend_y};
        tentative_sign   = (a_sign ^ operand_b.sign);
        effective_subtraction_first = effective_subtraction[0];
        info_min_is_zero = info_c.is_zero || info_d.is_zero;
        info_int_is_zero = info_e.is_zero;
        info_max_is_zero = info_a.is_zero || info_b.is_zero;
        addend_min_sign  = c_sign ^ operand_d.sign;
        addend_int_sign  = operand_e.sign;
        addend_max_sign  = a_sign ^ operand_b.sign;
      end
      // (x >= y), (x >= z), (y >= z)
      3'b111  : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_x, exponent_addend_y, exponent_addend_z};
        tentative_sign   = (a_sign ^ operand_b.sign);
        effective_subtraction_first = effective_subtraction[2];
        info_min_is_zero = info_e.is_zero;
        info_int_is_zero = info_c.is_zero || info_d.is_zero;
        info_max_is_zero = info_a.is_zero || info_b.is_zero;
        addend_min_sign  = operand_e.sign;
        addend_int_sign  = c_sign ^ operand_d.sign;
        addend_max_sign  = a_sign ^ operand_b.sign;
      end
      default : begin
        {exponent_max, exponent_int, exponent_min} = {exponent_addend_x, exponent_addend_y, exponent_addend_z};
        tentative_sign   = (a_sign ^ operand_b.sign);
        effective_subtraction_first = effective_subtraction[2];
        info_min_is_zero = info_e.is_zero;
        info_int_is_zero = info_c.is_zero || info_d.is_zero;
        info_max_is_zero = info_a.is_zero || info_b.is_zero;
        addend_min_sign  = operand_e.sign;
        addend_int_sign  = c_sign ^ operand_d.sign;
        addend_max_sign  = a_sign ^ operand_b.sign;
      end
    endcase
  end

  // Exponent difference is the maximum addend exponent minus the intermediate addend exponent,
  // where the addends are selected among the two products and the accumulator.
  // In the case of non-expanding VSUM, the two products are replaced by the larger inputs (the
  // multipliers are by-passed
  assign exponent_difference = exponent_max - exponent_int;
  // The tentative exponent will be the maximum exponent
  assign tentative_exponent = exponent_max;

  // Shift amount for product_y based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;
  always_comb begin : addend_shift_amount
    // The maximum addend and the intermediate addends have mutual bits to add
    if (exponent_difference <= signed'(2*DST_PRECISION_BITS + 3)) begin
      addend_shamt = unsigned'(signed'(exponent_difference));
    // The intermediate addend is only in the sticky bits
    end else begin
      addend_shamt = 2*DST_PRECISION_BITS + 3;
    end
  end

  // ------------------
  // Product data path
  // ------------------
  logic     [PRECISION_BITS-1:0] mantissa_a, mantissa_b, mantissa_c, mantissa_d;
  logic [DST_PRECISION_BITS-1:0] mantissa_e;
  logic [DST_PRECISION_BITS-1:0] mantissa_a_vsum, mantissa_c_vsum;
  logic   [2*PRECISION_BITS-1:0] product_x, product_y;  // the p*p product is 2p-bit wide

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};
  assign mantissa_d = {info_d.is_normal, operand_d.mantissa};
  assign mantissa_e = {info_e.is_normal, operand_e.mantissa};

  assign mantissa_a_vsum = {info_a.is_normal, operand_a_vsum.mantissa};
  assign mantissa_c_vsum = {info_c.is_normal, operand_c_vsum.mantissa};

  // Mantissa multiplier (a*b)
  assign product_x = mantissa_a * mantissa_b;
  // Mantissa multiplier (c*d)
  assign product_y = mantissa_c * mantissa_d;

  // ------------------
  // Shift data path
  // ------------------
  // The three addends are DST_PRECISION_BITS-wide since they might contain a product, which is
  // expressed with 2*PRECISION_BITS (< DST_PRECISION_BITS), or the accumulator which is expressed
  // with DST_PRECISION_BITS. In the case of non-expanding VSUM, all the operands are
  // DST_PRECISION_BITS-wide, if the largest format allowed is selected, or boxed into
  // DST_PRECISION_BITS, if a narrower format is selected.
  logic   [DST_PRECISION_BITS-1:0] addend_x, addend_y, addend_z;
  logic   [DST_PRECISION_BITS-1:0] addend_max, addend_int, addend_min;
  logic [2*DST_PRECISION_BITS+2:0] addend_max_shifted;
  logic [2*DST_PRECISION_BITS+2:0] addend_int_after_shift;
  logic   [DST_PRECISION_BITS-1:0] addend_sticky_bits;
  logic                            sticky_before_add;
  logic [2*DST_PRECISION_BITS+2:0] addend_int_shifted;
  logic                            inject_carry_in;     // inject carry for subtractions if needed

  // Bypass the multipliers in case of non-expanding VSUM
  // Place the products in the upper part of the addend in case of expanding operations (The addend
  // uses DST_PRECISION_BITS while 2*PRECISION_BITS might be narrower)
  assign addend_x = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::VSUM)
                      ? mantissa_a_vsum : product_x << ADDITIONAL_PRECISION_BITS;
  assign addend_y = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::VSUM)
                      ? mantissa_c_vsum : product_y << ADDITIONAL_PRECISION_BITS;
  assign addend_z = mantissa_e;

  // Sorting the addends
  always_comb begin : sort_addends
    case (exponent_cmp)
      // (x < y), (x < z), (y < z)
      3'b000  : {addend_max, addend_int, addend_min} = {addend_z, addend_y, addend_x};
      // (x < y), (x >= z), (y < z)
      3'b001  : {addend_max, addend_int, addend_min} = {addend_y, addend_z, addend_x};
      // // (x < y), (x < z), (y >= z) => IMPOSSIBLE
      // 3'b010  : IMPOSSIBLE
      // (x < y), (x >= z), (y >= z)
      3'b011  : {addend_max, addend_int, addend_min} = {addend_y, addend_x, addend_z};
      // (x >= y), (x < z), (y < z)
      3'b100  : {addend_max, addend_int, addend_min} = {addend_z, addend_x, addend_y};
      // // (x >= y), (x < z), (y >= z) => IMPOSSIBLE
      // 3'b101  : IMPOSSIBLE
      // (x >= y), (x >= z), (y < z)
      3'b110  : {addend_max, addend_int, addend_min} = {addend_x, addend_z, addend_y};
      // (x >= y), (x >= z), (y >= z)
      3'b111  : {addend_max, addend_int, addend_min} = {addend_x, addend_y, addend_z};
      default : {addend_max, addend_int, addend_min} = {addend_x, addend_y, addend_z};
    endcase
  end

  // Product max is placed into a 2p+3 bit wide vector. It is padded with 3 bits for rounding purposes:
  // | product_max  |  rnd  |
  //  <-  2p_dst  -> <  3   >
  assign addend_max_shifted = addend_max << (3 + DST_PRECISION_BITS); // constant shift

  // In parallel, the min product is right-shifted according to the exponent difference. Up to p_dst
  // bits are shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | addend_int | 000.....000 |
  //  <- p_dst  -> <- p_dst+3 ->
  // AFTER THE SHIFT:
  // | 000..........000 | addend_min | 000..................0GR |    sticky bits    |
  //  <- addend_shamt -> <- p_dst  -> <- p_dst+3-addend_shamt -> <-  up to p_dst  ->
  assign {addend_int_after_shift, addend_sticky_bits} =
      (addend_int << (2*DST_PRECISION_BITS + 3)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);

  // In case of a subtraction, the addend is inverted
  assign addend_int_shifted  = (effective_subtraction_first) ? ~addend_int_after_shift : addend_int_after_shift;
  assign inject_carry_in = effective_subtraction_first & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [2*DST_PRECISION_BITS+3:0] sum_raw;   // added one bit for the carry
  logic                            sum_carry; // observe carry bit from sum for sign fixing
  logic [2*DST_PRECISION_BITS+2:0] sum;       // discard carry
  logic                            final_sign;
  logic                            sum_exact_zero;

  // Mantissa adder (addend_max + addend_int)
  assign sum_raw = addend_max_shifted + addend_int_shifted + inject_carry_in;
  assign sum_carry = sum_raw[2*DST_PRECISION_BITS+3];

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction_first && ~sum_carry) ? -sum_raw : sum_raw;

  // Check whether the result is an exact zero for rounding purposes (needed to set the sign of a
  // final result equal to zero)
  assign sum_exact_zero = (sum == '0) && sum_carry && !sticky_before_add && effective_subtraction_first;
  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = sum_exact_zero ? (inp_pipe_rnd_mode_q[NUM_INP_REGS] == miv_rv32_pkg::RDN)
                                        : (effective_subtraction_first && (sum_carry == tentative_sign))
                                              ? 1'b1
                                              : (effective_subtraction_first ? 1'b0 : tentative_sign);

  // -------------
  // Second Shift
  // -------------
  logic signed [DST_EXP_WIDTH-1:0] exponent_difference_z;
  logic signed [DST_EXP_WIDTH-1:0] exponent_w;
  logic signed [DST_EXP_WIDTH-1:0] tentative_exponent_z;

  // W comes from the first addition. Adding +1 to take into account the following shift
  assign exponent_w = signed'(tentative_exponent + 1);
  // Exponent difference is the exponent of the first addition result (W) minus the minimum exponent
  assign exponent_difference_z = exponent_w - exponent_min;
  // The tentative exponent will be the larger of W exponent or the minimum exponent
  assign tentative_exponent_z  = exponent_w;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [DST_SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_z;
  logic   [2*DST_PRECISION_BITS+PRECISION_BITS+3:0] addend_min_after_shift;
  logic     [DST_PRECISION_BITS-1:0] addend_sticky_bits_z;  // up to p_dst bit of shifted addend are sticky
  logic                              sticky_before_add_z;   // they are compressed into a single sticky bit

  always_comb begin : addend_shift_amount_z
    // The result of the first addition and the minimum addends have mutual bits to add
    if (exponent_difference_z <= signed'(2 * DST_PRECISION_BITS + PRECISION_BITS + 4)) begin
      addend_shamt_z = unsigned'(signed'(exponent_difference_z));
    // The minimum addend is only in the sticky bits
    end else begin
      addend_shamt_z = 2 * DST_PRECISION_BITS + PRECISION_BITS + 4;
    end
  end

  // Shift the minimum addend
  // BEFORE THE SHIFT:
  // | addend_min | 000.....000 |
  //  <- p_dst  -> <- p_dst+4 ->
  // AFTER THE SHIFT:
  // | 000............000 | addend_min | 000.....................0GR |    sticky bits    |
  //  <- addend_shamt_z -> <- p_dst  -> <- p_dst+4-addend_shamt_z -> <-  up to p_dst  ->
  assign {addend_min_after_shift, addend_sticky_bits_z} =
      (addend_min << (2 * DST_PRECISION_BITS + PRECISION_BITS + 4)) >> addend_shamt_z;

  assign sticky_before_add_z     = (| addend_sticky_bits_z);

  // In case of result of both the first and second addition zero, some more checks need to be
  // performed to select the right final sign.
  logic final_sign_zero;
  always_comb begin
    final_sign_zero = addend_max_sign;
    if (info_max_is_zero && !info_int_is_zero && !info_min_is_zero) begin
      if (exponent_int > exponent_min) begin
        final_sign_zero = addend_int_sign;
      end else if (addend_int > addend_min) begin
        final_sign_zero = addend_int_sign;
      end else if (addend_int == addend_min) begin
        final_sign_zero = (addend_max_sign) ? addend_int_sign | addend_min_sign : addend_int_sign & addend_min_sign;
      end else begin
        final_sign_zero = addend_min_sign;
      end
    end else if (info_max_is_zero && info_int_is_zero && !info_min_is_zero) begin
      final_sign_zero = addend_min_sign;
    end else if (info_max_is_zero && info_int_is_zero && info_min_is_zero) begin
      final_sign_zero = (addend_max_sign) ? addend_int_sign | addend_min_sign : addend_int_sign & addend_min_sign;
    end else if (info_max_is_zero && !info_int_is_zero && info_min_is_zero) begin
      final_sign_zero = addend_int_sign;
    end
  end

  // -----------------
  // Internal pipeline
  // -----------------
  // Pipeline output signals as non-arrays
  logic                            effective_subtraction_first_q;
  logic                            final_sign_zero_q;
  logic                            info_min_is_zero_q;
  logic                            info_max_is_zero_q;
  logic                            addend_min_sign_q;
  logic                            sum_exact_zero_q;
  logic [DST_PRECISION_BITS-1:0]   addend_min_q;
  logic signed [DST_EXP_WIDTH-1:0] exponent_w_q;
  logic                            sticky_before_add_z_q;   // they are compressed into a single sticky bit
  logic [2*DST_PRECISION_BITS+PRECISION_BITS+3:0] addend_min_after_shift_q;
  logic                            operand_e_sign_q;
  logic                            product_x_sign_q;
  logic                            product_y_sign_q;
  logic [2:0]                      exponent_cmp_q;
  logic signed [DST_EXP_WIDTH-1:0] exponent_min_q;
  logic                            sticky_before_add_q;
  logic [2*DST_PRECISION_BITS+2:0] sum_q;
  logic                            final_sign_q;
  miv_rv32_pkg::fp_format_e           dst_fmt_q2;
  miv_rv32_pkg::roundmode_e           rnd_mode_q;
  logic                            result_is_special_q;
  fp_dst_t                         special_result_q;
  miv_rv32_pkg::status_t              special_status_q;
  logic                            sum_carry_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                           mid_pipe_eff_sub_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_final_sign_zero_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_info_min_is_zero_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_info_max_is_zero_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_addend_min_sign_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_sum_exact_zero_q;
  logic                  [0:NUM_MID_REGS][DST_PRECISION_BITS-1:0]   mid_pipe_addend_min_q;
  logic signed           [0:NUM_MID_REGS][DST_EXP_WIDTH-1:0]        mid_pipe_exp_first_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_sticky_before_add_z_q;
  logic                  [0:NUM_MID_REGS][2*DST_PRECISION_BITS+PRECISION_BITS+3:0] mid_pipe_add_min_after_shift_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_op_e_sign_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_prod_x_sign_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_prod_y_sign_q;
  logic                  [0:NUM_MID_REGS][2:0]                      mid_pipe_exp_cmp_q;
  logic signed           [0:NUM_MID_REGS][DST_EXP_WIDTH-1:0]        mid_pipe_exp_min_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][2*DST_PRECISION_BITS+2:0] mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_final_sign_q;
  miv_rv32_pkg::fp_format_e [0:NUM_MID_REGS]                           mid_pipe_dst_fmt_q;
  miv_rv32_pkg::roundmode_e [0:NUM_MID_REGS]                           mid_pipe_rnd_mode_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_res_is_spec_q;
  fp_dst_t               [0:NUM_MID_REGS]                           mid_pipe_spec_res_q;
  miv_rv32_pkg::status_t    [0:NUM_MID_REGS]                           mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                           mid_pipe_tag_q;
  AuxType                [0:NUM_MID_REGS]                           mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_valid_q;
  logic                  [0:NUM_MID_REGS]                           mid_pipe_sum_carry_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]                = effective_subtraction_first;
  assign mid_pipe_final_sign_zero_q[0]        = final_sign_zero;
  assign mid_pipe_info_min_is_zero_q[0]       = info_min_is_zero;
  assign mid_pipe_info_max_is_zero_q[0]       = info_max_is_zero;
  assign mid_pipe_addend_min_sign_q[0]        = addend_min_sign;
  assign mid_pipe_sum_exact_zero_q[0]         = sum_exact_zero;
  assign mid_pipe_addend_min_q[0]             = addend_min;
  assign mid_pipe_exp_first_q[0]              = exponent_w;
  assign mid_pipe_sticky_before_add_z_q[0]    = sticky_before_add_z;
  assign mid_pipe_add_min_after_shift_q[0]    = addend_min_after_shift;
  assign mid_pipe_op_e_sign_q[0]              = operand_e.sign;
  assign mid_pipe_prod_x_sign_q[0]            = (a_sign ^ operand_b.sign);
  assign mid_pipe_prod_y_sign_q[0]            = (c_sign ^ operand_d.sign);
  assign mid_pipe_exp_cmp_q[0]                = exponent_cmp;
  assign mid_pipe_exp_min_q[0]                = exponent_min;
  assign mid_pipe_sticky_q[0]                 = sticky_before_add;
  assign mid_pipe_sum_q[0]                    = sum;
  assign mid_pipe_final_sign_q[0]             = final_sign;
  assign mid_pipe_rnd_mode_q[0]               = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_dst_fmt_q[0]                = dst_fmt_q;
  assign mid_pipe_res_is_spec_q[0]            = result_is_special;
  assign mid_pipe_spec_res_q[0]               = special_result;
  assign mid_pipe_spec_stat_q[0]              = special_status;
  assign mid_pipe_tag_q[0]                    = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]                    = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]                  = inp_pipe_valid_q[NUM_INP_REGS];
  assign mid_pipe_sum_carry_q[0]              = sum_carry;
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS]         = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = mid_pipe_ready[i] & mid_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],             mid_pipe_eff_sub_q[i],             reg_ena, '0)
    `FFL(mid_pipe_final_sign_zero_q[i+1],     mid_pipe_final_sign_zero_q[i],     reg_ena, '0)
    `FFL(mid_pipe_info_min_is_zero_q[i+1],    mid_pipe_info_min_is_zero_q[i],    reg_ena, '0)
    `FFL(mid_pipe_info_max_is_zero_q[i+1],    mid_pipe_info_max_is_zero_q[i],    reg_ena, '0)
    `FFL(mid_pipe_addend_min_sign_q[i+1],     mid_pipe_addend_min_sign_q[i],     reg_ena, '0)
    `FFL(mid_pipe_sum_exact_zero_q[i+1],      mid_pipe_sum_exact_zero_q[i],      reg_ena, '0)
    `FFL(mid_pipe_addend_min_q[i+1],          mid_pipe_addend_min_q[i],          reg_ena, '0)
    `FFL(mid_pipe_exp_first_q[i+1],           mid_pipe_exp_first_q[i],           reg_ena, '0)
    `FFL(mid_pipe_sticky_before_add_z_q[i+1], mid_pipe_sticky_before_add_z_q[i], reg_ena, '0)
    `FFL(mid_pipe_add_min_after_shift_q[i+1], mid_pipe_add_min_after_shift_q[i], reg_ena, '0)
    `FFL(mid_pipe_op_e_sign_q[i+1],           mid_pipe_op_e_sign_q[i],           reg_ena, '0)
    `FFL(mid_pipe_prod_x_sign_q[i+1],         mid_pipe_prod_x_sign_q[i],         reg_ena, '0)
    `FFL(mid_pipe_prod_y_sign_q[i+1],         mid_pipe_prod_y_sign_q[i],         reg_ena, '0)
    `FFL(mid_pipe_exp_cmp_q[i+1],             mid_pipe_exp_cmp_q[i],             reg_ena, '0)
    `FFL(mid_pipe_exp_min_q[i+1],             mid_pipe_exp_min_q[i],             reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],              mid_pipe_sticky_q[i],              reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],                 mid_pipe_sum_q[i],                 reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],          mid_pipe_final_sign_q[i],          reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],            mid_pipe_rnd_mode_q[i],            reg_ena, miv_rv32_pkg::RNE)
    `FFL(mid_pipe_dst_fmt_q[i+1],             mid_pipe_dst_fmt_q[i],             reg_ena, miv_rv32_pkg::FP16)
    `FFL(mid_pipe_res_is_spec_q[i+1],         mid_pipe_res_is_spec_q[i],         reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],            mid_pipe_spec_res_q[i],            reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],           mid_pipe_spec_stat_q[i],           reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],                 mid_pipe_tag_q[i],                 reg_ena, TagType'('0))
    `FFL(mid_pipe_aux_q[i+1],                 mid_pipe_aux_q[i],                 reg_ena, AuxType'('0))
    `FFL(mid_pipe_sum_carry_q[i+1],           mid_pipe_sum_carry_q[i],           reg_ena, '0)
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign sum_carry_q                   = mid_pipe_sum_carry_q[NUM_MID_REGS];
  assign addend_min_q                  = mid_pipe_addend_min_q[NUM_MID_REGS];
  assign final_sign_zero_q             = mid_pipe_final_sign_zero_q[NUM_MID_REGS];
  assign info_min_is_zero_q            = mid_pipe_info_min_is_zero_q[NUM_MID_REGS];
  assign info_max_is_zero_q            = mid_pipe_info_max_is_zero_q[NUM_MID_REGS];
  assign addend_min_sign_q             = mid_pipe_addend_min_sign_q[NUM_MID_REGS];
  assign sum_exact_zero_q              = mid_pipe_sum_exact_zero_q[NUM_MID_REGS];
  assign effective_subtraction_first_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_w_q                  = mid_pipe_exp_first_q[NUM_MID_REGS];
  assign sticky_before_add_z_q         = mid_pipe_sticky_before_add_z_q[NUM_MID_REGS];
  assign addend_min_after_shift_q      = mid_pipe_add_min_after_shift_q[NUM_MID_REGS];
  assign operand_e_sign_q              = mid_pipe_op_e_sign_q[NUM_MID_REGS];
  assign product_x_sign_q              = mid_pipe_prod_x_sign_q[NUM_MID_REGS];
  assign product_y_sign_q              = mid_pipe_prod_y_sign_q[NUM_MID_REGS];
  assign exponent_cmp_q                = mid_pipe_exp_cmp_q[NUM_MID_REGS];
  assign exponent_min_q                = mid_pipe_exp_min_q[NUM_MID_REGS];
  assign sticky_before_add_q           = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                         = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q                  = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q                    = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign dst_fmt_q2                    = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign result_is_special_q           = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q              = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q              = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // ----------------------------------
  // Second Step of the Three-way Adder
  // ----------------------------------
  // Bypass the first addition in the case of result of the first addition equal to zero and
  // minimum addend not equal to zero.
  // Without bypassing, that situation might result in precision loss since the minimum addend is
  // shifted in parallel with the first sum (i.e. if the minimum addend is much smaller than 0,
  // it might have been shifted out before knowning that the result of the first addition was 0)
  logic bypass_w;
  assign bypass_w = sum_exact_zero_q && !info_min_is_zero_q && sticky_before_add_z_q;

  logic [2*DST_PRECISION_BITS+3:0] mantissa_w;
  logic [2*DST_PRECISION_BITS+PRECISION_BITS+3:0] mantissa_w_shifted;

  logic                            tentative_sign_z;
  logic                            effective_subtraction_z;
  logic signed [DST_EXP_WIDTH-1:0] final_tentative_exponent;

  assign final_tentative_exponent = (bypass_w) ? (exponent_min_q >= 0) ? exponent_min_q : 1'b0
                                               : exponent_w_q;

  assign mantissa_w = {sum_carry_q && ~effective_subtraction_first_q, sum_q};
  assign mantissa_w_shifted = mantissa_w << PRECISION_BITS;

  // The tentative sign shall be the sign of the first addition
  assign tentative_sign_z = (bypass_w) ? addend_min_sign_q : final_sign_q;

  always_comb begin
    case (exponent_cmp_q)
      3'b000  :  effective_subtraction_z = product_x_sign_q ^ tentative_sign_z;
      3'b001  :  effective_subtraction_z = product_x_sign_q ^ tentative_sign_z;
      3'b011  :  effective_subtraction_z = operand_e_sign_q ^ tentative_sign_z;
      3'b100  :  effective_subtraction_z = product_y_sign_q ^ tentative_sign_z;
      3'b110  :  effective_subtraction_z = product_y_sign_q ^ tentative_sign_z;
      3'b111  :  effective_subtraction_z = operand_e_sign_q ^ tentative_sign_z;
      default :  effective_subtraction_z = operand_e_sign_q ^ tentative_sign_z;
    endcase
  end

  logic [2*DST_PRECISION_BITS+PRECISION_BITS+3:0] addend_min_shifted;
  logic                            inject_carry_in_z; // inject carry for subtractions if needed

  // In case of a subtraction, the addend is inverted
  assign addend_min_shifted  = (effective_subtraction_z) ? ~addend_min_after_shift_q : addend_min_after_shift_q;
  assign inject_carry_in_z = effective_subtraction_z & ~sticky_before_add_z_q;

  // ------
  // Adder
  // ------
  logic [2*DST_PRECISION_BITS+PRECISION_BITS+4:0] sum_raw_z;   // added one bit for the carry
  logic                            sum_carry_z; // observe carry bit from sum for sign fixing
  logic [2*DST_PRECISION_BITS+PRECISION_BITS+3:0] sum_z;       // discard carry as sum won't overflow
  logic                            final_sign_z;

  // Mantissa adder (W+Z)
  assign sum_raw_z    = (bypass_w) ? (exponent_min_q > 0) ? addend_min_q << (DST_PRECISION_BITS+PRECISION_BITS+4)
                                                          : (addend_min_q << (DST_PRECISION_BITS+PRECISION_BITS+4))
                                                            >> signed'(-exponent_min_q+1)
                                   : mantissa_w_shifted + addend_min_shifted + inject_carry_in_z;
  assign sum_carry_z  = sum_raw_z[2*DST_PRECISION_BITS +PRECISION_BITS+ 4];

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum_z        = (effective_subtraction_z && ~sum_carry_z) ? -sum_raw_z : sum_raw_z;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign_z = (effective_subtraction_z && (sum_carry_z == tentative_sign_z))
                            ? 1'b1
                            : (effective_subtraction_z ? 1'b0 : tentative_sign_z);

  // --------------
  // Normalization
  // --------------
  logic        [LZC_SUM_WIDTH-1:0]    sum_lower;              // LZC_SUM_WIDTH bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [DST_SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [DST_EXP_WIDTH-1:0]          normalized_exponent;

  logic [2*DST_PRECISION_BITS+PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic     [DST_PRECISION_BITS:0] final_mantissa;    // final mantissa before rounding with round bit
  logic   [DST_PRECISION_BITS+PRECISION_BITS+2:0] sum_sticky_bits;   // remaining p_dst+3 sticky bits after normalization
  logic                            sticky_after_norm; // sticky bit after normalization

  logic signed [DST_EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = {(~effective_subtraction_z && sum_carry_z), sum_z};

  // Leading zero counter for cancellations
  miv_rv32_lzc #(
    .WIDTH ( LZC_SUM_WIDTH   ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and miv_rv32_lzc (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
   if ((final_tentative_exponent - leading_zero_count_sgn + 1 > 0) && !lzc_zeroes) begin
      // Remove the counted zeroes
      if (leading_zero_count > 0) begin
        norm_shamt          = leading_zero_count - 1;
        normalized_exponent = final_tentative_exponent - leading_zero_count_sgn + 1; // account for shift
      end else begin
        norm_shamt          = '0;
        normalized_exponent = final_tentative_exponent;
      end
    // Subnormal result
    end else begin
      // Cap the shift distance to align mantissa with minimum exponent
      if (final_tentative_exponent > 0)
        norm_shamt          = final_tentative_exponent - 1;
      else
        norm_shamt          = '0;
      normalized_exponent = '0; // subnormals encoded as 0
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_lower << norm_shamt;

  // Further 1-bit normalization since the leading-one can be to the left or right of the (non-carry)
  // MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[2*DST_PRECISION_BITS+PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[2*DST_PRECISION_BITS+PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits coming from the first addition
  always_comb begin
    sticky_after_norm = (| {sum_sticky_bits}) | (sticky_before_add_z_q && ~bypass_w) | sticky_before_add_q;
    if (sticky_before_add_q && !effective_subtraction_first_q && !sticky_before_add_z_q
        && effective_subtraction_z && (sum_sticky_bits == '0) && !info_min_is_zero_q) begin
      sticky_after_norm = 1'b0;
    end
    if (sticky_before_add_q && effective_subtraction_first_q && !sticky_before_add_z_q
       && !effective_subtraction_z && (sum_sticky_bits == '0) && !info_min_is_zero_q) begin
      sticky_after_norm = 1'b0;
    end
  end

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                                             pre_round_sign;
  logic [SUPER_DST_EXP_BITS+SUPER_DST_MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                                       round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][SUPER_DST_EXP_BITS+SUPER_DST_MAN_BITS-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0][1:0]                                       fmt_round_sticky_bits;

  logic [NUM_FORMATS-1:0]                           fmt_of_after_round;
  logic [NUM_FORMATS-1:0]                           fmt_uf_after_round;

  logic                                             rounded_sign;
  logic [SUPER_DST_EXP_BITS+SUPER_DST_MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding
  logic                                             result_zero;

  // Classification before round. RISC-V mandates checking underflow AFTER rounding
  assign of_before_round = final_exponent >= 2**(miv_rv32_pkg::exp_bits(dst_fmt_q2))-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    logic [EXP_BITS-1:0] pre_round_exponent;
    logic [MAN_BITS-1:0] pre_round_mantissa;

    if (DstDotpFpFmtConfig[fmt]) begin : active_dst_format

      assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : final_exponent[EXP_BITS-1:0];
      assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[SUPER_DST_MAN_BITS-:MAN_BITS];
      // Assemble result before rounding. In case of overflow, the largest normal value is set.
      assign fmt_pre_round_abs[fmt] = {pre_round_exponent, pre_round_mantissa}; // 0-extend

      // Round bit is after mantissa (1 in case of overflow for rounding)
      assign fmt_round_sticky_bits[fmt][1] = final_mantissa[SUPER_DST_MAN_BITS-MAN_BITS] |
                                             of_before_round;

      // remaining bits in mantissa to sticky (1 in case of overflow for rounding)
      if (MAN_BITS < SUPER_DST_MAN_BITS) begin : narrow_sticky
        assign fmt_round_sticky_bits[fmt][0] = (| final_mantissa[SUPER_DST_MAN_BITS-MAN_BITS-1:0]) |
                                               sticky_after_norm | of_before_round;
      end else begin : normal_sticky
        assign fmt_round_sticky_bits[fmt][0] = sticky_after_norm | of_before_round;
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_round_sticky_bits[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_abs      = fmt_pre_round_abs[dst_fmt_q2];

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = fmt_round_sticky_bits[dst_fmt_q2];
  assign pre_round_sign     = (info_max_is_zero_q && (pre_round_abs == '0) && (| round_sticky_bits))
                              ? final_sign_zero_q : final_sign_z;

  // Perform the rounding
  miv_rv32_fpnew_rounding #(
    .AbsWidth ( SUPER_DST_EXP_BITS + SUPER_DST_MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_z ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             ),
    .op_i                    ( op_i                    )
  );

  logic [NUM_FORMATS-1:0][DST_WIDTH-1:0] fmt_result;

  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (DstDotpFpFmtConfig[fmt]) begin : active_dst_format
      always_comb begin : post_process
        // detect of / uf
        fmt_uf_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // denormal
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones.
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = miv_rv32_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = miv_rv32_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = fmt_of_after_round[dst_fmt_q2];

  // -----------------
  // Result selection
  // -----------------
  logic [DST_WIDTH-1:0] regular_result;
  miv_rv32_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result    = fmt_result[dst_fmt_q2];
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  logic [DST_WIDTH-1:0] result_d;
  miv_rv32_pkg::status_t   status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][DST_WIDTH-1:0] out_pipe_result_q;
  miv_rv32_pkg::status_t [0:NUM_OUT_REGS]                out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]                out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]                out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]                out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = out_pipe_ready[i] & out_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_cast_multi.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_cast_multi #(
  parameter miv_rv32_pkg::fmt_logic_t   FpFmtConfig  = '1,
  parameter miv_rv32_pkg::ifmt_logic_t  IntFmtConfig = '1,
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = miv_rv32_pkg::maximum(miv_rv32_pkg::max_fp_width(FpFmtConfig),
                                                     miv_rv32_pkg::max_int_width(IntFmtConfig)),
  localparam int unsigned NUM_FORMATS = miv_rv32_pkg::NUM_FP_FORMATS
) (
  input  logic                   clk_i,
  input  logic                   rst_ni,
  // Input signals
  input  logic [WIDTH-1:0]       operands_i, // 1 operand
  input  logic [NUM_FORMATS-1:0] is_boxed_i, // 1 operand
  input  miv_rv32_pkg::roundmode_e  rnd_mode_i,
  input  miv_rv32_pkg::operation_e  op_i,
  input  logic                   op_mod_i,
  input  miv_rv32_pkg::fp_format_e  src_fmt_i,
  input  miv_rv32_pkg::fp_format_e  dst_fmt_i,
  input  miv_rv32_pkg::int_format_e int_fmt_i,
  input  TagType                 tag_i,
  input  AuxType                 aux_i,
  // Input Handshake
  input  logic                   in_valid_i,
  output logic                   in_ready_o,
  input  logic                   flush_i,
  // Output signals
  output logic [WIDTH-1:0]       result_o,
  output miv_rv32_pkg::status_t     status_o,
  output logic                   extension_bit_o,
  output TagType                 tag_o,
  output AuxType                 aux_o,
  // Output handshake
  output logic                   out_valid_o,
  input  logic                   out_ready_i,
  // Indication of valid data in flight
  output logic                   busy_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned NUM_INT_FORMATS = miv_rv32_pkg::NUM_INT_FORMATS;
  localparam int unsigned MAX_INT_WIDTH   = miv_rv32_pkg::max_int_width(IntFmtConfig);

  localparam miv_rv32_pkg::fp_encoding_t SUPER_FORMAT = miv_rv32_pkg::super_format(FpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;
  localparam int unsigned SUPER_BIAS     = 2**(SUPER_EXP_BITS - 1) - 1;

  // The internal mantissa includes normal bit or an entire integer
  localparam int unsigned INT_MAN_WIDTH = miv_rv32_pkg::maximum(SUPER_MAN_BITS + 1, MAX_INT_WIDTH);
  // If needed, there will be a miv_rv32_lzc for renormalization
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(INT_MAN_WIDTH);
  // The internal exponent must be able to represent the smallest denormal input value as signed
  // or the number of bits in an integer
  localparam int unsigned INT_EXP_WIDTH = miv_rv32_pkg::maximum($clog2(MAX_INT_WIDTH),
      miv_rv32_pkg::maximum(SUPER_EXP_BITS, $clog2(SUPER_BIAS + SUPER_MAN_BITS))) + 1;
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == miv_rv32_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == miv_rv32_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == miv_rv32_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [WIDTH-1:0]       operands_q;
  logic [NUM_FORMATS-1:0] is_boxed_q;
  logic                   op_mod_q;
  miv_rv32_pkg::fp_format_e  src_fmt_q;
  miv_rv32_pkg::fp_format_e  dst_fmt_q;
  miv_rv32_pkg::int_format_e int_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                   [0:NUM_INP_REGS][WIDTH-1:0]       inp_pipe_operands_q;
  logic                   [0:NUM_INP_REGS][NUM_FORMATS-1:0] inp_pipe_is_boxed_q;
  miv_rv32_pkg::roundmode_e  [0:NUM_INP_REGS]                  inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e  [0:NUM_INP_REGS]                  inp_pipe_op_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_op_mod_q;
  miv_rv32_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_src_fmt_q;
  miv_rv32_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_dst_fmt_q;
  miv_rv32_pkg::int_format_e [0:NUM_INP_REGS]                  inp_pipe_int_fmt_q;
  TagType                 [0:NUM_INP_REGS]                  inp_pipe_tag_q;
  AuxType                 [0:NUM_INP_REGS]                  inp_pipe_aux_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_int_fmt_q[0]  = int_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = inp_pipe_ready[i] & inp_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, miv_rv32_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(inp_pipe_int_fmt_q[i+1],  inp_pipe_int_fmt_q[i],  reg_ena, miv_rv32_pkg::int_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign is_boxed_q = inp_pipe_is_boxed_q[NUM_INP_REGS];
  assign op_mod_q   = inp_pipe_op_mod_q[NUM_INP_REGS];
  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];
  assign int_fmt_q  = inp_pipe_int_fmt_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic src_is_int, dst_is_int; // if 0, it's a float

  assign src_is_int = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::I2F);
  assign dst_is_int = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::F2I);

  logic [INT_MAN_WIDTH-1:0] encoded_mant; // input mantissa with implicit bit

  logic        [NUM_FORMATS-1:0]                    fmt_sign;
  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][INT_MAN_WIDTH-1:0] fmt_mantissa;
  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_shift_compensation; // for miv_rv32_lzc

  miv_rv32_pkg::fp_info_t [NUM_FORMATS-1:0] info;

  logic [NUM_INT_FORMATS-1:0][INT_MAN_WIDTH-1:0] ifmt_input_val;
  logic                                          int_sign;
  logic [INT_MAN_WIDTH-1:0]                      int_value, int_mantissa;

  // FP Input initialization
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      // Classify input
      miv_rv32_fpnew_classifier #(
        .FpFormat    ( miv_rv32_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 1                            )
      ) i_fpnew_classifier (
        .operands_i ( operands_q[FP_WIDTH-1:0] ),
        .is_boxed_i ( is_boxed_q[fmt]          ),
        .info_o     ( info[fmt]                )
      );

      assign fmt_sign[fmt]     = operands_q[FP_WIDTH-1];
      assign fmt_exponent[fmt] = signed'({1'b0, operands_q[MAN_BITS+:EXP_BITS]});
      assign fmt_mantissa[fmt] = {info[fmt].is_normal, operands_q[MAN_BITS-1:0]}; // zero pad
      // Compensation for the difference in mantissa widths used for leading-zero count
      assign fmt_shift_compensation[fmt] = signed'(INT_MAN_WIDTH - 1 - MAN_BITS);
    end else begin : inactive_format
      assign info[fmt]                   = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]               = miv_rv32_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt]           = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt]           = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_shift_compensation[fmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
    end
  end

  // Sign-extend INT input
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_sign_extend_int
    // Set up some constants
    localparam int unsigned INT_WIDTH = miv_rv32_pkg::int_width(miv_rv32_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format // only active formats
      always_comb begin : sign_ext_input
        // sign-extend value only if it's signed
        ifmt_input_val[ifmt]                = '{default: operands_q[INT_WIDTH-1] & ~op_mod_q};
        ifmt_input_val[ifmt][INT_WIDTH-1:0] = operands_q[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_input_val[ifmt] = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
    end
  end

  // Construct input mantissa from integer
  assign int_value    = ifmt_input_val[int_fmt_q];
  assign int_sign     = int_value[INT_MAN_WIDTH-1] & ~op_mod_q; // only signed ints are negative
  assign int_mantissa = int_sign ? unsigned'(-int_value) : int_value; // get magnitude of negative

  // select mantissa with source format
  assign encoded_mant = src_is_int ? int_mantissa : fmt_mantissa[src_fmt_q];

  // --------------
  // Normalization
  // --------------
  logic signed [INT_EXP_WIDTH-1:0] src_bias;      // src format bias
  logic signed [INT_EXP_WIDTH-1:0] src_exp;       // src format exponent (biased)
  logic signed [INT_EXP_WIDTH-1:0] src_subnormal; // src is subnormal
  logic signed [INT_EXP_WIDTH-1:0] src_offset;    // src offset within mantissa

  assign src_bias      = signed'(miv_rv32_pkg::bias(src_fmt_q));
  assign src_exp       = fmt_exponent[src_fmt_q];
  assign src_subnormal = signed'({1'b0, info[src_fmt_q].is_subnormal});
  assign src_offset    = fmt_shift_compensation[src_fmt_q];

  logic                            input_sign;   // input sign
  logic signed [INT_EXP_WIDTH-1:0] input_exp;    // unbiased true exponent
  logic        [INT_MAN_WIDTH-1:0] input_mant;   // normalized input mantissa
  logic                            mant_is_zero; // for integer zeroes

  logic signed [INT_EXP_WIDTH-1:0] fp_input_exp;
  logic signed [INT_EXP_WIDTH-1:0] int_input_exp;

  // Input mantissa needs to be normalized
  logic [LZC_RESULT_WIDTH-1:0] renorm_shamt;     // renormalization shift amount
  logic [LZC_RESULT_WIDTH:0]   renorm_shamt_sgn; // signed form for calculations

  // Leading-zero counter is needed for renormalization
  miv_rv32_lzc #(
    .WIDTH ( INT_MAN_WIDTH ),
    .MODE  ( 1             ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( encoded_mant ),
    .cnt_o   ( renorm_shamt ),
    .empty_o ( mant_is_zero )
  );
  assign renorm_shamt_sgn = signed'({1'b0, renorm_shamt});

  // Get the sign from the proper source
  assign input_sign = src_is_int ? int_sign : fmt_sign[src_fmt_q];
  // Realign input mantissa, append zeroes if destination is wider
  assign input_mant = encoded_mant << renorm_shamt;
  // Unbias exponent and compensate for shift
  assign fp_input_exp  = signed'(src_exp + src_subnormal - src_bias -
                                 renorm_shamt_sgn + src_offset); // compensate for shift
  assign int_input_exp = signed'(INT_MAN_WIDTH - 1 - renorm_shamt_sgn);

  assign input_exp     = src_is_int ? int_input_exp : fp_input_exp;

  logic signed [INT_EXP_WIDTH-1:0] destination_exp;  // re-biased exponent for destination

  // Rebias the exponent
  assign destination_exp = input_exp + signed'(miv_rv32_pkg::bias(dst_fmt_q));

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                            input_sign_q;
  logic signed [INT_EXP_WIDTH-1:0] input_exp_q;
  logic [INT_MAN_WIDTH-1:0]        input_mant_q;
  logic signed [INT_EXP_WIDTH-1:0] destination_exp_q;
  logic                            src_is_int_q;
  logic                            dst_is_int_q;
  miv_rv32_pkg::fp_info_t             info_q;
  logic                            mant_is_zero_q;
  logic                            op_mod_q2;
  miv_rv32_pkg::roundmode_e           rnd_mode_q;
  miv_rv32_pkg::fp_format_e           src_fmt_q2;
  miv_rv32_pkg::fp_format_e           dst_fmt_q2;
  miv_rv32_pkg::int_format_e          int_fmt_q2;
  // Internal pipeline signals, index i holds signal after i register stages


  logic                   [0:NUM_MID_REGS]                    mid_pipe_input_sign_q;
  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_input_exp_q;
  logic                   [0:NUM_MID_REGS][INT_MAN_WIDTH-1:0] mid_pipe_input_mant_q;
  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_dest_exp_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_src_is_int_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_dst_is_int_q;
  miv_rv32_pkg::fp_info_t    [0:NUM_MID_REGS]                    mid_pipe_info_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_mant_zero_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_op_mod_q;
  miv_rv32_pkg::roundmode_e  [0:NUM_MID_REGS]                    mid_pipe_rnd_mode_q;
  miv_rv32_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_src_fmt_q;
  miv_rv32_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_dst_fmt_q;
  miv_rv32_pkg::int_format_e [0:NUM_MID_REGS]                    mid_pipe_int_fmt_q;
  TagType                 [0:NUM_MID_REGS]                    mid_pipe_tag_q;
  AuxType                 [0:NUM_MID_REGS]                    mid_pipe_aux_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_input_sign_q[0] = input_sign;
  assign mid_pipe_input_exp_q[0]  = input_exp;
  assign mid_pipe_input_mant_q[0] = input_mant;
  assign mid_pipe_dest_exp_q[0]   = destination_exp;
  assign mid_pipe_src_is_int_q[0] = src_is_int;
  assign mid_pipe_dst_is_int_q[0] = dst_is_int;
  assign mid_pipe_info_q[0]       = info[src_fmt_q];
  assign mid_pipe_mant_zero_q[0]  = mant_is_zero;
  assign mid_pipe_op_mod_q[0]     = op_mod_q;
  assign mid_pipe_rnd_mode_q[0]   = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_src_fmt_q[0]    = src_fmt_q;
  assign mid_pipe_dst_fmt_q[0]    = dst_fmt_q;
  assign mid_pipe_int_fmt_q[0]    = int_fmt_q;
  assign mid_pipe_tag_q[0]        = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]        = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]      = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = mid_pipe_ready[i] & mid_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_input_sign_q[i+1], mid_pipe_input_sign_q[i], reg_ena, '0)
    `FFL(mid_pipe_input_exp_q[i+1],  mid_pipe_input_exp_q[i],  reg_ena, '0)
    `FFL(mid_pipe_input_mant_q[i+1], mid_pipe_input_mant_q[i], reg_ena, '0)
    `FFL(mid_pipe_dest_exp_q[i+1],   mid_pipe_dest_exp_q[i],   reg_ena, '0)
    `FFL(mid_pipe_src_is_int_q[i+1], mid_pipe_src_is_int_q[i], reg_ena, '0)
    `FFL(mid_pipe_dst_is_int_q[i+1], mid_pipe_dst_is_int_q[i], reg_ena, '0)
    `FFL(mid_pipe_info_q[i+1],       mid_pipe_info_q[i],       reg_ena, '0)
    `FFL(mid_pipe_mant_zero_q[i+1],  mid_pipe_mant_zero_q[i],  reg_ena, '0)
    `FFL(mid_pipe_op_mod_q[i+1],     mid_pipe_op_mod_q[i],     reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],   mid_pipe_rnd_mode_q[i],   reg_ena, miv_rv32_pkg::RNE)
    `FFL(mid_pipe_src_fmt_q[i+1],    mid_pipe_src_fmt_q[i],    reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(mid_pipe_dst_fmt_q[i+1],    mid_pipe_dst_fmt_q[i],    reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(mid_pipe_int_fmt_q[i+1],    mid_pipe_int_fmt_q[i],    reg_ena, miv_rv32_pkg::int_format_e'(0))
    `FFL(mid_pipe_tag_q[i+1],        mid_pipe_tag_q[i],        reg_ena, TagType'('0))
    `FFL(mid_pipe_aux_q[i+1],        mid_pipe_aux_q[i],        reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign input_sign_q      = mid_pipe_input_sign_q[NUM_MID_REGS];
  assign input_exp_q       = mid_pipe_input_exp_q[NUM_MID_REGS];
  assign input_mant_q      = mid_pipe_input_mant_q[NUM_MID_REGS];
  assign destination_exp_q = mid_pipe_dest_exp_q[NUM_MID_REGS];
  assign src_is_int_q      = mid_pipe_src_is_int_q[NUM_MID_REGS];
  assign dst_is_int_q      = mid_pipe_dst_is_int_q[NUM_MID_REGS];
  assign info_q            = mid_pipe_info_q[NUM_MID_REGS];
  assign mant_is_zero_q    = mid_pipe_mant_zero_q[NUM_MID_REGS];
  assign op_mod_q2         = mid_pipe_op_mod_q[NUM_MID_REGS];
  assign rnd_mode_q        = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign src_fmt_q2        = mid_pipe_src_fmt_q[NUM_MID_REGS];
  assign dst_fmt_q2        = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign int_fmt_q2        = mid_pipe_int_fmt_q[NUM_MID_REGS];

  // --------
  // Casting
  // --------
  logic [INT_EXP_WIDTH-1:0] final_exp;        // after eventual adjustments

  logic [2*INT_MAN_WIDTH:0]  preshift_mant;    // mantissa before final shift
  logic [2*INT_MAN_WIDTH:0]  destination_mant; // mantissa from shifter, with rnd bit
  logic [SUPER_MAN_BITS-1:0] final_mant;       // mantissa after adjustments
  logic [MAX_INT_WIDTH-1:0]  final_int;        // integer shifted in position

  logic [$clog2(INT_MAN_WIDTH+1)-1:0] denorm_shamt; // shift amount for denormalization

  logic [1:0] fp_round_sticky_bits, int_round_sticky_bits, round_sticky_bits;
  logic       of_before_round, uf_before_round;


  // Perform adjustments to mantissa and exponent
  always_comb begin : cast_value
    // Default assignment
    final_exp       = unsigned'(destination_exp_q); // take exponent as is, only look at lower bits
    preshift_mant   = '0;  // initialize mantissa container with zeroes
    denorm_shamt    = SUPER_MAN_BITS - miv_rv32_pkg::man_bits(dst_fmt_q2); // right of mantissa
    of_before_round = 1'b0;
    uf_before_round = 1'b0;

    // Place mantissa to the left of the shifter
    preshift_mant = input_mant_q << (INT_MAN_WIDTH + 1);

    // Handle INT casts
    if (dst_is_int_q) begin
      // By default right shift mantissa to be an integer
      denorm_shamt = unsigned'(MAX_INT_WIDTH - 1 - input_exp_q);
      // overflow: when converting to unsigned the range is larger by one
      if (input_exp_q >= signed'(miv_rv32_pkg::int_width(int_fmt_q2) - 1 + op_mod_q2)) begin
        denorm_shamt    = '0; // prevent shifting
        of_before_round = 1'b1;
      // underflow
      end else if (input_exp_q < -1) begin
        denorm_shamt    = MAX_INT_WIDTH + 1; // all bits go to the sticky
        uf_before_round = 1'b1;
      end
    // Handle FP over-/underflows
    end else begin
      // Overflow or infinities (for proper rounding)
      if ((destination_exp_q >= signed'(2**miv_rv32_pkg::exp_bits(dst_fmt_q2))-1) ||
          (~src_is_int_q && info_q.is_inf)) begin
        final_exp       = unsigned'(2**miv_rv32_pkg::exp_bits(dst_fmt_q2)-2); // largest normal value
        preshift_mant   = '1;                           // largest normal value and RS bits set
        of_before_round = 1'b1;
      // Denormalize underflowing values
      end else if (destination_exp_q < 1 &&
                   destination_exp_q >= -signed'(miv_rv32_pkg::man_bits(dst_fmt_q2))) begin
        final_exp       = '0; // denormal result
        denorm_shamt    = unsigned'(denorm_shamt + 1 - destination_exp_q); // adjust right shifting
        uf_before_round = 1'b1;
      // Limit the shift to retain sticky bits
      end else if (destination_exp_q < -signed'(miv_rv32_pkg::man_bits(dst_fmt_q2))) begin
        final_exp       = '0; // denormal result
        denorm_shamt    = unsigned'(denorm_shamt + 2 + miv_rv32_pkg::man_bits(dst_fmt_q2)); // to sticky
        uf_before_round = 1'b1;
      end
    end
  end

  localparam NUM_FP_STICKY  = 2 * INT_MAN_WIDTH - SUPER_MAN_BITS - 1; // removed mantissa, 1. and R
  localparam NUM_INT_STICKY = 2 * INT_MAN_WIDTH - MAX_INT_WIDTH; // removed int and R

  // Mantissa adjustment shift
  assign destination_mant = preshift_mant >> denorm_shamt;
  // Extract final mantissa and round bit, discard the normal bit (for FP)
  assign {final_mant, fp_round_sticky_bits[1]} =
      destination_mant[2*INT_MAN_WIDTH-1-:SUPER_MAN_BITS+1];
  assign {final_int, int_round_sticky_bits[1]} = destination_mant[2*INT_MAN_WIDTH-:MAX_INT_WIDTH+1];
  // Collapse sticky bits
  assign fp_round_sticky_bits[0]  = (| {destination_mant[NUM_FP_STICKY-1:0]});
  assign int_round_sticky_bits[0] = (| {destination_mant[NUM_INT_STICKY-1:0]});

  // select RS bits for destination operation
  assign round_sticky_bits = dst_is_int_q ? int_round_sticky_bits : fp_round_sticky_bits;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic [WIDTH-1:0] pre_round_abs;  // absolute value of result before rnd
  logic             of_after_round; // overflow
  logic             uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0]            fmt_of_after_round;
  logic [NUM_FORMATS-1:0]            fmt_uf_after_round;

  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_pre_round_abs; // per format
  logic [NUM_INT_FORMATS-1:0]            ifmt_of_after_round;

  logic             rounded_sign;
  logic [WIDTH-1:0] rounded_abs; // absolute value of result after rounding
  logic             result_true_zero;

  logic [WIDTH-1:0] rounded_int_res; // after possible inversion
  logic             rounded_int_res_zero; // after rounding


  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : assemble_result
        fmt_pre_round_abs[fmt] = {final_exp[EXP_BITS-1:0], final_mant[MAN_BITS-1:0]}; // 0-extend
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Sign-extend integer result
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_res_sign_ext
    // Set up some constants
    localparam int unsigned INT_WIDTH = miv_rv32_pkg::int_width(miv_rv32_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : assemble_result
        // sign-extend reusult
        ifmt_pre_round_abs[ifmt]                = '{default: final_int[INT_WIDTH-1]};
        ifmt_pre_round_abs[ifmt][INT_WIDTH-1:0] = final_int[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_pre_round_abs[ifmt] = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Select output with destination format and operation
  assign pre_round_abs = dst_is_int_q ? ifmt_pre_round_abs[int_fmt_q2] : fmt_pre_round_abs[dst_fmt_q2];

  miv_rv32_fpnew_rounding #(
    .AbsWidth ( WIDTH )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs     ),
    .sign_i                  ( input_sign_q      ), // source format
    .round_sticky_bits_i     ( round_sticky_bits ),
    .rnd_mode_i              ( rnd_mode_q        ),
    .effective_subtraction_i ( 1'b0              ), // no operation happened
    .abs_rounded_o           ( rounded_abs       ),
    .sign_o                  ( rounded_sign      ),
    .exact_zero_o            ( result_true_zero  ),
    .op_i                    ( op_i              )
  );

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;

  // Detect overflows and inject sign
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : post_process
        // detect of / uf
        fmt_uf_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // denormal
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones. Int zeroes need to be detected`
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = src_is_int_q & mant_is_zero_q
                                        ? '0
                                        : {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = miv_rv32_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = miv_rv32_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Negative integer result needs to be brought into two's complement
  assign rounded_int_res      = rounded_sign ? unsigned'(-rounded_abs) : rounded_abs;
  assign rounded_int_res_zero = (rounded_int_res == '0);

  // Detect integer overflows after rounding (only positives)
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_overflow
    // Set up some constants
    localparam int unsigned INT_WIDTH = miv_rv32_pkg::int_width(miv_rv32_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : detect_overflow
        ifmt_of_after_round[ifmt] = 1'b0;
        // Int result can overflow if we're at the max exponent
        if (!rounded_sign && input_exp_q == signed'(INT_WIDTH - 2 + op_mod_q2)) begin
          // Check whether the rounded MSB differs from unrounded MSB
          ifmt_of_after_round[ifmt] = ~rounded_int_res[INT_WIDTH-2+op_mod_q2];
        end
      end
    end else begin : inactive_format
      assign ifmt_of_after_round[ifmt] = miv_rv32_pkg::DONT_CARE;
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = dst_is_int_q ? ifmt_of_after_round[int_fmt_q2] : fmt_of_after_round[dst_fmt_q2];

  // -------------------------
  // FP Special case handling
  // -------------------------
  logic [WIDTH-1:0]   fp_special_result;
  miv_rv32_pkg::status_t fp_special_status;
  logic               fp_result_is_special;

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_special_result;

  // Special result construction
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_results
        logic [FP_WIDTH-1:0] special_res;
        special_res = info_q.is_zero
                      ? input_sign_q << FP_WIDTH-1 // signed zero
                      : {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN

        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Detect special case from source format, I2F casts don't produce a special result
  assign fp_result_is_special = ~src_is_int_q & (info_q.is_zero |
                                                 info_q.is_nan |
                                                 ~info_q.is_boxed);

  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign fp_special_status = '{NV: info_q.is_signalling, default: 1'b0};

  // Assemble result according to destination format
  assign fp_special_result = fmt_special_result[dst_fmt_q2]; // destination format

  // --------------------------
  // INT Special case handling
  // --------------------------
  logic [WIDTH-1:0]   int_special_result;
  miv_rv32_pkg::status_t int_special_status;
  logic               int_result_is_special;

  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_special_result;

  // Special result construction
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_special_results_int
    // Set up some constants
    localparam int unsigned INT_WIDTH = miv_rv32_pkg::int_width(miv_rv32_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : special_results
        automatic logic [INT_WIDTH-1:0] special_res;

        // Default is overflow to positive max, which is 2**INT_WIDTH-1 or 2**(INT_WIDTH-1)-1
        special_res[INT_WIDTH-2:0] = '1;       // alone yields 2**(INT_WIDTH-1)-1
        special_res[INT_WIDTH-1]   = op_mod_q2; // for unsigned casts yields 2**INT_WIDTH-1

        // Negative special case (except for nans) tie to -max or 0
        if (input_sign_q && !info_q.is_nan)
          special_res = ~special_res;

        // Initialize special result with sign-extension
        ifmt_special_result[ifmt]                = '{default: special_res[INT_WIDTH-1]};
        ifmt_special_result[ifmt][INT_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign ifmt_special_result[ifmt] = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Detect special case from source format (inf, nan, overflow, nan-boxing or negative unsigned)
  assign int_result_is_special = info_q.is_nan | info_q.is_inf |
                                 of_before_round | of_after_round | ~info_q.is_boxed |
                                 (input_sign_q & op_mod_q2 & ~rounded_int_res_zero);

  // All integer special cases are invalid
  assign int_special_status = '{NV: 1'b1, default: 1'b0};

  // Assemble result according to destination format
  assign int_special_result = ifmt_special_result[int_fmt_q2]; // destination format

  // -----------------
  // Result selection
  // -----------------
  miv_rv32_pkg::status_t int_regular_status, fp_regular_status;

  logic [WIDTH-1:0]   fp_result, int_result;
  miv_rv32_pkg::status_t fp_status, int_status;

  assign fp_regular_status.NV = src_is_int_q & (of_before_round | of_after_round); // overflow is invalid for I2F casts
  assign fp_regular_status.DZ = 1'b0; // no divisions
  assign fp_regular_status.OF = ~src_is_int_q & (~info_q.is_inf & (of_before_round | of_after_round)); // inf casts no OF
  assign fp_regular_status.UF = uf_after_round & fp_regular_status.NX;
  assign fp_regular_status.NX = src_is_int_q ? (| fp_round_sticky_bits) // overflow is invalid in i2f
            : (| fp_round_sticky_bits) | (~info_q.is_inf & (of_before_round | of_after_round));
  assign int_regular_status = '{NX: (| int_round_sticky_bits), default: 1'b0};

  assign fp_result  = fp_result_is_special  ? fp_special_result  : fmt_result[dst_fmt_q2];
  assign fp_status  = fp_result_is_special  ? fp_special_status  : fp_regular_status;
  assign int_result = int_result_is_special ? int_special_result : rounded_int_res;
  assign int_status = int_result_is_special ? int_special_status : int_regular_status;

  // Final results for output pipeline
  logic [WIDTH-1:0]   result_d;
  miv_rv32_pkg::status_t status_d;
  logic               extension_bit;

  // Select output depending on special case detection
  assign result_d = dst_is_int_q ? int_result : fp_result;
  assign status_d = dst_is_int_q ? int_status : fp_status;

  // MSB of int result decides extension, otherwise NaN box
  assign extension_bit = dst_is_int_q ? int_result[WIDTH-1] : 1'b1;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  miv_rv32_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_ext_bit_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0]  = result_d;
  assign out_pipe_status_q[0]  = status_d;
  assign out_pipe_ext_bit_q[0] = extension_bit;
  assign out_pipe_tag_q[0]     = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]     = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]   = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = out_pipe_ready[i] & out_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1],  out_pipe_result_q[i],  reg_ena, '0)
    `FFL(out_pipe_status_q[i+1],  out_pipe_status_q[i],  reg_ena, '0)
    `FFL(out_pipe_ext_bit_q[i+1], out_pipe_ext_bit_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],     out_pipe_tag_q[i],     reg_ena, TagType'('0))
    `FFL(out_pipe_aux_q[i+1],     out_pipe_aux_q[i],     reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = out_pipe_ext_bit_q[NUM_OUT_REGS];
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_classifier.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module miv_rv32_fpnew_classifier #(
  parameter miv_rv32_pkg::fp_format_e   FpFormat = miv_rv32_pkg::fp_format_e'(0),
  parameter int unsigned             NumOperands = 1,
  // Do not change
  localparam int unsigned WIDTH = miv_rv32_pkg::fp_width(FpFormat)
) (
  input  logic                [NumOperands-1:0][WIDTH-1:0] operands_i,
  input  logic                [NumOperands-1:0]            is_boxed_i,
  output miv_rv32_pkg::fp_info_t [NumOperands-1:0]            info_o
);

  localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(FpFormat);

  // Type definition
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // Iterate through all operands
  for (genvar op = 0; op < int'(NumOperands); op++) begin : gen_num_values

    fp_t value;
    logic is_boxed;
    logic is_normal;
    logic is_inf;
    logic is_nan;
    logic is_signalling;
    logic is_quiet;
    logic is_zero;
    logic is_subnormal;

    // ---------------
    // Classify Input
    // ---------------
    always_comb begin : classify_input
      value         = operands_i[op];
      is_boxed      = is_boxed_i[op];
      is_normal     = is_boxed && (value.exponent != '0) && (value.exponent != '1);
      is_zero       = is_boxed && (value.exponent == '0) && (value.mantissa == '0);
      is_subnormal  = is_boxed && (value.exponent == '0) && !is_zero;
      is_inf        = is_boxed && ((value.exponent == '1) && (value.mantissa == '0));
      is_nan        = !is_boxed || ((value.exponent == '1) && (value.mantissa != '0));
      is_signalling = is_boxed && is_nan && (value.mantissa[MAN_BITS-1] == 1'b0);
      is_quiet      = is_nan && !is_signalling;
      // Assign output for current input
      info_o[op].is_normal     = is_normal;
      info_o[op].is_subnormal  = is_subnormal;
      info_o[op].is_zero       = is_zero;
      info_o[op].is_inf        = is_inf;
      info_o[op].is_nan        = is_nan;
      info_o[op].is_signalling = is_signalling;
      info_o[op].is_quiet      = is_quiet;
      info_o[op].is_boxed      = is_boxed;
    end
  end
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_divsqrt_multi.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_divsqrt_multi #(
  parameter miv_rv32_pkg::fmt_logic_t   FpFmtConfig  = '1,
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::AFTER,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = miv_rv32_pkg::max_fp_width(FpFmtConfig),
  localparam int unsigned NUM_FORMATS = miv_rv32_pkg::NUM_FP_FORMATS
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [1:0][WIDTH-1:0]       operands_i, // 2 operands
  input  logic [NUM_FORMATS-1:0][1:0] is_boxed_i, // 2 operands
  input  miv_rv32_pkg::roundmode_e       rnd_mode_i,
  input  miv_rv32_pkg::operation_e       op_i,
  input  miv_rv32_pkg::fp_format_e       dst_fmt_i,
  input  TagType                      tag_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output miv_rv32_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o
);

  // ----------
  // Constants
  // ----------
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == miv_rv32_pkg::BEFORE)
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = (PipeConfig == miv_rv32_pkg::AFTER || PipeConfig == miv_rv32_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [1:0][WIDTH-1:0] operands_q;
  miv_rv32_pkg::roundmode_e rnd_mode_q;
  miv_rv32_pkg::operation_e op_q;
  miv_rv32_pkg::fp_format_e dst_fmt_q;
  logic                  in_valid_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0]       inp_pipe_operands_q;
  miv_rv32_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  miv_rv32_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_dst_fmt_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = inp_pipe_ready[i] & inp_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, miv_rv32_pkg::FMADD)
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign rnd_mode_q = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign op_q       = inp_pipe_op_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];
  assign in_valid_q = inp_pipe_valid_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic [1:0]       divsqrt_fmt;
  logic [1:0][63:0] divsqrt_operands; // those are fixed to 64bit
  logic             input_is_fp8;

  // Translate fpnew formats into divsqrt formats
  always_comb begin : translate_fmt
    unique case (dst_fmt_q)
      miv_rv32_pkg::FP32:    divsqrt_fmt = 2'b00;
      miv_rv32_pkg::FP64:    divsqrt_fmt = 2'b01;
      miv_rv32_pkg::FP16:    divsqrt_fmt = 2'b10;
      miv_rv32_pkg::FP16ALT: divsqrt_fmt = 2'b11;
      default:            divsqrt_fmt = 2'b10; // maps also FP8 to FP16
    endcase

    // Only if FP8 is enabled
    input_is_fp8 = FpFmtConfig[miv_rv32_pkg::FP8] & (dst_fmt_q == miv_rv32_pkg::FP8);

    // If FP8 is supported, map it to an FP16 value
    divsqrt_operands[0] = input_is_fp8 ? operands_q[0] << 8 : operands_q[0];
    divsqrt_operands[1] = input_is_fp8 ? operands_q[1] << 8 : operands_q[1];
  end

  // ------------
  // Control FSM
  // ------------
  logic in_ready;               // input handshake with upstream
  logic div_valid, sqrt_valid;  // input signalling with unit
  logic unit_ready, unit_done;  // status signals from unit instance
  logic op_starting;            // high in the cycle a new operation starts
  logic out_valid, out_ready;   // output handshake with downstream
  logic hold_result;            // whether to put result into hold register
  logic data_is_held;           // data in hold register is valid
  logic unit_busy;              // valid data in flight
  // FSM states
  typedef enum logic [1:0] {IDLE, BUSY, HOLD} fsm_state_e;
  fsm_state_e state_q, state_d;

  // Upstream ready comes from sanitization FSM
  assign inp_pipe_ready[NUM_INP_REGS] = in_ready;

  // Valids are gated by the FSM ready. Invalid input ops run a sqrt to not lose illegal instr.
  assign div_valid   = in_valid_q & (op_q == miv_rv32_pkg::DIV) & in_ready & ~flush_i;
  assign sqrt_valid  = in_valid_q & (op_q != miv_rv32_pkg::DIV) & in_ready & ~flush_i;
  assign op_starting = div_valid | sqrt_valid;

  // FSM to safely apply and receive data from DIVSQRT unit
  always_comb begin : flag_fsm
    // Default assignments
    in_ready     = 1'b0;
    out_valid    = 1'b0;
    hold_result  = 1'b0;
    data_is_held = 1'b0;
    unit_busy    = 1'b0;
    state_d      = state_q;

    unique case (state_q)
      // Waiting for work
      IDLE: begin
        in_ready = 1'b1; // we're ready
        if (in_valid_q && unit_ready) begin // New work arrives
          state_d = BUSY; // go into processing state
        end
      end
      // Operation in progress
      BUSY: begin
        unit_busy = 1'b1; // data in flight
        // If the unit is done with processing
        if (unit_done) begin
          out_valid = 1'b1; // try to commit result downstream
          // If downstream accepts our result
          if (out_ready) begin
            state_d = IDLE; // we anticipate going back to idling..
            if (in_valid_q && unit_ready) begin // ..unless new work comes in
              in_ready = 1'b1; // we acknowledge the instruction
              state_d  = BUSY; // and stay busy with it
            end
          // Otherwise if downstream is not ready for the result
          end else begin
            hold_result = 1'b1; // activate the hold register
            state_d     = HOLD; // wait for the pipeline to take the data
          end
        end
      end
      // Waiting with valid result for downstream
      HOLD: begin
        unit_busy    = 1'b1; // data in flight
        data_is_held = 1'b1; // data in hold register is valid
        out_valid    = 1'b1; // try to commit result downstream
        // If the result is accepted by downstream
        if (out_ready) begin
          state_d = IDLE; // go back to idle..
          if (in_valid_q && unit_ready) begin // ..unless new work comes in
            in_ready = 1'b1; // acknowledge the new transaction
            state_d  = BUSY; // will be busy with the next instruction
          end
        end
      end
      // fall into idle state otherwise
      default: state_d = IDLE;
    endcase

    // Flushing overrides the other actions
    if (flush_i) begin
      unit_busy = 1'b0; // data is invalidated
      out_valid = 1'b0; // cancel any valid data
      state_d   = IDLE; // go to default state
    end
  end

  // FSM status register (asynch active low reset)
  `FF(state_q, state_d, IDLE)

  // Hold additional information while the operation is in progress
  logic result_is_fp8_q;
  TagType result_tag_q;
  AuxType result_aux_q;

  // Fill the registers everytime a valid operation arrives (load FF, active low asynch rst)
  `FFL(result_is_fp8_q, input_is_fp8,                 op_starting, '0)
  `FFL(result_tag_q,    inp_pipe_tag_q[NUM_INP_REGS], op_starting, '0)
  `FFL(result_aux_q,    inp_pipe_aux_q[NUM_INP_REGS], op_starting, '0)

  // -----------------
  // DIVSQRT instance
  // -----------------
  logic [63:0]        unit_result;
  logic [WIDTH-1:0]   adjusted_result, held_result_q;
  miv_rv32_pkg::status_t unit_status, held_status_q;

  miv_rv32_div_sqrt_top_mvp i_divsqrt_lei (
   .Clk_CI           ( clk_i               ),
   .Rst_RBI          ( rst_ni              ),
   .Div_start_SI     ( div_valid           ),
   .Sqrt_start_SI    ( sqrt_valid          ),
   .Operand_a_DI     ( divsqrt_operands[0] ),
   .Operand_b_DI     ( divsqrt_operands[1] ),
   .RM_SI            ( rnd_mode_q          ),
   .Precision_ctl_SI ( '0                  ),
   .Format_sel_SI    ( divsqrt_fmt         ),
   .Kill_SI          ( flush_i             ),
   .Result_DO        ( unit_result         ),
   .Fflags_SO        ( unit_status         ),
   .Ready_SO         ( unit_ready          ),
   .Done_SO          ( unit_done           )
  );

  // Adjust result width and fix FP8
  assign adjusted_result = result_is_fp8_q ? unit_result >> 8 : unit_result;

  // The Hold register (load, no reset)
  `FFLNR(held_result_q, adjusted_result, hold_result, clk_i)
  `FFLNR(held_status_q, unit_status,     hold_result, clk_i)

  // --------------
  // Output Select
  // --------------
  logic [WIDTH-1:0]   result_d;
  miv_rv32_pkg::status_t status_d;
  // Prioritize hold register data
  assign result_d = data_is_held ? held_result_q : adjusted_result;
  assign status_d = data_is_held ? held_status_q : unit_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  miv_rv32_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = result_tag_q;
  assign out_pipe_aux_q[0]    = result_aux_q;
  assign out_pipe_valid_q[0]  = out_valid;
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign out_ready = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = out_pipe_ready[i] & out_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, unit_busy, out_pipe_valid_q});
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_fma.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_fma #(
  parameter miv_rv32_pkg::fp_format_e   FpFormat    = miv_rv32_pkg::fp_format_e'(0),
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  parameter                          NO_MACC_BLK = 0,

  localparam int unsigned WIDTH = miv_rv32_pkg::fp_width(FpFormat) // do not change
) (
  input logic                      clk_i,
  input logic                      rst_ni,
  // Input signals
  input logic [2:0][WIDTH-1:0]     operands_i, // 3 operands
  input logic [2:0]                is_boxed_i, // 3 operands
  input miv_rv32_pkg::roundmode_e     rnd_mode_i,
  input miv_rv32_pkg::operation_e     op_i,
  input logic                      op_mod_i,
  input TagType                    tag_i,
  input AuxType                    aux_i,
  // Input Handshake
  input  logic                     in_valid_i,
  output logic                     in_ready_o,
  input  logic                     flush_i,
  // Output signals
  output logic [WIDTH-1:0]         result_o,
  output miv_rv32_pkg::status_t       status_o,
  output logic                     extension_bit_o,
  output TagType                   tag_o,
  output AuxType                   aux_o,
  // Output handshake
  output logic                     out_valid_o,
  input  logic                     out_ready_i,
  // Indication of valid data in flight
  output logic                     busy_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(FpFormat);
  localparam int unsigned BIAS     = miv_rv32_pkg::bias(FpFormat);
  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = MAN_BITS + 1;
  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection
  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);
  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the miv_rv32_lzc result.
  // In most reasonable FP formats the internal exponent will be wider than the miv_rv32_lzc result.
  localparam int unsigned EXP_WIDTH = (miv_rv32_pkg::maximum(EXP_BITS + 2, LZC_RESULT_WIDTH));
  // Shift amount width: maximum internal mantissa size is 3p+4 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == miv_rv32_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == miv_rv32_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == miv_rv32_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0] inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][2:0]            inp_pipe_is_boxed_q;
  miv_rv32_pkg::roundmode_e [0:NUM_INP_REGS]                 inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e [0:NUM_INP_REGS]                 inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_op_mod_q;
  TagType                [0:NUM_INP_REGS]                 inp_pipe_tag_q;
  AuxType                [0:NUM_INP_REGS]                 inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = inp_pipe_ready[i] & inp_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, miv_rv32_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end

  // -----------------
  // Input processing
  // -----------------
  miv_rv32_pkg::fp_info_t [2:0] info_q;

  // Classify input
  miv_rv32_fpnew_classifier #(
    .FpFormat    ( FpFormat ),
    .NumOperands ( 3        )
    ) i_class_inputs (
    .operands_i ( inp_pipe_operands_q[NUM_INP_REGS] ),
    .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS] ),
    .info_o     ( info_q                            )
  );

  fp_t                 operand_a, operand_b, operand_c;
  miv_rv32_pkg::fp_info_t info_a,    info_b,    info_c;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | FMADD    | \c 0        | FMADD: none
  // | FMADD    | \c 1        | FMSUB: Invert sign of operand C
  // | FNMSUB   | \c 0        | FNMSUB: Invert sign of operand A
  // | FNMSUB   | \c 1        | FNMADD: Invert sign of operands A and C
  // | ADD      | \c 0        | ADD: Set operand A to +1.0
  // | ADD      | \c 1        | SUB: Set operand A to +1.0, invert sign of operand C
  // | MUL      | \c 0        | MUL: Set operand C to +0.0
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select

    // Default assignments - packing-order-agnostic
    operand_a = inp_pipe_operands_q[NUM_INP_REGS][0];
    operand_b = inp_pipe_operands_q[NUM_INP_REGS][1];
    operand_c = inp_pipe_operands_q[NUM_INP_REGS][2];
    info_a    = info_q[0];
    info_b    = info_q[1];
    info_c    = info_q[2];

    // op_mod_q inverts sign of operand C
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      miv_rv32_pkg::FMADD:  ; // do nothing
      miv_rv32_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product
      miv_rv32_pkg::ADD: begin // Set multiplicand to +1
        operand_a = '{sign: 1'b0, exponent: BIAS, mantissa: '0};
        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      miv_rv32_pkg::MUL: begin // Set addend to -0 (for proper rounding with RDN)
        operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};
        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: miv_rv32_pkg::DONT_CARE};
        operand_b  = '{default: miv_rv32_pkg::DONT_CARE};
        operand_c  = '{default: miv_rv32_pkg::DONT_CARE};
        info_a     = '{default: miv_rv32_pkg::DONT_CARE};
        info_b     = '{default: miv_rv32_pkg::DONT_CARE};
        info_c     = '{default: miv_rv32_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;
  logic effective_subtraction;
  logic tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});
  // Effective subtraction in FMA occurs when product and addend signs differ
  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;
  // The tentative sign of the FMA shall be the sign of the product
  assign tentative_sign = operand_a.sign ^ operand_b.sign;

  // ----------------------
  // Special case handling
  // ----------------------
  fp_t                special_result;
  miv_rv32_pkg::status_t special_status;
  logic               result_is_special;

  always_comb begin : special_cases
    // Default assignments
    special_result    = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)}; // canonical qNaN
    special_status    = '0;
    result_is_special = 1'b0;

    // Handle potentially mixed nan & infinity input => important for the case where infinity and
    // zero are multiplied and added to a qnan.
    // RISC-V mandates raising the NV exception in these cases:
    // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
    if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin
      result_is_special = 1'b1; // bypass FMA, output is the canonical qNaN
      special_status.NV = 1'b1; // invalid operation
    // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
    end else if (any_operand_nan) begin
      result_is_special = 1'b1;           // bypass FMA, output is the canonical qNaN
      special_status.NV = signalling_nan; // raise the invalid operation flag if signalling
    // Special cases involving infinity
    end else if (any_operand_inf) begin
      result_is_special = 1'b1; // bypass FMA
      // Effective addition of opposite infinities (±inf - ±inf) is invalid!
      if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)
        special_status.NV = 1'b1; // invalid operation
      // Handle cases where output will be inf because of inf product input
      else if (info_a.is_inf || info_b.is_inf) begin
        // Result is infinity with the sign of the product
        special_result    = '{sign: operand_a.sign ^ operand_b.sign, exponent: '1, mantissa: '0};
      // Handle cases where the addend is inf
      end else if (info_c.is_inf) begin
        // Result is inifinity with sign of the addend (= operand_c)
        special_result    = '{sign: operand_c.sign, exponent: '1, mantissa: '0};
      end
    end
  end

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;
  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;
  logic signed [EXP_WIDTH-1:0] tentative_exponent;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents stay biased.
  assign exponent_addend = signed'(exponent_c + $signed({1'b0, ~info_c.is_normal})); // 0 as subnorm
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product = (info_a.is_zero || info_b.is_zero)
                            ? 2 - signed'(BIAS) // in case the product is zero, set minimum exp.
                            : signed'(exponent_a + info_a.is_subnormal
                                      + exponent_b + info_b.is_subnormal
                                      - signed'(BIAS));
  // Exponent difference is the addend exponent minus the product exponent
  assign exponent_difference = exponent_addend - exponent_product;
  // The tentative exponent will be the larger of the product or addend exponent
  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend : exponent_product;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;

  always_comb begin : addend_shift_amount
    // Product-anchored case, saturated shift (addend is only in the sticky bit)
    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))
      addend_shamt = 3 * PRECISION_BITS + 4;
    // Addend and product will have mutual bits to add
    else if (exponent_difference <= signed'(PRECISION_BITS + 2))
      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);
    // Addend-anchored case, saturated shift (product is only in the sticky bit)
    else
      addend_shamt = 0;
  end

  // ------------------
  // Product data path
  // ------------------
  
  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;
  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide
  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};

  // Mantissa multiplier (a*b)
  generate
  if(NO_MACC_BLK[0]) begin : gen_product_logic 
    logic [2*PRECISION_BITS-1:0] product_temp /* synthesis syn_multstyle="logic" */;    
    assign product_temp = mantissa_a * mantissa_b;  
    assign product = product_temp;
  end else begin : gen_product_macc
    logic [2*PRECISION_BITS-1:0] product_temp /* synthesis syn_multstyle="dsp" */; 
    assign product_temp = mantissa_a * mantissa_b;
    assign product = product_temp;
  end
  endgenerate

  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:
  // | 000...000 | product | RS |
  //  <-  p+2  -> <-  2p -> < 2>
  assign product_shifted = product << 2; // constant shift
  // -----------------
  // Addend data path
  // -----------------
  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on
  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky
  logic                        sticky_before_add;   // they are compressed into a single sticky bit
  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)
  logic                        inject_carry_in;     // inject carry for subtractions if needed

  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits
  // are shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | mantissa_c | 000..000 |
  //  <-    p   -> <- 3p+4 ->
  // AFTER THE SHIFT:
  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |
  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->
  assign {addend_after_shift, addend_sticky_bits} =
      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);
  // assign addend_after_shift[0] = sticky_before_add;

  // In case of a subtraction, the addend is inverted
  assign addend_shifted  = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;
  assign inject_carry_in = effective_subtraction & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [3*PRECISION_BITS+4:0] sum_raw;   // added one bit for the carry
  logic                        sum_carry; // observe carry bit from sum for sign fixing
  logic [3*PRECISION_BITS+3:0] sum;       // discard carry as sum won't overflow
  logic                        final_sign;

  //Mantissa adder (ab+c). In normal addition, it cannot overflow.
  assign sum_raw = product_shifted + addend_shifted + inject_carry_in;
  assign sum_carry = sum_raw[3*PRECISION_BITS+4];

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction && ~sum_carry) ? -sum_raw : sum_raw;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))
                      ? 1'b1
                      : (effective_subtraction ? 1'b0 : tentative_sign);

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                          effective_subtraction_q;
  logic signed [EXP_WIDTH-1:0]   exponent_product_q;
  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;
  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;
  logic                          sticky_before_add_q;
  logic [3*PRECISION_BITS+3:0]   sum_q;
  logic                          final_sign_q;
  miv_rv32_pkg::roundmode_e         rnd_mode_q;
  logic                          result_is_special_q;
  fp_t                           special_result_q;
  miv_rv32_pkg::status_t            special_status_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;
  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;
  miv_rv32_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;
  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;
  miv_rv32_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;
  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;
  assign mid_pipe_exp_prod_q[0]    = exponent_product;
  assign mid_pipe_exp_diff_q[0]    = exponent_difference;
  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;
  assign mid_pipe_add_shamt_q[0]   = addend_shamt;
  assign mid_pipe_sticky_q[0]      = sticky_before_add;
  assign mid_pipe_sum_q[0]         = sum;
  assign mid_pipe_final_sign_q[0]  = final_sign;
  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_res_is_spec_q[0] = result_is_special;
  assign mid_pipe_spec_res_q[0]    = special_result;
  assign mid_pipe_spec_stat_q[0]   = special_status;
  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = mid_pipe_ready[i] & mid_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)
    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)
    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)
    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)
    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, miv_rv32_pkg::RNE)
    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))
    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];
  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];
  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];
  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];
  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // --------------
  // Normalization
  // --------------
  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [EXP_WIDTH-1:0]          normalized_exponent;

  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit
  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization
  logic                        sticky_after_norm; // sticky bit after normalization

  logic signed [EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];

  // Leading zero counter for cancellations
  miv_rv32_lzc #(
    .WIDTH ( LOWER_SUM_WIDTH ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and miv_rv32_lzc (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
    // Product-anchored case or cancellations require miv_rv32_lzc
    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin
      // Normal result (biased exponent > 0 and not a zero)
      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin
        // Undo initial product shift, remove the counted zeroes
        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;
        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift
      // Subnormal result
      end else begin
        // Cap the shift distance to align mantissa with minimum exponent
        norm_shamt          = unsigned'(signed'(PRECISION_BITS) + 2 + exponent_product_q);
        normalized_exponent = 0; // subnormals encoded as 0
      end
    // Addend-anchored case
    end else begin
      norm_shamt          = addend_shamt_q; // Undo the initial shift
      normalized_exponent = tentative_exponent_q;
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_q << norm_shamt;

  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left
  // or right of the (non-carry) MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits
  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                         pre_round_sign;
  logic [EXP_BITS-1:0]          pre_round_exponent;
  logic [MAN_BITS-1:0]          pre_round_mantissa;
  logic [EXP_BITS+MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                   round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow
  logic result_zero;

  logic                         rounded_sign;
  logic [EXP_BITS+MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding

  // Classification before round. RISC-V mandates checking underflow AFTER rounding!
  assign of_before_round = final_exponent >= 2**(EXP_BITS)-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_sign     = final_sign_q;
  assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : unsigned'(final_exponent[EXP_BITS-1:0]);
  assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[MAN_BITS:1]; // bit 0 is R bit
  assign pre_round_abs      = {pre_round_exponent, pre_round_mantissa};

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = (of_before_round) ? 2'b11 : {final_mantissa[0], sticky_after_norm};

  // Perform the rounding
  miv_rv32_fpnew_rounding #(
    .AbsWidth ( EXP_BITS + MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_q ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             ),
    .op_i                    ( op_i                    )
  );

  // Classification after rounding
  assign uf_after_round = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // exponent = 0
  assign of_after_round = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // exponent all ones

  // -----------------
  // Result selection
  // -----------------
  logic [WIDTH-1:0]     regular_result;
  miv_rv32_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result    = {rounded_sign, rounded_abs};
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  fp_t                result_d;
  miv_rv32_pkg::status_t status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  fp_t                [0:NUM_OUT_REGS] out_pipe_result_q;
  miv_rv32_pkg::status_t [0:NUM_OUT_REGS] out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS] out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS] out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS] out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = out_pipe_ready[i] & out_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_fma_multi.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_fma_multi #(
  parameter miv_rv32_pkg::fmt_logic_t   FpFmtConfig = '1,
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = miv_rv32_pkg::max_fp_width(FpFmtConfig),
  localparam int unsigned NUM_FORMATS = miv_rv32_pkg::NUM_FP_FORMATS
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [2:0][WIDTH-1:0]       operands_i, // 3 operands
  input  logic [NUM_FORMATS-1:0][2:0] is_boxed_i, // 3 operands
  input  miv_rv32_pkg::roundmode_e       rnd_mode_i,
  input  miv_rv32_pkg::operation_e       op_i,
  input  logic                        op_mod_i,
  input  miv_rv32_pkg::fp_format_e       src_fmt_i, // format of the multiplicands
  input  miv_rv32_pkg::fp_format_e       dst_fmt_i, // format of the addend and result
  input  TagType                      tag_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output miv_rv32_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o
);

  // ----------
  // Constants
  // ----------
  // The super-format that can hold all formats
  localparam miv_rv32_pkg::fp_encoding_t SUPER_FORMAT = miv_rv32_pkg::super_format(FpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;

  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = SUPER_MAN_BITS + 1;
  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection
  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);
  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the miv_rv32_lzc result.
  // In most reasonable FP formats the internal exponent will be wider than the miv_rv32_lzc result.
  localparam int unsigned EXP_WIDTH = miv_rv32_pkg::maximum(SUPER_EXP_BITS + 2, LZC_RESULT_WIDTH);
  // Shift amount width: maximum internal mantissa size is 3p+4 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == miv_rv32_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == miv_rv32_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == miv_rv32_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                      sign;
    logic [SUPER_EXP_BITS-1:0] exponent;
    logic [SUPER_MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [2:0][WIDTH-1:0] operands_q;
  miv_rv32_pkg::fp_format_e src_fmt_q;
  miv_rv32_pkg::fp_format_e dst_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0]       inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][NUM_FORMATS-1:0][2:0] inp_pipe_is_boxed_q;
  miv_rv32_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_op_mod_q;
  miv_rv32_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_src_fmt_q;
  miv_rv32_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_dst_fmt_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = inp_pipe_ready[i] & inp_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, miv_rv32_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic        [NUM_FORMATS-1:0][2:0]                     fmt_sign;
  logic signed [NUM_FORMATS-1:0][2:0][SUPER_EXP_BITS-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][2:0][SUPER_MAN_BITS-1:0] fmt_mantissa;

  miv_rv32_pkg::fp_info_t [NUM_FORMATS-1:0][2:0] info_q;

  // FP Input initialization
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      logic [2:0][FP_WIDTH-1:0] trimmed_ops;

      // Classify input
      miv_rv32_fpnew_classifier #(
        .FpFormat    ( miv_rv32_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 3                            )
      ) i_fpnew_classifier (
        .operands_i ( trimmed_ops                            ),
        .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS][fmt] ),
        .info_o     ( info_q[fmt]                            )
      );
      for (genvar op = 0; op < 3; op++) begin : gen_operands
        assign trimmed_ops[op]       = operands_q[op][FP_WIDTH-1:0];
        assign fmt_sign[fmt][op]     = operands_q[op][FP_WIDTH-1];
        assign fmt_exponent[fmt][op] = signed'({1'b0, operands_q[op][MAN_BITS+:EXP_BITS]});
        assign fmt_mantissa[fmt][op] = {info_q[fmt][op].is_normal, operands_q[op][MAN_BITS-1:0]} <<
                                       (SUPER_MAN_BITS - MAN_BITS); // move to left of mantissa
      end
    end else begin : inactive_format
      assign info_q[fmt]                 = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]               = miv_rv32_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt]           = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt]           = '{default: miv_rv32_pkg::DONT_CARE}; // format disabled
    end
  end

  fp_t                 operand_a, operand_b, operand_c;
  miv_rv32_pkg::fp_info_t info_a,    info_b,    info_c;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | FMADD    | \c 0        | FMADD: none
  // | FMADD    | \c 1        | FMSUB: Invert sign of operand C
  // | FNMSUB   | \c 0        | FNMSUB: Invert sign of operand A
  // | FNMSUB   | \c 1        | FNMADD: Invert sign of operands A and C
  // | ADD      | \c 0        | ADD: Set operand A to +1.0
  // | ADD      | \c 1        | SUB: Set operand A to +1.0, invert sign of operand C
  // | MUL      | \c 0        | MUL: Set operand C to +0.0
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select

    // Default assignments - packing-order-agnostic
    operand_a = {fmt_sign[src_fmt_q][0], fmt_exponent[src_fmt_q][0], fmt_mantissa[src_fmt_q][0]};
    operand_b = {fmt_sign[src_fmt_q][1], fmt_exponent[src_fmt_q][1], fmt_mantissa[src_fmt_q][1]};
    operand_c = {fmt_sign[dst_fmt_q][2], fmt_exponent[dst_fmt_q][2], fmt_mantissa[dst_fmt_q][2]};
    info_a    = info_q[src_fmt_q][0];
    info_b    = info_q[src_fmt_q][1];
    info_c    = info_q[dst_fmt_q][2];

    // op_mod_q inverts sign of operand C
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      miv_rv32_pkg::FMADD:  ; // do nothing
      miv_rv32_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product
      miv_rv32_pkg::ADD: begin // Set multiplicand to +1
        operand_a = '{sign: 1'b0, exponent: miv_rv32_pkg::bias(src_fmt_q), mantissa: '0};
        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      miv_rv32_pkg::MUL: begin // Set addend to -0 (for proper rounding with RDN)
        operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};
        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: miv_rv32_pkg::DONT_CARE};
        operand_b  = '{default: miv_rv32_pkg::DONT_CARE};
        operand_c  = '{default: miv_rv32_pkg::DONT_CARE};
        info_a     = '{default: miv_rv32_pkg::DONT_CARE};
        info_b     = '{default: miv_rv32_pkg::DONT_CARE};
        info_c     = '{default: miv_rv32_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;
  logic effective_subtraction;
  logic tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});
  // Effective subtraction in FMA occurs when product and addend signs differ
  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;
  // The tentative sign of the FMA shall be the sign of the product
  assign tentative_sign = operand_a.sign ^ operand_b.sign;

  // ----------------------
  // Special case handling
  // ----------------------
  logic [WIDTH-1:0]   special_result;
  miv_rv32_pkg::status_t special_status;
  logic               result_is_special;

  logic [NUM_FORMATS-1:0][WIDTH-1:0]    fmt_special_result;
  miv_rv32_pkg::status_t [NUM_FORMATS-1:0] fmt_special_status;
  logic [NUM_FORMATS-1:0]               fmt_result_is_special;


  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);
    localparam logic [MAN_BITS-1:0] ZERO_MANTISSA = '0;

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_results
        logic [FP_WIDTH-1:0] special_res;

        // Default assignment
        special_res                = {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN
        fmt_special_status[fmt]    = '0;
        fmt_result_is_special[fmt] = 1'b0;

        // Handle potentially mixed nan & infinity input => important for the case where infinity and
        // zero are multiplied and added to a qnan.
        // RISC-V mandates raising the NV exception in these cases:
        // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
        if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass FMA, output is the canonical qNaN
          fmt_special_status[fmt].NV = 1'b1; // invalid operation
        // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
        end else if (any_operand_nan) begin
          fmt_result_is_special[fmt] = 1'b1;           // bypass FMA, output is the canonical qNaN
          fmt_special_status[fmt].NV = signalling_nan; // raise the invalid operation flag if signalling
        // Special cases involving infinity
        end else if (any_operand_inf) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass FMA
          // Effective addition of opposite infinities (±inf - ±inf) is invalid!
          if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)
            fmt_special_status[fmt].NV = 1'b1; // invalid operation
          // Handle cases where output will be inf because of inf product input
          else if (info_a.is_inf || info_b.is_inf) begin
            // Result is infinity with the sign of the product
            special_res = {operand_a.sign ^ operand_b.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          // Handle cases where the addend is inf
          end else if (info_c.is_inf) begin
            // Result is inifinity with sign of the addend (= operand_c)
            special_res = {operand_c.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          end
        end
        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_special_status[fmt] = '0;
      assign fmt_result_is_special[fmt] = 1'b0;
    end
  end

  // Detect special case from source format, I2F casts don't produce a special result
  assign result_is_special = fmt_result_is_special[dst_fmt_q]; // they're all the same
  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign special_status = fmt_special_status[dst_fmt_q];
  // Assemble result according to destination format
  assign special_result = fmt_special_result[dst_fmt_q]; // destination format

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;
  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;
  logic signed [EXP_WIDTH-1:0] tentative_exponent;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents are biased to dst fmt.
  assign exponent_addend = signed'(exponent_c + $signed({1'b0, ~info_c.is_normal})); // 0 as subnorm
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product = (info_a.is_zero || info_b.is_zero) // in case the product is zero, set minimum exp.
                            ? 2 - signed'(miv_rv32_pkg::bias(dst_fmt_q))
                            : signed'(exponent_a + info_a.is_subnormal
                                      + exponent_b + info_b.is_subnormal
                                      - 2*signed'(miv_rv32_pkg::bias(src_fmt_q))
                                      + signed'(miv_rv32_pkg::bias(dst_fmt_q))); // rebias for dst fmt
  // Exponent difference is the addend exponent minus the product exponent
  assign exponent_difference = exponent_addend - exponent_product;
  // The tentative exponent will be the larger of the product or addend exponent
  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend : exponent_product;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;

  always_comb begin : addend_shift_amount
    // Product-anchored case, saturated shift (addend is only in the sticky bit)
    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))
      addend_shamt = 3 * PRECISION_BITS + 4;
    // Addend and product will have mutual bits to add
    else if (exponent_difference <= signed'(PRECISION_BITS + 2))
      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);
    // Addend-anchored case, saturated shift (product is only in the sticky bit)
    else
      addend_shamt = 0;
  end

  // ------------------
  // Product data path
  // ------------------
  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;
  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide
  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};

  // Mantissa multiplier (a*b)
  assign product = mantissa_a * mantissa_b;

  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:
  // | 000...000 | product | RS |
  //  <-  p+2  -> <-  2p -> < 2>
  assign product_shifted = product << 2; // constant shift

  // -----------------
  // Addend data path
  // -----------------
  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on
  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky
  logic                        sticky_before_add;   // they are compressed into a single sticky bit
  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)
  logic                        inject_carry_in;     // inject carry for subtractions if needed

  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits are
  // shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | mantissa_c | 000..000 |
  //  <-    p   -> <- 3p+4 ->
  // AFTER THE SHIFT:
  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |
  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->
  assign {addend_after_shift, addend_sticky_bits} =
      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);

  // In case of a subtraction, the addend is inverted
  assign addend_shifted = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;
  assign inject_carry_in = effective_subtraction & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [3*PRECISION_BITS+4:0] sum_raw;   // added one bit for the carry
  logic                        sum_carry; // observe carry bit from sum for sign fixing
  logic [3*PRECISION_BITS+3:0] sum;       // discard carry as sum won't overflow
  logic                        final_sign;

  //Mantissa adder (ab+c). In normal addition, it cannot overflow.
  assign sum_raw = product_shifted + addend_shifted + inject_carry_in;
  assign sum_carry = sum_raw[3*PRECISION_BITS+4];

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction && ~sum_carry) ? -sum_raw : sum_raw;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))
                      ? 1'b1
                      : (effective_subtraction ? 1'b0 : tentative_sign);

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                          effective_subtraction_q;
  logic signed [EXP_WIDTH-1:0]   exponent_product_q;
  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;
  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;
  logic                          sticky_before_add_q;
  logic [3*PRECISION_BITS+3:0]   sum_q;
  logic                          final_sign_q;
  miv_rv32_pkg::fp_format_e         dst_fmt_q2;
  miv_rv32_pkg::roundmode_e         rnd_mode_q;
  logic                          result_is_special_q;
  fp_t                           special_result_q;
  miv_rv32_pkg::status_t            special_status_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;
  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;
  miv_rv32_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;
  miv_rv32_pkg::fp_format_e [0:NUM_MID_REGS]                         mid_pipe_dst_fmt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;
  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;
  miv_rv32_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;
  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;
  assign mid_pipe_exp_prod_q[0]    = exponent_product;
  assign mid_pipe_exp_diff_q[0]    = exponent_difference;
  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;
  assign mid_pipe_add_shamt_q[0]   = addend_shamt;
  assign mid_pipe_sticky_q[0]      = sticky_before_add;
  assign mid_pipe_sum_q[0]         = sum;
  assign mid_pipe_final_sign_q[0]  = final_sign;
  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_dst_fmt_q[0]     = dst_fmt_q;
  assign mid_pipe_res_is_spec_q[0] = result_is_special;
  assign mid_pipe_spec_res_q[0]    = special_result;
  assign mid_pipe_spec_stat_q[0]   = special_status;
  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = mid_pipe_ready[i] & mid_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)
    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)
    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)
    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)
    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, miv_rv32_pkg::RNE)
    `FFL(mid_pipe_dst_fmt_q[i+1],     mid_pipe_dst_fmt_q[i],     reg_ena, miv_rv32_pkg::fp_format_e'(0))
    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))
    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];
  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];
  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];
  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];
  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign dst_fmt_q2              = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // --------------
  // Normalization
  // --------------
  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [EXP_WIDTH-1:0]          normalized_exponent;

  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit
  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization
  logic                        sticky_after_norm; // sticky bit after normalization

  logic signed [EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];

  // Leading zero counter for cancellations
  miv_rv32_lzc #(
    .WIDTH ( LOWER_SUM_WIDTH ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and miv_rv32_lzc (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
    // Product-anchored case or cancellations require miv_rv32_lzc
    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin
      // Normal result (biased exponent > 0 and not a zero)
      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin
        // Undo initial product shift, remove the counted zeroes
        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;
        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift
      // Subnormal result
      end else begin
        // Cap the shift distance to align mantissa with minimum exponent
        norm_shamt          = unsigned'(signed'(PRECISION_BITS + 2 + exponent_product_q));
        normalized_exponent = 0; // subnormals encoded as 0
      end
    // Addend-anchored case
    end else begin
      norm_shamt          = addend_shamt_q; // Undo the initial shift
      normalized_exponent = tentative_exponent_q;
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_q << norm_shamt;

  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left
  // or right of the (non-carry) MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits
  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                                     pre_round_sign;
  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                               round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0][1:0]                               fmt_round_sticky_bits;

  logic [NUM_FORMATS-1:0]                                    fmt_of_after_round;
  logic [NUM_FORMATS-1:0]                                    fmt_uf_after_round;

  logic                                     rounded_sign;
  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding
  logic                                     result_zero;

  // Classification before round. RISC-V mandates checking underflow AFTER rounding!
  assign of_before_round = final_exponent >= 2**(miv_rv32_pkg::exp_bits(dst_fmt_q2))-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    logic [EXP_BITS-1:0] pre_round_exponent;
    logic [MAN_BITS-1:0] pre_round_mantissa;

    if (FpFmtConfig[fmt]) begin : active_format

      assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : final_exponent[EXP_BITS-1:0];
      assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[SUPER_MAN_BITS-:MAN_BITS];
      // Assemble result before rounding. In case of overflow, the largest normal value is set.
      assign fmt_pre_round_abs[fmt] = {pre_round_exponent, pre_round_mantissa}; // 0-extend

      // Round bit is after mantissa (1 in case of overflow for rounding)
      assign fmt_round_sticky_bits[fmt][1] = final_mantissa[SUPER_MAN_BITS-MAN_BITS] |
                                             of_before_round;

      // remaining bits in mantissa to sticky (1 in case of overflow for rounding)
      if (MAN_BITS < SUPER_MAN_BITS) begin : narrow_sticky
        assign fmt_round_sticky_bits[fmt][0] = (| final_mantissa[SUPER_MAN_BITS-MAN_BITS-1:0]) |
                                               sticky_after_norm | of_before_round;
      end else begin : normal_sticky
        assign fmt_round_sticky_bits[fmt][0] = sticky_after_norm | of_before_round;
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_round_sticky_bits[fmt] = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_sign     = final_sign_q;
  assign pre_round_abs      = fmt_pre_round_abs[dst_fmt_q2];

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = fmt_round_sticky_bits[dst_fmt_q2];

  // Perform the rounding
  miv_rv32_fpnew_rounding #(
    .AbsWidth ( SUPER_EXP_BITS + SUPER_MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_q ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             ),
    .op_i                    ( op_i                    )
  );

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;

  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(miv_rv32_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(miv_rv32_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : post_process
        // detect of / uf
        fmt_uf_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // denormal
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones.
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = miv_rv32_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = miv_rv32_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: miv_rv32_pkg::DONT_CARE};
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = fmt_of_after_round[dst_fmt_q2];


  // -----------------
  // Result selection
  // -----------------
  logic [WIDTH-1:0]     regular_result;
  miv_rv32_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result = fmt_result[dst_fmt_q2];
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  logic [WIDTH-1:0]   result_d;
  miv_rv32_pkg::status_t status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  miv_rv32_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = out_pipe_ready[i] & out_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_noncomp.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_noncomp #(
  parameter miv_rv32_pkg::fp_format_e   FpFormat    = miv_rv32_pkg::fp_format_e'(0),
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,

  localparam int unsigned WIDTH = miv_rv32_pkg::fp_width(FpFormat) // do not change
) (
  input logic                  clk_i,
  input logic                  rst_ni,
  // Input signals
  input logic [1:0][WIDTH-1:0]     operands_i, // 2 operands
  input logic [1:0]                is_boxed_i, // 2 operands
  input miv_rv32_pkg::roundmode_e     rnd_mode_i,
  input miv_rv32_pkg::operation_e     op_i,
  input logic                      op_mod_i,
  input TagType                    tag_i,
  input AuxType                    aux_i,
  // Input Handshake
  input  logic                     in_valid_i,
  output logic                     in_ready_o,
  input  logic                     flush_i,
  // Output signals
  output logic [WIDTH-1:0]         result_o,
  output miv_rv32_pkg::status_t       status_o,
  output logic                     extension_bit_o,
  output miv_rv32_pkg::classmask_e    class_mask_o,
  output logic                     is_class_o,
  output TagType                   tag_o,
  output AuxType                   aux_o,
  // Output handshake
  output logic                     out_valid_o,
  input  logic                     out_ready_i,
  // Indication of valid data in flight
  output logic                     busy_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned EXP_BITS = miv_rv32_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = miv_rv32_pkg::man_bits(FpFormat);
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == miv_rv32_pkg::BEFORE || PipeConfig == miv_rv32_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == miv_rv32_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0] inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][1:0]            inp_pipe_is_boxed_q;
  miv_rv32_pkg::roundmode_e [0:NUM_INP_REGS]                 inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e [0:NUM_INP_REGS]                 inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_op_mod_q;
  TagType                [0:NUM_INP_REGS]                 inp_pipe_tag_q;
  AuxType                [0:NUM_INP_REGS]                 inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = inp_pipe_ready[i] & inp_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, miv_rv32_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end

  // ---------------------
  // Input classification
  // ---------------------
  miv_rv32_pkg::fp_info_t [1:0] info_q;

  // Classify input
  miv_rv32_fpnew_classifier #(
    .FpFormat    ( FpFormat ),
    .NumOperands ( 2        )
    ) i_class_a (
    .operands_i ( inp_pipe_operands_q[NUM_INP_REGS] ),
    .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS] ),
    .info_o     ( info_q                            )
  );

  fp_t                 operand_a, operand_b;
  miv_rv32_pkg::fp_info_t info_a,    info_b;

  // Packing-order-agnostic assignments
  assign operand_a = inp_pipe_operands_q[NUM_INP_REGS][0];
  assign operand_b = inp_pipe_operands_q[NUM_INP_REGS][1];
  assign info_a    = info_q[0];
  assign info_b    = info_q[1];

  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling});

  logic operands_equal, operand_a_smaller;

  // Equality checks for zeroes too
  assign operands_equal    = (operand_a == operand_b) || (info_a.is_zero && info_b.is_zero);
  // Invert result if non-zero signs involved (unsigned comparison)
  assign operand_a_smaller = (operand_a < operand_b) ^ (operand_a.sign || operand_b.sign);

  // ---------------
  // Sign Injection
  // ---------------
  fp_t                sgnj_result;
  miv_rv32_pkg::status_t sgnj_status;
  logic               sgnj_extension_bit;

  // Sign Injection - operation is encoded in rnd_mode_q:
  // RNE = SGNJ, RTZ = SGNJN, RDN = SGNJX, RUP = Passthrough (no NaN-box check)
  always_comb begin : sign_injections
    logic sign_a, sign_b; // internal signs
    // Default assignment
    sgnj_result = operand_a; // result based on operand a

    // NaN-boxing check will treat invalid inputs as canonical NaNs
    if (!info_a.is_boxed) sgnj_result = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)};

    // Internal signs are treated as positive in case of non-NaN-boxed values
    sign_a = operand_a.sign & info_a.is_boxed;
    sign_b = operand_b.sign & info_b.is_boxed;

    // Do the sign injection based on rm field
    unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
      miv_rv32_pkg::RNE: sgnj_result.sign = sign_b;          // SGNJ
      miv_rv32_pkg::RTZ: sgnj_result.sign = ~sign_b;         // SGNJN
      miv_rv32_pkg::RDN: sgnj_result.sign = sign_a ^ sign_b; // SGNJX
      miv_rv32_pkg::RUP: sgnj_result      = operand_a;       // passthrough
      default: sgnj_result = '{default: miv_rv32_pkg::DONT_CARE}; // don't care
    endcase
  end

  assign sgnj_status = '0;        // sign injections never raise exceptions

  // op_mod_q enables integer sign-extension of result (for storing to integer regfile)
  assign sgnj_extension_bit = inp_pipe_op_mod_q[NUM_INP_REGS] ? sgnj_result.sign : 1'b1;

  // ------------------
  // Minimum / Maximum
  // ------------------
  fp_t                minmax_result;
  miv_rv32_pkg::status_t minmax_status;
  logic               minmax_extension_bit;

  // Minimum/Maximum - operation is encoded in rnd_mode_q:
  // RNE = MIN, RTZ = MAX
  always_comb begin : min_max
    // Default assignment
    minmax_status = '0;

    // Min/Max use quiet comparisons - only sNaN are invalid
    minmax_status.NV = signalling_nan;

    // Both NaN inputs cause a NaN output
    if (info_a.is_nan && info_b.is_nan)
      minmax_result = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)}; // canonical qNaN
    // If one operand is NaN, the non-NaN operand is returned
    else if (info_a.is_nan) minmax_result = operand_b;
    else if (info_b.is_nan) minmax_result = operand_a;
    // Otherwise decide according to the operation
    else begin
      unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
        miv_rv32_pkg::RNE: minmax_result = operand_a_smaller ? operand_a : operand_b; // MIN
        miv_rv32_pkg::RTZ: minmax_result = operand_a_smaller ? operand_b : operand_a; // MAX
        default: minmax_result = '{default: miv_rv32_pkg::DONT_CARE}; // don't care
      endcase
    end
  end

  assign minmax_extension_bit = 1'b1; // NaN-box as result is always a float value

  // ------------
  // Comparisons
  // ------------
  fp_t                cmp_result;
  miv_rv32_pkg::status_t cmp_status;
  logic               cmp_extension_bit;

  // Comparisons - operation is encoded in rnd_mode_q:
  // RNE = LE, RTZ = LT, RDN = EQ
  // op_mod_q inverts boolean outputs
  always_comb begin : comparisons
    // Default assignment
    cmp_result = '0; // false
    cmp_status = '0; // no flags

    // Signalling NaNs always compare as false and are illegal
    if (signalling_nan) cmp_status.NV = 1'b1; // invalid operation
    // Otherwise do comparisons
    else begin
      unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
        miv_rv32_pkg::RNE: begin // Less than or equal
          if (any_operand_nan) cmp_status.NV = 1'b1; // Signalling comparison: NaNs are invalid
          else cmp_result = (operand_a_smaller | operands_equal) ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        miv_rv32_pkg::RTZ: begin // Less than
          if (any_operand_nan) cmp_status.NV = 1'b1; // Signalling comparison: NaNs are invalid
          else cmp_result = (operand_a_smaller & ~operands_equal) ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        miv_rv32_pkg::RDN: begin // Equal
          if (any_operand_nan) cmp_result = inp_pipe_op_mod_q[NUM_INP_REGS]; // NaN always not equal
          else cmp_result = operands_equal ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        default: cmp_result = '{default: miv_rv32_pkg::DONT_CARE}; // don't care
      endcase
    end
  end

  assign cmp_extension_bit = 1'b0; // Comparisons always produce booleans in integer registers

  // ---------------
  // Classification
  // ---------------
  miv_rv32_pkg::status_t    class_status;
  logic                  class_extension_bit;
  miv_rv32_pkg::classmask_e class_mask_d; // the result is actually here

  // Classification - always return the classification mask on the dedicated port
  always_comb begin : classify
    if (info_a.is_normal) begin
      class_mask_d = operand_a.sign       ? miv_rv32_pkg::NEGNORM    : miv_rv32_pkg::POSNORM;
    end else if (info_a.is_subnormal) begin
      class_mask_d = operand_a.sign       ? miv_rv32_pkg::NEGSUBNORM : miv_rv32_pkg::POSSUBNORM;
    end else if (info_a.is_zero) begin
      class_mask_d = operand_a.sign       ? miv_rv32_pkg::NEGZERO    : miv_rv32_pkg::POSZERO;
    end else if (info_a.is_inf) begin
      class_mask_d = operand_a.sign       ? miv_rv32_pkg::NEGINF     : miv_rv32_pkg::POSINF;
    end else if (info_a.is_nan) begin
      class_mask_d = info_a.is_signalling ? miv_rv32_pkg::SNAN       : miv_rv32_pkg::QNAN;
    end else begin
      class_mask_d = miv_rv32_pkg::QNAN; // default value
    end
  end

  assign class_status        = '0;   // classification does not set flags
  assign class_extension_bit = 1'b0; // classification always produces results in integer registers

  // -----------------
  // Result selection
  // -----------------
  fp_t                   result_d;
  miv_rv32_pkg::status_t    status_d;
  logic                  extension_bit_d;
  logic                  is_class_d;

  // Select result
  always_comb begin : select_result
    unique case (inp_pipe_op_q[NUM_INP_REGS])
      miv_rv32_pkg::SGNJ: begin
        result_d        = sgnj_result;
        status_d        = sgnj_status;
        extension_bit_d = sgnj_extension_bit;
      end
      miv_rv32_pkg::MINMAX: begin
        result_d        = minmax_result;
        status_d        = minmax_status;
        extension_bit_d = minmax_extension_bit;
      end
      miv_rv32_pkg::CMP: begin
        result_d        = cmp_result;
        status_d        = cmp_status;
        extension_bit_d = cmp_extension_bit;
      end
      miv_rv32_pkg::CLASSIFY: begin
        result_d        = '{default: miv_rv32_pkg::DONT_CARE}; // unused
        status_d        = class_status;
        extension_bit_d = class_extension_bit;
      end
      default: begin
        result_d        = '{default: miv_rv32_pkg::DONT_CARE}; // dont care
        status_d        = '{default: miv_rv32_pkg::DONT_CARE}; // dont care
        extension_bit_d = miv_rv32_pkg::DONT_CARE;             // dont care
      end
    endcase
  end

  assign is_class_d = (inp_pipe_op_q[NUM_INP_REGS] == miv_rv32_pkg::CLASSIFY);

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  fp_t                   [0:NUM_OUT_REGS] out_pipe_result_q;
  miv_rv32_pkg::status_t    [0:NUM_OUT_REGS] out_pipe_status_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_extension_bit_q;
  miv_rv32_pkg::classmask_e [0:NUM_OUT_REGS] out_pipe_class_mask_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_is_class_q;
  TagType                [0:NUM_OUT_REGS] out_pipe_tag_q;
  AuxType                [0:NUM_OUT_REGS] out_pipe_aux_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0]        = result_d;
  assign out_pipe_status_q[0]        = status_d;
  assign out_pipe_extension_bit_q[0] = extension_bit_d;
  assign out_pipe_class_mask_q[0]    = class_mask_d;
  assign out_pipe_is_class_q[0]      = is_class_d;
  assign out_pipe_tag_q[0]           = inp_pipe_tag_q[NUM_INP_REGS];
  assign out_pipe_aux_q[0]           = inp_pipe_aux_q[NUM_INP_REGS];
  assign out_pipe_valid_q[0]         = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign inp_pipe_ready[NUM_INP_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = out_pipe_ready[i] & out_pipe_valid_q[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1],        out_pipe_result_q[i],        reg_ena, '0)
    `FFL(out_pipe_status_q[i+1],        out_pipe_status_q[i],        reg_ena, '0)
    `FFL(out_pipe_extension_bit_q[i+1], out_pipe_extension_bit_q[i], reg_ena, '0)
    `FFL(out_pipe_class_mask_q[i+1],    out_pipe_class_mask_q[i],    reg_ena, miv_rv32_pkg::QNAN)
    `FFL(out_pipe_is_class_q[i+1],      out_pipe_is_class_q[i],      reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],           out_pipe_tag_q[i],           reg_ena, TagType'('0))
    `FFL(out_pipe_aux_q[i+1],           out_pipe_aux_q[i],           reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = out_pipe_extension_bit_q[NUM_OUT_REGS];
  assign class_mask_o    = out_pipe_class_mask_q[NUM_OUT_REGS];
  assign is_class_o      = out_pipe_is_class_q[NUM_OUT_REGS];
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, out_pipe_valid_q});
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_opgroup_block.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module miv_rv32_fpnew_opgroup_block #(
  parameter miv_rv32_pkg::opgroup_e        OpGroup       = miv_rv32_pkg::ADDMUL,
  // FPU configuration
  parameter                             NO_MACC_BLK   = 0,
  parameter int unsigned                Width         = 32,
  parameter logic                       EnableVectors = 1'b1,
  parameter miv_rv32_pkg::fmt_logic_t      FpFmtMask     = '1,
  parameter miv_rv32_pkg::ifmt_logic_t     IntFmtMask    = '1,
  parameter miv_rv32_pkg::fmt_unsigned_t   FmtPipeRegs   = '{default: 0},
  parameter miv_rv32_pkg::fmt_unit_types_t FmtUnitTypes  = '{default: miv_rv32_pkg::PARALLEL},
  parameter miv_rv32_pkg::pipe_config_t    PipeConfig    = miv_rv32_pkg::BEFORE,
  parameter type                        TagType       = logic,
  // Do not change
  localparam int unsigned NUM_FORMATS  = miv_rv32_pkg::NUM_FP_FORMATS,
  localparam int unsigned NUM_OPERANDS = miv_rv32_pkg::num_operands(OpGroup)
) (
  input logic                                     clk_i,
  input logic                                     rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,
  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,
  input miv_rv32_pkg::roundmode_e                    rnd_mode_i,
  input miv_rv32_pkg::operation_e                    op_i,
  input logic                                     op_mod_i,
  input miv_rv32_pkg::fp_format_e                    src_fmt_i,
  input miv_rv32_pkg::fp_format_e                    dst_fmt_i,
  input miv_rv32_pkg::int_format_e                   int_fmt_i,
  input logic                                     vectorial_op_i,
  input TagType                                   tag_i,
  // Input Handshake
  input  logic                                    in_valid_i,
  output logic                                    in_ready_o,
  input  logic                                    flush_i,
  // Output signals
  output logic [Width-1:0]                        result_o,
  output miv_rv32_pkg::status_t                      status_o,
  output logic                                    extension_bit_o,
  output TagType                                  tag_o,
  // Output handshake
  output logic                                    out_valid_o,
  input  logic                                    out_ready_i,
  // Indication of valid data in flight
  output logic                                    busy_o
);

  // ----------------
  // Type Definition
  // ----------------
  typedef struct packed {
    logic [Width-1:0]   result;
    miv_rv32_pkg::status_t status;
    logic               ext_bit;
    TagType             tag;
  } output_t;

  // Handshake signals for the slices
  logic [NUM_FORMATS-1:0] fmt_in_ready, fmt_out_valid, fmt_out_ready, fmt_busy;
  output_t [NUM_FORMATS-1:0] fmt_outputs;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o = in_valid_i & fmt_in_ready[dst_fmt_i]; // Ready is given by selected format

  // -------------------------
  // Generate Parallel Slices
  // -------------------------
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_parallel_slices
    // Some constants for this format
    localparam logic ANY_MERGED = miv_rv32_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask);
    localparam logic IS_FIRST_MERGED =
        miv_rv32_pkg::is_first_enabled_multi(miv_rv32_pkg::fp_format_e'(fmt), FmtUnitTypes, FpFmtMask);

    // Generate slice only if format enabled
    if (FpFmtMask[fmt] && (FmtUnitTypes[fmt] == miv_rv32_pkg::PARALLEL)) begin : active_format

      logic in_valid;

      assign in_valid = in_valid_i & (dst_fmt_i == fmt); // enable selected format

      miv_rv32_fpnew_opgroup_fmt_slice #(
        .OpGroup       ( OpGroup                      ),
        .FpFormat      ( miv_rv32_pkg::fp_format_e'(fmt) ),
        .Width         ( Width                        ),
        .EnableVectors ( EnableVectors                ),
        .NumPipeRegs   ( FmtPipeRegs[fmt]             ),
        .PipeConfig    ( PipeConfig                   ),
        .TagType       ( TagType                      ),
		.NO_MACC_BLK   ( NO_MACC_BLK                  )
      ) i_fmt_slice (
        .clk_i,
        .rst_ni,
        .operands_i     ( operands_i               ),
        .is_boxed_i     ( is_boxed_i[fmt]          ),
        .rnd_mode_i,
        .op_i,
        .op_mod_i,
        .vectorial_op_i,
        .tag_i,
        .in_valid_i     ( in_valid                 ),
        .in_ready_o     ( fmt_in_ready[fmt]        ),
        .flush_i,
        .result_o       ( fmt_outputs[fmt].result  ),
        .status_o       ( fmt_outputs[fmt].status  ),
        .extension_bit_o( fmt_outputs[fmt].ext_bit ),
        .tag_o          ( fmt_outputs[fmt].tag     ),
        .out_valid_o    ( fmt_out_valid[fmt]       ),
        .out_ready_i    ( fmt_out_ready[fmt]       ),
        .busy_o         ( fmt_busy[fmt]            )
      );
    // If the format wants to use merged ops, tie off the dangling ones not used here
    end else if (FpFmtMask[fmt] && ANY_MERGED && !IS_FIRST_MERGED) begin : merged_unused

      localparam FMT = miv_rv32_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);
      // Ready is split up into formats
      assign fmt_in_ready[fmt]  = fmt_in_ready[int'(FMT)];

      assign fmt_out_valid[fmt] = 1'b0; // don't emit values
      assign fmt_busy[fmt]      = 1'b0; // never busy
      // Outputs are don't care
      assign fmt_outputs[fmt].result  = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_outputs[fmt].status  = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_outputs[fmt].ext_bit = miv_rv32_pkg::DONT_CARE;
      assign fmt_outputs[fmt].tag     = TagType'(miv_rv32_pkg::DONT_CARE);

    // Tie off disabled formats
    end else if (!FpFmtMask[fmt] || (FmtUnitTypes[fmt] == miv_rv32_pkg::DISABLED)) begin : disable_fmt
      assign fmt_in_ready[fmt]  = 1'b0; // don't accept operations
      assign fmt_out_valid[fmt] = 1'b0; // don't emit values
      assign fmt_busy[fmt]      = 1'b0; // never busy
      // Outputs are don't care
      assign fmt_outputs[fmt].result  = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_outputs[fmt].status  = '{default: miv_rv32_pkg::DONT_CARE};
      assign fmt_outputs[fmt].ext_bit = miv_rv32_pkg::DONT_CARE;
      assign fmt_outputs[fmt].tag     = TagType'(miv_rv32_pkg::DONT_CARE);
    end
  end

  // ----------------------
  // Generate Merged Slice
  // ----------------------
  if (miv_rv32_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask)) begin : gen_merged_slice

    localparam FMT = miv_rv32_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);
    localparam REG = miv_rv32_pkg::get_num_regs_multi(FmtPipeRegs, FmtUnitTypes, FpFmtMask);

    logic in_valid;

    assign in_valid = in_valid_i & (FmtUnitTypes[dst_fmt_i] == miv_rv32_pkg::MERGED);

    miv_rv32_fpnew_opgroup_multifmt_slice #(
      .OpGroup       ( OpGroup          ),
      .Width         ( Width            ),
      .FpFmtConfig   ( FpFmtMask        ),
      .IntFmtConfig  ( IntFmtMask       ),
      .EnableVectors ( EnableVectors    ),
      .NumPipeRegs   ( REG              ),
      .PipeConfig    ( PipeConfig       ),
      .TagType       ( TagType          )
    ) i_multifmt_slice (
      .clk_i,
      .rst_ni,
      .operands_i,
      .is_boxed_i,
      .rnd_mode_i,
      .op_i,
      .op_mod_i,
      .src_fmt_i,
      .dst_fmt_i,
      .int_fmt_i,
      .vectorial_op_i,
      .tag_i,
      .in_valid_i      ( in_valid                 ),
      .in_ready_o      ( fmt_in_ready[FMT]        ),
      .flush_i,
      .result_o        ( fmt_outputs[FMT].result  ),
      .status_o        ( fmt_outputs[FMT].status  ),
      .extension_bit_o ( fmt_outputs[FMT].ext_bit ),
      .tag_o           ( fmt_outputs[FMT].tag     ),
      .out_valid_o     ( fmt_out_valid[FMT]       ),
      .out_ready_i     ( fmt_out_ready[FMT]       ),
      .busy_o          ( fmt_busy[FMT]            )
    );

  end

  // ------------------
  // Arbitrate Outputs
  // ------------------
  output_t arbiter_output;

  // Round-Robin arbiter to decide which result to use
  miv_rv32_rr_arb_tree #(
    .NumIn     ( NUM_FORMATS ),
    .DataType  ( output_t    ),
    .AxiVldRdy ( 1'b1        )
  ) i_arbiter (
    .clk_i,
    .rst_ni,
    .flush_i,
    .rr_i   ( '0             ),
    .req_i  ( fmt_out_valid  ),
    .gnt_o  ( fmt_out_ready  ),
    .data_i ( fmt_outputs    ),
    .gnt_i  ( out_ready_i    ),
    .req_o  ( out_valid_o    ),
    .data_o ( arbiter_output ),
    .idx_o  ( /* unused */   )
  );

  // Unpack output
  assign result_o        = arbiter_output.result;
  assign status_o        = arbiter_output.status;
  assign extension_bit_o = arbiter_output.ext_bit;
  assign tag_o           = arbiter_output.tag;

  assign busy_o = (| fmt_busy);

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_opgroup_fmt_slice.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module miv_rv32_fpnew_opgroup_fmt_slice #(
  parameter miv_rv32_pkg::opgroup_e     OpGroup       = miv_rv32_pkg::ADDMUL,
  parameter miv_rv32_pkg::fp_format_e   FpFormat      = miv_rv32_pkg::fp_format_e'(0),
  // FPU configuration
  parameter                          NO_MACC_BLK   = 0,
  parameter int unsigned             Width         = 32,
  parameter logic                    EnableVectors = 1'b1,
  parameter int unsigned             NumPipeRegs   = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig    = miv_rv32_pkg::BEFORE,
  parameter type                     TagType       = logic,
  // Do not change
  localparam int unsigned NUM_OPERANDS = miv_rv32_pkg::num_operands(OpGroup)
) (
  input logic                               clk_i,
  input logic                               rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0] operands_i,
  input logic [NUM_OPERANDS-1:0]            is_boxed_i,
  input miv_rv32_pkg::roundmode_e              rnd_mode_i,
  input miv_rv32_pkg::operation_e              op_i,
  input logic                               op_mod_i,
  input logic                               vectorial_op_i,
  input TagType                             tag_i,
  // Input Handshake
  input  logic                              in_valid_i,
  output logic                              in_ready_o,
  input  logic                              flush_i,
  // Output signals
  output logic [Width-1:0]                  result_o,
  output miv_rv32_pkg::status_t                status_o,
  output logic                              extension_bit_o,
  output TagType                            tag_o,
  // Output handshake
  output logic                              out_valid_o,
  input  logic                              out_ready_i,
  // Indication of valid data in flight
  output logic                              busy_o
);

  localparam int unsigned FP_WIDTH  = miv_rv32_pkg::fp_width(FpFormat);
  localparam int unsigned NUM_LANES = miv_rv32_pkg::num_lanes(Width, FpFormat, EnableVectors);
  localparam int unsigned AUX_BITS = 2;


  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid; // Handshake signals for the lanes
  logic                 vectorial_op, cmp_op;

  logic [NUM_LANES*FP_WIDTH-1:0] slice_result;
  logic [Width-1:0]              slice_regular_result, slice_class_result, slice_vec_class_result;
  logic [NUM_LANES-1:0]          slice_cmp_result;

  miv_rv32_pkg::status_t    [NUM_LANES-1:0] lane_status;
  logic                  [NUM_LANES-1:0] lane_ext_bit; // only the first one is actually used
  miv_rv32_pkg::classmask_e [NUM_LANES-1:0] lane_class_mask;
  TagType                [NUM_LANES-1:0] lane_tags; // only the first one is actually used
  logic                  [NUM_LANES-1:0] lane_busy, lane_is_class; // dito
  logic    [NUM_LANES-1:0][AUX_BITS-1:0] lane_aux; // dito

  logic result_is_vector, result_is_class, result_is_cmp;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane
  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled
  assign cmp_op       = (op_i == miv_rv32_pkg::CMP);

  // ---------------
  // Generate Lanes
  // ---------------
  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes
    logic [FP_WIDTH-1:0] local_result; // lane-local results
    logic                local_sign;

    // Generate instances only if needed, lane 0 always generated
    if ((lane == 0) || EnableVectors) begin : active_lane
      logic in_valid, out_valid, out_ready; // lane-local handshake

      logic [NUM_OPERANDS-1:0][FP_WIDTH-1:0] local_operands; // lane-local operands
      logic [FP_WIDTH-1:0]                   op_result;      // lane-local results
      miv_rv32_pkg::status_t                    op_status;
      logic [AUX_BITS-1:0]                   local_aux_data_input;

      assign local_aux_data_input = {vectorial_op, cmp_op};
      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors
      // Slice out the operands for this lane
      always_comb begin : prepare_input
        for (int i = 0; i < int'(NUM_OPERANDS); i++) begin
          local_operands[i] = operands_i[i][(unsigned'(lane)+1)*FP_WIDTH-1:unsigned'(lane)*FP_WIDTH];
        end
      end

      // Instantiate the operation from the selected opgroup
      if (OpGroup == miv_rv32_pkg::ADDMUL) begin : lane_instance
        miv_rv32_fpnew_fma #(
          .FpFormat    ( FpFormat             ),
          .NumPipeRegs ( NumPipeRegs          ),
          .PipeConfig  ( PipeConfig           ),
          .TagType     ( TagType              ),
          .AuxType     ( logic [AUX_BITS-1:0] ),
		  .NO_MACC_BLK ( NO_MACC_BLK          )
        ) i_fma (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands               ),
          .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .tag_i,
          .aux_i           ( local_aux_data_input ), // Remember whether operation was vectorial
          .in_valid_i      ( in_valid             ),
          .in_ready_o      ( lane_in_ready[lane]  ),
          .flush_i,
          .result_o        ( op_result            ),
          .status_o        ( op_status            ),
          .extension_bit_o ( lane_ext_bit[lane]   ),
          .tag_o           ( lane_tags[lane]      ),
          .aux_o           ( lane_aux[lane] ),
          .out_valid_o     ( out_valid            ),
          .out_ready_i     ( out_ready            ),
          .busy_o          ( lane_busy[lane]      )
        );
        assign lane_is_class[lane]   = 1'b0;
        assign lane_class_mask[lane] = miv_rv32_pkg::NEGINF;
      end else if (OpGroup == miv_rv32_pkg::DIVSQRT) begin : lane_instance
        // fpnew_divsqrt #(
        //   .FpFormat   (FpFormat),
        //   .NumPipeRegs(NumPipeRegs),
        //   .PipeConfig (PipeConfig),
        //   .TagType    (TagType),
        //   .AuxType    (logic)
        // ) i_divsqrt (
        //   .clk_i,
        //   .rst_ni,
        //   .operands_i      ( local_operands               ),
        //   .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
        //   .rnd_mode_i,
        //   .op_i,
        //   .op_mod_i,
        //   .tag_i,
        //   .aux_i           ( vectorial_op         ), // Remember whether operation was vectorial
        //   .in_valid_i      ( in_valid             ),
        //   .in_ready_o      ( lane_in_ready[lane]  ),
        //   .flush_i,
        //   .result_o        ( op_result            ),
        //   .status_o        ( op_status            ),
        //   .extension_bit_o ( lane_ext_bit[lane]   ),
        //   .tag_o           ( lane_tags[lane]      ),
        //   .aux_o           ( lane_vectorial[lane] ),
        //   .out_valid_o     ( out_valid            ),
        //   .out_ready_i     ( out_ready            ),
        //   .busy_o          ( lane_busy[lane]      )
        // );
        // assign lane_is_class[lane] = 1'b0;
      end else if (OpGroup == miv_rv32_pkg::NONCOMP) begin : lane_instance
        miv_rv32_fpnew_noncomp #(
          .FpFormat   ( FpFormat             ),
          .NumPipeRegs( NumPipeRegs          ),
          .PipeConfig ( PipeConfig           ),
          .TagType    ( TagType              ),
          .AuxType    ( logic [AUX_BITS-1:0] )
        ) i_noncomp (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands               ),
          .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .tag_i,
          .aux_i           ( local_aux_data_input  ), // Remember whether operation was vectorial
          .in_valid_i      ( in_valid              ),
          .in_ready_o      ( lane_in_ready[lane]   ),
          .flush_i,
          .result_o        ( op_result             ),
          .status_o        ( op_status             ),
          .extension_bit_o ( lane_ext_bit[lane]    ),
          .class_mask_o    ( lane_class_mask[lane] ),
          .is_class_o      ( lane_is_class[lane]   ),
          .tag_o           ( lane_tags[lane]       ),
          .aux_o           ( lane_aux[lane]        ),
          .out_valid_o     ( out_valid             ),
          .out_ready_i     ( out_ready             ),
          .busy_o          ( lane_busy[lane]       )
        );
      end // ADD OTHER OPTIONS HERE

      // Handshakes are only done if the lane is actually used
      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);
      assign lane_out_valid[lane] = out_valid   & ((lane == 0) | result_is_vector);

      // Properly NaN-box or sign-extend the slice result if not in use
      assign local_result      = lane_out_valid[lane] ? op_result : '{default: lane_ext_bit[0]};
      assign lane_status[lane] = lane_out_valid[lane] ? op_status : '0;

    // Otherwise generate constant sign-extension
    end else begin
      assign lane_out_valid[lane] = 1'b0; // unused lane
      assign lane_in_ready[lane]  = 1'b0; // unused lane
      assign local_result         = '{default: lane_ext_bit[0]}; // sign-extend/nan box
      assign lane_status[lane]    = '0;
      assign lane_busy[lane]      = 1'b0;
      assign lane_is_class[lane]  = 1'b0;
    end

    // Insert lane result into slice result
    assign slice_result[(unsigned'(lane)+1)*FP_WIDTH-1:unsigned'(lane)*FP_WIDTH] = local_result;

    // Insert lane result into slice result for CMP operations
    assign slice_cmp_result[unsigned'(lane)] = local_result[0];

    // Create Classification results
    if ((lane+1)*8 <= Width) begin : vectorial_class // vectorial class blocks are 8bits in size
      assign local_sign = (lane_class_mask[lane] == miv_rv32_pkg::NEGINF ||
                           lane_class_mask[lane] == miv_rv32_pkg::NEGNORM ||
                           lane_class_mask[lane] == miv_rv32_pkg::NEGSUBNORM ||
                           lane_class_mask[lane] == miv_rv32_pkg::NEGZERO);
      // Write the current block segment
      assign slice_vec_class_result[(lane+1)*8-1:lane*8] = {
        local_sign,  // BIT 7
        ~local_sign, // BIT 6
        lane_class_mask[lane] == miv_rv32_pkg::QNAN, // BIT 5
        lane_class_mask[lane] == miv_rv32_pkg::SNAN, // BIT 4
        lane_class_mask[lane] == miv_rv32_pkg::POSZERO
            || lane_class_mask[lane] == miv_rv32_pkg::NEGZERO, // BIT 3
        lane_class_mask[lane] == miv_rv32_pkg::POSSUBNORM
            || lane_class_mask[lane] == miv_rv32_pkg::NEGSUBNORM, // BIT 2
        lane_class_mask[lane] == miv_rv32_pkg::POSNORM
            || lane_class_mask[lane] == miv_rv32_pkg::NEGNORM, // BIT 1
        lane_class_mask[lane] == miv_rv32_pkg::POSINF
            || lane_class_mask[lane] == miv_rv32_pkg::NEGINF // BIT 0
      };
    end
  end

  // ------------
  // Output Side
  // ------------
  assign result_is_vector = lane_aux[0][1];
  assign result_is_cmp    = lane_aux[0][0];
  assign result_is_class  = lane_is_class[0];

  assign slice_regular_result = $signed({extension_bit_o, slice_result});

  localparam int unsigned CLASS_VEC_BITS = (NUM_LANES*8 > Width) ? 8 * (Width / 8) : NUM_LANES*8;

  // Pad out unused vec_class bits
  if (CLASS_VEC_BITS < Width) begin : pad_vectorial_class
    assign slice_vec_class_result[Width-1:CLASS_VEC_BITS] = '0;
  end

  // localparam logic [Width-1:0] CLASS_VEC_MASK = 2**CLASS_VEC_BITS - 1;

  assign slice_class_result = result_is_vector ? slice_vec_class_result : lane_class_mask[0];

  // Select the proper result
  assign result_o = result_is_class ? slice_class_result     :
                    result_is_cmp   ? {'0, slice_cmp_result} : slice_regular_result;

  assign extension_bit_o                              = lane_ext_bit[0]; // upper lanes unused
  assign tag_o                                        = lane_tags[0];    // upper lanes unused
  assign busy_o                                       = (| lane_busy);
  assign out_valid_o                                  = lane_out_valid[0]; // upper lanes unused


  // Collapse the lane status
  always_comb begin : output_processing
    // Collapse the status
    automatic miv_rv32_pkg::status_t temp_status;
    temp_status = '0;
    for (int i = 0; i < int'(NUM_LANES); i++)
      temp_status |= lane_status[i];
    status_o = temp_status;
  end
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_opgroup_multifmt_slice.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_opgroup_multifmt_slice #(
  parameter miv_rv32_pkg::opgroup_e     OpGroup       = miv_rv32_pkg::CONV,
  parameter int unsigned             Width         = 64,
  // FPU configuration
  parameter miv_rv32_pkg::fmt_logic_t   FpFmtConfig   = '1,
  parameter miv_rv32_pkg::ifmt_logic_t  IntFmtConfig  = '1,
  parameter logic                    EnableVectors = 1'b1,
  parameter int unsigned             NumPipeRegs   = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig    = miv_rv32_pkg::BEFORE,
  parameter type                     TagType       = logic,
  // Do not change
  localparam int unsigned NUM_OPERANDS = miv_rv32_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_FORMATS  = miv_rv32_pkg::NUM_FP_FORMATS
) (
  input logic                                     clk_i,
  input logic                                     rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,
  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,
  input miv_rv32_pkg::roundmode_e                    rnd_mode_i,
  input miv_rv32_pkg::operation_e                    op_i,
  input logic                                     op_mod_i,
  input miv_rv32_pkg::fp_format_e                    src_fmt_i,
  input miv_rv32_pkg::fp_format_e                    dst_fmt_i,
  input miv_rv32_pkg::int_format_e                   int_fmt_i,
  input logic                                     vectorial_op_i,
  input TagType                                   tag_i,
  // Input Handshake
  input  logic                                    in_valid_i,
  output logic                                    in_ready_o,
  input  logic                                    flush_i,
  // Output signals
  output logic [Width-1:0]                        result_o,
  output miv_rv32_pkg::status_t                      status_o,
  output logic                                    extension_bit_o,
  output TagType                                  tag_o,
  // Output handshake
  output logic                                    out_valid_o,
  input  logic                                    out_ready_i,
  // Indication of valid data in flight
  output logic                                    busy_o
);

  localparam int unsigned MAX_FP_WIDTH   = miv_rv32_pkg::max_fp_width(FpFmtConfig);
  localparam int unsigned MAX_INT_WIDTH  = miv_rv32_pkg::max_int_width(IntFmtConfig);
  localparam int unsigned NUM_LANES = miv_rv32_pkg::max_num_lanes(Width, FpFmtConfig, 1'b1);
  localparam int unsigned NUM_INT_FORMATS = miv_rv32_pkg::NUM_INT_FORMATS;
  // We will send the format information along with the data
  localparam int unsigned FMT_BITS =
      miv_rv32_pkg::maximum($clog2(NUM_FORMATS), $clog2(NUM_INT_FORMATS));
  localparam int unsigned AUX_BITS = FMT_BITS + 4; // also add vectorial and integer flags

  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid; // Handshake signals for the lanes
  logic                 vectorial_op;
  logic [FMT_BITS-1:0]  dst_fmt; // destination format to pass along with operation
  logic [AUX_BITS-1:0]  aux_data;

  // additional flags for CONV
  logic       dst_fmt_is_int, dst_is_cpk;
  logic [1:0] dst_vec_op; // info for vectorial results (for packing)
  logic [1:0] target_aux_d, target_aux_q;
  logic       is_up_cast, is_down_cast;

  logic [NUM_FORMATS-1:0][Width-1:0]      fmt_slice_result;
  logic [NUM_INT_FORMATS-1:0][Width-1:0]  ifmt_slice_result;
  logic [NUM_FORMATS-1:0][3:0][Width-1:0] fmt_conv_cpk_result;


  logic [Width-1:0] conv_target_d, conv_target_q; // vectorial conversions update a register

  miv_rv32_pkg::status_t [NUM_LANES-1:0]   lane_status;
  logic   [NUM_LANES-1:0]               lane_ext_bit; // only the first one is actually used
  TagType [NUM_LANES-1:0]               lane_tags; // only the first one is actually used
  logic   [NUM_LANES-1:0][AUX_BITS-1:0] lane_aux; // only the first one is actually used
  logic   [NUM_LANES-1:0]               lane_busy; // dito

  logic                result_is_vector, result_is_vsum, op_is_vsum;
  logic [FMT_BITS-1:0] result_fmt;
  logic                result_fmt_is_int, result_is_cpk;
  logic [1:0]          result_vec_op; // info for vectorial results (for packing)

  // -----------
  // Input Side
  // -----------
  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane
  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled

  // Cast-and-Pack ops are encoded in operation and modifier
  assign dst_fmt_is_int = (OpGroup == miv_rv32_pkg::CONV) & (op_i == miv_rv32_pkg::F2I);
  assign dst_is_cpk     = (OpGroup == miv_rv32_pkg::CONV) & (op_i == miv_rv32_pkg::CPKAB ||
                                                          op_i == miv_rv32_pkg::CPKCD);
  assign dst_vec_op     = {2{(OpGroup == miv_rv32_pkg::CONV)}} & {(op_i == miv_rv32_pkg::CPKCD), op_mod_i};

  assign is_up_cast   = (miv_rv32_pkg::fp_width(dst_fmt_i) > miv_rv32_pkg::fp_width(src_fmt_i));
  assign is_down_cast = (miv_rv32_pkg::fp_width(dst_fmt_i) < miv_rv32_pkg::fp_width(src_fmt_i));
  assign op_is_vsum   = op_i == miv_rv32_pkg::VSUM ? 1'b1 : 1'b0;

  // The destination format is the int format for F2I casts
  assign dst_fmt    = dst_fmt_is_int ? int_fmt_i : dst_fmt_i;

  // The data sent along consists of the vectorial flag and format bits
  assign aux_data      = {dst_is_cpk, dst_fmt_is_int, vectorial_op, dst_fmt, op_is_vsum};
  assign target_aux_d  = dst_vec_op;

  // CONV passes one operand for assembly after the unit: opC for cpk, opB for others
  if (OpGroup == miv_rv32_pkg::CONV) begin : conv_target
    assign conv_target_d = dst_is_cpk ? operands_i[2] : operands_i[1];
  end

  // For 2-operand units, prepare boxing info
  logic [NUM_FORMATS-1:0]      is_boxed_1op;
  logic [NUM_FORMATS-1:0][1:0] is_boxed_2op;

  always_comb begin : boxed_2op
    for (int fmt = 0; fmt < NUM_FORMATS; fmt++) begin
      is_boxed_1op[fmt] = is_boxed_i[fmt][0];
      is_boxed_2op[fmt] = is_boxed_i[fmt][1:0];
    end
  end

  // ---------------
  // Generate Lanes
  // ---------------
  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes
    localparam int unsigned LANE = (lane); // unsigned to please the linter
    // Get a mask of active formats for this lane
    localparam miv_rv32_pkg::fmt_logic_t ACTIVE_FORMATS =
        miv_rv32_pkg::get_lane_formats(Width, FpFmtConfig, LANE);
    localparam miv_rv32_pkg::ifmt_logic_t ACTIVE_INT_FORMATS =
        miv_rv32_pkg::get_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);
    localparam int unsigned MAX_WIDTH = miv_rv32_pkg::max_fp_width(ACTIVE_FORMATS);

    // Cast-specific parameters
    localparam miv_rv32_pkg::fmt_logic_t CONV_FORMATS =
        miv_rv32_pkg::get_conv_lane_formats(Width, FpFmtConfig, LANE);
    localparam miv_rv32_pkg::ifmt_logic_t CONV_INT_FORMATS =
        miv_rv32_pkg::get_conv_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);
    localparam int unsigned CONV_WIDTH = miv_rv32_pkg::max_fp_width(CONV_FORMATS);

    // Dotp-specific parameters
    localparam miv_rv32_pkg::fmt_logic_t DOTP_FORMATS =
        miv_rv32_pkg::get_dotp_lane_formats(Width, FpFmtConfig, LANE);
    localparam int unsigned DOTP_MAX_FMT_WIDTH = miv_rv32_pkg::max_fp_width(DOTP_FORMATS);
    localparam int unsigned DOTP_WIDTH = 2*DOTP_MAX_FMT_WIDTH;

    // Lane parameters from Opgroup
    localparam miv_rv32_pkg::fmt_logic_t LANE_FORMATS = (OpGroup == miv_rv32_pkg::CONV) ? CONV_FORMATS :
                                                     (OpGroup == miv_rv32_pkg::DOTP) ? DOTP_FORMATS :
                                                                                    ACTIVE_FORMATS;
    localparam int unsigned LANE_WIDTH = (OpGroup == miv_rv32_pkg::CONV) ? CONV_WIDTH :
                                         (OpGroup == miv_rv32_pkg::DOTP) ? DOTP_WIDTH : MAX_WIDTH;

    logic [LANE_WIDTH-1:0] local_result; // lane-local results

    // Generate instances only if needed, lane 0 always generated
    if ((lane == 0) || (EnableVectors & !(OpGroup == miv_rv32_pkg::DOTP && (lane > 3)) )) begin : active_lane
      logic in_valid, out_valid, out_ready; // lane-local handshake

      logic [NUM_OPERANDS-1:0][LANE_WIDTH-1:0] local_operands;  // lane-local oprands
      logic [LANE_WIDTH-1:0]                   op_result;       // lane-local results
      miv_rv32_pkg::status_t                      op_status;

      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors

      // Slice out the operands for this lane, upper bits are ignored in the unit
      always_comb begin : prepare_input
        for (int unsigned i = 0; i < NUM_OPERANDS; i++) begin
          local_operands[i] = operands_i[i] >> LANE*miv_rv32_pkg::fp_width(src_fmt_i);
        end

        if (OpGroup == miv_rv32_pkg::DOTP) begin
          for (int unsigned i = 0; i < NUM_OPERANDS; i++) begin
            local_operands[i] = operands_i[i] >> LANE*2*miv_rv32_pkg::fp_width(src_fmt_i); // expanded format is twice the width of src_fmt
          end
        end else if (OpGroup == miv_rv32_pkg::CONV) begin // override operand 0 for some conversions
          // Source is an integer
          if (op_i == miv_rv32_pkg::I2F) begin
            local_operands[0] = operands_i[0] >> LANE*miv_rv32_pkg::int_width(int_fmt_i);
          // vectorial F2F up casts
          end else if (op_i == miv_rv32_pkg::F2F) begin
            if (vectorial_op && op_mod_i && is_up_cast) begin // up cast with upper half
              local_operands[0] = operands_i[0] >> LANE*miv_rv32_pkg::fp_width(src_fmt_i) +
                                                   MAX_FP_WIDTH/2;
            end
          // CPK
          end else if (dst_is_cpk) begin
            if (lane == 1) begin
              local_operands[0] = operands_i[1];
            end
          end
        end
      end

      // Instantiate the operation from the selected opgroup
      if (OpGroup == miv_rv32_pkg::ADDMUL) begin : lane_instance
        miv_rv32_fpnew_fma_multi #(
          .FpFmtConfig ( LANE_FORMATS         ),
          .NumPipeRegs ( NumPipeRegs          ),
          .PipeConfig  ( PipeConfig           ),
          .TagType     ( TagType              ),
          .AuxType     ( logic [AUX_BITS-1:0] )
        ) i_fpnew_fma_multi (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands  ),
          .is_boxed_i,
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .dst_fmt_i,
          .tag_i,
          .aux_i           ( aux_data            ),
          .in_valid_i      ( in_valid            ),
          .in_ready_o      ( lane_in_ready[lane] ),
          .flush_i,
          .result_o        ( op_result           ),
          .status_o        ( op_status           ),
          .extension_bit_o ( lane_ext_bit[lane]  ),
          .tag_o           ( lane_tags[lane]     ),
          .aux_o           ( lane_aux[lane]      ),
          .out_valid_o     ( out_valid           ),
          .out_ready_i     ( out_ready           ),
          .busy_o          ( lane_busy[lane]     )
        );
      end else if (OpGroup == miv_rv32_pkg::DOTP) begin : lane_instance
        miv_rv32_fpnew_sdotp_multi_wrapper #(
          .FpFmtConfig ( LANE_FORMATS         ), // fp64 and fp32 not supported
          .NumPipeRegs ( NumPipeRegs          ),
          .PipeConfig  ( PipeConfig           ),
          .TagType     ( TagType              ),
          .AuxType     ( logic [AUX_BITS-1:0] )
        ) i_fpnew_sdotp_multi_wrapper (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands[2:0] ), // 3 operands
          .is_boxed_i,
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .dst_fmt_i,
          .tag_i,
          .aux_i           ( aux_data            ),
          .in_valid_i      ( in_valid            ),
          .in_ready_o      ( lane_in_ready[lane] ),
          .flush_i,
          .result_o        ( op_result           ),
          .status_o        ( op_status           ),
          .extension_bit_o ( lane_ext_bit[lane]  ),
          .tag_o           ( lane_tags[lane]     ),
          .aux_o           ( lane_aux[lane]      ),
          .out_valid_o     ( out_valid           ),
          .out_ready_i     ( out_ready           ),
          .busy_o          ( lane_busy[lane]     )
        );
      end else if ((OpGroup == miv_rv32_pkg::DIVSQRT) && (l_core_pulp_divsqrt == 0)) begin : lane_instance
	            // The T-head-based DivSqrt unit is supported only in FP32-only configurations
          miv_rv32_fpnew_divsqrt_th_32 #(
            .NumPipeRegs ( NumPipeRegs          ),
            .PipeConfig  ( PipeConfig           ),
            .TagType     ( TagType              ),
            .AuxType     ( logic [AUX_BITS-1:0] )
          ) i_fpnew_divsqrt_multi_th (
            .clk_i,                                                      
            .rst_ni,                                                     
            .operands_i      ( local_operands[1:0] ), // 2 operands      
            .is_boxed_i      ( is_boxed_2op        ), // 2 operands      
            .rnd_mode_i,                                                 
            .op_i,                                                       
            .tag_i,                                                           
            .mask_i          ( '0  ),                
            .aux_i           ( aux_data            ),                    
            .in_valid_i      ( in_valid            ),                    
            .in_ready_o      ( lane_in_ready[lane] ),                    
            .flush_i,                                                    
            .result_o        ( op_result           ),                    
            .status_o        ( op_status           ),                    
            .extension_bit_o ( lane_ext_bit[lane]  ),                    
            .tag_o           ( lane_tags[lane]     ),                       
            .mask_o          (    ),                   
            .aux_o           ( lane_aux[lane]      ),                    
            .out_valid_o     ( out_valid           ),                    
            .out_ready_i     ( out_ready           ),                    
            .busy_o          ( lane_busy[lane]     ),
            .reg_ena_i       ( '0    )
          );
		  
      end else if ((OpGroup == miv_rv32_pkg::DIVSQRT) && (l_core_pulp_divsqrt == 1)) begin : lane_instance
        miv_rv32_fpnew_divsqrt_multi #(
          .FpFmtConfig ( LANE_FORMATS         ),
          .NumPipeRegs ( NumPipeRegs          ),
          .PipeConfig  ( PipeConfig           ),
          .TagType     ( TagType              ),
          .AuxType     ( logic [AUX_BITS-1:0] )
        ) i_fpnew_divsqrt_multi (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands[1:0] ), // 2 operands
          .is_boxed_i      ( is_boxed_2op        ), // 2 operands
          .rnd_mode_i,
          .op_i,
          .dst_fmt_i,
          .tag_i,
          .aux_i           ( aux_data            ),
          .in_valid_i      ( in_valid            ),
          .in_ready_o      ( lane_in_ready[lane] ),
          .flush_i,
          .result_o        ( op_result           ),
          .status_o        ( op_status           ),
          .extension_bit_o ( lane_ext_bit[lane]  ),
          .tag_o           ( lane_tags[lane]     ),
          .aux_o           ( lane_aux[lane]      ),
          .out_valid_o     ( out_valid           ),
          .out_ready_i     ( out_ready           ),
          .busy_o          ( lane_busy[lane]     )
        );
      end else if (OpGroup == miv_rv32_pkg::NONCOMP) begin : lane_instance

      end else if (OpGroup == miv_rv32_pkg::CONV) begin : lane_instance
        miv_rv32_fpnew_cast_multi #(
          .FpFmtConfig  ( LANE_FORMATS         ),
          .IntFmtConfig ( CONV_INT_FORMATS     ),
          .NumPipeRegs  ( NumPipeRegs          ),
          .PipeConfig   ( PipeConfig           ),
          .TagType      ( TagType              ),
          .AuxType      ( logic [AUX_BITS-1:0] )
        ) i_fpnew_cast_multi (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands[0]   ),
          .is_boxed_i      ( is_boxed_1op        ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .dst_fmt_i,
          .int_fmt_i,
          .tag_i,
          .aux_i           ( aux_data            ),
          .in_valid_i      ( in_valid            ),
          .in_ready_o      ( lane_in_ready[lane] ),
          .flush_i,
          .result_o        ( op_result           ),
          .status_o        ( op_status           ),
          .extension_bit_o ( lane_ext_bit[lane]  ),
          .tag_o           ( lane_tags[lane]     ),
          .aux_o           ( lane_aux[lane]      ),
          .out_valid_o     ( out_valid           ),
          .out_ready_i     ( out_ready           ),
          .busy_o          ( lane_busy[lane]     )
        );
      end // ADD OTHER OPTIONS HERE

      // Handshakes are only done if the lane is actually used
      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);
      assign lane_out_valid[lane] = out_valid & ((lane == 0) | result_is_vector);

      // Properly NaN-box or sign-extend the slice result if not in use
      assign local_result      = lane_out_valid[lane] ? op_result : '{default: lane_ext_bit[0]};
      assign lane_status[lane] = lane_out_valid[lane] ? op_status : '0;

    // Otherwise generate constant sign-extension
    end else begin : inactive_lane
      assign lane_out_valid[lane] = 1'b0; // unused lane
      assign lane_in_ready[lane]  = 1'b0; // unused lane
      assign lane_aux[lane]       = 1'b0; // unused lane
      assign lane_tags[lane]      = 1'b0; // unused lane
      assign lane_ext_bit[lane]   = 1'b1; // NaN-box unused lane
      assign local_result         = '{default: lane_ext_bit[0]}; // sign-extend/nan box
      assign lane_status[lane]    = '0;
      assign lane_busy[lane]      = 1'b0;
    end

    // Generate result packing depending on float format
    for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : pack_fp_result
      // Set up some constants
      if (OpGroup == miv_rv32_pkg::DOTP) begin
        localparam int unsigned INACTIVE_MASK = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(LANE_FORMATS[fmt]));
        localparam int unsigned FP_WIDTH      = miv_rv32_pkg::minimum(INACTIVE_MASK, miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt)));
        // only for active formats within the lane
        if (ACTIVE_FORMATS[fmt] && (LANE_WIDTH>0)) begin
          if (FP_WIDTH==INACTIVE_MASK) begin
            assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
                local_result[FP_WIDTH-1:0];
          end else begin
            assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
                local_result[FP_WIDTH-1:0];
          end
        end else if ((LANE+1)*FP_WIDTH <= Width) begin
          assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
              '{default: lane_ext_bit[LANE]};
        end else if (LANE*FP_WIDTH < Width) begin
          assign fmt_slice_result[fmt][Width-1:LANE*FP_WIDTH] =
              '{default: lane_ext_bit[LANE]};
        end
      end else begin
        localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
        // only for active formats within the lane
        if (ACTIVE_FORMATS[fmt]) begin
          assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
              local_result[FP_WIDTH-1:0];
        end else if ((LANE+1)*FP_WIDTH <= Width) begin
          assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
              '{default: lane_ext_bit[LANE]};
        end else if (LANE*FP_WIDTH < Width) begin
          assign fmt_slice_result[fmt][Width-1:LANE*FP_WIDTH] =
              '{default: lane_ext_bit[LANE]};
        end
      end
    end

    // Generate result packing depending on integer format
    if (OpGroup == miv_rv32_pkg::CONV) begin : int_results_enabled
      for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : pack_int_result
        // Set up some constants
        localparam int unsigned INT_WIDTH = miv_rv32_pkg::int_width(miv_rv32_pkg::int_format_e'(ifmt));
        if (ACTIVE_INT_FORMATS[ifmt]) begin
          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] =
            local_result[INT_WIDTH-1:0];
        end else if ((LANE+1)*INT_WIDTH <= Width) begin
          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] = '0;
        end else if (LANE*INT_WIDTH < Width) begin
          assign ifmt_slice_result[ifmt][Width-1:LANE*INT_WIDTH] = '0;
        end
      end
    end
  end

  // Extend slice result if needed
  for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : extend_fp_result
    // Set up some constants
    localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));
    if (NUM_LANES*FP_WIDTH < Width)
      assign fmt_slice_result[fmt][Width-1:NUM_LANES*FP_WIDTH] = '{default: lane_ext_bit[0]};
  end

  // Mute int results if unused
  for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : int_results_disabled
    if (OpGroup != miv_rv32_pkg::CONV) begin : mute_int_result
      assign ifmt_slice_result[ifmt] = '0;
    end
  end

  // Bypass lanes with target operand for vectorial casts
  if (OpGroup == miv_rv32_pkg::CONV) begin : target_regs
    // Bypass pipeline signals, index i holds signal after i register stages
    logic [0:NumPipeRegs][Width-1:0] byp_pipe_target_q;
    logic [0:NumPipeRegs][1:0]       byp_pipe_aux_q;
    logic [0:NumPipeRegs]            byp_pipe_valid_q;
    // Ready signal is combinatorial for all stages
    logic [0:NumPipeRegs] byp_pipe_ready;

    // Input stage: First element of pipeline is taken from inputs
    assign byp_pipe_target_q[0]  = conv_target_d;
    assign byp_pipe_aux_q[0]     = target_aux_d;
    assign byp_pipe_valid_q[0]   = in_valid_i & vectorial_op;
    // Generate the register stages
    for (genvar i = 0; i < NumPipeRegs; i++) begin : gen_bypass_pipeline
      // Internal register enable for this stage
      logic reg_ena;
      // Determine the ready signal of the current stage - advance the pipeline:
      // 1. if the next stage is ready for our data
      // 2. if the next stage only holds a bubble (not valid) -> we can pop it
      assign byp_pipe_ready[i] = byp_pipe_ready[i+1] | ~byp_pipe_valid_q[i+1];
      // Valid: enabled by ready signal, synchronous clear with the flush signal
      `FFLARNC(byp_pipe_valid_q[i+1], byp_pipe_valid_q[i], byp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
      // Enable register if pipleine ready and a valid data item is present
      assign reg_ena = byp_pipe_ready[i] & byp_pipe_valid_q[i];
      // Generate the pipeline registers within the stages, use enable-registers
      `FFL(byp_pipe_target_q[i+1],  byp_pipe_target_q[i],  reg_ena, '0)
      `FFL(byp_pipe_aux_q[i+1],     byp_pipe_aux_q[i],     reg_ena, '0)
    end
    // Output stage: Ready travels backwards from output side, driven by downstream circuitry
    assign byp_pipe_ready[NumPipeRegs] = out_ready_i & result_is_vector;
    // Output stage: assign module outputs
    assign conv_target_q = byp_pipe_target_q[NumPipeRegs];

    // decode the aux data
    assign result_vec_op = byp_pipe_aux_q[NumPipeRegs];

    for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : pack_conv_cpk_result
      localparam int unsigned FP_WIDTH = miv_rv32_pkg::fp_width(miv_rv32_pkg::fp_format_e'(fmt));

      for (genvar op_idx = 0; op_idx < 4; op_idx++) begin : pack_conv_cpk_result_operands
        localparam int unsigned UPPER_LEFT  = 2*(op_idx+1)*FP_WIDTH;
        localparam int unsigned LOWER_LEFT  = 2*op_idx*FP_WIDTH;
        localparam int unsigned UPPER_RIGHT = 2*FP_WIDTH;

        if(UPPER_LEFT <= Width) begin
          always_comb begin : pack_conv_cpk
            fmt_conv_cpk_result[fmt][op_idx] = conv_target_q; // rd pre-load
            fmt_conv_cpk_result[fmt][op_idx][UPPER_LEFT-1:LOWER_LEFT] = fmt_slice_result[fmt][UPPER_RIGHT-1:0*FP_WIDTH]; // vfcpk
          end
        end else begin
          assign fmt_conv_cpk_result[fmt][op_idx] = '0;
        end
      end
    end

  end else begin : no_conv
    assign result_vec_op = '0;
    assign fmt_conv_cpk_result = '0;
  end

  // ------------
  // Output Side
  // ------------
  assign {result_is_cpk, result_fmt_is_int, result_is_vector, result_fmt, result_is_vsum} = lane_aux[0];

  assign result_o = result_fmt_is_int ? ifmt_slice_result[result_fmt]                   :
                    result_is_cpk     ? fmt_conv_cpk_result[result_fmt][result_vec_op]  :
                    result_is_vsum    ? {{(Width/2){1'b1}}, {fmt_slice_result[result_fmt][Width/2-1:0]}} :
                                        fmt_slice_result[result_fmt];

  assign extension_bit_o = lane_ext_bit[0]; // don't care about upper ones
  assign tag_o           = lane_tags[0];    // don't care about upper ones
  assign busy_o          = (| lane_busy);

  assign out_valid_o     = lane_out_valid[0]; // don't care about upper ones

  // Collapse the status
  always_comb begin : output_processing
    // Collapse the status
    automatic miv_rv32_pkg::status_t temp_status;
    temp_status = '0;
    for (int i = 0; i < int'(NUM_LANES); i++)
      temp_status |= lane_status[i];
    status_o = temp_status;
  end
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_fpnew_rounding.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module miv_rv32_fpnew_rounding #(
  parameter int unsigned AbsWidth=2 // Width of the abolute value, without sign bit
) (
  // Input value
  input logic [AbsWidth-1:0]   abs_value_i,             // absolute value without sign
  input logic                  sign_i,
  // Rounding information
  input logic [1:0]            round_sticky_bits_i,     // round and sticky bits {RS}
  input miv_rv32_pkg::roundmode_e rnd_mode_i,
  input logic                  effective_subtraction_i, // sign of inputs affects rounding of zeroes
  // Output value
  output logic [AbsWidth-1:0]  abs_rounded_o,           // absolute value without sign
  output logic                 sign_o,
  // Output classification
  output logic                 exact_zero_o,             // output is an exact zero
  input miv_rv32_pkg::operation_e op_i
);

  logic round_up; // Rounding decision

  // Take the rounding decision according to RISC-V spec
  // RoundMode | Mnemonic | Meaning
  // :--------:|:--------:|:-------
  //    000    |   RNE    | Round to Nearest, ties to Even
  //    001    |   RTZ    | Round towards Zero
  //    010    |   RDN    | Round Down (towards -\infty)
  //    011    |   RUP    | Round Up (towards \infty)
  //    100    |   RMM    | Round to Nearest, ties to Max Magnitude
  //  others   |          | *invalid*
  always_comb begin : rounding_decision
    unique case (rnd_mode_i)
      miv_rv32_pkg::RNE: // Decide accoring to round/sticky bits
        unique case (round_sticky_bits_i)
          2'b00,
          2'b01: round_up = 1'b0;           // < ulp/2 away, round down
          2'b10: round_up = abs_value_i[0]; // = ulp/2 away, round towards even result
          2'b11: round_up = 1'b1;           // > ulp/2 away, round up
          default: round_up = miv_rv32_pkg::DONT_CARE;
        endcase
      miv_rv32_pkg::RTZ: round_up = 1'b0; // always round down
      miv_rv32_pkg::RDN: round_up = (| round_sticky_bits_i) ? sign_i  : 1'b0; // to 0 if +, away if -
      miv_rv32_pkg::RUP: round_up = (| round_sticky_bits_i) ? ~sign_i : 1'b0; // to 0 if -, away if +
      miv_rv32_pkg::RMM: round_up = round_sticky_bits_i[1]; // round down if < ulp/2 away, else up
      default: round_up = miv_rv32_pkg::DONT_CARE; // propagate x
    endcase
  end

  // Perform the rounding, exponent change and overflow to inf happens automagically
  assign abs_rounded_o = abs_value_i + round_up;

  // True zero result is a zero result without dirty round/sticky bits
  assign exact_zero_o = (abs_value_i == '0) && (round_sticky_bits_i == '0);

  // In case of effective subtraction (thus signs of addition operands must have differed) and a
  // true zero result, the result sign is '-' in case of RDN and '+' for other modes.
  assign sign_o = (exact_zero_o && effective_subtraction_i)
                    ? ((rnd_mode_i == miv_rv32_pkg::RDN) & (op_i != miv_rv32_pkg::MUL))
                    : sign_i;
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_iteration_div_sqrt_mvp.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
////////////////////////////////////////////////////////////////////////////////
// Company:        IIS @ ETHZ - Federal Institute of Technology               //
//                                                                            //
// Engineers:      Lei Li                  lile@iis.ee.ethz.ch                //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    12/01/2017                                                 //
// Design Name:    FPU                                                        //
// Module Name:    miv_rv32_iteration_div_sqrt_mvp                                     //
// Project Name:   Private FPU                                                //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:    iteration unit for div and sqrt                            //
//                                                                            //
//                                                                            //
// Revision:        03/14/2018                                                //
//                  For div_sqrt_mvp                                          //
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_iteration_div_sqrt_mvp
#(
   parameter   WIDTH=25
)
  (//Input

   input logic [WIDTH-1:0]      A_DI,
   input logic [WIDTH-1:0]      B_DI,
   input logic                  Div_enable_SI,
   input logic                  Div_start_dly_SI,
   input logic                  Sqrt_enable_SI,
   input logic [1:0]            D_DI,

   output logic [1:0]           D_DO,
   output logic [WIDTH-1:0]     Sum_DO,
   output logic                 Carry_out_DO
    );

   logic                        D_carry_D;
   logic                        Sqrt_cin_D;
   logic                        Cin_D;

   assign D_DO[0]=~D_DI[0];
   assign D_DO[1]=~(D_DI[1] ^ D_DI[0]);
   assign D_carry_D=D_DI[1] | D_DI[0];
   assign Sqrt_cin_D=Sqrt_enable_SI&&D_carry_D;
   assign Cin_D=Div_enable_SI?1'b0:Sqrt_cin_D;
   assign {Carry_out_DO,Sum_DO}=A_DI+B_DI+Cin_D;

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_lzc.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2018 - 2019 ETH Zurich, University of Bologna
// All rights reserved.
//
// This code is under development and not yet released to the public.
// Until it is released, the code is under the copyright of ETH Zurich and
// the University of Bologna, and may contain confidential and/or unpublished
// work. Any reuse/redistribution is strictly forbidden without written
// permission from ETH Zurich.
//
// Bug fixes and contributions will eventually be released under the
// SolderPad open hardware license in the context of the PULP platform
// (http://www.pulp-platform.org), under the copyright of ETH Zurich and the
// University of Bologna.

/// A trailing zero counter / leading zero counter.
/// Set MODE to 0 for trailing zero counter => cnt_o is the number of trailing zeros (from the LSB)
/// Set MODE to 1 for leading zero counter  => cnt_o is the number of leading zeros  (from the MSB)
/// If the input does not contain a zero, `empty_o` is asserted. Additionally `cnt_o` contains
/// the maximum number of zeros - 1. For example:
///   in_i = 000_0000, empty_o = 1, cnt_o = 6 (mode = 0)
///   in_i = 000_0001, empty_o = 0, cnt_o = 0 (mode = 0)
///   in_i = 000_1000, empty_o = 0, cnt_o = 3 (mode = 0)
/// Furthermore, this unit contains a more efficient implementation for Verilator (simulation only).
/// This speeds up simulation significantly.
import miv_rv32_pkg::*;
module miv_rv32_lzc #(
  /// The width of the input vector.
  parameter int unsigned WIDTH = 2,
  /// Mode selection: 0 -> trailing zero, 1 -> leading zero
  parameter bit          MODE  = 1'b0,
  /// Dependent parameter. Do **not** change!
  ///
  /// Width of the output signal with the zero count.
  parameter int unsigned CNT_WIDTH = miv_rv32_pkg::idx_width(WIDTH)
) (
  /// Input vector to be counted.
  input  logic [WIDTH-1:0]     in_i,
  /// Count of the leading / trailing zeros.
  output logic [CNT_WIDTH-1:0] cnt_o,
  /// Counter is empty: Asserted if all bits in in_i are zero.
  output logic                 empty_o
);

  if (WIDTH == 1) begin : gen_degenerate_lzc

    assign cnt_o[0] = !in_i[0];
    assign empty_o = !in_i[0];

  end else begin : gen_lzc

    localparam int unsigned NumLevels = $clog2(WIDTH);

    // pragma translate_off
    initial begin
      assert(WIDTH > 0) else $fatal(1, "input must be at least one bit wide");
    end
    // pragma translate_on

    logic [WIDTH-1:0][NumLevels-1:0] index_lut;
    logic [2**NumLevels-1:0] sel_nodes;
    logic [2**NumLevels-1:0][NumLevels-1:0] index_nodes;

    logic [WIDTH-1:0] in_tmp;

    // reverse vector if required
    always_comb begin : flip_vector
      for (int unsigned i = 0; i < WIDTH; i++) begin
        in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];
      end
    end

    for (genvar j = 0; unsigned'(j) < WIDTH; j++) begin : g_index_lut
      assign index_lut[j] = (NumLevels)'(unsigned'(j));
    end

    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : g_levels
      if (unsigned'(level) == NumLevels - 1) begin : g_last_level
        for (genvar k = 0; k < 2 ** level; k++) begin : g_level
          // if two successive indices are still in the vector...
          if (unsigned'(k) * 2 < WIDTH - 1) begin : g_reduce
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2] | in_tmp[k * 2 + 1];
            assign index_nodes[2 ** level - 1 + k] = (in_tmp[k * 2] == 1'b1)
              ? index_lut[k * 2] :
                index_lut[k * 2 + 1];
          end
          // if only the first index is still in the vector...
          if (unsigned'(k) * 2 == WIDTH - 1) begin : g_base
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2];
            assign index_nodes[2 ** level - 1 + k] = index_lut[k * 2];
          end
          // if index is out of range
          if (unsigned'(k) * 2 > WIDTH - 1) begin : g_out_of_range
            assign sel_nodes[2 ** level - 1 + k] = 1'b0;
            assign index_nodes[2 ** level - 1 + k] = '0;
          end
        end
      end else begin : g_not_last_level
        for (genvar l = 0; l < 2 ** level; l++) begin : g_level
          assign sel_nodes[2 ** level - 1 + l] =
              sel_nodes[2 ** (level + 1) - 1 + l * 2] | sel_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
          assign index_nodes[2 ** level - 1 + l] = (sel_nodes[2 ** (level + 1) - 1 + l * 2] == 1'b1)
            ? index_nodes[2 ** (level + 1) - 1 + l * 2] :
              index_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
        end
      end
    end

    assign cnt_o = NumLevels > unsigned'(0) ? index_nodes[0] : {($clog2(WIDTH)) {1'b0}};
    assign empty_o = NumLevels > unsigned'(0) ? ~sel_nodes[0] : ~(|in_i);

  end : gen_lzc

endmodule : miv_rv32_lzc

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_norm_div_sqrt_mvp.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

////////////////////////////////////////////////////////////////////////////////
// Company:        IIS @ ETHZ - Federal Institute of Technology               //
//                                                                            //
// Engineers:      Lei Li    lile@iis.ee.ethz.ch                              //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    09/03/2018                                                 //
// Design Name:    FPU                                                        //
// Module Name:    miv_rv32_norm_div_sqrt_mvp.sv                                       //
// Project Name:                                                              //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:    Floating point Normalizer/Rounding unit                    //
//                 Since this module is design as a combinatinal logic, it can//
//                 be added arbinary register stages for different frequency  //
//                 in the wrapper module.                                     //
//                                                                            //
//                                                                            //
//                                                                            //
// Revision Date:  12/04/2018                                                 //
//                 Lei Li                                                     //
//                 To address some requirements by Stefan                     //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

import miv_rv32_pkg::*;

module miv_rv32_norm_div_sqrt_mvp
  (//Inputs
   input logic [C_MANT_FP64+4:0]                Mant_in_DI,  // Include the needed 4-bit for rounding and hidden bit
   input logic signed [C_EXP_FP64+1:0]          Exp_in_DI,
   input logic                                  Sign_in_DI,
   input logic                                  Div_enable_SI,
   input logic                                  Sqrt_enable_SI,
   input logic                                  Inf_a_SI,
   input logic                                  Inf_b_SI,
   input logic                                  Zero_a_SI,
   input logic                                  Zero_b_SI,
   input logic                                  NaN_a_SI,
   input logic                                  NaN_b_SI,
   input logic                                  SNaN_SI,
   input logic [C_RM-1:0]                       RM_SI,
   input logic                                  Full_precision_SI,
   input logic                                  FP32_SI,
   input logic                                  FP64_SI,
   input logic                                  FP16_SI,
   input logic                                  FP16ALT_SI,
   //Outputs
   output logic [C_EXP_FP64+C_MANT_FP64:0]      Result_DO,
   output logic [4:0]                           Fflags_SO //{NV,DZ,OF,UF,NX}
   );


   logic                                        Sign_res_D;

   logic                                        NV_OP_S;
   logic                                        Exp_OF_S;
   logic                                        Exp_UF_S;
   logic                                        Div_Zero_S;
   logic                                        In_Exact_S;

   /////////////////////////////////////////////////////////////////////////////
   // Normalization                                                           //
   /////////////////////////////////////////////////////////////////////////////
   logic [C_MANT_FP64:0]                        Mant_res_norm_D;
   logic [C_EXP_FP64-1:0]                       Exp_res_norm_D;

   /////////////////////////////////////////////////////////////////////////////
   // Right shift operations for negtive exponents                            //
   /////////////////////////////////////////////////////////////////////////////

  logic  [C_EXP_FP64+1:0]                       Exp_Max_RS_FP64_D;
  logic  [C_EXP_FP32+1:0]                       Exp_Max_RS_FP32_D;
  logic  [C_EXP_FP16+1:0]                       Exp_Max_RS_FP16_D;
  logic  [C_EXP_FP16ALT+1:0]                    Exp_Max_RS_FP16ALT_D;
  //
  assign Exp_Max_RS_FP64_D=Exp_in_DI[C_EXP_FP64:0]+C_MANT_FP64+1; // to check exponent after (C_MANT_FP64+1)-bit >> when Exp_in_DI is negative
  assign Exp_Max_RS_FP32_D=Exp_in_DI[C_EXP_FP32:0]+C_MANT_FP32+1; // to check exponent after (C_MANT_FP32+1)-bit >> when Exp_in_DI is negative
  assign Exp_Max_RS_FP16_D=Exp_in_DI[C_EXP_FP16:0]+C_MANT_FP16+1; // to check exponent after (C_MANT_FP16+1)-bit >> when Exp_in_DI is negative
  assign Exp_Max_RS_FP16ALT_D=Exp_in_DI[C_EXP_FP16ALT:0]+C_MANT_FP16ALT+1; // to check exponent after (C_MANT_FP16ALT+1)-bit >> when Exp_in_DI is negative
  logic  [C_EXP_FP64+1:0]                       Num_RS_D;
  assign Num_RS_D=~Exp_in_DI+1+1;            // How many right shifts(RS) are needed to generate a denormal number? >> is need only when Exp_in_DI is negative
  logic  [C_MANT_FP64:0]                        Mant_RS_D;
  logic  [C_MANT_FP64+4:0]                      Mant_forsticky_D;
  assign  {Mant_RS_D,Mant_forsticky_D} ={Mant_in_DI,{(C_MANT_FP64+1){1'b0}} } >>(Num_RS_D); //
//
  logic [C_EXP_FP64+1:0]                        Exp_subOne_D;
  assign Exp_subOne_D = Exp_in_DI -1;

   //normalization
   logic [1:0]                                  Mant_lower_D;
   logic                                        Mant_sticky_bit_D;
   logic [C_MANT_FP64+4:0]                      Mant_forround_D;

   always_comb
     begin

       if(NaN_a_SI)  //  if a is NaN, return NaN
         begin
           Div_Zero_S=1'b0;
           Exp_OF_S=1'b0;
           Exp_UF_S=1'b0;
           Mant_res_norm_D={1'b0,C_MANT_NAN_FP64};
           Exp_res_norm_D='1;
           Mant_forround_D='0;
           Sign_res_D=1'b0;
           NV_OP_S = SNaN_SI;
         end

      else if(NaN_b_SI)   //if b is NaN, return NaN
        begin
          Div_Zero_S=1'b0;
          Exp_OF_S=1'b0;
          Exp_UF_S=1'b0;
          Mant_res_norm_D={1'b0,C_MANT_NAN_FP64};
          Exp_res_norm_D='1;
          Mant_forround_D='0;
          Sign_res_D=1'b0;
          NV_OP_S = SNaN_SI;
        end

      else if(Inf_a_SI)
        begin
          if(Div_enable_SI&&Inf_b_SI)                     //Inf/Inf, retrurn NaN
            begin
              Div_Zero_S=1'b0;
              Exp_OF_S=1'b0;
              Exp_UF_S=1'b0;
              Mant_res_norm_D={1'b0,C_MANT_NAN_FP64};
              Exp_res_norm_D='1;
              Mant_forround_D='0;
              Sign_res_D=1'b0;
              NV_OP_S = 1'b1;
            end
          else if (Sqrt_enable_SI && Sign_in_DI) begin // catch sqrt(-inf)
            Div_Zero_S=1'b0;
            Exp_OF_S=1'b0;
            Exp_UF_S=1'b0;
            Mant_res_norm_D={1'b0,C_MANT_NAN_FP64};
            Exp_res_norm_D='1;
            Mant_forround_D='0;
            Sign_res_D=1'b0;
            NV_OP_S = 1'b1;
          end else begin
            Div_Zero_S=1'b0;
            Exp_OF_S=1'b1;
            Exp_UF_S=1'b0;
            Mant_res_norm_D= '0;
            Exp_res_norm_D='1;
            Mant_forround_D='0;
            Sign_res_D=Sign_in_DI;
            NV_OP_S = 1'b0;
          end
        end

      else if(Div_enable_SI&&Inf_b_SI)
        begin
          Div_Zero_S=1'b0;
          Exp_OF_S=1'b1;
          Exp_UF_S=1'b0;
          Mant_res_norm_D= '0;
          Exp_res_norm_D='0;
          Mant_forround_D='0;
          Sign_res_D=Sign_in_DI;
          NV_OP_S = 1'b0;
        end

     else if(Zero_a_SI)
       begin
         if(Div_enable_SI&&Zero_b_SI)
           begin
              Div_Zero_S=1'b1;
              Exp_OF_S=1'b0;
              Exp_UF_S=1'b0;
              Mant_res_norm_D={1'b0,C_MANT_NAN_FP64};
              Exp_res_norm_D='1;
              Mant_forround_D='0;
              Sign_res_D=1'b0;
              NV_OP_S = 1'b1;
           end
         else
           begin
             Div_Zero_S=1'b0;
             Exp_OF_S=1'b0;
             Exp_UF_S=1'b0;
             Mant_res_norm_D='0;
             Exp_res_norm_D='0;
             Mant_forround_D='0;
             Sign_res_D=Sign_in_DI;
             NV_OP_S = 1'b0;
           end
       end

     else  if(Div_enable_SI&&(Zero_b_SI))  //div Zero
       begin
         Div_Zero_S=1'b1;
         Exp_OF_S=1'b0;
         Exp_UF_S=1'b0;
         Mant_res_norm_D='0;
         Exp_res_norm_D='1;
         Mant_forround_D='0;
         Sign_res_D=Sign_in_DI;
         NV_OP_S = 1'b0;
       end

      else if(Sign_in_DI&&Sqrt_enable_SI)   //sqrt(-a)
        begin
          Div_Zero_S=1'b0;
          Exp_OF_S=1'b0;
          Exp_UF_S=1'b0;
          Mant_res_norm_D={1'b0,C_MANT_NAN_FP64};
          Exp_res_norm_D='1;
          Mant_forround_D='0;
          Sign_res_D=1'b0;
          NV_OP_S = 1'b1;
        end

     else if((Exp_in_DI[C_EXP_FP64:0]=='0))
       begin
         if(Mant_in_DI!='0)       //Exp=0, Mant!=0, it is denormal
           begin
             Div_Zero_S=1'b0;
             Exp_OF_S=1'b0;
             Exp_UF_S=1'b1;
             Mant_res_norm_D={1'b0,Mant_in_DI[C_MANT_FP64+4:5]};
             Exp_res_norm_D='0;
             Mant_forround_D={Mant_in_DI[4:0],{(C_MANT_FP64){1'b0}} };
             Sign_res_D=Sign_in_DI;
             NV_OP_S = 1'b0;
           end
         else                 // Zero
           begin
             Div_Zero_S=1'b0;
             Exp_OF_S=1'b0;
             Exp_UF_S=1'b0;
             Mant_res_norm_D='0;
             Exp_res_norm_D='0;
             Mant_forround_D='0;
             Sign_res_D=Sign_in_DI;
             NV_OP_S = 1'b0;
           end
        end

      else if((Exp_in_DI[C_EXP_FP64:0]==C_EXP_ONE_FP64)&&(~Mant_in_DI[C_MANT_FP64+4]))  //denormal
        begin
          Div_Zero_S=1'b0;
          Exp_OF_S=1'b0;
          Exp_UF_S=1'b1;
          Mant_res_norm_D=Mant_in_DI[C_MANT_FP64+4:4];
          Exp_res_norm_D='0;
          Mant_forround_D={Mant_in_DI[3:0],{(C_MANT_FP64+1){1'b0}}};
          Sign_res_D=Sign_in_DI;
          NV_OP_S = 1'b0;
        end

      else if(Exp_in_DI[C_EXP_FP64+1])    //minus              //consider format
        begin
          Div_Zero_S=1'b0;
          Exp_OF_S=1'b0;
          Exp_UF_S=1'b1;
          Mant_res_norm_D={Mant_RS_D[C_MANT_FP64:0]};
          Exp_res_norm_D='0;
          Mant_forround_D={Mant_forsticky_D[C_MANT_FP64+4:0]};   //??
          Sign_res_D=Sign_in_DI;
          NV_OP_S = 1'b0;
        end

      else if( (Exp_in_DI[C_EXP_FP32]&&FP32_SI) | (Exp_in_DI[C_EXP_FP64]&&FP64_SI) | (Exp_in_DI[C_EXP_FP16]&&FP16_SI) | (Exp_in_DI[C_EXP_FP16ALT]&&FP16ALT_SI) )            //OF
        begin
          Div_Zero_S=1'b0;
          Exp_OF_S=1'b1;
          Exp_UF_S=1'b0;
          Mant_res_norm_D='0;
          Exp_res_norm_D='1;
          Mant_forround_D='0;
          Sign_res_D=Sign_in_DI;
          NV_OP_S = 1'b0;
        end

      else if( ((Exp_in_DI[C_EXP_FP32-1:0]=='1)&&FP32_SI) | ((Exp_in_DI[C_EXP_FP64-1:0]=='1)&&FP64_SI) |  ((Exp_in_DI[C_EXP_FP16-1:0]=='1)&&FP16_SI) | ((Exp_in_DI[C_EXP_FP16ALT-1:0]=='1)&&FP16ALT_SI) )//255
        begin
          if(~Mant_in_DI[C_MANT_FP64+4]) // MSB=0
            begin
              Div_Zero_S=1'b0;
              Exp_OF_S=1'b0;
              Exp_UF_S=1'b0;
              Mant_res_norm_D=Mant_in_DI[C_MANT_FP64+3:3];
              Exp_res_norm_D=Exp_subOne_D;
              Mant_forround_D={Mant_in_DI[2:0],{(C_MANT_FP64+2){1'b0}}};
              Sign_res_D=Sign_in_DI;
              NV_OP_S = 1'b0;
            end
          else if(Mant_in_DI!='0)         //NaN
            begin
              Div_Zero_S=1'b0;
              Exp_OF_S=1'b1;
              Exp_UF_S=1'b0;
              Mant_res_norm_D= '0;
              Exp_res_norm_D='1;
              Mant_forround_D='0;
              Sign_res_D=Sign_in_DI;
              NV_OP_S = 1'b0;
            end
          else                         //infinity
            begin
              Div_Zero_S=1'b0;
              Exp_OF_S=1'b1;
              Exp_UF_S=1'b0;
              Mant_res_norm_D= '0;
              Exp_res_norm_D='1;
              Mant_forround_D='0;
              Sign_res_D=Sign_in_DI;
              NV_OP_S = 1'b0;
            end
         end

      else if(Mant_in_DI[C_MANT_FP64+4])  //normal numbers with 1.XXX
        begin
           Div_Zero_S=1'b0;
           Exp_OF_S=1'b0;
           Exp_UF_S=1'b0;
           Mant_res_norm_D= Mant_in_DI[C_MANT_FP64+4:4];
           Exp_res_norm_D=Exp_in_DI[C_EXP_FP64-1:0];
           Mant_forround_D={Mant_in_DI[3:0],{(C_MANT_FP64+1){1'b0}}};
           Sign_res_D=Sign_in_DI;
           NV_OP_S = 1'b0;
        end

      else                                   //normal numbers with 0.1XX
         begin
           Div_Zero_S=1'b0;
           Exp_OF_S=1'b0;
           Exp_UF_S=1'b0;
           Mant_res_norm_D=Mant_in_DI[C_MANT_FP64+3:3];
           Exp_res_norm_D=Exp_subOne_D;
           Mant_forround_D={Mant_in_DI[2:0],{(C_MANT_FP64+2){1'b0}}};
           Sign_res_D=Sign_in_DI;
           NV_OP_S = 1'b0;
         end

     end

   /////////////////////////////////////////////////////////////////////////////
   // Rounding enable only for full precision (Full_precision_SI==1'b1)       //
   /////////////////////////////////////////////////////////////////////////////

   logic [C_MANT_FP64:0]                   Mant_upper_D;
   logic [C_MANT_FP64+1:0]                 Mant_upperRounded_D;
   logic                                   Mant_roundUp_S;
   logic                                   Mant_rounded_S;

  always_comb //determine which bits for Mant_lower_D and Mant_sticky_bit_D
    begin
      if(FP32_SI)
        begin
          Mant_upper_D = {Mant_res_norm_D[C_MANT_FP64:C_MANT_FP64-C_MANT_FP32-1], {(C_MANT_FP64-C_MANT_FP32-1){1'b0}} };   // TS FIX RNE
          Mant_lower_D = Mant_res_norm_D[C_MANT_FP64-C_MANT_FP32-1:C_MANT_FP64-C_MANT_FP32-2];
          Mant_sticky_bit_D = | Mant_res_norm_D[C_MANT_FP64-C_MANT_FP32-3:0];
        end
      else if(FP64_SI)
        begin
          Mant_upper_D = Mant_res_norm_D[C_MANT_FP64:0];
          Mant_lower_D = Mant_forround_D[C_MANT_FP64+4:C_MANT_FP64+3];
          Mant_sticky_bit_D = | Mant_forround_D[C_MANT_FP64+3:0];
        end
      else if(FP16_SI)
        begin
          Mant_upper_D = {Mant_res_norm_D[C_MANT_FP64:C_MANT_FP64-C_MANT_FP16], {(C_MANT_FP64-C_MANT_FP16){1'b0}} };
          Mant_lower_D = Mant_res_norm_D[C_MANT_FP64-C_MANT_FP16-1:C_MANT_FP64-C_MANT_FP16-2];
          Mant_sticky_bit_D = | Mant_res_norm_D[C_MANT_FP64-C_MANT_FP16-3:30];
        end
      else  //FP16ALT
      begin
          Mant_upper_D = {Mant_res_norm_D[C_MANT_FP64:C_MANT_FP64-C_MANT_FP16ALT], {(C_MANT_FP64-C_MANT_FP16ALT){1'b0}} };
          Mant_lower_D = Mant_res_norm_D[C_MANT_FP64-C_MANT_FP16ALT-1:C_MANT_FP64-C_MANT_FP16ALT-2];
          Mant_sticky_bit_D = | Mant_res_norm_D[C_MANT_FP64-C_MANT_FP16ALT-3:30];
      end
    end

   assign Mant_rounded_S = (|(Mant_lower_D))| Mant_sticky_bit_D;




   always_comb //determine whether to round up or not
     begin
        Mant_roundUp_S = 1'b0;
        case (RM_SI)
          C_RM_NEAREST :
            Mant_roundUp_S = Mant_lower_D[1] && ((Mant_lower_D[0] | Mant_sticky_bit_D )| ( (FP32_SI&&Mant_upper_D[C_MANT_FP64-C_MANT_FP32-1]) | (FP64_SI&&Mant_upper_D[0]) | (FP16_SI&&Mant_upper_D[C_MANT_FP64-C_MANT_FP16]) | (FP16ALT_SI&&Mant_upper_D[C_MANT_FP64-C_MANT_FP16ALT]) ) );  // TS FIX RNE
          C_RM_TRUNC   :
            Mant_roundUp_S = 0;
          C_RM_MINUSINF:
            Mant_roundUp_S = Mant_rounded_S & ~Sign_in_DI;
          C_RM_PLUSINF :
            Mant_roundUp_S = Mant_rounded_S & Sign_in_DI;
          C_RM_NEAREST_RMM: 
            Mant_roundUp_S = & Mant_lower_D;
          default          :
            Mant_roundUp_S = 0;
        endcase // case (RM_DI)
     end // always_comb begin

  logic                                 Mant_renorm_S;
  logic  [C_MANT_FP64:0]                Mant_roundUp_Vector_S; // for all the formats

  assign Mant_roundUp_Vector_S={7'h0,(FP16ALT_SI&&Mant_roundUp_S),2'h0,(FP16_SI&&Mant_roundUp_S),12'h0,(FP32_SI&&Mant_roundUp_S),28'h0,(FP64_SI&&Mant_roundUp_S)};


  assign Mant_upperRounded_D = Mant_upper_D + Mant_roundUp_Vector_S;
  assign Mant_renorm_S       = Mant_upperRounded_D[C_MANT_FP64+1];

  /////////////////////////////////////////////////////////////////////////////
  // Renormalization for Rounding                                           //
  /////////////////////////////////////////////////////////////////////////////
  logic [C_MANT_FP64-1:0]               Mant_res_round_D;
  logic [C_EXP_FP64-1:0]                Exp_res_round_D;


  assign Mant_res_round_D = (Mant_renorm_S)?Mant_upperRounded_D[C_MANT_FP64:1]:Mant_upperRounded_D[C_MANT_FP64-1:0]; // including the process of the hidden bit
  assign Exp_res_round_D  = Exp_res_norm_D+Mant_renorm_S;

  /////////////////////////////////////////////////////////////////////////////
  //  Output Assignments                                                     //
  /////////////////////////////////////////////////////////////////////////////
  logic [C_MANT_FP64-1:0]               Mant_before_format_ctl_D;
  logic [C_EXP_FP64-1:0]                Exp_before_format_ctl_D;
  assign Mant_before_format_ctl_D = Full_precision_SI ? Mant_res_round_D : Mant_res_norm_D;
  assign Exp_before_format_ctl_D = Full_precision_SI ? Exp_res_round_D : Exp_res_norm_D;

  always_comb    //NaN Boxing
    begin  //
      if(FP32_SI)
          begin
            Result_DO ={32'hffff_ffff,Sign_res_D,Exp_before_format_ctl_D[C_EXP_FP32-1:0],Mant_before_format_ctl_D[C_MANT_FP64-1:C_MANT_FP64-C_MANT_FP32]};
          end
       else if(FP64_SI)
          begin
            Result_DO ={Sign_res_D,Exp_before_format_ctl_D[C_EXP_FP64-1:0],Mant_before_format_ctl_D[C_MANT_FP64-1:0]};
          end
      else if(FP16_SI)
          begin
            Result_DO ={48'hffff_ffff_ffff,Sign_res_D,Exp_before_format_ctl_D[C_EXP_FP16-1:0],Mant_before_format_ctl_D[C_MANT_FP64-1:C_MANT_FP64-C_MANT_FP16]};
          end
      else
          begin
            Result_DO ={48'hffff_ffff_ffff,Sign_res_D,Exp_before_format_ctl_D[C_EXP_FP16ALT-1:0],Mant_before_format_ctl_D[C_MANT_FP64-1:C_MANT_FP64-C_MANT_FP16ALT]};
          end
    end

assign In_Exact_S = (~Full_precision_SI) | Mant_rounded_S;
assign Fflags_SO = {NV_OP_S,Div_Zero_S,Exp_OF_S,Exp_UF_S,In_Exact_S}; //{NV,DZ,OF,UF,NX}

endmodule // miv_rv32_norm_div_sqrt_mvp

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_nrbd_nrsc_mvp.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
////////////////////////////////////////////////////////////////////////////////
// Company:        IIS @ ETHZ - Federal Institute of Technology               //
//                                                                            //
// Engineers:      Lei Li      lile@iis.ee.ethz.ch                            //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    10/04/2018                                                 //
// Design Name:    FPU                                                        //
// Module Name:    miv_rv32_nrbd_nrsc_mvp.sv                                           //
// Project Name:   Private FPU                                                //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:   non restroring binary  divisior/ square root                //
//                                                                            //
// Revision Date:  12/04/2018                                                 //
//                 Lei Li                                                     //
//                 To address some requirements by Stefan and add low power   //
//                 control for special cases                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_nrbd_nrsc_mvp import miv_rv32_pkg::*;

  (//Input
   input logic                                 Clk_CI,
   input logic                                 Rst_RBI,
   input logic                                 Div_start_SI,
   input logic                                 Sqrt_start_SI,
   input logic                                 Start_SI,
   input logic                                 Kill_SI,
   input logic                                 Special_case_SBI,
   input logic                                 Special_case_dly_SBI,
   input logic [C_PC-1:0]                      Precision_ctl_SI,
   input logic [1:0]                           Format_sel_SI,
   input logic [C_MANT_FP64:0]                 Mant_a_DI,
   input logic [C_MANT_FP64:0]                 Mant_b_DI,
   input logic [C_EXP_FP64:0]                  Exp_a_DI,
   input logic [C_EXP_FP64:0]                  Exp_b_DI,
  //output
   output logic                                Div_enable_SO,
   output logic                                Sqrt_enable_SO,

   output logic                                Full_precision_SO,
   output logic                                FP32_SO,
   output logic                                FP64_SO,
   output logic                                FP16_SO,
   output logic                                FP16ALT_SO,
   output logic                                Ready_SO,
   output logic                                Done_SO,
   output logic  [C_MANT_FP64+4:0]             Mant_z_DO,
   output logic [C_EXP_FP64+1:0]               Exp_z_DO
    );


    logic                                     Div_start_dly_S,Sqrt_start_dly_S;


miv_rv32_control_mvp         control_U0
(  .Clk_CI                                   (Clk_CI                          ),
   .Rst_RBI                                  (Rst_RBI                         ),
   .Div_start_SI                             (Div_start_SI                    ),
   .Sqrt_start_SI                            (Sqrt_start_SI                   ),
   .Start_SI                                 (Start_SI                        ),
   .Kill_SI                                  (Kill_SI                         ),
   .Special_case_SBI                         (Special_case_SBI                ),
   .Special_case_dly_SBI                     (Special_case_dly_SBI            ),
   .Precision_ctl_SI                         (Precision_ctl_SI                ),
   .Format_sel_SI                            (Format_sel_SI                   ),
   .Numerator_DI                             (Mant_a_DI                       ),
   .Exp_num_DI                               (Exp_a_DI                        ),
   .Denominator_DI                           (Mant_b_DI                       ),
   .Exp_den_DI                               (Exp_b_DI                        ),
   .Div_start_dly_SO                         (Div_start_dly_S                 ),
   .Sqrt_start_dly_SO                        (Sqrt_start_dly_S                ),
   .Div_enable_SO                            (Div_enable_SO                   ),
   .Sqrt_enable_SO                           (Sqrt_enable_SO                  ),
   .Full_precision_SO                        (Full_precision_SO               ),
   .FP32_SO                                  (FP32_SO                         ),
   .FP64_SO                                  (FP64_SO                         ),
   .FP16_SO                                  (FP16_SO                         ),
   .FP16ALT_SO                               (FP16ALT_SO                      ),
   .Ready_SO                                 (Ready_SO                        ),
   .Done_SO                                  (Done_SO                         ),
   .Mant_result_prenorm_DO                   (Mant_z_DO                       ),
   .Exp_result_prenorm_DO                    (Exp_z_DO                        )
);



endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_popcount.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2018 ETH Zurich, University of Bologna
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Manuel Eggimann <meggimann@iis.ee.ethz.ch>

// Description: This module calculates the hamming weight (number of ones) in
// its input vector using a balanced binary adder tree. Recursive instantiation
// is used to build the tree.  Any unsigned INPUT_WIDTH larger or equal 2 is
// legal.  The module pads the signal internally to the next power of two.  The
// output result width is ceil(log2(INPUT_WIDTH))+1.

module miv_rv32_popcount #(
    parameter int unsigned INPUT_WIDTH = 256,
    localparam int unsigned PopcountWidth = $clog2(INPUT_WIDTH)+1
) (
    input logic [INPUT_WIDTH-1:0]     data_i,
    output logic [PopcountWidth-1:0] popcount_o
);

   localparam int unsigned PaddedWidth = 1 << $clog2(INPUT_WIDTH);

   logic [PaddedWidth-1:0]           padded_input;
   logic [PopcountWidth-2:0]         left_child_result, right_child_result;

   //Zero pad the input to next power of two
   always_comb begin
     padded_input = '0;
     padded_input[INPUT_WIDTH-1:0] = data_i;
   end

   //Recursive instantiation to build binary adder tree
   if (INPUT_WIDTH == 1) begin : single_node
     assign left_child_result  = 1'b0;
     assign right_child_result = padded_input[0];
   end else if (INPUT_WIDTH == 2) begin : leaf_node
     assign left_child_result  = padded_input[1];
     assign right_child_result = padded_input[0];
   end else begin : non_leaf_node
     miv_rv32_popcount #(.INPUT_WIDTH(PaddedWidth / 2))
         left_child(
                    .data_i(padded_input[PaddedWidth-1:PaddedWidth/2]),
                    .popcount_o(left_child_result));

     miv_rv32_popcount #(.INPUT_WIDTH(PaddedWidth / 2))
         right_child(
                     .data_i(padded_input[PaddedWidth/2-1:0]),
                     .popcount_o(right_child_result));
   end

   //Output assignment
   assign popcount_o = left_child_result + right_child_result;

endmodule : miv_rv32_popcount

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_popcount.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
////////////////////////////////////////////////////////////////////////////////
// Company:        IIS @ ETHZ - Federal Institute of Technology               //
//                                                                            //
// Engineers:                Lei Li  //lile@iis.ee.ethz.ch                    //
//		                                                                        //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    01/03/2018                                                 //
// Design Name:    FPU                                                        //
// Module Name:    miv_rv32_preprocess_mvp.sv                                          //
// Project Name:   Private FPU                                                //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:           decode and data preparation                         //
//                                                                            //
// Revision Date:  12/04/2018                                                 //
//                 Lei Li                                                     //
//                 To address some requirements by Stefan and add low power   //
//                 control for special cases                                  //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_preprocess_mvp import miv_rv32_pkg::*;
  (
   input logic                   Clk_CI,
   input logic                   Rst_RBI,
   input logic                   Div_start_SI,
   input logic                   Sqrt_start_SI,
   input logic                   Ready_SI,
   //Input Operands
   input logic [C_OP_FP64-1:0]   Operand_a_DI,
   input logic [C_OP_FP64-1:0]   Operand_b_DI,
   input logic [C_RM-1:0]        RM_SI,    //Rounding Mode
   input logic [C_FS-1:0]        Format_sel_SI,  // Format Selection

   // to control
   output logic                  Start_SO,
   output logic [C_EXP_FP64:0]   Exp_a_DO_norm,
   output logic [C_EXP_FP64:0]   Exp_b_DO_norm,
   output logic [C_MANT_FP64:0]  Mant_a_DO_norm,
   output logic [C_MANT_FP64:0]  Mant_b_DO_norm,

   output logic [C_RM-1:0]       RM_dly_SO,

   output logic                  Sign_z_DO,
   output logic                  Inf_a_SO,
   output logic                  Inf_b_SO,
   output logic                  Zero_a_SO,
   output logic                  Zero_b_SO,
   output logic                  NaN_a_SO,
   output logic                  NaN_b_SO,
   output logic                  SNaN_SO,
   output logic                  Special_case_SBO,
   output logic                  Special_case_dly_SBO
   );

   //Hidden Bits
   logic                         Hb_a_D;
   logic                         Hb_b_D;

   logic [C_EXP_FP64-1:0]        Exp_a_D;
   logic [C_EXP_FP64-1:0]        Exp_b_D;
   logic [C_MANT_FP64-1:0]       Mant_a_NonH_D;
   logic [C_MANT_FP64-1:0]       Mant_b_NonH_D;
   logic [C_MANT_FP64:0]         Mant_a_D;
   logic [C_MANT_FP64:0]         Mant_b_D;

   /////////////////////////////////////////////////////////////////////////////
   // Disassemble operands
   /////////////////////////////////////////////////////////////////////////////
   logic                      Sign_a_D,Sign_b_D;
   logic                      Start_S;

     always_comb
       begin
         case(Format_sel_SI)
           2'b00:
             begin
               Sign_a_D = Operand_a_DI[C_OP_FP32-1];
               Sign_b_D = Operand_b_DI[C_OP_FP32-1];
               Exp_a_D  = {3'h0, Operand_a_DI[C_OP_FP32-2:C_MANT_FP32]};
               Exp_b_D  = {3'h0, Operand_b_DI[C_OP_FP32-2:C_MANT_FP32]};
               Mant_a_NonH_D = {Operand_a_DI[C_MANT_FP32-1:0],29'h0};
               Mant_b_NonH_D = {Operand_b_DI[C_MANT_FP32-1:0],29'h0};
             end
           2'b01:
             begin
               Sign_a_D = Operand_a_DI[C_OP_FP64-1];
               Sign_b_D = Operand_b_DI[C_OP_FP64-1];
               Exp_a_D  = Operand_a_DI[C_OP_FP64-2:C_MANT_FP64];
               Exp_b_D  = Operand_b_DI[C_OP_FP64-2:C_MANT_FP64];
               Mant_a_NonH_D = Operand_a_DI[C_MANT_FP64-1:0];
               Mant_b_NonH_D = Operand_b_DI[C_MANT_FP64-1:0];
             end
           2'b10:
             begin
               Sign_a_D = Operand_a_DI[C_OP_FP16-1];
               Sign_b_D = Operand_b_DI[C_OP_FP16-1];
               Exp_a_D  = {6'h00, Operand_a_DI[C_OP_FP16-2:C_MANT_FP16]};
               Exp_b_D  = {6'h00, Operand_b_DI[C_OP_FP16-2:C_MANT_FP16]};
               Mant_a_NonH_D = {Operand_a_DI[C_MANT_FP16-1:0],42'h0};
               Mant_b_NonH_D = {Operand_b_DI[C_MANT_FP16-1:0],42'h0};
             end
           2'b11:
             begin
               Sign_a_D = Operand_a_DI[C_OP_FP16ALT-1];
               Sign_b_D = Operand_b_DI[C_OP_FP16ALT-1];
               Exp_a_D  = {3'h0, Operand_a_DI[C_OP_FP16ALT-2:C_MANT_FP16ALT]};
               Exp_b_D  = {3'h0, Operand_b_DI[C_OP_FP16ALT-2:C_MANT_FP16ALT]};
               Mant_a_NonH_D = {Operand_a_DI[C_MANT_FP16ALT-1:0],45'h0};
               Mant_b_NonH_D = {Operand_b_DI[C_MANT_FP16ALT-1:0],45'h0};
             end
           endcase
       end


   assign Mant_a_D = {Hb_a_D,Mant_a_NonH_D};
   assign Mant_b_D = {Hb_b_D,Mant_b_NonH_D};

   assign Hb_a_D = | Exp_a_D; // hidden bit
   assign Hb_b_D = | Exp_b_D; // hidden bit

   assign Start_S= Div_start_SI | Sqrt_start_SI;



   /////////////////////////////////////////////////////////////////////////////
   // preliminary checks for infinite/zero/NaN operands                       //
   /////////////////////////////////////////////////////////////////////////////

   logic               Mant_a_prenorm_zero_S;
   logic               Mant_b_prenorm_zero_S;

   logic               Exp_a_prenorm_zero_S;
   logic               Exp_b_prenorm_zero_S;
   assign Exp_a_prenorm_zero_S = ~Hb_a_D;
   assign Exp_b_prenorm_zero_S = ~Hb_b_D;

   logic               Exp_a_prenorm_Inf_NaN_S;
   logic               Exp_b_prenorm_Inf_NaN_S;

   logic               Mant_a_prenorm_QNaN_S;
   logic               Mant_a_prenorm_SNaN_S;
   logic               Mant_b_prenorm_QNaN_S;
   logic               Mant_b_prenorm_SNaN_S;

   assign Mant_a_prenorm_QNaN_S=Mant_a_NonH_D[C_MANT_FP64-1]&&(~(|Mant_a_NonH_D[C_MANT_FP64-2:0]));
   assign Mant_a_prenorm_SNaN_S=(~Mant_a_NonH_D[C_MANT_FP64-1])&&((|Mant_a_NonH_D[C_MANT_FP64-2:0]));
   assign Mant_b_prenorm_QNaN_S=Mant_b_NonH_D[C_MANT_FP64-1]&&(~(|Mant_b_NonH_D[C_MANT_FP64-2:0]));
   assign Mant_b_prenorm_SNaN_S=(~Mant_b_NonH_D[C_MANT_FP64-1])&&((|Mant_b_NonH_D[C_MANT_FP64-2:0]));

     always_comb
       begin
         case(Format_sel_SI)
           2'b00:
             begin
               Mant_a_prenorm_zero_S=(Operand_a_DI[C_MANT_FP32-1:0] == C_MANT_ZERO_FP32);
               Mant_b_prenorm_zero_S=(Operand_b_DI[C_MANT_FP32-1:0] == C_MANT_ZERO_FP32);
               Exp_a_prenorm_Inf_NaN_S=(Operand_a_DI[C_OP_FP32-2:C_MANT_FP32] == C_EXP_INF_FP32);
               Exp_b_prenorm_Inf_NaN_S=(Operand_b_DI[C_OP_FP32-2:C_MANT_FP32] == C_EXP_INF_FP32);
             end
           2'b01:
             begin
               Mant_a_prenorm_zero_S=(Operand_a_DI[C_MANT_FP64-1:0] == C_MANT_ZERO_FP64);
               Mant_b_prenorm_zero_S=(Operand_b_DI[C_MANT_FP64-1:0] == C_MANT_ZERO_FP64);
               Exp_a_prenorm_Inf_NaN_S=(Operand_a_DI[C_OP_FP64-2:C_MANT_FP64] == C_EXP_INF_FP64);
               Exp_b_prenorm_Inf_NaN_S=(Operand_b_DI[C_OP_FP64-2:C_MANT_FP64] == C_EXP_INF_FP64);
             end
           2'b10:
             begin
               Mant_a_prenorm_zero_S=(Operand_a_DI[C_MANT_FP16-1:0] == C_MANT_ZERO_FP16);
               Mant_b_prenorm_zero_S=(Operand_b_DI[C_MANT_FP16-1:0] == C_MANT_ZERO_FP16);
               Exp_a_prenorm_Inf_NaN_S=(Operand_a_DI[C_OP_FP16-2:C_MANT_FP16] == C_EXP_INF_FP16);
               Exp_b_prenorm_Inf_NaN_S=(Operand_b_DI[C_OP_FP16-2:C_MANT_FP16] == C_EXP_INF_FP16);
             end
           2'b11:
             begin
               Mant_a_prenorm_zero_S=(Operand_a_DI[C_MANT_FP16ALT-1:0] == C_MANT_ZERO_FP16ALT);
               Mant_b_prenorm_zero_S=(Operand_b_DI[C_MANT_FP16ALT-1:0] == C_MANT_ZERO_FP16ALT);
               Exp_a_prenorm_Inf_NaN_S=(Operand_a_DI[C_OP_FP16ALT-2:C_MANT_FP16ALT] == C_EXP_INF_FP16ALT);
               Exp_b_prenorm_Inf_NaN_S=(Operand_b_DI[C_OP_FP16ALT-2:C_MANT_FP16ALT] == C_EXP_INF_FP16ALT);
             end
           endcase
       end




   logic               Zero_a_SN,Zero_a_SP;
   logic               Zero_b_SN,Zero_b_SP;
   logic               Inf_a_SN,Inf_a_SP;
   logic               Inf_b_SN,Inf_b_SP;
   logic               NaN_a_SN,NaN_a_SP;
   logic               NaN_b_SN,NaN_b_SP;
   logic               SNaN_SN,SNaN_SP;

   assign Zero_a_SN = (Start_S&&Ready_SI)?(Exp_a_prenorm_zero_S&&Mant_a_prenorm_zero_S):Zero_a_SP;
   assign Zero_b_SN = (Start_S&&Ready_SI)?(Exp_b_prenorm_zero_S&&Mant_b_prenorm_zero_S):Zero_b_SP;
   assign Inf_a_SN = (Start_S&&Ready_SI)?(Exp_a_prenorm_Inf_NaN_S&&Mant_a_prenorm_zero_S):Inf_a_SP;
   assign Inf_b_SN = (Start_S&&Ready_SI)?(Exp_b_prenorm_Inf_NaN_S&&Mant_b_prenorm_zero_S):Inf_b_SP;
   assign NaN_a_SN = (Start_S&&Ready_SI)?(Exp_a_prenorm_Inf_NaN_S&&(~Mant_a_prenorm_zero_S)):NaN_a_SP;
   assign NaN_b_SN = (Start_S&&Ready_SI)?(Exp_b_prenorm_Inf_NaN_S&&(~Mant_b_prenorm_zero_S)):NaN_b_SP;
   assign SNaN_SN = (Start_S&&Ready_SI) ? ((Mant_a_prenorm_SNaN_S&&NaN_a_SN) | (Mant_b_prenorm_SNaN_S&&NaN_b_SN)) : SNaN_SP;

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Zero_a_SP <='0;
            Zero_b_SP <='0;
            Inf_a_SP <='0;
            Inf_b_SP <='0;
            NaN_a_SP <='0;
            NaN_b_SP <='0;
            SNaN_SP <= '0;
          end
        else
         begin
           Inf_a_SP <=Inf_a_SN;
           Inf_b_SP <=Inf_b_SN;
           Zero_a_SP <=Zero_a_SN;
           Zero_b_SP <=Zero_b_SN;
           NaN_a_SP <=NaN_a_SN;
           NaN_b_SP <=NaN_b_SN;
           SNaN_SP <= SNaN_SN;
         end
      end

   /////////////////////////////////////////////////////////////////////////////
   // Low power control
   /////////////////////////////////////////////////////////////////////////////

   assign Special_case_SBO=(~{(Div_start_SI)?(Zero_a_SN | Zero_b_SN |  Inf_a_SN | Inf_b_SN | NaN_a_SN | NaN_b_SN): (Zero_a_SN | Inf_a_SN | NaN_a_SN | Sign_a_D) })&&(Start_S&&Ready_SI);


   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
       if(~Rst_RBI)
          begin
            Special_case_dly_SBO <= '0;
          end
       else if((Start_S&&Ready_SI))
         begin
            Special_case_dly_SBO <= Special_case_SBO;
         end
       else if(Special_case_dly_SBO)
         begin
         Special_case_dly_SBO <= 1'b1;
         end
      else
         begin
            Special_case_dly_SBO <= '0;
         end
    end

   /////////////////////////////////////////////////////////////////////////////
   // Delay sign for normalization and round                                  //
   /////////////////////////////////////////////////////////////////////////////

   logic                   Sign_z_DN;
   logic                   Sign_z_DP;

   always_comb
     begin
       if(Div_start_SI&&Ready_SI)
           Sign_z_DN = Sign_a_D ^ Sign_b_D;
       else if(Sqrt_start_SI&&Ready_SI)
           Sign_z_DN = Sign_a_D;
       else
           Sign_z_DN = Sign_z_DP;
    end

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
       if(~Rst_RBI)
          begin
            Sign_z_DP <= '0;
          end
       else
         begin
            Sign_z_DP <= Sign_z_DN;
         end
    end

   logic [C_RM-1:0]                  RM_DN;
   logic [C_RM-1:0]                  RM_DP;

   always_comb
     begin
       if(Start_S&&Ready_SI)
           RM_DN = RM_SI;
       else
           RM_DN = RM_DP;
    end

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
       if(~Rst_RBI)
          begin
            RM_DP <= '0;
          end
       else
         begin
            RM_DP <= RM_DN;
         end
    end
   assign RM_dly_SO = RM_DP;

   logic [5:0]                  Mant_leadingOne_a, Mant_leadingOne_b;
   logic                        Mant_zero_S_a,Mant_zero_S_b;

  miv_rv32_lzc #(
    .WIDTH ( C_MANT_FP64+1 ),
    .MODE  ( 1             )
  ) LOD_Ua (
    .in_i    ( Mant_a_D          ),
    .cnt_o   ( Mant_leadingOne_a ),
    .empty_o ( Mant_zero_S_a     )
  );

   logic [C_MANT_FP64:0]            Mant_a_norm_DN,Mant_a_norm_DP;

   assign  Mant_a_norm_DN = ((Start_S&&Ready_SI))?(Mant_a_D<<(Mant_leadingOne_a)):Mant_a_norm_DP;

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Mant_a_norm_DP <= '0;
          end
        else
          begin
            Mant_a_norm_DP<=Mant_a_norm_DN;
          end
     end

   logic [C_EXP_FP64:0]            Exp_a_norm_DN,Exp_a_norm_DP;
   assign  Exp_a_norm_DN = ((Start_S&&Ready_SI))?(Exp_a_D-Mant_leadingOne_a+(|Mant_leadingOne_a)):Exp_a_norm_DP;  //Covering the process of denormal numbers

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Exp_a_norm_DP <= '0;
          end
        else
          begin
            Exp_a_norm_DP<=Exp_a_norm_DN;
          end
     end

  miv_rv32_lzc #(
    .WIDTH ( C_MANT_FP64+1 ),
    .MODE  ( 1             )
  ) LOD_Ub (
    .in_i    ( Mant_b_D          ),
    .cnt_o   ( Mant_leadingOne_b ),
    .empty_o ( Mant_zero_S_b     )
  );


   logic [C_MANT_FP64:0]            Mant_b_norm_DN,Mant_b_norm_DP;

   assign  Mant_b_norm_DN = ((Start_S&&Ready_SI))?(Mant_b_D<<(Mant_leadingOne_b)):Mant_b_norm_DP;

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Mant_b_norm_DP <= '0;
          end
        else
          begin
            Mant_b_norm_DP<=Mant_b_norm_DN;
          end
     end

   logic [C_EXP_FP64:0]            Exp_b_norm_DN,Exp_b_norm_DP;
   assign  Exp_b_norm_DN = ((Start_S&&Ready_SI))?(Exp_b_D-Mant_leadingOne_b+(|Mant_leadingOne_b)):Exp_b_norm_DP; //Covering the process of denormal numbers

   always_ff @(posedge Clk_CI, negedge Rst_RBI)
     begin
        if(~Rst_RBI)
          begin
            Exp_b_norm_DP <= '0;
          end
        else
          begin
            Exp_b_norm_DP<=Exp_b_norm_DN;
          end
     end

   /////////////////////////////////////////////////////////////////////////////
   // Output assignments                                                      //
   /////////////////////////////////////////////////////////////////////////////

   assign Start_SO=Start_S;
   assign Exp_a_DO_norm=Exp_a_norm_DP;
   assign Exp_b_DO_norm=Exp_b_norm_DP;
   assign Mant_a_DO_norm=Mant_a_norm_DP;
   assign Mant_b_DO_norm=Mant_b_norm_DP;
   assign Sign_z_DO=Sign_z_DP;
   assign Inf_a_SO=Inf_a_SP;
   assign Inf_b_SO=Inf_b_SP;
   assign Zero_a_SO=Zero_a_SP;
   assign Zero_b_SO=Zero_b_SP;
   assign NaN_a_SO=NaN_a_SP;
   assign NaN_b_SO=NaN_b_SP;
   assign SNaN_SO=SNaN_SP;

endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_rr_arb_tree.sv
//
//   Purpose:   
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
//         Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>, ETH Zurich
// Date: 02.04.2019
// Description: logarithmic arbitration tree with round robin arbitration scheme.

/// The miv_rv32_rr_arb_tree employs non-starving round robin-arbitration - i.e., the priorities
/// rotate each cycle.
///
/// ## Fair vs. unfair Arbitration
///
/// This refers to fair throughput distribution when not all inputs have active requests.
/// This module has an internal state `rr_q` which defines the highest priority input. (When
/// `ExtPrio` is `1'b1` this state is provided from the outside.) The arbitration tree will
/// choose the input with the same index as currently defined by the state if it has an active
/// request. Otherwise a *random* other active input is selected. The parameter `FairArb` is used
/// to distinguish between two methods of calculating the next state.
/// * `1'b0`: The next state is calculated by advancing the current state by one. This leads to the
///           state being calculated without the context of the active request. Leading to an
///           unfair throughput distribution if not all inputs have active requests.
/// * `1'b1`: The next state jumps to the next unserved request with higher index.
///           This is achieved by using two trailing-zero-counters (`miv_rv32_lzc`). The upper has the masked
///           `req_i` signal with all indices which will have a higher priority in the next state.
///           The trailing zero count defines the input index with the next highest priority after
///           the current one is served. When the upper is empty the lower `miv_rv32_lzc` provides the
///           wrapped index if there are outstanding requests with lower or same priority.
/// The implication of throughput fairness on the module timing are:
/// * The trailing zero counter (`miv_rv32_lzc`) has a loglog relation of input to output timing. This means
///   that in this module the input to register path scales with Log(Log(`NumIn`)).
/// * The `miv_rv32_rr_arb_tree` data multiplexing scales with Log(`NumIn`). This means that the input to output
///   timing path of this module also scales scales with Log(`NumIn`).
/// This implies that in this module the input to output path is always longer than the input to
/// register path. As the output data usually also terminates in a register the parameter `FairArb`
/// only has implications on the area. When it is `1'b0` a static plus one adder is instantiated.
/// If it is `1'b1` two `miv_rv32_lzc`, a masking logic stage and a two input multiplexer are instantiated.
/// However these are small in respect of the data multiplexers needed, as the width of the `req_i`
/// signal is usually less as than `DataWidth`.
module miv_rv32_rr_arb_tree #(
  /// Number of inputs to be arbitrated.
  parameter int unsigned NumIn      = 64,
  /// Data width of the payload in bits. Not needed if `DataType` is overwritten.
  parameter int unsigned DataWidth  = 32,
  /// Data type of the payload, can be overwritten with custom type. Only use of `DataWidth`.
  parameter type         DataType   = logic [DataWidth-1:0],
  /// The `ExtPrio` option allows to override the internal round robin counter via the
  /// `rr_i` signal. This can be useful in case multiple arbiters need to have
  /// rotating priorities that are operating in lock-step. If static priority arbitration
  /// is needed, just connect `rr_i` to '0.
  ///
  /// Set to 1'b1 to enable.
  parameter bit          ExtPrio    = 1'b0,
  /// If `AxiVldRdy` is set, the req/gnt signals are compliant with the AXI style vld/rdy
  /// handshake. Namely, upstream vld (req) must not depend on rdy (gnt), as it can be deasserted
  /// again even though vld is asserted. Enabling `AxiVldRdy` leads to a reduction of arbiter
  /// delay and area.
  ///
  /// Set to `1'b1` to treat req/gnt as vld/rdy.
  parameter bit          AxiVldRdy  = 1'b0,
  /// The `LockIn` option prevents the arbiter from changing the arbitration
  /// decision when the arbiter is disabled. I.e., the index of the first request
  /// that wins the arbitration will be locked in case the destination is not
  /// able to grant the request in the same cycle.
  ///
  /// Set to `1'b1` to enable.
  parameter bit          LockIn     = 1'b0,
  /// When set, ensures that throughput gets distributed evenly between all inputs.
  ///
  /// Set to `1'b0` to disable.
  parameter bit          FairArb    = 1'b1,
  /// Dependent parameter, do **not** overwrite.
  /// Width of the arbitration priority signal and the arbitrated index.
  parameter int unsigned IdxWidth   = (NumIn > 32'd1) ? unsigned'($clog2(NumIn)) : 32'd1,
  /// Dependent parameter, do **not** overwrite.
  /// Type for defining the arbitration priority and arbitrated index signal.
  parameter type         idx_t      = logic [IdxWidth-1:0]
) (
  /// Clock, positive edge triggered.
  input  logic                clk_i,
  /// Asynchronous reset, active low.
  input  logic                rst_ni,
  /// Clears the arbiter state. Only used if `ExtPrio` is `1'b0` or `LockIn` is `1'b1`.
  input  logic                flush_i,
  /// External round-robin priority. Only used if `ExtPrio` is `1'b1.`
  input  idx_t                rr_i,
  /// Input requests arbitration.
  input  logic    [NumIn-1:0] req_i,
  /* verilator lint_off UNOPTFLAT */
  /// Input request is granted.
  output logic    [NumIn-1:0] gnt_o,
  /* verilator lint_on UNOPTFLAT */
  /// Input data for arbitration.
  input  DataType [NumIn-1:0] data_i,
  /// Output request is valid.
  output logic                req_o,
  /// Output request is granted.
  input  logic                gnt_i,
  /// Output data.
  output DataType             data_o,
  /// Index from which input the data came from.
  output idx_t                idx_o
);

  // pragma translate_off
  `ifndef VERILATOR
  // Default SVA reset
  default disable iff (!rst_ni || flush_i);
  `endif
  // pragma translate_on

  // just pass through in this corner case
  if (NumIn == unsigned'(1)) begin : gen_pass_through
    assign req_o    = req_i[0];
    assign gnt_o[0] = gnt_i;
    assign data_o   = data_i[0];
    assign idx_o    = '0;
  // non-degenerate cases
  end else begin : gen_arbiter
    localparam int unsigned NumLevels = $clog2(NumIn);

    /* verilator lint_off UNOPTFLAT */
    idx_t    [2**NumLevels-2:0] index_nodes; // used to propagate the indices
    DataType [2**NumLevels-2:0] data_nodes;  // used to propagate the data
    logic    [2**NumLevels-2:0] gnt_nodes;   // used to propagate the grant to initiators
    logic    [2**NumLevels-2:0] req_nodes;   // used to propagate the requests to target
    /* lint_off */
    idx_t                       rr_q;
    logic [NumIn-1:0]           req_d;

    // the final arbitration decision can be taken from the root of the tree
    assign req_o        = req_nodes[0];
    assign data_o       = data_nodes[0];
    assign idx_o        = index_nodes[0];

    if (ExtPrio) begin : gen_ext_rr
      assign rr_q       = rr_i;
      assign req_d      = req_i;
    end else begin : gen_int_rr
      idx_t rr_d;

      // lock arbiter decision in case we got at least one req and no acknowledge
      if (LockIn) begin : gen_lock
        logic  lock_d, lock_q;
        logic [NumIn-1:0] req_q;

        assign lock_d     = req_o & ~gnt_i;
        assign req_d      = (lock_q) ? req_q : req_i;

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_lock_reg
          if (!rst_ni) begin
            lock_q <= '0;
          end else begin
            if (flush_i) begin
              lock_q <= '0;
            end else begin
              lock_q <= lock_d;
            end
          end
        end

        // pragma translate_off
        `ifndef VERILATOR
          lock: assert property(
            @(posedge clk_i) LockIn |-> req_o && !gnt_i |=> idx_o == $past(idx_o)) else
                $fatal (1, "Lock implies same arbiter decision in next cycle if output is not \
                            ready.");

          logic [NumIn-1:0] req_tmp;
          assign req_tmp = req_q & req_i;
          lock_req: assume property(
            @(posedge clk_i) LockIn |-> lock_d |=> req_tmp == req_q) else
                $fatal (1, "It is disallowed to deassert unserved request signals when LockIn is \
                            enabled.");
        `endif
        // pragma translate_on

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_req_regs
          if (!rst_ni) begin
            req_q  <= '0;
          end else begin
            if (flush_i) begin
              req_q  <= '0;
            end else begin
              req_q  <= req_d;
            end
          end
        end
      end else begin : gen_no_lock
        assign req_d = req_i;
      end

      if (FairArb) begin : gen_fair_arb
        logic [NumIn-1:0] upper_mask,  lower_mask;
        idx_t             upper_idx,   lower_idx,   next_idx;
        logic             upper_empty, lower_empty;

        for (genvar i = 0; i < NumIn; i++) begin : gen_mask
          assign upper_mask[i] = (i >  rr_q) ? req_d[i] : 1'b0;
          assign lower_mask[i] = (i <= rr_q) ? req_d[i] : 1'b0;
        end

        miv_rv32_lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_upper (
          .in_i    ( upper_mask  ),
          .cnt_o   ( upper_idx   ),
          .empty_o ( upper_empty )
        );

        miv_rv32_lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_lower (
          .in_i    ( lower_mask  ),
          .cnt_o   ( lower_idx   ),
          .empty_o ( /*unused*/  )
        );

        assign next_idx = upper_empty      ? lower_idx : upper_idx;
        assign rr_d     = (gnt_i && req_o) ? next_idx  : rr_q;

      end else begin : gen_unfair_arb
        assign rr_d = (gnt_i && req_o) ? ((rr_q == idx_t'(NumIn-1)) ? '0 : rr_q + 1'b1) : rr_q;
      end

      // this holds the highest priority
      always_ff @(posedge clk_i or negedge rst_ni) begin : p_rr_regs
        if (!rst_ni) begin
          rr_q   <= '0;
        end else begin
          if (flush_i) begin
            rr_q   <= '0;
          end else begin
            rr_q   <= rr_d;
          end
        end
      end
    end

    assign gnt_nodes[0] = gnt_i;

    // arbiter tree
    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : gen_levels
      for (genvar l = 0; l < 2**level; l++) begin : gen_level
        // local select signal
        logic sel;
        // index calcs
        localparam int unsigned Idx0 = 2**level-1+l;// current node
        localparam int unsigned Idx1 = 2**(level+1)-1+l*2;
        //////////////////////////////////////////////////////////////
        // uppermost level where data is fed in from the inputs
        if (unsigned'(level) == NumLevels-1) begin : gen_first_level
          // if two successive indices are still in the vector...
          if (unsigned'(l) * 2 < NumIn-1) begin : gen_reduce
            assign req_nodes[Idx0]   = req_d[l*2] | req_d[l*2+1];

            // arbitration: round robin
            assign sel =  ~req_d[l*2] | req_d[l*2+1] & rr_q[NumLevels-1-level];

            assign index_nodes[Idx0] = idx_t'(sel);
            assign data_nodes[Idx0]  = (sel) ? data_i[l*2+1] : data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2])   & ~sel;
            assign gnt_o[l*2+1]      = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2+1]) & sel;
          end
          // if only the first index is still in the vector...
          if (unsigned'(l) * 2 == NumIn-1) begin : gen_first
            assign req_nodes[Idx0]   = req_d[l*2];
            assign index_nodes[Idx0] = '0;// always zero in this case
            assign data_nodes[Idx0]  = data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2]);
          end
          // if index is out of range, fill up with zeros (will get pruned)
          if (unsigned'(l) * 2 > NumIn-1) begin : gen_out_of_range
            assign req_nodes[Idx0]   = 1'b0;
            assign index_nodes[Idx0] = idx_t'('0);
            assign data_nodes[Idx0]  = DataType'('0);
          end
        //////////////////////////////////////////////////////////////
        // general case for other levels within the tree
        end else begin : gen_other_levels
          assign req_nodes[Idx0]   = req_nodes[Idx1] | req_nodes[Idx1+1];

          // arbitration: round robin
          assign sel =  ~req_nodes[Idx1] | req_nodes[Idx1+1] & rr_q[NumLevels-1-level];

          assign index_nodes[Idx0] = (sel) ?
            idx_t'({1'b1, index_nodes[Idx1+1][NumLevels-unsigned'(level)-2:0]}) :
            idx_t'({1'b0, index_nodes[Idx1][NumLevels-unsigned'(level)-2:0]});

          assign data_nodes[Idx0]  = (sel) ? data_nodes[Idx1+1] : data_nodes[Idx1];
          assign gnt_nodes[Idx1]   = gnt_nodes[Idx0] & ~sel;
          assign gnt_nodes[Idx1+1] = gnt_nodes[Idx0] & sel;
        end
        //////////////////////////////////////////////////////////////
      end
    end

    // pragma translate_off
    `ifndef VERILATOR
    initial begin : p_assert
      assert(NumIn)
        else $fatal(1, "Input must be at least one element wide.");
      assert(!(LockIn && ExtPrio))
        else $fatal(1,"Cannot use LockIn feature together with external ExtPrio.");
    end

    hot_one : assert property(
      @(posedge clk_i) $onehot0(gnt_o))
        else $fatal (1, "Grant signal must be hot1 or zero.");

    gnt0 : assert property(
      @(posedge clk_i) |gnt_o |-> gnt_i)
        else $fatal (1, "Grant out implies grant in.");

    gnt1 : assert property(
      @(posedge clk_i) req_o |-> gnt_i |-> |gnt_o)
        else $fatal (1, "Req out and grant in implies grant out.");

    gnt_idx : assert property(
      @(posedge clk_i) req_o |->  gnt_i |-> gnt_o[idx_o])
        else $fatal (1, "Idx_o / gnt_o do not match.");

    req0 : assert property(
      @(posedge clk_i) |req_i |-> req_o)
        else $fatal (1, "Req in implies req out.");

    req1 : assert property(
      @(posedge clk_i) req_o |-> |req_i)
        else $fatal (1, "Req out implies req in.");
    `endif
    // pragma translate_on
  end

endmodule : miv_rv32_rr_arb_tree
// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
// Copyright 2019-2022 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Authors: Stefan Mach <smach@iis.ee.ethz.ch>
//          Luca Bertaccini <lbertaccini@iis.ee.ethz.ch>
//          Jiang Lannan <jiangl@ethz.ch>
//          Kexin Li <likexi@ethz.ch>

//`include "miv_rv32_registers.v"

module miv_rv32_fpnew_divsqrt_th_32 #(
  // FP32-only DivSqrt
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter miv_rv32_pkg::pipe_config_t PipeConfig  = miv_rv32_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = 32,
  localparam int unsigned NUM_FORMATS = miv_rv32_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [1:0][WIDTH-1:0]       operands_i, // 2 operands
  input  logic [NUM_FORMATS-1:0][1:0] is_boxed_i, // 2 operands
  input  miv_rv32_pkg::roundmode_e       rnd_mode_i,
  input  miv_rv32_pkg::operation_e       op_i,
  input  TagType                      tag_i,
  input  logic                        mask_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output miv_rv32_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output logic                        mask_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i
);

  // ----------
  // Constants
  // ----------
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == miv_rv32_pkg::BEFORE)
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = (PipeConfig == miv_rv32_pkg::AFTER || PipeConfig == miv_rv32_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == miv_rv32_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [1:0][WIDTH-1:0] operands_q;
  miv_rv32_pkg::roundmode_e rnd_mode_q;
  miv_rv32_pkg::operation_e op_q;
  logic                  in_valid_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0]       inp_pipe_operands_q;
  miv_rv32_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  miv_rv32_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, miv_rv32_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, miv_rv32_pkg::FMADD)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign rnd_mode_q = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign op_q       = inp_pipe_op_q[NUM_INP_REGS];
  assign in_valid_q = inp_pipe_valid_q[NUM_INP_REGS];

  // ------------
  // Control FSM
  // ------------
  logic in_ready;               // input handshake with upstream
  logic div_op, sqrt_op;        // input signalling with unit
  logic unit_ready_q, unit_done;  // status signals from unit instance
  logic op_starting;            // high in the cycle a new operation starts
  logic out_valid, out_ready;   // output handshake with downstream
  logic hold_result;            // whether to put result into hold register
  logic data_is_held;           // data in hold register is valid
  logic unit_busy;              // valid data in flight
  // FSM states
  typedef enum logic [1:0] {IDLE, BUSY, HOLD} fsm_state_e;
  fsm_state_e state_q, state_d;

  // Operations are gated by the FSM ready. Invalid input ops run a sqrt to not lose illegal instr.
  assign div_op   = in_valid_q & (op_q == miv_rv32_pkg::DIV) & in_ready & ~flush_i;  //in_ready delete, valid independent of ready
  assign sqrt_op  = in_valid_q & (op_q == miv_rv32_pkg::SQRT) & in_ready & ~flush_i;
  assign op_starting = div_op | sqrt_op;  //start computing or handshake, modify tb handshake right

  logic fdsu_fpu_ex1_stall, fdsu_fpu_ex1_stall_q;
  logic div_op_d, div_op_q;
  logic sqrt_op_d, sqrt_op_q;

  assign div_op_d  = (fdsu_fpu_ex1_stall) ? div_op  : 1'b0;
  assign sqrt_op_d = (fdsu_fpu_ex1_stall) ? sqrt_op : 1'b0;

  `FFL(fdsu_fpu_ex1_stall_q, fdsu_fpu_ex1_stall, 1'b1, '0)
  `FFL(div_op_q, div_op_d, 1'b1, '0)
  `FFL(sqrt_op_q, sqrt_op_d, 1'b1, '0)

  // FSM to safely apply and receive data from DIVSQRT unit
  always_comb begin : flag_fsm
    // Default assignments
    in_ready     = 1'b0;
    out_valid    = 1'b0;
    hold_result  = 1'b0;
    data_is_held = 1'b0;
    unit_busy    = 1'b0;
    state_d      = state_q;
    inp_pipe_ready[NUM_INP_REGS] = unit_ready_q;

    unique case (state_q)
      // Waiting for work
      IDLE: begin
        // in_ready = 1'b1; // we're ready
        in_ready = unit_ready_q;  //***
        if (in_valid_q && unit_ready_q) begin // New work arrives
          inp_pipe_ready[NUM_INP_REGS] = unit_ready_q && !fdsu_fpu_ex1_stall;
          state_d = BUSY; // go into processing state
        end
      end
      // Operation in progress
      BUSY: begin
        inp_pipe_ready[NUM_INP_REGS] = fdsu_fpu_ex1_stall_q;
        unit_busy = 1'b1; // data in flight
        // If the unit is done with processing
        if (unit_done) begin
          out_valid = 1'b1; // try to commit result downstream
          // If downstream accepts our result
          if (out_ready) begin
            state_d = IDLE; // we anticipate going back to idling..
            if (in_valid_q && unit_ready_q) begin // ..unless new work comes in
              in_ready = 1'b1; // we acknowledge the instruction
              state_d  = BUSY; // and stay busy with it
            end
          // Otherwise if downstream is not ready for the result
          end else begin
            hold_result = 1'b1; // activate the hold register
            state_d     = HOLD; // wait for the pipeline to take the data
          end
        end
      end
      // Waiting with valid result for downstream
      HOLD: begin
        unit_busy    = 1'b1; // data in flight
        data_is_held = 1'b1; // data in hold register is valid
        out_valid    = 1'b1; // try to commit result downstream
        // If the result is accepted by downstream
        if (out_ready) begin
          state_d = IDLE; // go back to idle..
          if (in_valid_q && unit_ready_q) begin // ..unless new work comes in
            in_ready = 1'b1; // acknowledge the new transaction
            state_d  = BUSY; // will be busy with the next instruction
          end
        end
      end
      // fall into idle state otherwise
      default: state_d = IDLE;
    endcase

    // Flushing overrides the other actions
    if (flush_i) begin
      unit_busy = 1'b0; // data is invalidated
      out_valid = 1'b0; // cancel any valid data
      state_d   = IDLE; // go to default state
    end
  end

  // FSM status register (asynch active low reset)
  `FF(state_q, state_d, IDLE)

  // Hold additional information while the operation is in progress
  TagType result_tag_q;
  AuxType result_aux_q;
  logic   result_mask_q;

  // Fill the registers everytime a valid operation arrives (load FF, active low asynch rst)
  `FFL(result_tag_q,  inp_pipe_tag_q[NUM_INP_REGS],  op_starting, '0)
  `FFL(result_mask_q, inp_pipe_mask_q[NUM_INP_REGS], op_starting, '0)
  `FFL(result_aux_q,  inp_pipe_aux_q[NUM_INP_REGS],  op_starting, '0)

  // -----------------
  // DIVSQRT instance
  // -----------------
  logic [WIDTH-1:0]   unit_result, held_result_q;
  miv_rv32_pkg::status_t unit_status, held_status_q;

  // thead define fdsu module's input and output
  logic        ctrl_fdsu_ex1_sel;
  logic        fdsu_fpu_ex1_cmplt;
  logic  [4:0] fdsu_fpu_ex1_fflags;
  logic  [7:0] fdsu_fpu_ex1_special_sel;
  logic  [3:0] fdsu_fpu_ex1_special_sign;
  logic        fdsu_fpu_no_op;
  logic  [2:0] idu_fpu_ex1_eu_sel;
  logic [31:0] fdsu_frbus_data;
  logic  [4:0] fdsu_frbus_fflags;
  logic        fdsu_frbus_wb_vld;

  // dp
  logic [31:0] dp_frbus_ex2_data;
  logic  [4:0] dp_frbus_ex2_fflags;
  logic  [2:0] dp_xx_ex1_cnan;
  logic  [2:0] dp_xx_ex1_id;
  logic  [2:0] dp_xx_ex1_inf;
  logic  [2:0] dp_xx_ex1_norm;
  logic  [2:0] dp_xx_ex1_qnan;
  logic  [2:0] dp_xx_ex1_snan;
  logic  [2:0] dp_xx_ex1_zero;
  logic        ex2_inst_wb;
  logic        ex2_inst_wb_vld_d, ex2_inst_wb_vld_q;

  // frbus
  logic [31:0] fpu_idu_fwd_data;
  logic  [4:0] fpu_idu_fwd_fflags;
  logic        fpu_idu_fwd_vld;

  logic unit_ready_d;

  // unit_ready_q related to state machine, different under special and normal cases.
  always_comb begin
    if(op_starting && unit_ready_q) begin
      if(ex2_inst_wb && ex2_inst_wb_vld_q) begin
        unit_ready_d = 1'b1;
      end else begin
        unit_ready_d = 1'b0;
      end
    end else if(fpu_idu_fwd_vld | flush_i) begin
      unit_ready_d = 1'b1;
    end else begin
      unit_ready_d = unit_ready_q;
    end
  end

  `FFL(unit_ready_q, unit_ready_d, 1'b1, 1'b1)

  // determine input of time to select operands
  always_comb begin
    ctrl_fdsu_ex1_sel = 1'b0;
    idu_fpu_ex1_eu_sel = 3'h0;
    if (op_starting) begin  // time to start calculation
      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands
      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module
    end else if (fdsu_fpu_ex1_stall_q) begin
      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands
      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module
    end else begin
      ctrl_fdsu_ex1_sel = 1'b0;
      idu_fpu_ex1_eu_sel = 3'h0;
    end
  end

  miv_rv32_pa_fdsu_top i_divsqrt_thead (
   .cp0_fpu_icg_en                ( 1'b0               ),  // input clock gate enable in miv_rv32_gated_clk_cell, active 0.
   .cp0_fpu_xx_dqnan              ( 1'b0               ),  // When dqnan = 0, QNAN (0x7fc00000).
   .cp0_yy_clk_en                 ( 1'b1               ),  // clock enable in miv_rv32_gated_clk_cell, active 1.
   .cpurst_b                      ( rst_ni             ),  // If negedge cpu reset, all state machines reset to IDLE.
   .ctrl_fdsu_ex1_sel             ( ctrl_fdsu_ex1_sel  ),  // select operands
   .ctrl_xx_ex1_cmplt_dp          ( ctrl_fdsu_ex1_sel  ),  // complete datapath
   .ctrl_xx_ex1_inst_vld          ( ctrl_fdsu_ex1_sel  ),  // instance valid
   .ctrl_xx_ex1_stall             ( fdsu_fpu_ex1_stall ),
   .ctrl_xx_ex1_warm_up           ( 1'b0               ),
   .ctrl_xx_ex2_warm_up           ( 1'b0               ),
   .ctrl_xx_ex3_warm_up           ( 1'b0               ),
   .dp_xx_ex1_cnan                ( dp_xx_ex1_cnan     ),  // Special input type determination
   .dp_xx_ex1_id                  ( dp_xx_ex1_id       ),
   .dp_xx_ex1_inf                 ( dp_xx_ex1_inf      ),
   .dp_xx_ex1_qnan                ( dp_xx_ex1_qnan     ),
   .dp_xx_ex1_rm                  ( rnd_mode_q         ),  // rounding mode
   .dp_xx_ex1_snan                ( dp_xx_ex1_snan     ),
   .dp_xx_ex1_zero                ( dp_xx_ex1_zero     ),
   .fdsu_fpu_debug_info           (                    ),  // output, not used
   .fdsu_fpu_ex1_cmplt            ( fdsu_fpu_ex1_cmplt ),  // output, ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel_i[2]
   .fdsu_fpu_ex1_cmplt_dp         (                    ),  // output, not used
   .fdsu_fpu_ex1_fflags           ( fdsu_fpu_ex1_fflags       ),  // output, special case fflags
   .fdsu_fpu_ex1_special_sel      ( fdsu_fpu_ex1_special_sel  ),  // output, special case type selection
   .fdsu_fpu_ex1_special_sign     ( fdsu_fpu_ex1_special_sign ),  // output, special case sign determination
   .fdsu_fpu_ex1_stall            ( fdsu_fpu_ex1_stall        ),  // output, determine whether stall in ex1
   .fdsu_fpu_no_op                ( fdsu_fpu_no_op            ),  // output, if Write Back SM and fdsu SM no operation, fdsu_fpu_no_op = 1; Otherwise if busy, fdsu_fpu_no_op = 0. (not used)
   .fdsu_frbus_data               ( fdsu_frbus_data           ),  // output, normal case result
   .fdsu_frbus_fflags             ( fdsu_frbus_fflags         ),  // output, normal case fflags
   .fdsu_frbus_freg               (                           ),  // output, determined by input idu_fpu_ex1_dst_freg
   .fdsu_frbus_wb_vld             ( fdsu_frbus_wb_vld         ),  // output, determine whether write back valid
   .forever_cpuclk                ( clk_i                     ),
   .frbus_fdsu_wb_grant           ( fdsu_frbus_wb_vld         ),  // input is fdsu_frbus_wb_vld
   .idu_fpu_ex1_dst_freg          ( 5'h0f                     ),  // register index to write back (not used)
   .idu_fpu_ex1_eu_sel            ( idu_fpu_ex1_eu_sel        ),  // time to select operands
   .idu_fpu_ex1_func              ( {8'b0, div_op | div_op_q, sqrt_op | sqrt_op_q} ),
   .idu_fpu_ex1_srcf0             ( operands_q[0][31:0]       ),  // the first operand
   .idu_fpu_ex1_srcf1             ( operands_q[1][31:0]       ),  // the second operand
   .pad_yy_icg_scan_en            ( 1'b0                      ),  // input of core_top, set to 1'b0 from the beginning to end
   .rtu_xx_ex1_cancel             ( 1'b0                      ),
   .rtu_xx_ex2_cancel             ( 1'b0                      ),
   .rtu_yy_xx_async_flush         ( flush_i                   ),
   .rtu_yy_xx_flush               ( 1'b0                      )
  );

  miv_rv32_pa_fpu_dp  x_pa_fpu_dp (
    .cp0_fpu_icg_en              ( 1'b0                       ),
    .cp0_fpu_xx_rm               ( rnd_mode_q                 ),
    .cp0_yy_clk_en               ( 1'b1                       ),
    .ctrl_xx_ex1_inst_vld        ( ctrl_fdsu_ex1_sel          ),
    .ctrl_xx_ex1_stall           ( 1'b0                       ),
    .ctrl_xx_ex1_warm_up         ( 1'b0                       ),
    .dp_frbus_ex2_data           ( dp_frbus_ex2_data          ),  // output
    .dp_frbus_ex2_fflags         ( dp_frbus_ex2_fflags        ),  // output
    .dp_xx_ex1_cnan              ( dp_xx_ex1_cnan             ),  // output
    .dp_xx_ex1_id                ( dp_xx_ex1_id               ),  // output
    .dp_xx_ex1_inf               ( dp_xx_ex1_inf              ),  // output
    .dp_xx_ex1_norm              ( dp_xx_ex1_norm             ),  // output
    .dp_xx_ex1_qnan              ( dp_xx_ex1_qnan             ),  // output
    .dp_xx_ex1_snan              ( dp_xx_ex1_snan             ),  // output
    .dp_xx_ex1_zero              ( dp_xx_ex1_zero             ),  // output
    .ex2_inst_wb                 ( ex2_inst_wb                ),  // output
    .fdsu_fpu_ex1_fflags         ( fdsu_fpu_ex1_fflags        ),
    .fdsu_fpu_ex1_special_sel    ( fdsu_fpu_ex1_special_sel   ),
    .fdsu_fpu_ex1_special_sign   ( fdsu_fpu_ex1_special_sign  ),
    .forever_cpuclk              ( clk_i                      ),
    .idu_fpu_ex1_eu_sel          ( idu_fpu_ex1_eu_sel         ),
    .idu_fpu_ex1_func            ( {8'b0, div_op, sqrt_op}    ),
    .idu_fpu_ex1_gateclk_vld     ( fdsu_fpu_ex1_cmplt         ),
    .idu_fpu_ex1_rm              ( rnd_mode_q                 ),
    .idu_fpu_ex1_srcf0           ( operands_q[0][31:0]        ),
    .idu_fpu_ex1_srcf1           ( operands_q[1][31:0]        ),
    .idu_fpu_ex1_srcf2           ( '0                         ),
    .pad_yy_icg_scan_en          ( 1'b0                       )
  );

  assign ex2_inst_wb_vld_d = ctrl_fdsu_ex1_sel;
  `FF(ex2_inst_wb_vld_q, ex2_inst_wb_vld_d, '0)

  miv_rv32_pa_fpu_frbus x_pa_fpu_frbus (
    .ctrl_frbus_ex2_wb_req     ( ex2_inst_wb & ex2_inst_wb_vld_q ),
    .dp_frbus_ex2_data         ( dp_frbus_ex2_data   ),
    .dp_frbus_ex2_fflags       ( dp_frbus_ex2_fflags ),
    .fdsu_frbus_data           ( fdsu_frbus_data     ),
    .fdsu_frbus_fflags         ( fdsu_frbus_fflags   ),
    .fdsu_frbus_wb_vld         ( fdsu_frbus_wb_vld   ),
    .fpu_idu_fwd_data          ( fpu_idu_fwd_data    ),  // output
    .fpu_idu_fwd_fflags        ( fpu_idu_fwd_fflags  ),  // output
    .fpu_idu_fwd_vld           ( fpu_idu_fwd_vld     )   // output
  );

  always_comb begin
    unit_result[31:0] = fpu_idu_fwd_data[31:0];
    unit_status[4:0]  = fpu_idu_fwd_fflags[4:0];
    unit_done         = fpu_idu_fwd_vld;
  end

  // The Hold register (load, no reset)
  `FFLNR(held_result_q, unit_result, hold_result, clk_i)
  `FFLNR(held_status_q, unit_status, hold_result, clk_i)

  // --------------
  // Output Select
  // --------------
  logic [WIDTH-1:0]   result_d;
  miv_rv32_pkg::status_t status_d;
  // Prioritize hold register data
  assign result_d = data_is_held ? held_result_q : unit_result;
  assign status_d = data_is_held ? held_status_q : unit_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  miv_rv32_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = result_tag_q;
  assign out_pipe_mask_q[0]   = result_mask_q;
  assign out_pipe_aux_q[0]    = result_aux_q;
  assign out_pipe_valid_q[0]  = out_valid;
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign out_ready = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, unit_busy, out_pipe_valid_q});
endmodule

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module miv_rv32_gated_clk_cell(
  clk_in,
  global_en,
  module_en,
  local_en,
  external_en,
  pad_yy_icg_scan_en,
  clk_out
);

input  clk_in;
input  global_en;
input  module_en;
input  local_en;
input  external_en;
input  pad_yy_icg_scan_en;
output clk_out;

wire   clk_en_bf_latch;
wire   SE;

assign clk_en_bf_latch = (global_en && (module_en || local_en)) || external_en ;

// SE driven from primary input, held constant
assign SE	       = pad_yy_icg_scan_en;
 
// //   &Connect(    .clk_in           (clk_in), @50
// //                .SE               (SE), @51
// //                .external_en      (clk_en_bf_latch), @52
// //                .clk_out          (clk_out) @53
// //                ) ; @54

assign clk_out = clk_in;

endmodule   

// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_ctrl(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_fdsu_ex1_sel,
  ctrl_xx_ex1_cmplt_dp,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  ctrl_xx_ex2_warm_up,
  ctrl_xx_ex3_warm_up,
  ex1_div,
  ex1_expnt_adder_op0,
  ex1_of_result_lfn,
  ex1_op0_id,
  ex1_op0_norm,
  ex1_op1_id_vld,
  ex1_op1_norm,
  ex1_op1_sel,
  ex1_oper_id_expnt,
  ex1_oper_id_expnt_f,
  ex1_pipedown,
  ex1_pipedown_gate,
  ex1_result_sign,
  ex1_rm,
  ex1_save_op0,
  ex1_save_op0_gate,
  ex1_sqrt,
  ex1_srt_skip,
  ex2_expnt_adder_op0,
  ex2_of,
  ex2_pipe_clk,
  ex2_pipedown,
  ex2_potnt_of,
  ex2_potnt_uf,
  ex2_result_inf,
  ex2_result_lfn,
  ex2_rslt_denorm,
  ex2_srt_expnt_rst,
  ex2_srt_first_round,
  ex2_uf,
  ex2_uf_srt_skip,
  ex3_expnt_adjust_result,
  ex3_pipedown,
  ex3_rslt_denorm,
  fdsu_ex1_sel,
  fdsu_fpu_debug_info,
  fdsu_fpu_ex1_cmplt,
  fdsu_fpu_ex1_cmplt_dp,
  fdsu_fpu_ex1_stall,
  fdsu_fpu_no_op,
  fdsu_frbus_wb_vld,
  fdsu_yy_div,
  fdsu_yy_expnt_rst,
  fdsu_yy_of,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_op0_norm,
  fdsu_yy_op1_norm,
  fdsu_yy_potnt_of,
  fdsu_yy_potnt_uf,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rm,
  fdsu_yy_rslt_denorm,
  fdsu_yy_sqrt,
  fdsu_yy_uf,
  fdsu_yy_wb_freg,
  forever_cpuclk,
  frbus_fdsu_wb_grant,
  idu_fpu_ex1_dst_freg,
  idu_fpu_ex1_eu_sel,
  pad_yy_icg_scan_en,
  rtu_xx_ex1_cancel,
  rtu_xx_ex2_cancel,
  rtu_yy_xx_async_flush,
  rtu_yy_xx_flush,
  srt_remainder_zero,
  srt_sm_on
);

// &Ports; @24
input           cp0_fpu_icg_en;         
input           cp0_yy_clk_en;          
input           cpurst_b;               
input           ctrl_fdsu_ex1_sel;      
input           ctrl_xx_ex1_cmplt_dp;   
input           ctrl_xx_ex1_inst_vld;   
input           ctrl_xx_ex1_stall;      
input           ctrl_xx_ex1_warm_up;    
input           ctrl_xx_ex2_warm_up;    
input           ctrl_xx_ex3_warm_up;    
input           ex1_div;                
input   [12:0]  ex1_expnt_adder_op0;    
input           ex1_of_result_lfn;      
input           ex1_op0_id;             
input           ex1_op0_norm;           
input           ex1_op1_id_vld;         
input           ex1_op1_norm;           
input   [12:0]  ex1_oper_id_expnt;      
input           ex1_result_sign;        
input   [2 :0]  ex1_rm;                 
input           ex1_sqrt;               
input           ex1_srt_skip;           
input           ex2_of;                 
input           ex2_potnt_of;           
input           ex2_potnt_uf;           
input           ex2_result_inf;         
input           ex2_result_lfn;         
input           ex2_rslt_denorm;        
input   [9 :0]  ex2_srt_expnt_rst;      
input           ex2_uf;                 
input           ex2_uf_srt_skip;        
input   [9 :0]  ex3_expnt_adjust_result; 
input           ex3_rslt_denorm;        
input           forever_cpuclk;         
input           frbus_fdsu_wb_grant;    
input   [4 :0]  idu_fpu_ex1_dst_freg;   
input   [2 :0]  idu_fpu_ex1_eu_sel;     
input           pad_yy_icg_scan_en;     
input           rtu_xx_ex1_cancel;      
input           rtu_xx_ex2_cancel;      
input           rtu_yy_xx_async_flush;  
input           rtu_yy_xx_flush;        
input           srt_remainder_zero;     
output          ex1_op1_sel;            
output  [12:0]  ex1_oper_id_expnt_f;    
output          ex1_pipedown;           
output          ex1_pipedown_gate;      
output          ex1_save_op0;           
output          ex1_save_op0_gate;      
output  [9 :0]  ex2_expnt_adder_op0;    
output          ex2_pipe_clk;           
output          ex2_pipedown;           
output          ex2_srt_first_round;    
output          ex3_pipedown;           
output          fdsu_ex1_sel;           
output  [4 :0]  fdsu_fpu_debug_info;    
output          fdsu_fpu_ex1_cmplt;     
output          fdsu_fpu_ex1_cmplt_dp;  
output          fdsu_fpu_ex1_stall;     
output          fdsu_fpu_no_op;         
output          fdsu_frbus_wb_vld;      
output          fdsu_yy_div;            
output  [9 :0]  fdsu_yy_expnt_rst;      
output          fdsu_yy_of;             
output          fdsu_yy_of_rm_lfn;      
output          fdsu_yy_op0_norm;       
output          fdsu_yy_op1_norm;       
output          fdsu_yy_potnt_of;       
output          fdsu_yy_potnt_uf;       
output          fdsu_yy_result_inf;     
output          fdsu_yy_result_lfn;     
output          fdsu_yy_result_sign;    
output  [2 :0]  fdsu_yy_rm;             
output          fdsu_yy_rslt_denorm;    
output          fdsu_yy_sqrt;           
output          fdsu_yy_uf;             
output  [4 :0]  fdsu_yy_wb_freg;        
output          srt_sm_on;              

// &Regs; @25
reg             ex2_srt_first_round;    
reg     [2 :0]  fdsu_cur_state;         
reg             fdsu_div;               
reg     [9 :0]  fdsu_expnt_rst;         
reg     [2 :0]  fdsu_next_state;        
reg             fdsu_of;                
reg             fdsu_of_rm_lfn;         
reg             fdsu_potnt_of;          
reg             fdsu_potnt_uf;          
reg             fdsu_result_inf;        
reg             fdsu_result_lfn;        
reg             fdsu_result_sign;       
reg     [2 :0]  fdsu_rm;                
reg             fdsu_sqrt;              
reg             fdsu_uf;                
reg     [4 :0]  fdsu_wb_freg;           
reg             fdsu_yy_rslt_denorm;    
reg     [4 :0]  srt_cnt;                
reg     [1 :0]  wb_cur_state;           
reg     [1 :0]  wb_nxt_state;           

// &Wires; @26
wire            cp0_fpu_icg_en;         
wire            cp0_yy_clk_en;          
wire            cpurst_b;               
wire            ctrl_fdsu_ex1_sel;      
wire            ctrl_fdsu_ex1_stall;    
wire            ctrl_fdsu_wb_vld;       
wire            ctrl_iter_start;        
wire            ctrl_iter_start_gate;   
wire            ctrl_pack;              
wire            ctrl_result_vld;        
wire            ctrl_round;             
wire            ctrl_sm_cmplt;          
wire            ctrl_sm_ex1;            
wire            ctrl_sm_idle;           
wire            ctrl_sm_start;          
wire            ctrl_sm_start_gate;     
wire            ctrl_srt_idle;          
wire            ctrl_srt_itering;       
wire            ctrl_wb_idle;           
wire            ctrl_wb_sm_cmplt;       
wire            ctrl_wb_sm_ex2;         
wire            ctrl_wb_sm_idle;        
wire            ctrl_wfi2;              
wire            ctrl_wfwb;              
wire            ctrl_xx_ex1_cmplt_dp;   
wire            ctrl_xx_ex1_inst_vld;   
wire            ctrl_xx_ex1_stall;      
wire            ctrl_xx_ex1_warm_up;    
wire            ctrl_xx_ex2_warm_up;    
wire            ctrl_xx_ex3_warm_up;    
wire            ex1_div;                
wire    [12:0]  ex1_expnt_adder_op0;    
wire            ex1_of_result_lfn;      
wire            ex1_op0_id;             
wire            ex1_op1_id_vld;         
wire            ex1_op1_sel;            
wire    [12:0]  ex1_oper_id_expnt;      
wire    [12:0]  ex1_oper_id_expnt_f;    
wire            ex1_pipe_clk;           
wire            ex1_pipe_clk_en;        
wire            ex1_pipedown;           
wire            ex1_pipedown_gate;      
wire            ex1_result_sign;        
wire    [2 :0]  ex1_rm;                 
wire            ex1_save_op0;           
wire            ex1_save_op0_gate;      
wire            ex1_sqrt;               
wire            ex1_srt_skip;           
wire    [4 :0]  ex1_wb_freg;            
wire    [9 :0]  ex2_expnt_adder_op0;    
wire            ex2_of;                 
wire            ex2_pipe_clk;           
wire            ex2_pipe_clk_en;        
wire            ex2_pipedown;           
wire            ex2_potnt_of;           
wire            ex2_potnt_uf;           
wire            ex2_result_inf;         
wire            ex2_result_lfn;         
wire            ex2_rslt_denorm;        
wire    [9 :0]  ex2_srt_expnt_rst;      
wire            ex2_uf;                 
wire            ex2_uf_srt_skip;        
wire    [9 :0]  ex3_expnt_adjust_result; 
wire            ex3_pipedown;           
wire            ex3_rslt_denorm;        
wire            expnt_rst_clk;          
wire            expnt_rst_clk_en;       
wire            fdsu_busy;              
wire            fdsu_clk;               
wire            fdsu_clk_en;            
wire            fdsu_dn_stall;          
wire            fdsu_ex1_inst_vld;      
wire            fdsu_ex1_res_vld;       
wire            fdsu_ex1_sel;           
wire            fdsu_flush;             
wire    [4 :0]  fdsu_fpu_debug_info;    
wire            fdsu_fpu_ex1_cmplt;     
wire            fdsu_fpu_ex1_cmplt_dp;  
wire            fdsu_fpu_ex1_stall;     
wire            fdsu_fpu_no_op;         
wire            fdsu_frbus_wb_vld;      
wire            fdsu_op0_norm;          
wire            fdsu_op1_norm;          
wire            fdsu_wb_grant;          
wire            fdsu_yy_div;            
wire    [9 :0]  fdsu_yy_expnt_rst;      
wire            fdsu_yy_of;             
wire            fdsu_yy_of_rm_lfn;      
wire            fdsu_yy_op0_norm;       
wire            fdsu_yy_op1_norm;       
wire            fdsu_yy_potnt_of;       
wire            fdsu_yy_potnt_uf;       
wire            fdsu_yy_result_inf;     
wire            fdsu_yy_result_lfn;     
wire            fdsu_yy_result_sign;    
wire    [2 :0]  fdsu_yy_rm;             
wire            fdsu_yy_sqrt;           
wire            fdsu_yy_uf;             
wire    [4 :0]  fdsu_yy_wb_freg;        
wire            forever_cpuclk;         
wire            frbus_fdsu_wb_grant;    
wire    [4 :0]  idu_fpu_ex1_dst_freg;   
wire    [2 :0]  idu_fpu_ex1_eu_sel;     
wire            pad_yy_icg_scan_en;     
wire            rtu_xx_ex1_cancel;      
wire            rtu_xx_ex2_cancel;      
wire            rtu_yy_xx_async_flush;  
wire            rtu_yy_xx_flush;        
wire    [4 :0]  srt_cnt_ini;            
wire            srt_cnt_zero;           
wire            srt_last_round;         
wire            srt_remainder_zero;     
wire            srt_skip;               
wire            srt_sm_on;              


//==========================================================
//                       Input Signal
//==========================================================
assign ex1_wb_freg[4:0] = idu_fpu_ex1_dst_freg[4:0];
assign fdsu_ex1_inst_vld = ctrl_xx_ex1_inst_vld && ctrl_fdsu_ex1_sel;
assign fdsu_ex1_sel      = idu_fpu_ex1_eu_sel[2];
// &Force("input", "idu_fpu_ex1_eu_sel"); &Force("bus", "idu_fpu_ex1_eu_sel", 2, 0); @34

//==========================================================
//                 FDSU Main State Machine
//==========================================================
assign fdsu_ex1_res_vld  = fdsu_ex1_inst_vld && ex1_srt_skip;
assign fdsu_wb_grant = frbus_fdsu_wb_grant;

assign ctrl_iter_start = ctrl_sm_start && !fdsu_dn_stall
                      || ctrl_wfi2;
assign ctrl_iter_start_gate = ctrl_sm_start_gate && !fdsu_dn_stall
                           || ctrl_wfi2;
assign ctrl_sm_start = fdsu_ex1_inst_vld && ctrl_srt_idle
                   && !ex1_srt_skip;
assign ctrl_sm_start_gate = fdsu_ex1_inst_vld && ctrl_srt_idle;

assign srt_last_round = (srt_skip ||
                         srt_remainder_zero ||
                         srt_cnt_zero)      &&
                         ctrl_srt_itering;
assign srt_skip       =  ex2_of ||
                         ex2_uf_srt_skip;
assign srt_cnt_zero   = ~|srt_cnt[4:0];
assign fdsu_dn_stall  = ctrl_sm_start && ex1_op1_id_vld;

parameter IDLE  = 3'b000;
parameter WFI2  = 3'b001;
parameter ITER  = 3'b010;
parameter RND   = 3'b011;
parameter PACK  = 3'b100;
parameter WFWB  = 3'b101;

always @ (posedge fdsu_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    fdsu_cur_state[2:0] <= IDLE;
  else if (fdsu_flush)
    fdsu_cur_state[2:0] <= IDLE;
  else
    fdsu_cur_state[2:0] <= fdsu_next_state[2:0];
end

// &CombBeg; @76
always @( ctrl_sm_start
       or fdsu_dn_stall
       or srt_last_round
       or fdsu_cur_state[2:0]
       or fdsu_wb_grant)
begin
case (fdsu_cur_state[2:0])
  IDLE:
  begin
    if (ctrl_sm_start)
      if (fdsu_dn_stall)
        fdsu_next_state[2:0] = WFI2;
      else
        fdsu_next_state[2:0] = ITER;
    else
      fdsu_next_state[2:0] = IDLE;
  end
  WFI2:
    fdsu_next_state[2:0] = ITER;
  ITER:
  begin
    if (srt_last_round)
      fdsu_next_state[2:0] = RND;
    else
      fdsu_next_state[2:0] = ITER;
  end
  RND:
    fdsu_next_state[2:0] = PACK;
  PACK:
  begin
    if (fdsu_wb_grant)
      if (ctrl_sm_start)
        if (fdsu_dn_stall)
          fdsu_next_state[2:0] = WFI2;
        else
          fdsu_next_state[2:0] = ITER;
      else
        fdsu_next_state[2:0] = IDLE;
    else
      fdsu_next_state[2:0] = WFWB;
  end
  WFWB:
  begin
    if (fdsu_wb_grant)
      if (ctrl_sm_start)
        if (fdsu_dn_stall)
          fdsu_next_state[2:0] = WFI2;
        else
          fdsu_next_state[2:0] = ITER;
      else
        fdsu_next_state[2:0] = IDLE;
    else
      fdsu_next_state[2:0] = WFWB;
  end
  default:
    fdsu_next_state[2:0] = IDLE;
endcase
// &CombEnd; @128
end

assign ctrl_sm_idle     = fdsu_cur_state[2:0] == IDLE;
assign ctrl_wfi2        = fdsu_cur_state[2:0] == WFI2;
assign ctrl_srt_itering = fdsu_cur_state[2:0] == ITER;
assign ctrl_round       = fdsu_cur_state[2:0] == RND;
assign ctrl_pack        = fdsu_cur_state[2:0] == PACK;
assign ctrl_wfwb        = fdsu_cur_state[2:0] == WFWB;

assign ctrl_sm_cmplt    = ctrl_pack || ctrl_wfwb;
assign ctrl_srt_idle     = ctrl_sm_idle
                       || fdsu_wb_grant;
assign ctrl_sm_ex1      = ctrl_srt_idle || ctrl_wfi2;

//==========================================================
//                    Iteration Counter
//==========================================================
always @ (posedge fdsu_clk)
begin
  if (fdsu_flush)
    srt_cnt[4:0] <= 5'b0;
  else if (ctrl_iter_start)
    srt_cnt[4:0] <= srt_cnt_ini[4:0];
  else if (ctrl_srt_itering)
    srt_cnt[4:0] <= srt_cnt[4:0] - 5'b1;
  else
    srt_cnt[4:0] <= srt_cnt[4:0];
end

//srt_cnt_ini[4:0]
//For Double, initial is 5'b11100('d28), calculate 29 round
//For Single, initial is 5'b01110('d14), calculate 15 round
assign srt_cnt_ini[4:0] = 5'b01110;

//fdsu srt first round signal 
//For srt calculate special use
always @(posedge fdsu_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ex2_srt_first_round <= 1'b0;
  else if(fdsu_flush)
    ex2_srt_first_round <= 1'b0;
  else if(ex1_pipedown)
    ex2_srt_first_round <= 1'b1;
  else
    ex2_srt_first_round <= 1'b0;
end

//==========================================================
//                 Write Back State Machine
//==========================================================
parameter WB_IDLE  = 2'b00,
          WB_EX2   = 2'b10,
          WB_CMPLT = 2'b01;

always @ (posedge fdsu_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    wb_cur_state[1:0] <= WB_IDLE;
  else if (fdsu_flush)
    wb_cur_state[1:0] <= WB_IDLE;
  else
    wb_cur_state[1:0] <= wb_nxt_state[1:0];
end

// &CombBeg; @215
always @( ctrl_fdsu_wb_vld
       or fdsu_dn_stall
       or ctrl_xx_ex1_stall
       or fdsu_ex1_inst_vld
       or ctrl_iter_start
       or fdsu_ex1_res_vld
       or wb_cur_state[1:0])
begin
  case(wb_cur_state[1:0])
    WB_IDLE:
      if (fdsu_ex1_inst_vld)
        if (ctrl_xx_ex1_stall || fdsu_ex1_res_vld || fdsu_dn_stall)
          wb_nxt_state[1:0] = WB_IDLE;
        else
          wb_nxt_state[1:0] = WB_EX2;
      else
        wb_nxt_state[1:0] = WB_IDLE;
    WB_EX2:
      // if (ctrl_xx_ex2_stall)
      //   wb_nxt_state[1:0] = WB_EX2;
      // else
        if (ctrl_fdsu_wb_vld)
          if (ctrl_iter_start && !ctrl_xx_ex1_stall)
            wb_nxt_state[1:0] = WB_EX2;
          else
            wb_nxt_state[1:0] = WB_IDLE;
        else
          wb_nxt_state[1:0] = WB_CMPLT;
    WB_CMPLT:
      if (ctrl_fdsu_wb_vld)
        if (ctrl_iter_start && !ctrl_xx_ex1_stall)
          wb_nxt_state[1:0] = WB_EX2;
        else
          wb_nxt_state[1:0] = WB_IDLE;
      else
        wb_nxt_state[1:0] = WB_CMPLT;
    default:
      wb_nxt_state[1:0] = WB_IDLE;
  endcase
// &CombEnd; @247
end

assign ctrl_wb_idle  = wb_cur_state[1:0] == WB_IDLE
                       || wb_cur_state[1:0] == WB_CMPLT && ctrl_fdsu_wb_vld;
assign ctrl_wb_sm_idle  = wb_cur_state[1:0] == WB_IDLE;
assign ctrl_wb_sm_ex2   = wb_cur_state[1:0] == WB_EX2;
assign ctrl_wb_sm_cmplt = wb_cur_state[1:0] == WB_EX2
                       || wb_cur_state[1:0] == WB_CMPLT;

assign ctrl_result_vld  = ctrl_sm_cmplt && ctrl_wb_sm_cmplt;
assign ctrl_fdsu_wb_vld = ctrl_result_vld && frbus_fdsu_wb_grant;

assign ctrl_fdsu_ex1_stall = fdsu_ex1_inst_vld && !ctrl_sm_ex1 && !ctrl_wb_idle
                          || fdsu_ex1_inst_vld && fdsu_dn_stall;

//==========================================================
//                          Flops
//==========================================================
always @(posedge ex1_pipe_clk)
begin
  if(ex1_pipedown)
  begin
    fdsu_wb_freg[4:0]    <= ex1_wb_freg[4:0];
    fdsu_result_sign     <= ex1_result_sign;
    fdsu_of_rm_lfn       <= ex1_of_result_lfn;
    fdsu_div             <= ex1_div;
    fdsu_sqrt            <= ex1_sqrt;
    fdsu_rm[2:0]         <= ex1_rm[2:0];
  end
  else
  begin
    fdsu_wb_freg[4:0]    <= fdsu_wb_freg[4:0];
    fdsu_result_sign     <= fdsu_result_sign;
    fdsu_of_rm_lfn       <= fdsu_of_rm_lfn;
    fdsu_div             <= fdsu_div;
    fdsu_sqrt            <= fdsu_sqrt;
    fdsu_rm[2:0]         <= fdsu_rm[2:0];
  end
end

// In 906 FDSU, if one op0/1 is not norm, it will not enter EX2.
assign fdsu_op0_norm = 1'b1;
assign fdsu_op1_norm = 1'b1;
// &Force("input", "ex1_op0_norm"); @337
// &Force("input", "ex1_op1_norm"); @338

// fdsu_expnt_rst is used to save:
//  1. op0 denormal expnt;
//  2. op0 expnt;
//  3. result expnt.
// &Force("bus", "ex1_oper_id_expnt", 12, 0); @378
// &Force("bus", "ex1_expnt_adder_op0", 12, 0); @379


always @ (posedge expnt_rst_clk)
begin
  if (ex1_save_op0)
    fdsu_expnt_rst[9:0] <= ex1_oper_id_expnt[9:0];
  else if (ex1_pipedown)
    fdsu_expnt_rst[9:0] <= ex1_expnt_adder_op0[9:0];
  else if (ex2_pipedown)
    fdsu_expnt_rst[9:0] <= ex2_srt_expnt_rst[9:0];
  else if (ex3_pipedown)
    fdsu_expnt_rst[9:0] <= ex3_expnt_adjust_result[9:0];
  else
    fdsu_expnt_rst[9:0] <= fdsu_expnt_rst[9:0];
end

assign ex1_oper_id_expnt_f[12:0] = {3'b1, fdsu_expnt_rst[9:0]};

always @ (posedge expnt_rst_clk)
begin
  if (ex2_pipedown)
    fdsu_yy_rslt_denorm <= ex2_rslt_denorm;
  else if (ex3_pipedown)
    fdsu_yy_rslt_denorm <= ex3_rslt_denorm;
  else
    fdsu_yy_rslt_denorm <= fdsu_yy_rslt_denorm;
end
// &Force("output", "fdsu_yy_rslt_denorm"); @440

// EX2 signal used in EX3 & EX4
always @ (posedge ex2_pipe_clk)
begin
  if (ex2_pipedown)
  begin
    fdsu_result_inf <= ex2_result_inf;
    fdsu_result_lfn <= ex2_result_lfn;
    fdsu_of         <= ex2_of;
    fdsu_uf         <= ex2_uf;
    fdsu_potnt_of   <= ex2_potnt_of;
    fdsu_potnt_uf   <= ex2_potnt_uf;
  end
  else
  begin
    fdsu_result_inf <= fdsu_result_inf;
    fdsu_result_lfn <= fdsu_result_lfn;
    fdsu_of         <= fdsu_of;
    fdsu_uf         <= fdsu_uf;
    fdsu_potnt_of   <= fdsu_potnt_of;
    fdsu_potnt_uf   <= fdsu_potnt_uf;
  end
end

//==========================================================
//                          Flush
//==========================================================
assign fdsu_flush = rtu_xx_ex1_cancel && ctrl_wb_idle
                 || rtu_xx_ex2_cancel && ctrl_wb_sm_ex2
                 || ctrl_xx_ex1_warm_up
                 || rtu_yy_xx_async_flush;

//==========================================================
//                           ICG
//==========================================================
assign fdsu_busy = fdsu_ex1_inst_vld
                || !ctrl_sm_idle
                || !ctrl_wb_sm_idle;
assign fdsu_clk_en = fdsu_busy
                  || !ctrl_sm_idle
                  || rtu_yy_xx_flush;
// &Instance("miv_rv32_gated_clk_cell", "x_fdsu_clk"); @514
miv_rv32_gated_clk_cell  x_fdsu_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (fdsu_clk          ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (fdsu_clk_en       ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect(.clk_in      (forever_cpuclk), @515
//          .external_en (1'b0), @516
//          .global_en   (cp0_yy_clk_en), @517
//          .module_en   (cp0_fpu_icg_en), @518
//          .local_en    (fdsu_clk_en), @519
//          .clk_out     (fdsu_clk)); @520

assign ex1_pipe_clk_en = ex1_pipedown_gate;
// &Instance("miv_rv32_gated_clk_cell","x_ex1_pipe_clk"); @523
miv_rv32_gated_clk_cell  x_ex1_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex1_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex1_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @524
//           .clk_out        (ex1_pipe_clk),//Out Clock @525
//           .external_en    (1'b0), @526
//           .global_en      (cp0_yy_clk_en), @527
//           .local_en       (ex1_pipe_clk_en),//Local Condition @528
//           .module_en      (cp0_fpu_icg_en) @529
//         ); @530

assign ex2_pipe_clk_en = ex2_pipedown;
// &Instance("miv_rv32_gated_clk_cell","x_ex2_pipe_clk"); @533
miv_rv32_gated_clk_cell  x_ex2_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex2_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex2_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @534
//           .clk_out        (ex2_pipe_clk),//Out Clock @535
//           .external_en    (1'b0), @536
//           .global_en      (cp0_yy_clk_en), @537
//           .local_en       (ex2_pipe_clk_en),//Local Condition @538
//           .module_en      (cp0_fpu_icg_en) @539
//         ); @540
// &Force("output", "ex2_pipe_clk"); @541

assign expnt_rst_clk_en = ex1_save_op0_gate
                       || ex1_pipedown_gate
                       || ex2_pipedown
                       || ex3_pipedown;
// &Instance("miv_rv32_gated_clk_cell", "x_expnt_rst_clk"); @547
miv_rv32_gated_clk_cell  x_expnt_rst_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (expnt_rst_clk     ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (expnt_rst_clk_en  ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect(.clk_in      (forever_cpuclk), @548
//          .external_en (1'b0), @549
//          .global_en   (cp0_yy_clk_en), @550
//          .module_en   (cp0_fpu_icg_en), @551
//          .local_en    (expnt_rst_clk_en), @552
//          .clk_out     (expnt_rst_clk)); @553

//==========================================================
//                      Output Signal
//==========================================================
assign fdsu_yy_wb_freg[4:0]    = fdsu_wb_freg[4:0];
assign fdsu_yy_result_sign     = fdsu_result_sign;
assign fdsu_yy_op0_norm        = fdsu_op0_norm;
assign fdsu_yy_op1_norm        = fdsu_op1_norm;
assign fdsu_yy_of_rm_lfn       = fdsu_of_rm_lfn;
assign fdsu_yy_div             = fdsu_div;
assign fdsu_yy_sqrt            = fdsu_sqrt;
assign fdsu_yy_rm[2:0]         = fdsu_rm[2:0];

assign fdsu_yy_expnt_rst[9:0] = fdsu_expnt_rst[9:0];
assign ex2_expnt_adder_op0[9:0] = fdsu_expnt_rst[9:0];

assign fdsu_yy_result_inf = fdsu_result_inf;
assign fdsu_yy_result_lfn = fdsu_result_lfn;
assign fdsu_yy_of         = fdsu_of;
assign fdsu_yy_uf         = fdsu_uf;
assign fdsu_yy_potnt_of   = fdsu_potnt_of;
assign fdsu_yy_potnt_uf   = fdsu_potnt_uf;

assign ex1_pipedown = ctrl_iter_start || ctrl_xx_ex1_warm_up;
assign ex1_pipedown_gate = ctrl_iter_start_gate || ctrl_xx_ex1_warm_up;
assign ex2_pipedown = ctrl_srt_itering && srt_last_round || ctrl_xx_ex2_warm_up;
assign ex3_pipedown = ctrl_round || ctrl_xx_ex3_warm_up;
// &Force("output", "ex1_pipedown"); @589
// &Force("output", "ex1_pipedown_gate"); @590
// &Force("output", "ex2_pipedown"); @591
// &Force("output", "ex3_pipedown"); @592

assign srt_sm_on = ctrl_srt_itering;

assign fdsu_fpu_ex1_cmplt = fdsu_ex1_inst_vld;
assign fdsu_fpu_ex1_cmplt_dp =  ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel[2];
assign fdsu_fpu_ex1_stall = ctrl_fdsu_ex1_stall;
assign fdsu_frbus_wb_vld  = ctrl_result_vld;
// &Force("bus","idu_fpu_ex1_eu_sel",2,0); @600
assign fdsu_fpu_no_op = !fdsu_busy;
assign ex1_op1_sel = ctrl_wfi2;
assign ex1_save_op0 = ctrl_sm_start && ex1_op0_id && ex1_op1_id_vld;
assign ex1_save_op0_gate = ctrl_sm_start_gate && ex1_op0_id && ex1_op1_id_vld;
// &Force("output", "ex1_save_op0"); @605
// &Force("output", "ex1_save_op0_gate"); @606

assign fdsu_fpu_debug_info[4:0] = {wb_cur_state[1:0], fdsu_cur_state[2:0]};

// &ModuleEnd; @610
endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_ff1(
  fanc_shift_num,
  frac_bin_val,
  frac_num
);

// &Ports; @24
input   [51:0]  frac_num;      
output  [51:0]  fanc_shift_num; 
output  [12:0]  frac_bin_val;  

// &Regs; @25
reg     [51:0]  fanc_shift_num; 
reg     [12:0]  frac_bin_val;  

// &Wires; @26
wire    [51:0]  frac_num;      


// &CombBeg; @28
always @( frac_num[51:0])
begin
casez(frac_num[51:0])
  52'b1???????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h0;
  52'b01??????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1fff;
  52'b001?????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffe;
  52'b0001????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffd;
  52'b00001???????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffc;
  52'b000001??????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffb;
  52'b0000001?????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffa;
  52'b00000001????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff9;
  52'b000000001???????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff8;
  52'b0000000001??????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff7;
  52'b00000000001?????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff6;
  52'b000000000001????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff5;
  52'b0000000000001???????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff4;
  52'b00000000000001??????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff3;
  52'b000000000000001?????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff2;
  52'b0000000000000001????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff1;
  52'b00000000000000001???????????????????????????????????: frac_bin_val[12:0] = 13'h1ff0;
  52'b000000000000000001??????????????????????????????????: frac_bin_val[12:0] = 13'h1fef;
  52'b0000000000000000001?????????????????????????????????: frac_bin_val[12:0] = 13'h1fee;
  52'b00000000000000000001????????????????????????????????: frac_bin_val[12:0] = 13'h1fed;
  52'b000000000000000000001???????????????????????????????: frac_bin_val[12:0] = 13'h1fec;
  52'b0000000000000000000001??????????????????????????????: frac_bin_val[12:0] = 13'h1feb;
  52'b00000000000000000000001?????????????????????????????: frac_bin_val[12:0] = 13'h1fea;
  52'b000000000000000000000001????????????????????????????: frac_bin_val[12:0] = 13'h1fe9;
  52'b0000000000000000000000001???????????????????????????: frac_bin_val[12:0] = 13'h1fe8;
  52'b00000000000000000000000001??????????????????????????: frac_bin_val[12:0] = 13'h1fe7;
  52'b000000000000000000000000001?????????????????????????: frac_bin_val[12:0] = 13'h1fe6;
  52'b0000000000000000000000000001????????????????????????: frac_bin_val[12:0] = 13'h1fe5;
  52'b00000000000000000000000000001???????????????????????: frac_bin_val[12:0] = 13'h1fe4;
  52'b000000000000000000000000000001??????????????????????: frac_bin_val[12:0] = 13'h1fe3;
  52'b0000000000000000000000000000001?????????????????????: frac_bin_val[12:0] = 13'h1fe2;
  52'b00000000000000000000000000000001????????????????????: frac_bin_val[12:0] = 13'h1fe1;
  52'b000000000000000000000000000000001???????????????????: frac_bin_val[12:0] = 13'h1fe0;
  52'b0000000000000000000000000000000001??????????????????: frac_bin_val[12:0] = 13'h1fdf;
  52'b00000000000000000000000000000000001?????????????????: frac_bin_val[12:0] = 13'h1fde;
  52'b000000000000000000000000000000000001????????????????: frac_bin_val[12:0] = 13'h1fdd;
  52'b0000000000000000000000000000000000001???????????????: frac_bin_val[12:0] = 13'h1fdc;
  52'b00000000000000000000000000000000000001??????????????: frac_bin_val[12:0] = 13'h1fdb;
  52'b000000000000000000000000000000000000001?????????????: frac_bin_val[12:0] = 13'h1fda;
  52'b0000000000000000000000000000000000000001????????????: frac_bin_val[12:0] = 13'h1fd9;
  52'b00000000000000000000000000000000000000001???????????: frac_bin_val[12:0] = 13'h1fd8;
  52'b000000000000000000000000000000000000000001??????????: frac_bin_val[12:0] = 13'h1fd7;
  52'b0000000000000000000000000000000000000000001?????????: frac_bin_val[12:0] = 13'h1fd6;
  52'b00000000000000000000000000000000000000000001????????: frac_bin_val[12:0] = 13'h1fd5;
  52'b000000000000000000000000000000000000000000001???????: frac_bin_val[12:0] = 13'h1fd4;
  52'b0000000000000000000000000000000000000000000001??????: frac_bin_val[12:0] = 13'h1fd3;
  52'b00000000000000000000000000000000000000000000001?????: frac_bin_val[12:0] = 13'h1fd2;
  52'b000000000000000000000000000000000000000000000001????: frac_bin_val[12:0] = 13'h1fd1;
  52'b0000000000000000000000000000000000000000000000001???: frac_bin_val[12:0] = 13'h1fd0;
  52'b00000000000000000000000000000000000000000000000001??: frac_bin_val[12:0] = 13'h1fcf;
  52'b000000000000000000000000000000000000000000000000001?: frac_bin_val[12:0] = 13'h1fce;
  52'b0000000000000000000000000000000000000000000000000001: frac_bin_val[12:0] = 13'h1fcd;
  52'b0000000000000000000000000000000000000000000000000000: frac_bin_val[12:0] = 13'h1fcc;
  default                                                 : frac_bin_val[12:0] = 13'h000;
endcase
// &CombEnd; @85
end

// &CombBeg; @87
always @( frac_num[51:0])
begin
casez(frac_num[51:0])
  52'b1???????????????????????????????????????????????????: fanc_shift_num[51:0] = frac_num[51:0];
  52'b01??????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[50:0],1'b0};
  52'b001?????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[49:0],2'b0};
  52'b0001????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[48:0],3'b0};
  52'b00001???????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[47:0],4'b0};
  52'b000001??????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[46:0],5'b0};
  52'b0000001?????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[45:0],6'b0};
  52'b00000001????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[44:0],7'b0};
  52'b000000001???????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[43:0],8'b0};
  52'b0000000001??????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[42:0],9'b0};
  52'b00000000001?????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[41:0],10'b0};
  52'b000000000001????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[40:0],11'b0};
  52'b0000000000001???????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[39:0],12'b0};
  52'b00000000000001??????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[38:0],13'b0};
  52'b000000000000001?????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[37:0],14'b0};
  52'b0000000000000001????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[36:0],15'b0};
  52'b00000000000000001???????????????????????????????????: fanc_shift_num[51:0] = {frac_num[35:0],16'b0};
  52'b000000000000000001??????????????????????????????????: fanc_shift_num[51:0] = {frac_num[34:0],17'b0};
  52'b0000000000000000001?????????????????????????????????: fanc_shift_num[51:0] = {frac_num[33:0],18'b0};
  52'b00000000000000000001????????????????????????????????: fanc_shift_num[51:0] = {frac_num[32:0],19'b0};
  52'b000000000000000000001???????????????????????????????: fanc_shift_num[51:0] = {frac_num[31:0],20'b0};
  52'b0000000000000000000001??????????????????????????????: fanc_shift_num[51:0] = {frac_num[30:0],21'b0};
  52'b00000000000000000000001?????????????????????????????: fanc_shift_num[51:0] = {frac_num[29:0],22'b0};
  52'b000000000000000000000001????????????????????????????: fanc_shift_num[51:0] = {frac_num[28:0],23'b0};
  52'b0000000000000000000000001???????????????????????????: fanc_shift_num[51:0] = {frac_num[27:0],24'b0};
  52'b00000000000000000000000001??????????????????????????: fanc_shift_num[51:0] = {frac_num[26:0],25'b0};
  52'b000000000000000000000000001?????????????????????????: fanc_shift_num[51:0] = {frac_num[25:0],26'b0};
  52'b0000000000000000000000000001????????????????????????: fanc_shift_num[51:0] = {frac_num[24:0],27'b0};
  52'b00000000000000000000000000001???????????????????????: fanc_shift_num[51:0] = {frac_num[23:0],28'b0};
  52'b000000000000000000000000000001??????????????????????: fanc_shift_num[51:0] = {frac_num[22:0],29'b0};
  52'b0000000000000000000000000000001?????????????????????: fanc_shift_num[51:0] = {frac_num[21:0],30'b0};
  52'b00000000000000000000000000000001????????????????????: fanc_shift_num[51:0] = {frac_num[20:0],31'b0};
  52'b000000000000000000000000000000001???????????????????: fanc_shift_num[51:0] = {frac_num[19:0],32'b0};
  52'b0000000000000000000000000000000001??????????????????: fanc_shift_num[51:0] = {frac_num[18:0],33'b0};
  52'b00000000000000000000000000000000001?????????????????: fanc_shift_num[51:0] = {frac_num[17:0],34'b0};
  52'b000000000000000000000000000000000001????????????????: fanc_shift_num[51:0] = {frac_num[16:0],35'b0};
  52'b0000000000000000000000000000000000001???????????????: fanc_shift_num[51:0] = {frac_num[15:0],36'b0};
  52'b00000000000000000000000000000000000001??????????????: fanc_shift_num[51:0] = {frac_num[14:0],37'b0};
  52'b000000000000000000000000000000000000001?????????????: fanc_shift_num[51:0] = {frac_num[13:0],38'b0};
  52'b0000000000000000000000000000000000000001????????????: fanc_shift_num[51:0] = {frac_num[12:0],39'b0};
  52'b00000000000000000000000000000000000000001???????????: fanc_shift_num[51:0] = {frac_num[11:0],40'b0};
  52'b000000000000000000000000000000000000000001??????????: fanc_shift_num[51:0] = {frac_num[10:0],41'b0};
  52'b0000000000000000000000000000000000000000001?????????: fanc_shift_num[51:0] = {frac_num[9:0],42'b0};
  52'b00000000000000000000000000000000000000000001????????: fanc_shift_num[51:0] = {frac_num[8:0],43'b0};
  52'b000000000000000000000000000000000000000000001???????: fanc_shift_num[51:0] = {frac_num[7:0],44'b0};
  52'b0000000000000000000000000000000000000000000001??????: fanc_shift_num[51:0] = {frac_num[6:0],45'b0};
  52'b00000000000000000000000000000000000000000000001?????: fanc_shift_num[51:0] = {frac_num[5:0],46'b0};
  52'b000000000000000000000000000000000000000000000001????: fanc_shift_num[51:0] = {frac_num[4:0],47'b0};
  52'b0000000000000000000000000000000000000000000000001???: fanc_shift_num[51:0] = {frac_num[3:0],48'b0};
  52'b00000000000000000000000000000000000000000000000001??: fanc_shift_num[51:0] = {frac_num[2:0],49'b0};
  52'b000000000000000000000000000000000000000000000000001?: fanc_shift_num[51:0] = {frac_num[1:0],50'b0};
  52'b0000000000000000000000000000000000000000000000000001: fanc_shift_num[51:0] = {frac_num[0:0],51'b0};
  52'b0000000000000000000000000000000000000000000000000000: fanc_shift_num[51:0] = {52'b0};
  default                                                 : fanc_shift_num[51:0] = {52'b0};
endcase
// &CombEnd; @144
end

// &ModuleEnd; @146
endmodule



// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_pack_single(
  fdsu_ex4_denorm_to_tiny_frac,
  fdsu_ex4_frac,
  fdsu_ex4_nx,
  fdsu_ex4_potnt_norm,
  fdsu_ex4_result_nor,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_freg,
  fdsu_yy_expnt_rst,
  fdsu_yy_of,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_potnt_of,
  fdsu_yy_potnt_uf,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rslt_denorm,
  fdsu_yy_uf,
  fdsu_yy_wb_freg
);

// &Ports; @24
input           fdsu_ex4_denorm_to_tiny_frac; 
input   [25:0]  fdsu_ex4_frac;               
input           fdsu_ex4_nx;                 
input   [1 :0]  fdsu_ex4_potnt_norm;         
input           fdsu_ex4_result_nor;         
input   [9 :0]  fdsu_yy_expnt_rst;           
input           fdsu_yy_of;                  
input           fdsu_yy_of_rm_lfn;           
input           fdsu_yy_potnt_of;            
input           fdsu_yy_potnt_uf;            
input           fdsu_yy_result_inf;          
input           fdsu_yy_result_lfn;          
input           fdsu_yy_result_sign;         
input           fdsu_yy_rslt_denorm;         
input           fdsu_yy_uf;                  
input   [4 :0]  fdsu_yy_wb_freg;             
output  [31:0]  fdsu_frbus_data;             
output  [4 :0]  fdsu_frbus_fflags;           
output  [4 :0]  fdsu_frbus_freg;             

// &Regs; @25
reg     [22:0]  ex4_frac_23;                 
reg     [31:0]  ex4_result;                  
reg     [22:0]  ex4_single_denorm_frac;      
reg     [9 :0]  expnt_add_op1;               

// &Wires; @26
wire            ex4_cor_nx;                  
wire            ex4_cor_uf;                  
wire            ex4_denorm_potnt_norm;       
wire    [31:0]  ex4_denorm_result;           
wire    [9 :0]  ex4_expnt_rst;               
wire    [4 :0]  ex4_expt;                    
wire            ex4_final_rst_norm;          
wire    [25:0]  ex4_frac;                    
wire            ex4_of_plus;                 
wire            ex4_result_inf;              
wire            ex4_result_lfn;              
wire            ex4_rslt_denorm;             
wire    [31:0]  ex4_rst_inf;                 
wire    [31:0]  ex4_rst_lfn;                 
wire            ex4_rst_nor;                 
wire    [31:0]  ex4_rst_norm;                
wire            ex4_uf_plus;                 
wire            fdsu_ex4_denorm_to_tiny_frac; 
wire            fdsu_ex4_dz;                 
wire    [9 :0]  fdsu_ex4_expnt_rst;          
wire    [25:0]  fdsu_ex4_frac;               
wire            fdsu_ex4_nv;                 
wire            fdsu_ex4_nx;                 
wire            fdsu_ex4_of;                 
wire            fdsu_ex4_of_rst_lfn;         
wire    [1 :0]  fdsu_ex4_potnt_norm;         
wire            fdsu_ex4_potnt_of;           
wire            fdsu_ex4_potnt_uf;           
wire            fdsu_ex4_result_inf;         
wire            fdsu_ex4_result_lfn;         
wire            fdsu_ex4_result_nor;         
wire            fdsu_ex4_result_sign;        
wire            fdsu_ex4_rslt_denorm;        
wire            fdsu_ex4_uf;                 
wire    [31:0]  fdsu_frbus_data;             
wire    [4 :0]  fdsu_frbus_fflags;           
wire    [4 :0]  fdsu_frbus_freg;             
wire    [9 :0]  fdsu_yy_expnt_rst;           
wire            fdsu_yy_of;                  
wire            fdsu_yy_of_rm_lfn;           
wire            fdsu_yy_potnt_of;            
wire            fdsu_yy_potnt_uf;            
wire            fdsu_yy_result_inf;          
wire            fdsu_yy_result_lfn;          
wire            fdsu_yy_result_sign;         
wire            fdsu_yy_rslt_denorm;         
wire            fdsu_yy_uf;                  
wire    [4 :0]  fdsu_yy_wb_freg;             


assign fdsu_ex4_result_sign     = fdsu_yy_result_sign;
assign fdsu_ex4_of_rst_lfn      = fdsu_yy_of_rm_lfn;
assign fdsu_ex4_result_inf      = fdsu_yy_result_inf;
assign fdsu_ex4_result_lfn      = fdsu_yy_result_lfn;
assign fdsu_ex4_of              = fdsu_yy_of;
assign fdsu_ex4_uf              = fdsu_yy_uf;
assign fdsu_ex4_potnt_of        = fdsu_yy_potnt_of;
assign fdsu_ex4_potnt_uf        = fdsu_yy_potnt_uf;
assign fdsu_ex4_nv              = 1'b0;
assign fdsu_ex4_dz              = 1'b0;
assign fdsu_ex4_expnt_rst[9:0] = fdsu_yy_expnt_rst[9:0];
assign fdsu_ex4_rslt_denorm     = fdsu_yy_rslt_denorm;
//============================EX4 STAGE=====================
assign ex4_frac[25:0] = fdsu_ex4_frac[25:0];
//exponent adder
// &CombBeg; @43
always @( ex4_frac[25:24])
begin
casez(ex4_frac[25:24])
  2'b00   : expnt_add_op1[9:0] = 10'h1ff;  //the expnt sub 1
  2'b01   : expnt_add_op1[9:0] = 10'h0;    //the expnt stay the origi
  2'b1?   : expnt_add_op1[9:0] = 10'h1;    // the exptn add 1
  default : expnt_add_op1[9:0] = 10'b0;  
endcase
// &CombEnd; @50
end
assign ex4_expnt_rst[9:0] = fdsu_ex4_expnt_rst[9:0] + 
                             expnt_add_op1[9:0];

//==========================Result Pack=====================

// result denormal pack 
// shift to the denormal number
// &CombBeg; @58
always @( fdsu_ex4_expnt_rst[9:0]
       or fdsu_ex4_denorm_to_tiny_frac
       or ex4_frac[25:1])
begin
case(fdsu_ex4_expnt_rst[9:0])
  10'h1:   ex4_single_denorm_frac[22:0] = {      ex4_frac[23:1]}; //-1022 1
  10'h0:   ex4_single_denorm_frac[22:0] = {      ex4_frac[24:2]}; //-1023 0
  10'h3ff:ex4_single_denorm_frac[22:0] = {      ex4_frac[25:3]}; //-1024 -1
  10'h3fe:ex4_single_denorm_frac[22:0] = {1'b0, ex4_frac[25:4]}; //-1025 -2
  10'h3fd:ex4_single_denorm_frac[22:0] = {2'b0, ex4_frac[25:5]}; //-1026 -3
  10'h3fc:ex4_single_denorm_frac[22:0] = {3'b0, ex4_frac[25:6]}; //-1027 -4
  10'h3fb:ex4_single_denorm_frac[22:0] = {4'b0, ex4_frac[25:7]}; //-1028 -5
  10'h3fa:ex4_single_denorm_frac[22:0] = {5'b0, ex4_frac[25:8]}; //-1029 -6
  10'h3f9:ex4_single_denorm_frac[22:0] = {6'b0, ex4_frac[25:9]}; //-1030 -7
  10'h3f8:ex4_single_denorm_frac[22:0] = {7'b0, ex4_frac[25:10]}; //-1031 -8
  10'h3f7:ex4_single_denorm_frac[22:0] = {8'b0, ex4_frac[25:11]}; //-1032 -9
  10'h3f6:ex4_single_denorm_frac[22:0] = {9'b0, ex4_frac[25:12]}; //-1033 -10
  10'h3f5:ex4_single_denorm_frac[22:0] = {10'b0,ex4_frac[25:13]}; //-1034 -11
  10'h3f4:ex4_single_denorm_frac[22:0] = {11'b0,ex4_frac[25:14]}; //-1035 -12
  10'h3f3:ex4_single_denorm_frac[22:0] = {12'b0,ex4_frac[25:15]}; //-1036 -13  
  10'h3f2:ex4_single_denorm_frac[22:0] = {13'b0,ex4_frac[25:16]}; // -1037
  10'h3f1:ex4_single_denorm_frac[22:0] = {14'b0,ex4_frac[25:17]}; //-1038
  10'h3f0:ex4_single_denorm_frac[22:0] = {15'b0,ex4_frac[25:18]}; //-1039
  10'h3ef:ex4_single_denorm_frac[22:0] = {16'b0,ex4_frac[25:19]}; //-1040
  10'h3ee:ex4_single_denorm_frac[22:0] = {17'b0,ex4_frac[25:20]}; //-1041
  10'h3ed:ex4_single_denorm_frac[22:0] = {18'b0,ex4_frac[25:21]}; //-1042
  10'h3ec:ex4_single_denorm_frac[22:0] = {19'b0,ex4_frac[25:22]}; //-1043
  10'h3eb:ex4_single_denorm_frac[22:0] = {20'b0,ex4_frac[25:23]}; //-1044
  10'h3ea:ex4_single_denorm_frac[22:0] = {21'b0,ex4_frac[25:24]}; //-1044
  default :ex4_single_denorm_frac[22:0] = fdsu_ex4_denorm_to_tiny_frac ? 23'b1 : 23'b0; //-1045
endcase                                                                  
// &CombEnd; @86
end
//here when denormal number round to add1, it will become normal number
assign ex4_denorm_potnt_norm    = (fdsu_ex4_potnt_norm[1] && ex4_frac[24]) || 
                                  (fdsu_ex4_potnt_norm[0] && ex4_frac[25]) ;
assign ex4_rslt_denorm          = fdsu_ex4_rslt_denorm && !ex4_denorm_potnt_norm;
assign ex4_denorm_result[31:0]  = {fdsu_ex4_result_sign,
                                        8'h0,ex4_single_denorm_frac[22:0]};
                                   
                                                              
//ex4 overflow/underflow plus                                 
assign ex4_rst_nor = fdsu_ex4_result_nor;                    
assign ex4_of_plus = fdsu_ex4_potnt_of  && 
                     (|ex4_frac[25:24])  && 
                     ex4_rst_nor;
assign ex4_uf_plus = fdsu_ex4_potnt_uf  && 
                     (~|ex4_frac[25:24]) && 
                     ex4_rst_nor;
//ex4 overflow round result
assign ex4_result_lfn = (ex4_of_plus &&  fdsu_ex4_of_rst_lfn) ||
                        fdsu_ex4_result_lfn;
assign ex4_result_inf = (ex4_of_plus && !fdsu_ex4_of_rst_lfn) ||
                        fdsu_ex4_result_inf;
//Special Result Form
// result largest finity number
assign ex4_rst_lfn[31:0]      = {fdsu_ex4_result_sign,8'hfe,{23{1'b1}}};
//result infinity
assign ex4_rst_inf[31:0]  = {fdsu_ex4_result_sign,8'hff,23'b0};
//result normal
// &CombBeg; @114
always @( ex4_frac[25:0])
begin
casez(ex4_frac[25:24])
  2'b00   : ex4_frac_23[22:0]  = ex4_frac[22:0];
  2'b01   : ex4_frac_23[22:0]  = ex4_frac[23:1];
  2'b1?   : ex4_frac_23[22:0]  = ex4_frac[24:2];
  default : ex4_frac_23[22:0]  = 23'b0;
endcase
// &CombEnd; @121
end
assign ex4_rst_norm[31:0] = {fdsu_ex4_result_sign,
                                  ex4_expnt_rst[7:0],
                                  ex4_frac_23[22:0]};
assign ex4_cor_uf            = (fdsu_ex4_uf && !ex4_denorm_potnt_norm || ex4_uf_plus)
                               && fdsu_ex4_nx;
assign ex4_cor_nx            =  fdsu_ex4_nx 
                                || fdsu_ex4_of 
                                || ex4_of_plus;
                                        
assign ex4_expt[4:0]           = {
                                  fdsu_ex4_nv,
                                  fdsu_ex4_dz,
                                  fdsu_ex4_of | ex4_of_plus,
                                  ex4_cor_uf,
                                  ex4_cor_nx};

assign ex4_final_rst_norm      = !ex4_result_inf        &&
                                 !ex4_result_lfn        && 
                                 !ex4_rslt_denorm; 
// &CombBeg; @141
always @( ex4_denorm_result[31:0]
       or ex4_result_lfn
       or ex4_result_inf
       or ex4_final_rst_norm
       or ex4_rst_norm[31:0]
       or ex4_rst_lfn[31:0]
       or ex4_rst_inf[31:0]
       or ex4_rslt_denorm)
begin
case({ex4_rslt_denorm,
      ex4_result_inf,
      ex4_result_lfn,
      ex4_final_rst_norm})
  4'b1000 : ex4_result[31:0]  = ex4_denorm_result[31:0];
  4'b0100 : ex4_result[31:0]  = ex4_rst_inf[31:0];
  4'b0010 : ex4_result[31:0]  = ex4_rst_lfn[31:0];
  4'b0001 : ex4_result[31:0]  = ex4_rst_norm[31:0];
  default   : ex4_result[31:0]  = 32'b0;
endcase
// &CombEnd; @152
end

//==========================================================
//                     Result Generate
//==========================================================
assign fdsu_frbus_freg[4:0]   = fdsu_yy_wb_freg[4:0];
assign fdsu_frbus_data[31:0]  = ex4_result[31:0];
assign fdsu_frbus_fflags[4:0] = ex4_expt[4:0];

// &ModuleEnd; @161
endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_prepare(
  dp_xx_ex1_rm,
  ex1_div,
  ex1_divisor,
  ex1_expnt_adder_op0,
  ex1_expnt_adder_op1,
  ex1_of_result_lfn,
  ex1_op0_id,
  ex1_op0_sign,
  ex1_op1_id,
  ex1_op1_id_vld,
  ex1_op1_sel,
  ex1_oper_id_expnt,
  ex1_oper_id_expnt_f,
  ex1_oper_id_frac,
  ex1_oper_id_frac_f,
  ex1_remainder,
  ex1_result_sign,
  ex1_rm,
  ex1_sqrt,
  fdsu_ex1_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1
);

// &Ports; @24
input   [2 :0]  dp_xx_ex1_rm;            
input           ex1_op0_id;              
input           ex1_op1_id;              
input           ex1_op1_sel;             
input   [12:0]  ex1_oper_id_expnt_f;     
input   [51:0]  ex1_oper_id_frac_f;      
input           fdsu_ex1_sel;            
input   [9 :0]  idu_fpu_ex1_func;        
input   [31:0]  idu_fpu_ex1_srcf0;       
input   [31:0]  idu_fpu_ex1_srcf1;       
output          ex1_div;                 
output  [23:0]  ex1_divisor;             
output  [12:0]  ex1_expnt_adder_op0;     
output  [12:0]  ex1_expnt_adder_op1;     
output          ex1_of_result_lfn;       
output          ex1_op0_sign;            
output          ex1_op1_id_vld;          
output  [12:0]  ex1_oper_id_expnt;       
output  [51:0]  ex1_oper_id_frac;        
output  [31:0]  ex1_remainder;           
output          ex1_result_sign;         
output  [2 :0]  ex1_rm;                  
output          ex1_sqrt;                

// &Regs; @25
reg     [12:0]  ex1_expnt_adder_op1;     
reg             ex1_of_result_lfn;       

// &Wires; @26
wire            div_sign;                
wire    [2 :0]  dp_xx_ex1_rm;            
wire            ex1_div;                 
wire    [52:0]  ex1_div_noid_nor_srt_op0; 
wire    [52:0]  ex1_div_noid_nor_srt_op1; 
wire    [52:0]  ex1_div_nor_srt_op0;     
wire    [52:0]  ex1_div_nor_srt_op1;     
wire    [12:0]  ex1_div_op0_expnt;       
wire    [12:0]  ex1_div_op1_expnt;       
wire    [52:0]  ex1_div_srt_op0;         
wire    [52:0]  ex1_div_srt_op1;         
wire    [23:0]  ex1_divisor;             
wire            ex1_double;              
wire    [12:0]  ex1_expnt_adder_op0;     
wire            ex1_op0_id;              
wire            ex1_op0_id_nor;          
wire            ex1_op0_sign;            
wire            ex1_op1_id;              
wire            ex1_op1_id_nor;          
wire            ex1_op1_id_vld;          
wire            ex1_op1_sel;             
wire            ex1_op1_sign;            
wire    [63:0]  ex1_oper0;               
wire    [51:0]  ex1_oper0_frac;          
wire    [12:0]  ex1_oper0_id_expnt;      
wire    [51:0]  ex1_oper0_id_frac;       
wire    [63:0]  ex1_oper1;               
wire    [51:0]  ex1_oper1_frac;          
wire    [12:0]  ex1_oper1_id_expnt;      
wire    [51:0]  ex1_oper1_id_frac;       
wire    [51:0]  ex1_oper_frac;           
wire    [12:0]  ex1_oper_id_expnt;       
wire    [12:0]  ex1_oper_id_expnt_f;     
wire    [51:0]  ex1_oper_id_frac;        
wire    [51:0]  ex1_oper_id_frac_f;      
wire    [31:0]  ex1_remainder;           
wire            ex1_result_sign;         
wire    [2 :0]  ex1_rm;                  
wire            ex1_single;              
wire            ex1_sqrt;                
wire            ex1_sqrt_expnt_odd;      
wire            ex1_sqrt_op0_expnt_0;    
wire    [12:0]  ex1_sqrt_op1_expnt;      
wire    [52:0]  ex1_sqrt_srt_op0;        
wire            fdsu_ex1_sel;            
wire    [9 :0]  idu_fpu_ex1_func;        
wire    [31:0]  idu_fpu_ex1_srcf0;       
wire    [31:0]  idu_fpu_ex1_srcf1;       
wire    [59:0]  sqrt_remainder;          
wire            sqrt_sign;               


assign ex1_sqrt                    = idu_fpu_ex1_func[0];
assign ex1_div                     = idu_fpu_ex1_func[1];
assign ex1_oper0[63:0]             = {32'b0, idu_fpu_ex1_srcf0[31:0] & {32{fdsu_ex1_sel}}};
assign ex1_oper1[63:0]             = {32'b0, idu_fpu_ex1_srcf1[31:0] & {32{fdsu_ex1_sel}}};
assign ex1_double                  = 1'b0;
assign ex1_single                  = 1'b1;
// &Force("bus", "idu_fpu_ex1_func", 9, 0); @43
assign ex1_op0_id_nor              = ex1_op0_id;
assign ex1_op1_id_nor              = ex1_op1_id;

//Sign bit prepare
assign ex1_op0_sign                = ex1_double && ex1_oper0[63]
                                  || ex1_single && ex1_oper0[31];
assign ex1_op1_sign                = ex1_double && ex1_oper1[63]
                                  || ex1_single && ex1_oper1[31];
assign div_sign                    = ex1_op0_sign ^ ex1_op1_sign;
assign sqrt_sign                   = ex1_op0_sign;
assign ex1_result_sign             = (ex1_div)
                                   ? div_sign
                                   : sqrt_sign;

//=====================find first one=======================
// this is for the denormal number
assign ex1_oper_frac[51:0] = ex1_op1_sel ? ex1_oper1_frac[51:0]
                                         : ex1_oper0_frac[51:0];

// &Instance("miv_rv32_pa_fdsu_ff1", "x_frac_expnt"); @63
miv_rv32_pa_fdsu_ff1  x_frac_expnt (
  .fanc_shift_num          (ex1_oper_id_frac[51:0] ),
  .frac_bin_val            (ex1_oper_id_expnt[12:0]),
  .frac_num                (ex1_oper_frac[51:0]    )
);

// &Connect(.frac_num(ex1_oper_frac[51:0])); @64
// &Connect(.frac_bin_val(ex1_oper_id_expnt[12:0])); @65
// &Connect(.fanc_shift_num(ex1_oper_id_frac[51:0])); @66
// &Force("output", "ex1_oper_id_expnt"); &Force("bus", "ex1_oper_id_expnt", 12, 0); @67
// &Force("output", "ex1_oper_id_frac"); &Force("bus", "ex1_oper_id_frac", 51, 0); @68

assign ex1_oper0_id_expnt[12:0] = ex1_op1_sel ? ex1_oper_id_expnt_f[12:0]
                                              : ex1_oper_id_expnt[12:0];
assign ex1_oper0_id_frac[51:0]  = ex1_op1_sel ? ex1_oper_id_frac_f[51:0]
                                              : ex1_oper_id_frac[51:0];
assign ex1_oper1_id_expnt[12:0] = ex1_oper_id_expnt[12:0];
assign ex1_oper1_id_frac[51:0]  = ex1_oper_id_frac[51:0];

assign ex1_oper0_frac[51:0] = {52{ex1_double}} & ex1_oper0[51:0]
                            | {52{ex1_single}} & {ex1_oper0[22:0],29'b0};
assign ex1_oper1_frac[51:0] = {52{ex1_double}} & ex1_oper1[51:0]
                            | {52{ex1_single}} & {ex1_oper1[22:0],29'b0};

//=====================exponent add=========================
//exponent number 0
assign ex1_div_op0_expnt[12:0]     = {13{ex1_double}} & {2'b0,ex1_oper0[62:52]}
                                   | {13{ex1_single}} & {5'b0,ex1_oper0[30:23]};
assign ex1_expnt_adder_op0[12:0]   = ex1_op0_id_nor ? ex1_oper0_id_expnt[12:0]
                                                : ex1_div_op0_expnt[12:0];
//exponent number 1
assign ex1_div_op1_expnt[12:0]  = {13{ex1_double}} & {2'b0,ex1_oper1[62:52]}
                                | {13{ex1_single}} & {5'b0,ex1_oper1[30:23]};
assign ex1_sqrt_op1_expnt[12:0] = {13{ex1_double}} & {3'b0,{10{1'b1}}} //'d1023
                                | {13{ex1_single}} & {6'b0,{7{1'b1}}}; //'d127
// &CombBeg; @93
always @( ex1_oper1_id_expnt[12:0]
       or ex1_div
       or ex1_op1_id_nor
       or ex1_sqrt_op1_expnt[12:0]
       or ex1_sqrt
       or ex1_div_op1_expnt[12:0])
begin
case({ex1_div,ex1_sqrt})
  2'b10:   ex1_expnt_adder_op1[12:0] = ex1_op1_id_nor ? ex1_oper1_id_expnt[12:0]
                                                  : ex1_div_op1_expnt[12:0];
  2'b01:   ex1_expnt_adder_op1[12:0] = ex1_sqrt_op1_expnt[12:0];
  default: ex1_expnt_adder_op1[12:0] = 13'b0;
endcase
// &CombEnd; @100
end

//ex1_sqrt_expnt_odd
//fraction will shift left by 1
// adder_op0/1 timing is bad.
// assign ex1_sqrt_expnt_odd          = ex1_expnt_adder_op0[0] ^ ex1_expnt_adder_op1[0];

// sqrt_odd is only used when is sqrt.
assign ex1_sqrt_op0_expnt_0        = ex1_op0_id_nor ? ex1_oper_id_expnt[0]
                                                    : ex1_div_op0_expnt[0];
// ex1_expnt_adder_op1 is always 1'b1, so adder_op0[0] should be 0.
assign ex1_sqrt_expnt_odd          = !ex1_sqrt_op0_expnt_0;

assign ex1_rm[2:0]       = dp_xx_ex1_rm[2:0];
//RNE : Always inc 1 because round to nearest of 1.111...11
//RTZ : Always not inc 1
//RUP : Always not inc 1 when posetive
//RDN : Always not inc 1 when negative
//RMM : Always inc 1 because round to max magnitude
// &CombBeg; @119
always @( ex1_rm[2:0]
       or ex1_result_sign)
begin
case(ex1_rm[2:0])
  3'b000  : ex1_of_result_lfn = 1'b0;
  3'b001  : ex1_of_result_lfn = 1'b1;
  3'b010  : ex1_of_result_lfn = !ex1_result_sign;
  3'b011  : ex1_of_result_lfn = ex1_result_sign;
  3'b100  : ex1_of_result_lfn = 1'b0;
  default: ex1_of_result_lfn = 1'b0;
endcase
// &CombEnd; @128
end

//EX1 Remainder
//div  : 1/8  <= x < 1/4
//sqrt : 1/16 <= x < 1/4
assign ex1_remainder[31:0] = {32{ex1_div }} & {5'b0,ex1_div_srt_op0[52:28],2'b0} |
                             {32{ex1_sqrt}} & sqrt_remainder[59:28];

//EX1 Divisor
//1/2 <= y < 1
assign ex1_divisor[23:0]   = ex1_div_srt_op1[52:29];

//ex1_div_srt_op0
assign ex1_div_srt_op0[52:0]     = ex1_div_nor_srt_op0[52:0];
//ex1_div_srt_op1
assign ex1_div_srt_op1[52:0]     =  ex1_div_nor_srt_op1[52:0];
//ex1_div_nor_srt_op0
assign ex1_div_noid_nor_srt_op0[52:0] = {53{ex1_double}} & {1'b1,ex1_oper0[51:0]}
                                      | {53{ex1_single}} & {1'b1,ex1_oper0[22:0],29'b0};
assign ex1_div_nor_srt_op0[52:0] = ex1_op0_id_nor ? {ex1_oper0_id_frac[51:0],1'b0}
                                                  : ex1_div_noid_nor_srt_op0[52:0];
//ex1_div_nor_srt_op1
assign ex1_div_noid_nor_srt_op1[52:0] = {53{ex1_double}} & {1'b1,ex1_oper1[51:0]}
                                      | {53{ex1_single}} & {1'b1,ex1_oper1[22:0],29'b0};
assign ex1_div_nor_srt_op1[52:0] = ex1_op1_id_nor ? {ex1_oper1_id_frac[51:0],1'b0}
                                                  : ex1_div_noid_nor_srt_op1[52:0];
//sqrt_remainder
assign sqrt_remainder[59:0]      = (ex1_sqrt_expnt_odd)
                                 ? {5'b0,ex1_sqrt_srt_op0[52:0],2'b0}
                                 : {6'b0,ex1_sqrt_srt_op0[52:0],1'b0};
//ex1_sqrt_srt_op0
assign ex1_sqrt_srt_op0[52:0]    = ex1_div_srt_op0[52:0];

//========================Pipe to EX2=======================
//exponent register cal result
// &Force("output", "ex1_expnt_adder_op0"); &Force("bus", "ex1_expnt_adder_op0", 12, 0); @173
// &Force("output", "ex1_expnt_adder_op1"); &Force("bus", "ex1_expnt_adder_op1", 12, 0); @174
// &Force("output", "ex1_double"); @175
// &Force("output", "ex1_expnt_adder_op0"); &Force("bus", "ex1_expnt_adder_op0", 12, 0); @177
// &Force("output", "ex1_expnt_adder_op1"); &Force("bus", "ex1_expnt_adder_op1", 12, 0); @178
// &Force("output", "ex1_result_sign"); @180
// &Force("output", "ex1_div"); @181
// &Force("output", "ex1_sqrt"); @182
// &Force("output", "ex1_rm"); &Force("bus", "ex1_rm", 2, 0); @183
// &Force("output", "ex1_op0_sign"); @184

assign ex1_op1_id_vld = ex1_op1_id_nor && ex1_div;

// &ModuleEnd; @188
endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_round_single(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  ex3_expnt_adjust_result,
  ex3_frac_final_rst,
  ex3_pipedown,
  ex3_rslt_denorm,
  fdsu_ex3_id_srt_skip,
  fdsu_ex3_rem_sign,
  fdsu_ex3_rem_zero,
  fdsu_ex3_result_denorm_round_add_num,
  fdsu_ex4_denorm_to_tiny_frac,
  fdsu_ex4_nx,
  fdsu_ex4_potnt_norm,
  fdsu_ex4_result_nor,
  fdsu_yy_expnt_rst,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rm,
  fdsu_yy_rslt_denorm,
  forever_cpuclk,
  pad_yy_icg_scan_en,
  total_qt_rt_30
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_yy_clk_en;                       
input           ex3_pipedown;                        
input           fdsu_ex3_id_srt_skip;                
input           fdsu_ex3_rem_sign;                   
input           fdsu_ex3_rem_zero;                   
input   [23:0]  fdsu_ex3_result_denorm_round_add_num; 
input   [9 :0]  fdsu_yy_expnt_rst;                   
input           fdsu_yy_result_inf;                  
input           fdsu_yy_result_lfn;                  
input           fdsu_yy_result_sign;                 
input   [2 :0]  fdsu_yy_rm;                          
input           fdsu_yy_rslt_denorm;                 
input           forever_cpuclk;                      
input           pad_yy_icg_scan_en;                  
input   [29:0]  total_qt_rt_30;                      
output  [9 :0]  ex3_expnt_adjust_result;             
output  [25:0]  ex3_frac_final_rst;                  
output          ex3_rslt_denorm;                     
output          fdsu_ex4_denorm_to_tiny_frac;        
output          fdsu_ex4_nx;                         
output  [1 :0]  fdsu_ex4_potnt_norm;                 
output          fdsu_ex4_result_nor;                 

// &Regs; @25
reg             denorm_to_tiny_frac;                 
reg             fdsu_ex4_denorm_to_tiny_frac;        
reg             fdsu_ex4_nx;                         
reg     [1 :0]  fdsu_ex4_potnt_norm;                 
reg             fdsu_ex4_result_nor;                 
reg     [25:0]  frac_add1_op1;                       
reg             frac_add_1;                          
reg             frac_orig;                           
reg     [25:0]  frac_sub1_op1;                       
reg             frac_sub_1;                          
reg     [27:0]  qt_result_single_denorm_for_round;   
reg             single_denorm_lst_frac;              

// &Wires; @26
wire            cp0_fpu_icg_en;                      
wire            cp0_yy_clk_en;                       
wire            ex3_denorm_eq;                       
wire            ex3_denorm_gr;                       
wire            ex3_denorm_lst_frac;                 
wire            ex3_denorm_nx;                       
wire            ex3_denorm_plus;                     
wire            ex3_denorm_potnt_norm;               
wire            ex3_denorm_zero;                     
wire    [9 :0]  ex3_expnt_adjst;                     
wire    [9 :0]  ex3_expnt_adjust_result;             
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_nx;                              
wire            ex3_pipe_clk;                        
wire            ex3_pipe_clk_en;                     
wire            ex3_pipedown;                        
wire    [1 :0]  ex3_potnt_norm;                      
wire            ex3_qt_eq;                           
wire            ex3_qt_gr;                           
wire            ex3_qt_sing_lo3_not0;                
wire            ex3_qt_sing_lo4_not0;                
wire            ex3_qt_zero;                         
wire            ex3_rslt_denorm;                     
wire            ex3_rst_eq_1;                        
wire            ex3_rst_nor;                         
wire            ex3_single_denorm_eq;                
wire            ex3_single_denorm_gr;                
wire            ex3_single_denorm_zero;              
wire            ex3_single_low_not_zero;             
wire    [9 :0]  fdsu_ex3_expnt_rst;                  
wire            fdsu_ex3_id_srt_skip;                
wire            fdsu_ex3_rem_sign;                   
wire            fdsu_ex3_rem_zero;                   
wire    [23:0]  fdsu_ex3_result_denorm_round_add_num; 
wire            fdsu_ex3_result_inf;                 
wire            fdsu_ex3_result_lfn;                 
wire            fdsu_ex3_result_sign;                
wire    [2 :0]  fdsu_ex3_rm;                         
wire            fdsu_ex3_rslt_denorm;                
wire    [9 :0]  fdsu_yy_expnt_rst;                   
wire            fdsu_yy_result_inf;                  
wire            fdsu_yy_result_lfn;                  
wire            fdsu_yy_result_sign;                 
wire    [2 :0]  fdsu_yy_rm;                          
wire            fdsu_yy_rslt_denorm;                 
wire            forever_cpuclk;                      
wire    [25:0]  frac_add1_op1_with_denorm;           
wire    [25:0]  frac_add1_rst;                       
wire            frac_denorm_rdn_add_1;               
wire            frac_denorm_rdn_sub_1;               
wire            frac_denorm_rmm_add_1;               
wire            frac_denorm_rne_add_1;               
wire            frac_denorm_rtz_sub_1;               
wire            frac_denorm_rup_add_1;               
wire            frac_denorm_rup_sub_1;               
wire    [25:0]  frac_final_rst;                      
wire            frac_rdn_add_1;                      
wire            frac_rdn_sub_1;                      
wire            frac_rmm_add_1;                      
wire            frac_rne_add_1;                      
wire            frac_rtz_sub_1;                      
wire            frac_rup_add_1;                      
wire            frac_rup_sub_1;                      
wire    [25:0]  frac_sub1_op1_with_denorm;           
wire    [25:0]  frac_sub1_rst;                       
wire            pad_yy_icg_scan_en;                  
wire    [29:0]  total_qt_rt_30;                      


assign fdsu_ex3_result_sign     = fdsu_yy_result_sign;
assign fdsu_ex3_expnt_rst[9:0]  = fdsu_yy_expnt_rst[9:0];
assign fdsu_ex3_result_inf      = fdsu_yy_result_inf;
assign fdsu_ex3_result_lfn      = fdsu_yy_result_lfn;
assign fdsu_ex3_rm[2:0]         = fdsu_yy_rm[2:0];
assign fdsu_ex3_rslt_denorm     = fdsu_yy_rslt_denorm;
//=======================Round Rule=========================
//1/8 <= x < 1/4, 1/2 <= y < 1, => 1/8 < z < 1/2
//q[29:0] represent the fraction part result of quotient, q[29] for 1/2
//Thus the first "1" in 30 bit quotient will be in q[28] or q[27]
//For Single Float
//15 round to get 30 bit quotient, 23+1 bit as valid result, other for round
//if q[28] is 1, q[28:5] as 1.xxxx valid result, [4:0] for round
//if q[28] is 0, q[27:4] as 1.xxxx valid result, [3:0] for round
// &Force("bus","total_qt_rt_30",29,0); @42
assign ex3_qt_sing_lo4_not0 = |total_qt_rt_30[3:0];
assign ex3_qt_sing_lo3_not0 = |total_qt_rt_30[2:0];
//the quotient round bits great than "10000"(ronnd bits 10..0)
assign ex3_qt_gr          = (total_qt_rt_30[28])
                            ?  total_qt_rt_30[4] && ex3_qt_sing_lo4_not0
                            :  total_qt_rt_30[3] && ex3_qt_sing_lo3_not0;

//the quotient round bits is equal to "10000"(ronnd bits 10..0)
assign ex3_qt_eq          = (total_qt_rt_30[28])
                            ?  total_qt_rt_30[4] && !ex3_qt_sing_lo4_not0
                            :  total_qt_rt_30[3] && !ex3_qt_sing_lo3_not0;
//the quotient round bits is zero
assign ex3_qt_zero        = (total_qt_rt_30[28])
                            ? ~|total_qt_rt_30[4:0]
                            : ~|total_qt_rt_30[3:0];
//quotient is 1.00000..00 need special dealt with in the following
assign ex3_rst_eq_1    = total_qt_rt_30[28] && ~|total_qt_rt_30[27:5];
// for denormal result, first select the quotation num for rounding
//  specially for the result e=-126 and e=-1022,the denorm depends on the
//  MSB of the quotient
assign ex3_denorm_plus       = !total_qt_rt_30[28] && (fdsu_ex3_expnt_rst[9:0] == 10'h382);
assign ex3_denorm_potnt_norm = total_qt_rt_30[28] && (fdsu_ex3_expnt_rst[9:0] == 10'h381);
assign ex3_rslt_denorm            = ex3_denorm_plus || fdsu_ex3_rslt_denorm;
// &Force("output", "ex3_rslt_denorm"); @66

//denomal result, check for rounding further optimization can be done in
//future
// &CombBeg; @70
always @( total_qt_rt_30[28:0]
       or fdsu_ex3_expnt_rst[9:0])
begin
case(fdsu_ex3_expnt_rst[9:0])
  10'h382:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[4:0],23'b0}; //-126 1
                single_denorm_lst_frac =  total_qt_rt_30[5];
			 		end//-1022 1
  10'h381:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[5:0],22'b0}; //-127 0
                single_denorm_lst_frac =  total_qt_rt_30[6];
			 		end//-1022 1
  10'h380:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[6:0],21'b0}; //-128 -1
                single_denorm_lst_frac =  total_qt_rt_30[7];
			 		end//-1022 1
  10'h37f:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[7:0],20'b0}; //-129 -2
                single_denorm_lst_frac =  total_qt_rt_30[8];
			 		end//-1022 1
  10'h37e:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[8:0],19'b0}; //-130 -3
                single_denorm_lst_frac =  total_qt_rt_30[9];
			 		end//-1022 1
  10'h37d:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[9:0],18'b0}; //-131 -4
                single_denorm_lst_frac =  total_qt_rt_30[10];
			 		end//-1022 1
  10'h37c:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[10:0],17'b0}; //-132 -5
                single_denorm_lst_frac =  total_qt_rt_30[11];
			 		end//-1022 1
  10'h37b:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[11:0],16'b0}; //-133 -6
                single_denorm_lst_frac =  total_qt_rt_30[12];
			 		end//-1022 1
  10'h37a:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[12:0],15'b0}; //-134 -7
                single_denorm_lst_frac =  total_qt_rt_30[13];
			 		end//-1022 1
  10'h379:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[13:0],14'b0}; //-135 -8
                single_denorm_lst_frac =  total_qt_rt_30[14];
			 		end//-1022 1
  10'h378:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[14:0],13'b0}; //-136 -9
                single_denorm_lst_frac =  total_qt_rt_30[15];
			 		end//-1022 1
  10'h377:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[15:0],12'b0}; //-137 -10
                single_denorm_lst_frac =  total_qt_rt_30[16];
			 		end//-1022 1
  10'h376:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[16:0],11'b0}; //-138 -11
                single_denorm_lst_frac =  total_qt_rt_30[17];
			 		end//-1022 1
  10'h375:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[17:0],10'b0}; //-139 -12
                single_denorm_lst_frac =  total_qt_rt_30[18];
			 		end//-1022 1
  10'h374:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[18:0],9'b0}; //-140 -13
                single_denorm_lst_frac =  total_qt_rt_30[19];
			 		end//-1022 1
  10'h373:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[19:0],8'b0}; // -141
                single_denorm_lst_frac =  total_qt_rt_30[20];
			 		end//-1022 1
  10'h372:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[20:0],7'b0};//-142
                single_denorm_lst_frac =  total_qt_rt_30[21];
			 		end//-1022 1
  10'h371:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[21:0],6'b0};//-143
                single_denorm_lst_frac =  total_qt_rt_30[22];
			 		end//-1022 1
  10'h370:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[22:0],5'b0}; //-144
                single_denorm_lst_frac =  total_qt_rt_30[23];
			 		end//-1022 1
  10'h36f:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[23:0],4'b0}; //-145
                single_denorm_lst_frac =  total_qt_rt_30[24];
			 		end//-1022 1
  10'h36e:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[24:0],3'b0}; //-146
                single_denorm_lst_frac =  total_qt_rt_30[25];
			 		end//-1022 1
  10'h36d:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[25:0],2'b0}; //-147
                single_denorm_lst_frac =  total_qt_rt_30[26];
			 		end//-1022 1
  10'h36c:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[26:0],1'b0}; //-148
                single_denorm_lst_frac =  total_qt_rt_30[27];
			 		end//-1022 1
  10'h36b: begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[27:0]};
                 single_denorm_lst_frac = total_qt_rt_30[28] ;
						end//-1022 1
  default:  begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[28:1]};
                 single_denorm_lst_frac = 1'b0;
						end//-1022 1
endcase
// &CombEnd; @148
end
//rounding evaluation for single denormalize number
assign ex3_single_denorm_eq      = qt_result_single_denorm_for_round[27]
                                   &&  !ex3_single_low_not_zero;
assign ex3_single_low_not_zero   = |qt_result_single_denorm_for_round[26:0];
assign ex3_single_denorm_gr      = qt_result_single_denorm_for_round[27]
                                   &&  ex3_single_low_not_zero;
assign ex3_single_denorm_zero    = !qt_result_single_denorm_for_round[27]
                                   && !ex3_single_low_not_zero;

//rounding check fo denormalize result
assign ex3_denorm_eq             = ex3_single_denorm_eq;
assign ex3_denorm_gr             = ex3_single_denorm_gr;
assign ex3_denorm_zero           = ex3_single_denorm_zero;
assign ex3_denorm_lst_frac       = single_denorm_lst_frac;
//Different Round Mode with different rounding rule
//Here we call rounding bit as "rb", remainder as "rem"
//RNE :
//  1.+1 : rb>10000 || rb==10000 && rem>0
//  2. 0 : Rest Condition
//  3.-1 : Never occur
//RTZ :
//  1.+1 : Never occur
//  2. 0 : Rest Condition
//  3.-1 : rb=10000 && rem<0
//RDN :
//  1.+1 : Q>0 Never occur   ; Q<0 Rest condition
//  2. 0 : Q>0 Rest condition; Q<0 Rem<0 && rb=0
//  3.-1 : Q>0 Rem<0 && rb=0 ; Q<0 Never occur
//RUP :
//  1.+1 : Q>0 Rest Condition; Q<0 Never occur
//  2. 0 : Q>0 Rem<0 && rb=0 ; Q<0 Rest condition
//  3.-1 : Q>0 Never occur   ; Q<0 Rem<0 && rb=0
//RMM :
//  1.+1 : rb>10000 || rb==10000 && rem>0
//  2. 0 : Rest Condition
//  3.-1 : Never occur
assign frac_rne_add_1 = ex3_qt_gr ||
                       (ex3_qt_eq && !fdsu_ex3_rem_sign);
assign frac_rtz_sub_1 = ex3_qt_zero && fdsu_ex3_rem_sign;
assign frac_rup_add_1 = !fdsu_ex3_result_sign &&
                       (!ex3_qt_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_rup_sub_1 = fdsu_ex3_result_sign &&
                       (ex3_qt_zero && fdsu_ex3_rem_sign);
assign frac_rdn_add_1 = fdsu_ex3_result_sign &&
                       (!ex3_qt_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_rdn_sub_1 = !fdsu_ex3_result_sign &&
                       (ex3_qt_zero && fdsu_ex3_rem_sign);
assign frac_rmm_add_1 = ex3_qt_gr ||
                       (ex3_qt_eq && !fdsu_ex3_rem_sign);
//denormal result
assign frac_denorm_rne_add_1 = ex3_denorm_gr ||
                               (ex3_denorm_eq &&
                               ((fdsu_ex3_rem_zero &&
                                ex3_denorm_lst_frac) ||
                               (!fdsu_ex3_rem_zero &&
                                !fdsu_ex3_rem_sign)));
assign frac_denorm_rtz_sub_1 = ex3_denorm_zero && fdsu_ex3_rem_sign;
assign frac_denorm_rup_add_1 = !fdsu_ex3_result_sign &&
                               (!ex3_denorm_zero ||
                               (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_denorm_rup_sub_1 = fdsu_ex3_result_sign &&
                       (ex3_denorm_zero && fdsu_ex3_rem_sign);
assign frac_denorm_rdn_add_1 = fdsu_ex3_result_sign &&
                       (!ex3_denorm_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_denorm_rdn_sub_1 = !fdsu_ex3_result_sign &&
                       (ex3_denorm_zero && fdsu_ex3_rem_sign);
assign frac_denorm_rmm_add_1 = ex3_denorm_gr ||
                       (ex3_denorm_eq && !fdsu_ex3_rem_sign);

//RM select
// &CombBeg; @222
always @( fdsu_ex3_rm[2:0]
       or frac_denorm_rdn_add_1
       or frac_rne_add_1
       or frac_denorm_rdn_sub_1
       or fdsu_ex3_result_sign
       or frac_rup_add_1
       or frac_denorm_rup_sub_1
       or frac_rdn_sub_1
       or frac_rtz_sub_1
       or frac_rdn_add_1
       or fdsu_ex3_id_srt_skip
       or frac_denorm_rtz_sub_1
       or ex3_rslt_denorm
       or frac_rup_sub_1
       or frac_denorm_rmm_add_1
       or frac_denorm_rup_add_1
       or frac_denorm_rne_add_1
       or frac_rmm_add_1)
begin
case(fdsu_ex3_rm[2:0])
  3'b000://round to nearst,ties to even
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rne_add_1 : frac_rne_add_1;
    frac_sub_1          =  1'b0;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rne_add_1 : !frac_rne_add_1;
    denorm_to_tiny_frac =  fdsu_ex3_id_srt_skip ? 1'b0 : frac_denorm_rne_add_1;
  end
  3'b001:// round to 0
  begin
    frac_add_1           =  1'b0;
    frac_sub_1           =  ex3_rslt_denorm ? frac_denorm_rtz_sub_1 : frac_rtz_sub_1;
    frac_orig            =  ex3_rslt_denorm ? !frac_denorm_rtz_sub_1 : !frac_rtz_sub_1;
    denorm_to_tiny_frac  = 1'b0;
  end
  3'b010://round to -inf
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rdn_add_1 : frac_rdn_add_1;
    frac_sub_1          =  ex3_rslt_denorm ? frac_denorm_rdn_sub_1 : frac_rdn_sub_1;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rdn_add_1 && !frac_denorm_rdn_sub_1
                                           : !frac_rdn_add_1 && !frac_rdn_sub_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? fdsu_ex3_result_sign
                                                : frac_denorm_rdn_add_1;
  end
  3'b011://round to +inf
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rup_add_1 : frac_rup_add_1;
    frac_sub_1          =  ex3_rslt_denorm ? frac_denorm_rup_sub_1 : frac_rup_sub_1;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rup_add_1 && !frac_denorm_rup_sub_1
                                           : !frac_rup_add_1 && !frac_rup_sub_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? !fdsu_ex3_result_sign
                                                : frac_denorm_rup_add_1;
  end
  3'b100://round to nearest,ties to max magnitude
  begin
    frac_add_1          = ex3_rslt_denorm ? frac_denorm_rmm_add_1 : frac_rmm_add_1;
    frac_sub_1          = 1'b0;
    frac_orig           = ex3_rslt_denorm ? !frac_denorm_rmm_add_1 : !frac_rmm_add_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? 1'b0 : frac_denorm_rmm_add_1;
  end
  default:
  begin
    frac_add_1          = 1'b0;
    frac_sub_1          = 1'b0;
    frac_orig           = 1'b0;
    denorm_to_tiny_frac = 1'b0;
  end
endcase
// &CombEnd; @271
end
//Add 1 or Sub 1 constant
// &CombBeg; @273
always @( total_qt_rt_30[28])
begin
case(total_qt_rt_30[28])
  1'b0:
  begin
    frac_add1_op1[25:0] = {2'b0,24'b1};
    frac_sub1_op1[25:0] = {2'b11,{24{1'b1}}};
  end
  1'b1:
  begin
    frac_add1_op1[25:0] = {25'b1,1'b0};
    frac_sub1_op1[25:0] = {{25{1'b1}},1'b0};
  end
  default:
  begin
    frac_add1_op1[25:0] = 26'b0;
    frac_sub1_op1[25:0] = 26'b0;
  end
endcase
// &CombEnd; @291
end

//Add 1 or Sub1 final result
//Conner case when quotient is 0.010000...00 and remainder is negative,
//The real quotient is actually 0.00fff..ff,
//The final result will need to sub 1 when
//RN : Never occur
//RP : sign of quotient is -
//RM : sign of quotient is +
assign frac_add1_rst[25:0]             = {1'b0,total_qt_rt_30[28:4]} +
                                         frac_add1_op1_with_denorm[25:0];
assign frac_add1_op1_with_denorm[25:0] = ex3_rslt_denorm ?
                                  {1'b0,fdsu_ex3_result_denorm_round_add_num[23:0],1'b0} :
                                  frac_add1_op1[25:0];
assign frac_sub1_rst[25:0]             = (ex3_rst_eq_1)
                                       ? {3'b0,{23{1'b1}}}
                                       : {1'b0,total_qt_rt_30[28:4]} +
                                         frac_sub1_op1_with_denorm[25:0] + {25'b0, ex3_rslt_denorm};
assign frac_sub1_op1_with_denorm[25:0] = ex3_rslt_denorm ?
                                ~{1'b0,fdsu_ex3_result_denorm_round_add_num[23:0],1'b0} :
                                frac_sub1_op1[25:0];
assign frac_final_rst[25:0]           = (frac_add1_rst[25:0]         & {26{frac_add_1}}) |
                                        (frac_sub1_rst[25:0]         & {26{frac_sub_1}}) |
                                        ({1'b0,total_qt_rt_30[28:4]} & {26{frac_orig}});

//===============Pipe down signal prepare===================
// assign ex3_rst_nor = !fdsu_ex3_result_zero &&
//                      !fdsu_ex3_result_qnan &&
//                      !fdsu_ex3_result_inf  &&
//                      !fdsu_ex3_result_lfn;
assign ex3_rst_nor = !fdsu_ex3_result_inf  &&
                     !fdsu_ex3_result_lfn;
assign ex3_nx      = ex3_rst_nor &&
                    (!ex3_qt_zero || !fdsu_ex3_rem_zero || ex3_denorm_nx);
assign ex3_denorm_nx = ex3_rslt_denorm && (!ex3_denorm_zero ||  !fdsu_ex3_rem_zero);
//Adjust expnt
//Div:Actural expnt should plus 1 when op0 is id, sub 1 when op1 id
assign ex3_expnt_adjst[9:0] = 10'h7f;

assign ex3_expnt_adjust_result[9:0] = fdsu_ex3_expnt_rst[9:0] +
                                       ex3_expnt_adjst[9:0];
//this information is for the packing, which determin the result is normal
//numer or not;
assign ex3_potnt_norm[1:0]    = {ex3_denorm_plus,ex3_denorm_potnt_norm};
//=======================Pipe to EX4========================
//gate clk
// &Instance("miv_rv32_gated_clk_cell","x_ex3_pipe_clk"); @337
miv_rv32_gated_clk_cell  x_ex3_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex3_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex3_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @338
//           .clk_out        (ex3_pipe_clk),//Out Clock @339
//           .external_en    (1'b0), @340
//           .global_en      (cp0_yy_clk_en), @341
//           .local_en       (ex3_pipe_clk_en),//Local Condition @342
//           .module_en      (cp0_fpu_icg_en) @343
//         ); @344
assign ex3_pipe_clk_en = ex3_pipedown;

always @(posedge ex3_pipe_clk)
begin
  if(ex3_pipedown)
  begin
    fdsu_ex4_result_nor      <= ex3_rst_nor;
    fdsu_ex4_nx              <= ex3_nx;
    fdsu_ex4_denorm_to_tiny_frac
                              <= denorm_to_tiny_frac;
    fdsu_ex4_potnt_norm[1:0] <= ex3_potnt_norm[1:0];
  end
  else
  begin
    fdsu_ex4_result_nor      <= fdsu_ex4_result_nor;
    fdsu_ex4_nx              <= fdsu_ex4_nx;
    fdsu_ex4_denorm_to_tiny_frac
                              <= fdsu_ex4_denorm_to_tiny_frac;
    fdsu_ex4_potnt_norm[1:0] <= fdsu_ex4_potnt_norm[1:0];
  end
end

// ex3_frac Pipedown to ex4 use srt_divisor.
assign ex3_frac_final_rst[25:0] = frac_final_rst[25:0];
// &Force("output","fdsu_ex4_result_nor"); @397
// &Force("output","fdsu_ex4_nx"); @398
// &Force("output","fdsu_ex4_denorm_to_tiny_frac"); @399
// &Force("output","fdsu_ex4_potnt_norm"); @400


// &ModuleEnd; @403
endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_special(
  cp0_fpu_xx_dqnan,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_qnan,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  ex1_div,
  ex1_op0_id,
  ex1_op0_norm,
  ex1_op0_sign,
  ex1_op1_id,
  ex1_op1_norm,
  ex1_result_sign,
  ex1_sqrt,
  ex1_srt_skip,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign
);

// &Ports; @24
input          cp0_fpu_xx_dqnan;         
input   [2:0]  dp_xx_ex1_cnan;           
input   [2:0]  dp_xx_ex1_id;             
input   [2:0]  dp_xx_ex1_inf;            
input   [2:0]  dp_xx_ex1_qnan;           
input   [2:0]  dp_xx_ex1_snan;           
input   [2:0]  dp_xx_ex1_zero;           
input          ex1_div;                  
input          ex1_op0_sign;             
input          ex1_result_sign;          
input          ex1_sqrt;                 
output         ex1_op0_id;               
output         ex1_op0_norm;             
output         ex1_op1_id;               
output         ex1_op1_norm;             
output         ex1_srt_skip;             
output  [4:0]  fdsu_fpu_ex1_fflags;      
output  [7:0]  fdsu_fpu_ex1_special_sel; 
output  [3:0]  fdsu_fpu_ex1_special_sign; 

// &Regs; @25
reg            ex1_result_cnan;          
reg            ex1_result_qnan_op0;      
reg            ex1_result_qnan_op1;      

// &Wires; @26
wire           cp0_fpu_xx_dqnan;         
wire    [2:0]  dp_xx_ex1_cnan;           
wire    [2:0]  dp_xx_ex1_id;             
wire    [2:0]  dp_xx_ex1_inf;            
wire    [2:0]  dp_xx_ex1_qnan;           
wire    [2:0]  dp_xx_ex1_snan;           
wire    [2:0]  dp_xx_ex1_zero;           
wire           ex1_div;                  
wire           ex1_div_dz;               
wire           ex1_div_nv;               
wire           ex1_div_rst_inf;          
wire           ex1_div_rst_qnan;         
wire           ex1_div_rst_zero;         
wire           ex1_dz;                   
wire    [4:0]  ex1_fflags;               
wire           ex1_nv;                   
wire           ex1_op0_cnan;             
wire           ex1_op0_id;               
wire           ex1_op0_inf;              
wire           ex1_op0_is_qnan;          
wire           ex1_op0_is_snan;          
wire           ex1_op0_norm;             
wire           ex1_op0_qnan;             
wire           ex1_op0_sign;             
wire           ex1_op0_snan;             
wire           ex1_op0_tt_zero;          
wire           ex1_op0_zero;             
wire           ex1_op1_cnan;             
wire           ex1_op1_id;               
wire           ex1_op1_inf;              
wire           ex1_op1_is_qnan;          
wire           ex1_op1_is_snan;          
wire           ex1_op1_norm;             
wire           ex1_op1_qnan;             
wire           ex1_op1_snan;             
wire           ex1_op1_tt_zero;          
wire           ex1_op1_zero;             
wire           ex1_result_inf;           
wire           ex1_result_lfn;           
wire           ex1_result_qnan;          
wire           ex1_result_sign;          
wire           ex1_result_zero;          
wire           ex1_rst_default_qnan;     
wire    [7:0]  ex1_special_sel;          
wire    [3:0]  ex1_special_sign;         
wire           ex1_sqrt;                 
wire           ex1_sqrt_nv;              
wire           ex1_sqrt_rst_inf;         
wire           ex1_sqrt_rst_qnan;        
wire           ex1_sqrt_rst_zero;        
wire           ex1_srt_skip;             
wire    [4:0]  fdsu_fpu_ex1_fflags;      
wire    [7:0]  fdsu_fpu_ex1_special_sel; 
wire    [3:0]  fdsu_fpu_ex1_special_sign; 


//infinity number
// &Force("bus", "dp_xx_ex1_inf", 2, 0); @29
assign  ex1_op0_inf                = dp_xx_ex1_inf[0];
assign  ex1_op1_inf                = dp_xx_ex1_inf[1];

//zero
// &Force("bus", "dp_xx_ex1_zero", 2, 0); @34
assign ex1_op0_zero                = dp_xx_ex1_zero[0];
assign ex1_op1_zero                = dp_xx_ex1_zero[1];

//denormalize number
// &Force("bus", "dp_xx_ex1_id", 2, 0); @39
assign ex1_op0_id                  = dp_xx_ex1_id[0];
assign ex1_op1_id                  = dp_xx_ex1_id[1];

//cNaN
// &Force("bus", "dp_xx_ex1_cnan", 2, 0); @44
assign ex1_op0_cnan                = dp_xx_ex1_cnan[0];
assign ex1_op1_cnan                = dp_xx_ex1_cnan[1];

//sNaN
// &Force("bus", "dp_xx_ex1_snan", 2, 0); @49
assign ex1_op0_snan                = dp_xx_ex1_snan[0];
assign ex1_op1_snan                = dp_xx_ex1_snan[1];

//qNaN
// &Force("bus", "dp_xx_ex1_qnan", 2, 0); @54
assign ex1_op0_qnan                = dp_xx_ex1_qnan[0];
assign ex1_op1_qnan                = dp_xx_ex1_qnan[1];


//======================EX1 expt detect=====================
//ex1_id_detect
//any opration is zero
// no input denormalize exception anymore
//
//ex1_nv_detect
//div_nv
//  1.any operation is sNaN
//  2.0/0(include DN flush to zero)
//  3.inf/inf
//sqrt_nv
//  1.any operation is sNaN
//  2.operation sign is 1 && operation is not zero/qNaN
assign ex1_nv      = ex1_div  && ex1_div_nv  ||
                     ex1_sqrt && ex1_sqrt_nv;
//ex1_div_nv
assign ex1_div_nv  = ex1_op0_snan ||
                     ex1_op1_snan ||
                    (ex1_op0_tt_zero && ex1_op1_tt_zero)||
                    (ex1_op0_inf && ex1_op1_inf);
assign ex1_op0_tt_zero = ex1_op0_zero;
assign ex1_op1_tt_zero = ex1_op1_zero;
//ex1_sqrt_nv
assign ex1_sqrt_nv = ex1_op0_snan ||
                     ex1_op0_sign &&
                    (ex1_op0_norm ||
                     ex1_op0_inf );

// This 'norm' also include denorm.
assign ex1_op0_norm = !ex1_op0_inf && !ex1_op0_zero && !ex1_op0_snan && !ex1_op0_qnan && !ex1_op0_cnan;
assign ex1_op1_norm = !ex1_op1_inf && !ex1_op1_zero && !ex1_op1_snan && !ex1_op1_qnan && !ex1_op1_cnan;

//ex1_of_detect
//div_of
//  1.only detect id overflow case
//assign ex1_of      = ex1_div && ex1_div_of;
//assign ex1_div_of  = ex1_op1_id_fm1 &&
//                     ex1_op0_norm &&
//                     ex1_div_id_of;
//
////ex1_uf_detect
////div_uf
////  1.only detect id underflow case
//assign ex1_uf      = ex1_div && ex1_div_uf;
//assign ex1_div_uf  = ex1_op0_id &&
//                     ex1_op1_norm &&
//                     ex1_div_id_uf;
//ex1_dz_detect
//div_dz
//  1.op0 is normal && op1 zero
assign ex1_dz      = ex1_div && ex1_div_dz;
assign ex1_div_dz  = ex1_op1_tt_zero && ex1_op0_norm;

//===================special cal result=====================
//ex1 result is zero
//div_zero
//  1.op0 is zero && op1 is normal
//  2.op0 is zero/normal && op1 is inf
//sqrt_zero
//  1.op0 is zero
assign ex1_result_zero   = ex1_div_rst_zero  && ex1_div  ||
                           ex1_sqrt_rst_zero && ex1_sqrt;
assign ex1_div_rst_zero  = (ex1_op0_tt_zero && ex1_op1_norm ) ||
                           // (!ex1_expnt0_max && !ex1_op0_cnan && ex1_op1_inf);
                           (!ex1_op0_inf && !ex1_op0_qnan && !ex1_op0_snan && !ex1_op0_cnan && ex1_op1_inf);
assign ex1_sqrt_rst_zero = ex1_op0_tt_zero;

//ex1 result is qNaN
//ex1_nv
//div_qnan
//  1.op0 is qnan || op1 is qnan
//sqrt_qnan
//  1.op0 is qnan
assign ex1_result_qnan   = ex1_div_rst_qnan  && ex1_div  ||
                           ex1_sqrt_rst_qnan && ex1_sqrt ||
                           ex1_nv;
assign ex1_div_rst_qnan  = ex1_op0_qnan ||
                           ex1_op1_qnan;
assign ex1_sqrt_rst_qnan = ex1_op0_qnan;

//ex1_rst_default_qnan
//0/0, inf/inf, sqrt negative should get default qNaN
assign ex1_rst_default_qnan = (ex1_div && ex1_op0_zero && ex1_op1_zero) ||
                              (ex1_div && ex1_op0_inf  && ex1_op1_inf)  ||
                              (ex1_sqrt&& ex1_op0_sign && (ex1_op0_norm || ex1_op0_inf));

//ex1 result is inf
//ex1_dz
//
//div_inf
//  1.op0 is inf && op1 is normal/zero
//sqrt_inf
//  1.op0 is inf
assign ex1_result_inf    = ex1_div_rst_inf  && ex1_div  ||
                           ex1_sqrt_rst_inf && ex1_sqrt ||
                           ex1_dz ;
// assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_expnt1_max && !ex1_op1_cnan;
assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_op1_inf && !ex1_op1_qnan && !ex1_op1_snan && !ex1_op1_cnan;
assign ex1_sqrt_rst_inf  = ex1_op0_inf && !ex1_op0_sign;

//ex1 result is lfn
//ex1_of && round result toward not inc 1
assign ex1_result_lfn = 1'b0;

//Default_qnan/Standard_qnan Select
assign ex1_op0_is_snan      = ex1_op0_snan;
assign ex1_op1_is_snan      = ex1_op1_snan && ex1_div;
assign ex1_op0_is_qnan      = ex1_op0_qnan;
assign ex1_op1_is_qnan      = ex1_op1_qnan && ex1_div;

// &CombBeg; @169
always @( ex1_op0_is_snan
       or ex1_op0_cnan
       or ex1_result_qnan
       or ex1_op0_is_qnan
       or ex1_rst_default_qnan
       or cp0_fpu_xx_dqnan
       or ex1_op1_cnan
       or ex1_op1_is_qnan
       or ex1_op1_is_snan)
begin
if(ex1_rst_default_qnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan;
end
else if(ex1_op0_is_snan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = ex1_result_qnan;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = 1'b0;
end
else if(ex1_op1_is_snan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = ex1_result_qnan;
  ex1_result_cnan      = 1'b0;
end
else if(ex1_op0_is_qnan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = ex1_result_qnan && !ex1_op0_cnan;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan &&  ex1_op0_cnan;
end
else if(ex1_op1_is_qnan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = ex1_result_qnan && !ex1_op1_cnan;
  ex1_result_cnan      = ex1_result_qnan &&  ex1_op1_cnan;
end
else
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan;
end
// &CombEnd; @206
end


//Special result should skip SRT logic
assign ex1_srt_skip = ex1_result_zero ||
                      ex1_result_qnan ||
                      ex1_result_lfn  ||
                      ex1_result_inf;
// fflags:
// NV, DZ, OF, UF, NX
assign ex1_fflags[4:0] = {ex1_nv, ex1_dz, 3'b0};
// Special Sel[7:0]:
// qnan_src2, qnan_src1, qnan_src0, cnan, lfn, inf, zero, src2
assign ex1_special_sel[7:0] = {1'b0, ex1_result_qnan_op1, ex1_result_qnan_op0,
                               ex1_result_cnan, ex1_result_lfn, ex1_result_inf,
                               ex1_result_zero, 1'b0};
// Special Sign[3:0]
// lfn, inf, zero, src2
assign ex1_special_sign[3:0] = {ex1_result_sign, ex1_result_sign, ex1_result_sign, 1'b0};

//==========================================================
//                      Output Signal
//==========================================================
assign fdsu_fpu_ex1_fflags[4:0]       = ex1_fflags[4:0];
assign fdsu_fpu_ex1_special_sel[7:0]  = ex1_special_sel[7:0];
assign fdsu_fpu_ex1_special_sign[3:0] = ex1_special_sign[3:0];

// &Force("output", "ex1_op0_norm"); @233
// &Force("output", "ex1_op1_norm"); @234

// &ModuleEnd; @236
endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_srt_single(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  ex1_divisor,
  ex1_expnt_adder_op1,
  ex1_oper_id_frac,
  ex1_oper_id_frac_f,
  ex1_pipedown,
  ex1_pipedown_gate,
  ex1_remainder,
  ex1_save_op0,
  ex1_save_op0_gate,
  ex2_expnt_adder_op0,
  ex2_of,
  ex2_pipe_clk,
  ex2_pipedown,
  ex2_potnt_of,
  ex2_potnt_uf,
  ex2_result_inf,
  ex2_result_lfn,
  ex2_rslt_denorm,
  ex2_srt_expnt_rst,
  ex2_srt_first_round,
  ex2_uf,
  ex2_uf_srt_skip,
  ex3_frac_final_rst,
  ex3_pipedown,
  fdsu_ex3_id_srt_skip,
  fdsu_ex3_rem_sign,
  fdsu_ex3_rem_zero,
  fdsu_ex3_result_denorm_round_add_num,
  fdsu_ex4_frac,
  fdsu_yy_div,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_op0_norm,
  fdsu_yy_op1_norm,
  fdsu_yy_sqrt,
  forever_cpuclk,
  pad_yy_icg_scan_en,
  srt_remainder_zero,
  srt_sm_on,
  total_qt_rt_30
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_yy_clk_en;                       
input   [23:0]  ex1_divisor;                         
input   [12:0]  ex1_expnt_adder_op1;                 
input   [51:0]  ex1_oper_id_frac;                    
input           ex1_pipedown;                        
input           ex1_pipedown_gate;                   
input   [31:0]  ex1_remainder;                       
input           ex1_save_op0;                        
input           ex1_save_op0_gate;                   
input   [9 :0]  ex2_expnt_adder_op0;                 
input           ex2_pipe_clk;                        
input           ex2_pipedown;                        
input           ex2_srt_first_round;                 
input   [25:0]  ex3_frac_final_rst;                  
input           ex3_pipedown;                        
input           fdsu_yy_div;                         
input           fdsu_yy_of_rm_lfn;                   
input           fdsu_yy_op0_norm;                    
input           fdsu_yy_op1_norm;                    
input           fdsu_yy_sqrt;                        
input           forever_cpuclk;                      
input           pad_yy_icg_scan_en;                  
input           srt_sm_on;                           
output  [51:0]  ex1_oper_id_frac_f;                  
output          ex2_of;                              
output          ex2_potnt_of;                        
output          ex2_potnt_uf;                        
output          ex2_result_inf;                      
output          ex2_result_lfn;                      
output          ex2_rslt_denorm;                     
output  [9 :0]  ex2_srt_expnt_rst;                   
output          ex2_uf;                              
output          ex2_uf_srt_skip;                     
output          fdsu_ex3_id_srt_skip;                
output          fdsu_ex3_rem_sign;                   
output          fdsu_ex3_rem_zero;                   
output  [23:0]  fdsu_ex3_result_denorm_round_add_num; 
output  [25:0]  fdsu_ex4_frac;                       
output          srt_remainder_zero;                  
output  [29:0]  total_qt_rt_30;                      

// &Regs; @25
reg     [31:0]  cur_rem;                             
reg     [7 :0]  digit_bound_1;                       
reg     [7 :0]  digit_bound_2;                       
reg     [23:0]  ex2_result_denorm_round_add_num;     
reg             fdsu_ex3_id_srt_skip;                
reg             fdsu_ex3_rem_sign;                   
reg             fdsu_ex3_rem_zero;                   
reg     [23:0]  fdsu_ex3_result_denorm_round_add_num; 
reg     [29:0]  qt_rt_const_shift_std;               
reg     [7 :0]  qtrt_sel_rem;                        
reg     [31:0]  rem_add1_op1;                        
reg     [31:0]  rem_add2_op1;                        
reg     [25:0]  srt_divisor;                         
reg     [31:0]  srt_remainder;                       
reg     [29:0]  total_qt_rt_30;                      
reg     [29:0]  total_qt_rt_30_next;                 
reg     [29:0]  total_qt_rt_minus_30;                
reg     [29:0]  total_qt_rt_minus_30_next;           

// &Wires; @26
wire    [7 :0]  bound1_cmp_result;                   
wire            bound1_cmp_sign;                     
wire    [7 :0]  bound2_cmp_result;                   
wire            bound2_cmp_sign;                     
wire    [3 :0]  bound_sel;                           
wire            cp0_fpu_icg_en;                      
wire            cp0_yy_clk_en;                       
wire    [31:0]  cur_doub_rem_1;                      
wire    [31:0]  cur_doub_rem_2;                      
wire    [31:0]  cur_rem_1;                           
wire    [31:0]  cur_rem_2;                           
wire    [31:0]  div_qt_1_rem_add_op1;                
wire    [31:0]  div_qt_2_rem_add_op1;                
wire    [31:0]  div_qt_r1_rem_add_op1;               
wire    [31:0]  div_qt_r2_rem_add_op1;               
wire    [23:0]  ex1_divisor;                         
wire            ex1_ex2_pipe_clk;                    
wire            ex1_ex2_pipe_clk_en;                 
wire    [12:0]  ex1_expnt_adder_op1;                 
wire    [51:0]  ex1_oper_id_frac;                    
wire    [51:0]  ex1_oper_id_frac_f;                  
wire            ex1_pipedown;                        
wire            ex1_pipedown_gate;                   
wire    [31:0]  ex1_remainder;                       
wire            ex1_save_op0;                        
wire            ex1_save_op0_gate;                   
wire            ex2_div_of;                          
wire            ex2_div_uf;                          
wire    [9 :0]  ex2_expnt_adder_op0;                 
wire    [9 :0]  ex2_expnt_adder_op1;                 
wire            ex2_expnt_of;                        
wire    [9 :0]  ex2_expnt_result;                    
wire            ex2_expnt_uf;                        
wire            ex2_id_nor_srt_skip;                 
wire            ex2_of;                              
wire            ex2_of_plus;                         
wire            ex2_pipe_clk;                        
wire            ex2_pipedown;                        
wire            ex2_potnt_of;                        
wire            ex2_potnt_of_pre;                    
wire            ex2_potnt_uf;                        
wire            ex2_potnt_uf_pre;                    
wire            ex2_result_inf;                      
wire            ex2_result_lfn;                      
wire            ex2_rslt_denorm;                     
wire    [9 :0]  ex2_sqrt_expnt_result;               
wire    [9 :0]  ex2_srt_expnt_rst;                   
wire            ex2_srt_first_round;                 
wire            ex2_uf;                              
wire            ex2_uf_plus;                         
wire            ex2_uf_srt_skip;                     
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_pipedown;                        
wire            fdsu_ex2_div;                        
wire    [9 :0]  fdsu_ex2_expnt_rst;                  
wire            fdsu_ex2_of_rm_lfn;                  
wire            fdsu_ex2_op0_norm;                   
wire            fdsu_ex2_op1_norm;                   
wire            fdsu_ex2_result_lfn;                 
wire            fdsu_ex2_sqrt;                       
wire    [25:0]  fdsu_ex4_frac;                       
wire            fdsu_yy_div;                         
wire            fdsu_yy_of_rm_lfn;                   
wire            fdsu_yy_op0_norm;                    
wire            fdsu_yy_op1_norm;                    
wire            fdsu_yy_sqrt;                        
wire            forever_cpuclk;                      
wire            pad_yy_icg_scan_en;                  
wire            qt_clk;                              
wire            qt_clk_en;                           
wire    [29:0]  qt_rt_const_pre_sel_q1;              
wire    [29:0]  qt_rt_const_pre_sel_q2;              
wire    [29:0]  qt_rt_const_q1;                      
wire    [29:0]  qt_rt_const_q2;                      
wire    [29:0]  qt_rt_const_q3;                      
wire    [29:0]  qt_rt_const_shift_std_next;          
wire    [29:0]  qt_rt_mins_const_pre_sel_q1;         
wire    [29:0]  qt_rt_mins_const_pre_sel_q2;         
wire            rem_sign;                            
wire    [31:0]  sqrt_qt_1_rem_add_op1;               
wire    [31:0]  sqrt_qt_2_rem_add_op1;               
wire    [31:0]  sqrt_qt_r1_rem_add_op1;              
wire    [31:0]  sqrt_qt_r2_rem_add_op1;              
wire            srt_div_clk;                         
wire            srt_div_clk_en;                      
wire    [31:0]  srt_remainder_nxt;                   
wire    [31:0]  srt_remainder_shift;                 
wire            srt_remainder_sign;                  
wire            srt_remainder_zero;                  
wire            srt_sm_on;                           
wire    [29:0]  total_qt_rt_pre_sel;                 


assign fdsu_ex2_div             = fdsu_yy_div;
assign fdsu_ex2_sqrt            = fdsu_yy_sqrt;
assign fdsu_ex2_op0_norm        = fdsu_yy_op0_norm;
assign fdsu_ex2_op1_norm        = fdsu_yy_op1_norm;
assign fdsu_ex2_of_rm_lfn       = fdsu_yy_of_rm_lfn;
assign fdsu_ex2_result_lfn      = 1'b0;

//==========================================================
//                    EX2 Expnt Generate
//==========================================================
//expnt0 sub expnt1
assign ex2_expnt_result[9:0] =  ex2_expnt_adder_op0[9:0] -
                                 ex2_expnt_adder_op1[9:0];

//===================sqrt exponent prepare==================
//sqrt exponent prepare
//afert E sub, div E by 2
assign ex2_sqrt_expnt_result[9:0] = {ex2_expnt_result[9],
                                      ex2_expnt_result[9:1]};

assign ex2_srt_expnt_rst[9:0] = (fdsu_ex2_sqrt)
                               ? ex2_sqrt_expnt_result[9:0]
                               : ex2_expnt_result[9:0];
// &Force("output", "ex2_srt_expnt_rst"); &Force("bus", "ex2_srt_expnt_rst", 9, 0); @51
assign fdsu_ex2_expnt_rst[9:0] = ex2_srt_expnt_rst[9:0];


//====================EX2 Expt info=========================
//EX1 only detect of/uf under id condition
//EX2 will deal with other condition

//When input is normal, overflow when E1-E2 > 128/1024
assign ex2_expnt_of = ~fdsu_ex2_expnt_rst[9] && (fdsu_ex2_expnt_rst[8]
                                                      || (fdsu_ex2_expnt_rst[7]  &&
                                                          |fdsu_ex2_expnt_rst[6:0]));
//potential overflow when E1-E2 = 128/1024
assign ex2_potnt_of_pre = ~fdsu_ex2_expnt_rst[9]  &&
                           ~fdsu_ex2_expnt_rst[8]  &&
                            fdsu_ex2_expnt_rst[7]  &&
                          ~|fdsu_ex2_expnt_rst[6:0];
assign ex2_potnt_of      = ex2_potnt_of_pre &&
                           fdsu_ex2_op0_norm &&
                           fdsu_ex2_op1_norm &&
                           fdsu_ex2_div;

//When input is normal, underflow when E1-E2 <= -127/-1023
assign ex2_expnt_uf = fdsu_ex2_expnt_rst[9] &&(fdsu_ex2_expnt_rst[8:0] <= 9'h181);
//potential underflow when E1-E2 = -126/-1022
assign ex2_potnt_uf_pre = &fdsu_ex2_expnt_rst[9:7]   &&
                          ~|fdsu_ex2_expnt_rst[6:2]   &&
                            fdsu_ex2_expnt_rst[1]     &&
                           !fdsu_ex2_expnt_rst[0];
assign ex2_potnt_uf      = (ex2_potnt_uf_pre &&
                            fdsu_ex2_op0_norm &&
                            fdsu_ex2_op1_norm &&
                            fdsu_ex2_div)     ||
                           (ex2_potnt_uf_pre   &&
                            fdsu_ex2_op0_norm);

//========================EX2 Overflow======================
//ex2 overflow when
//  1.op0 & op1 both norm && expnt overflow
//  2.ex1_id_of
// &Force("output","ex2_of"); @91
assign ex2_of      = ex2_of_plus;
assign ex2_of_plus = ex2_div_of  && fdsu_ex2_div;
assign ex2_div_of  = fdsu_ex2_op0_norm &&
                     fdsu_ex2_op1_norm &&
                     ex2_expnt_of;

//=======================EX2 Underflow======================
//ex2 underflow when
//  1.op0 & op1 both norm && expnt underflow
//  2.ex1_id_uf
//  and detect when to skip the srt, here, we have further optmization
assign ex2_uf      = ex2_uf_plus;
assign ex2_uf_plus = ex2_div_uf  && fdsu_ex2_div;
assign ex2_div_uf  = fdsu_ex2_op0_norm &&
                     fdsu_ex2_op1_norm &&
                     ex2_expnt_uf;
assign ex2_id_nor_srt_skip =  fdsu_ex2_expnt_rst[9]
                                     && (fdsu_ex2_expnt_rst[8:0]<9'h16a);
assign ex2_uf_srt_skip            = ex2_id_nor_srt_skip;
assign ex2_rslt_denorm            = ex2_uf;
//===============ex2 round prepare for denormal round======
// &CombBeg; @113
always @( fdsu_ex2_expnt_rst[9:0])
begin
case(fdsu_ex2_expnt_rst[9:0])
  10'h382:ex2_result_denorm_round_add_num[23:0] = 24'h1; //-126 1
  10'h381:ex2_result_denorm_round_add_num[23:0] = 24'h2; //-127 0
  10'h380:ex2_result_denorm_round_add_num[23:0] = 24'h4; //-128 -1
  10'h37f:ex2_result_denorm_round_add_num[23:0] = 24'h8; //-129 -2
  10'h37e:ex2_result_denorm_round_add_num[23:0] = 24'h10; //-130 -3
  10'h37d:ex2_result_denorm_round_add_num[23:0] = 24'h20; //-131 -4
  10'h37c:ex2_result_denorm_round_add_num[23:0] = 24'h40; //-132 -5
  10'h37b:ex2_result_denorm_round_add_num[23:0] = 24'h80; //-133 -6
  10'h37a:ex2_result_denorm_round_add_num[23:0] = 24'h100; //-134 -7
  10'h379:ex2_result_denorm_round_add_num[23:0] = 24'h200; //-135 -8
  10'h378:ex2_result_denorm_round_add_num[23:0] = 24'h400; //-136 -9
  10'h377:ex2_result_denorm_round_add_num[23:0] = 24'h800; //-137 -10
  10'h376:ex2_result_denorm_round_add_num[23:0] = 24'h1000; //-138 -11
  10'h375:ex2_result_denorm_round_add_num[23:0] = 24'h2000; //-139 -12
  10'h374:ex2_result_denorm_round_add_num[23:0] = 24'h4000; //-140 -13
  10'h373:ex2_result_denorm_round_add_num[23:0] = 24'h8000; // -141 -14
  10'h372:ex2_result_denorm_round_add_num[23:0] = 24'h10000;//-142  -15
  10'h371:ex2_result_denorm_round_add_num[23:0] = 24'h20000;//-143 -16
  10'h370:ex2_result_denorm_round_add_num[23:0] = 24'h40000; //-144 -17
  10'h36f:ex2_result_denorm_round_add_num[23:0] = 24'h80000; //-145 -18
  10'h36e:ex2_result_denorm_round_add_num[23:0] = 24'h100000; //-146 -19
  10'h36d:ex2_result_denorm_round_add_num[23:0] = 24'h200000; //-147 -20
  10'h36c:ex2_result_denorm_round_add_num[23:0] = 24'h400000; //-148 -21
  10'h36b:ex2_result_denorm_round_add_num[23:0] = 24'h800000; //-148 -22
  default: ex2_result_denorm_round_add_num[23:0] = 24'h0;  // -23
endcase
// &CombEnd; @141
end

//===================special result========================
assign ex2_result_inf  = ex2_of_plus && !fdsu_ex2_of_rm_lfn;
assign ex2_result_lfn  = fdsu_ex2_result_lfn ||
                         ex2_of_plus &&  fdsu_ex2_of_rm_lfn;



//====================Pipe to EX3===========================
always @(posedge ex1_ex2_pipe_clk)
begin
  if(ex1_pipedown)
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= {14'b0, ex1_expnt_adder_op1[9:0]};
  end
  else if(ex2_pipedown)
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= ex2_result_denorm_round_add_num[23:0];
  end
  else
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= fdsu_ex3_result_denorm_round_add_num[23:0];
  end
end
assign ex2_expnt_adder_op1 = fdsu_ex3_result_denorm_round_add_num[9:0];
// &Force("bus", "ex1_expnt_adder_op1", 12, 0); @193

assign ex1_ex2_pipe_clk_en = ex1_pipedown_gate || ex2_pipedown;
// &Instance("miv_rv32_gated_clk_cell", "x_ex1_ex2_pipe_clk"); @196
miv_rv32_gated_clk_cell  x_ex1_ex2_pipe_clk (
  .clk_in              (forever_cpuclk     ),
  .clk_out             (ex1_ex2_pipe_clk   ),
  .external_en         (1'b0               ),
  .global_en           (cp0_yy_clk_en      ),
  .local_en            (ex1_ex2_pipe_clk_en),
  .module_en           (cp0_fpu_icg_en     ),
  .pad_yy_icg_scan_en  (pad_yy_icg_scan_en )
);

// &Connect(.clk_in      (forever_cpuclk), @197
//          .external_en (1'b0), @198
//          .global_en   (cp0_yy_clk_en), @199
//          .module_en   (cp0_fpu_icg_en), @200
//          .local_en    (ex1_ex2_pipe_clk_en), @201
//          .clk_out     (ex1_ex2_pipe_clk)); @202

always @(posedge ex2_pipe_clk)
begin
  if(ex2_pipedown)
  begin
    fdsu_ex3_rem_sign        <= srt_remainder_sign;
    fdsu_ex3_rem_zero        <= srt_remainder_zero;
    fdsu_ex3_id_srt_skip     <= ex2_id_nor_srt_skip;
  end
  else
  begin
    fdsu_ex3_rem_sign        <= fdsu_ex3_rem_sign;
    fdsu_ex3_rem_zero        <= fdsu_ex3_rem_zero;
    fdsu_ex3_id_srt_skip    <=  fdsu_ex3_id_srt_skip;
  end
end

// &Force("output","fdsu_ex3_rem_sign"); @243
// &Force("output","fdsu_ex3_rem_zero"); @244
// &Force("output","fdsu_ex3_result_denorm_round_add_num"); @245
// &Force("output","fdsu_ex3_id_srt_skip"); @246

//==========================================================
//    SRT Remainder & Divisor for Quotient/Root Generate
//==========================================================

//===================Remainder Generate=====================
//gate clk
// &Instance("miv_rv32_gated_clk_cell","x_srt_rem_clk");
// // &Connect( .clk_in         (forever_cpuclk), @255
// //           .clk_out        (srt_rem_clk),//Out Clock @256
// //           .external_en    (1'b0), @257
// //           .global_en      (cp0_yy_clk_en), @258
// //           .local_en       (srt_rem_clk_en),//Local Condition @259
// //           .module_en      (cp0_fpu_icg_en) @260
// //         ); @261
// assign srt_rem_clk_en = ex1_pipedown ||
//                         srt_sm_on;

always @(posedge qt_clk)
begin
  if (ex1_pipedown)
    srt_remainder[31:0] <= ex1_remainder[31:0];
  else if (srt_sm_on)
    srt_remainder[31:0] <= srt_remainder_nxt[31:0];
  else
    srt_remainder[31:0] <= srt_remainder[31:0];
end

//=====================Divisor Generate=====================
//gate clk
// &Instance("miv_rv32_gated_clk_cell","x_srt_div_clk"); @291
miv_rv32_gated_clk_cell  x_srt_div_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (srt_div_clk       ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (srt_div_clk_en    ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @292
//           .clk_out        (srt_div_clk),//Out Clock @293
//           .external_en    (1'b0), @294
//           .global_en      (cp0_yy_clk_en), @295
//           .local_en       (srt_div_clk_en),//Local Condition @296
//           .module_en      (cp0_fpu_icg_en) @297
//         ); @298
assign srt_div_clk_en = ex1_pipedown_gate
                     || ex1_save_op0_gate
                     || ex3_pipedown;
// final_rst saved in srt_divisor.
// srt_divisor is 26 bits, final_rst is 24 bits.
always @(posedge srt_div_clk)
begin
  if (ex1_save_op0)
    srt_divisor[25:0] <= {3'b0, {ex1_oper_id_frac[51:29]}};
  else if (ex1_pipedown)
    srt_divisor[25:0] <= {2'b0, ex1_divisor[23:0]};
  else if (ex3_pipedown)
    srt_divisor[25:0] <= ex3_frac_final_rst[25:0];
  else
    srt_divisor[25:0] <= srt_divisor[25:0];
end
assign ex1_oper_id_frac_f[51:0] = {srt_divisor[22:0], 29'b0};
// &Force("bus", "ex1_oper_id_frac", 51, 0); @332
assign fdsu_ex4_frac[25:0] = srt_divisor[25:0];

//=======================Bound Select=======================
//---------------------------------------+
// K   | 8 | 9 | 10| 11| 12| 13| 14|15,16|
//---------------------------------------+
//32S1 | 7 | 7 | 8 | 9 | 9 | 10| 11|  12 |
//---------------------------------------+
//32S2 | 25| 28| 31| 33| 36| 39| 41|  47 |
//---------------------------------------+

//bound_sel[3:0]
//For div,  use divisor high four bit as K
//For sqrt, use 2qi high four bit as K next round and
//          use 1010 as K first round
assign bound_sel[3:0] = (fdsu_ex2_div)
                      ? srt_divisor[23:20]
                      : (ex2_srt_first_round)
                        ? 4'b1010
                        : total_qt_rt_30[28:25];
//Select bound as look up table
//   K = bound_sel[3:0]
//32S1 = digit_bound_1[7:0]
//32s2 = digit_bound_2[7:0]
// &CombBeg; @357
always @( bound_sel[3:0])
begin
case(bound_sel[3:0])
4'b0000:       //when first interation get "10", choose k=16
   begin
     digit_bound_1[7:0] = 8'b11110100;//-12
     digit_bound_2[7:0] = 8'b11010001;//-47
   end
4'b1000:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100111;//-25
   end
4'b1001:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100100;//-28
   end
4'b1010:
   begin
     digit_bound_1[7:0] = 8'b11111000;//-8
     digit_bound_2[7:0] = 8'b11100001;//-31
   end
4'b1011:
   begin
     digit_bound_1[7:0] = 8'b11110111;//-9
     digit_bound_2[7:0] = 8'b11011111;//-33
   end
4'b1100:
   begin
     digit_bound_1[7:0] = 8'b11110111;//-9
     digit_bound_2[7:0] = 8'b11011100;//-36
   end
4'b1101:
   begin
     digit_bound_1[7:0] = 8'b11110110;//-10
     digit_bound_2[7:0] = 8'b11011001;//-39
   end
4'b1110:
   begin
     digit_bound_1[7:0] = 8'b11110101;//-11
     digit_bound_2[7:0] = 8'b11010111;//-41
   end
4'b1111:
   begin
     digit_bound_1[7:0] = 8'b11110100;//-12
     digit_bound_2[7:0] = 8'b11010001;//-47
   end
default:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100111;//-25
   end
endcase
// &CombEnd; @410
end

//==============Prepare for quotient generate===============
assign bound1_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_1[7:0];
assign bound2_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_2[7:0];
assign bound1_cmp_sign        = bound1_cmp_result[7];
assign bound2_cmp_sign        = bound2_cmp_result[7];
assign rem_sign               = srt_remainder[29];

//qtrt_sel_rem is use to select quotient
//Only when sqrt first round use 8R0 select quotient(special rule)
//4R0 is used to select quotient on other condition
//For negative remaider, we use ~rem not (~rem + 1)
//Because  bound1 <=  rem   <   bound2, when positive rem
//        -bound2 <=  rem   <  -bound1, when negative rem
//Thus     bound1 <  -rem   <=  bound2, when negative rem
//Thus     bound1 <= -rem-1 <   bound2, when negative rem
//Thus     bound1 <= ~rem   <   bound2, when negative rem
//srt_remainder[29] used as sign bit
// &CombBeg; @429
always @( ex2_srt_first_round
       or fdsu_ex2_sqrt
       or srt_remainder[29:21])
begin
if(ex2_srt_first_round && fdsu_ex2_sqrt)
  qtrt_sel_rem[7:0] = {srt_remainder[29],   srt_remainder[27:21]};
else
  qtrt_sel_rem[7:0] =  srt_remainder[29] ? ~srt_remainder[29:22]
                                         :  srt_remainder[29:22];
// &CombEnd; @435
end

//==========================================================
//     on fly round method to generate total quotient
//==========================================================
//gate clk
// &Instance("miv_rv32_gated_clk_cell","x_qt_clk"); @441
miv_rv32_gated_clk_cell  x_qt_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (qt_clk            ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (qt_clk_en         ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @442
//           .clk_out        (qt_clk),//Out Clock @443
//           .external_en    (1'b0), @444
//           .global_en      (cp0_yy_clk_en), @445
//           .local_en       (qt_clk_en),//Local Condition @446
//           .module_en      (cp0_fpu_icg_en) @447
//         ); @448
assign qt_clk_en = srt_sm_on ||
                   ex1_pipedown_gate;

//qt_rt_const_shift_std[29:0] is const data for on fly round
//                which is used to record the times of round
//
//total_qt_rt[29:0]       is total quotient
//total_qt_rt_minus[29:0] is total quotient minus
//                which is used to generate quotient rapidly
always @(posedge qt_clk)
begin
  if(ex1_pipedown)
  begin
    qt_rt_const_shift_std[29:0] <= {1'b0,1'b1,28'b0};
    total_qt_rt_30[29:0]        <= 30'b0;
    total_qt_rt_minus_30[29:0]  <= 30'b0;
  end
  else if(srt_sm_on)
  begin
    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std_next[29:0];
    total_qt_rt_30[29:0]        <= total_qt_rt_30_next[29:0];
    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30_next[29:0];
  end
  else
  begin
    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std[29:0];
    total_qt_rt_30[29:0]        <= total_qt_rt_30[29:0];
    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30[29:0];
  end
end
// &Force("output","total_qt_rt_30"); @508

//qt_rt_const_q1/q2/q3 for shift 1/2/3 in
assign qt_rt_const_q1[29:0] =  qt_rt_const_shift_std[29:0];
assign qt_rt_const_q2[29:0] = {qt_rt_const_shift_std[28:0],1'b0};
assign qt_rt_const_q3[29:0] =  qt_rt_const_q1[29:0] |
                               qt_rt_const_q2[29:0];
//qt_rt_const update value
assign qt_rt_const_shift_std_next[29:0] = {2'b0, qt_rt_const_shift_std[29:2]};

//========total_qt_rt & total_qt_rt_minus update value======
//q(i+1) is the total quotient/root after the (i+1) digit
//is calculated
//                 q(i+1)             qm(i+1)
//d(i+1)=-2     qm(i)+2*shift      qm(i)+1*shift
//d(i+1)=-1     qm(i)+3*shift      qm(i)+2*shift
//d(i+1)=0      q(i)               qm(i)+3*shift
//d(i+1)=1      q(i)+1*shift       q(i)
//d(i+1)=2      q(i)+2*shift       q(i)+1*shift
//Note:
//shift = 4^(-i-1), qm(i+1)=q(i+1)-shift

//pre select for quotient
assign total_qt_rt_pre_sel[29:0]         = (rem_sign) ?
                                           total_qt_rt_minus_30[29:0] :
                                           total_qt_rt_30[29:0];
//when the quotient is 2 or -2
assign qt_rt_const_pre_sel_q2[29:0]      = qt_rt_const_q2[29:0];
assign qt_rt_mins_const_pre_sel_q2[29:0] = qt_rt_const_q1[29:0];
//when the quotient is 1 or -1
assign qt_rt_const_pre_sel_q1[29:0]      = (rem_sign) ?
                                           qt_rt_const_q3[29:0] ://-1
                                           qt_rt_const_q1[29:0]; //1
assign qt_rt_mins_const_pre_sel_q1[29:0] = (rem_sign) ?
                                           qt_rt_const_q2[29:0] : //-1
                                           30'b0;

//After bound compare, the final selection
// &CombBeg; @546
always @( qt_rt_const_q3[29:0]
       or qt_rt_mins_const_pre_sel_q1[29:0]
       or bound1_cmp_sign
       or total_qt_rt_30[29:0]
       or qt_rt_mins_const_pre_sel_q2[29:0]
       or total_qt_rt_minus_30[29:0]
       or bound2_cmp_sign
       or qt_rt_const_pre_sel_q2[29:0]
       or qt_rt_const_pre_sel_q1[29:0]
       or total_qt_rt_pre_sel[29:0])
begin
casez({bound1_cmp_sign,bound2_cmp_sign})
  2'b00:// the quotient is -2 or 2
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_const_pre_sel_q2[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_mins_const_pre_sel_q2[29:0];
  end
  2'b01:// quotient is -1 or 1
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_const_pre_sel_q1[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_mins_const_pre_sel_q1[29:0];
  end
  2'b1?: // quotient is 0
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_30[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_minus_30[29:0] |
                                      qt_rt_const_q3[29:0];
  end
  default:
  begin
    total_qt_rt_30_next[29:0]       = 30'b0;
    total_qt_rt_minus_30_next[29:0] = 30'b0;
  end
endcase
// &CombEnd; @574
end

//==========================================================
//      on fly round method to generate cur remainder
//==========================================================
//Division emainder add value
//Quoit 1
assign div_qt_1_rem_add_op1[31:0]   = ~{3'b0,srt_divisor[23:0],5'b0};
//Quoit 2
assign div_qt_2_rem_add_op1[31:0]   = ~{2'b0,srt_divisor[23:0],6'b0};
//Quoit -1
assign div_qt_r1_rem_add_op1[31:0]  =  {3'b0,srt_divisor[23:0],5'b0};
//Quoit -2
assign div_qt_r2_rem_add_op1[31:0]  =  {2'b0,srt_divisor[23:0],6'b0};

//Sqrt remainder add value op1
//Quoit 1
assign sqrt_qt_1_rem_add_op1[31:0]  = ~({2'b0,total_qt_rt_30[29:0]} |
                                        {3'b0,qt_rt_const_q1[29:1]});
//Quoit 2
assign sqrt_qt_2_rem_add_op1[31:0]  = ~({1'b0,total_qt_rt_30[29:0],1'b0} |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0});
//Quoit -1
assign sqrt_qt_r1_rem_add_op1[31:0] =   {2'b0,total_qt_rt_minus_30[29:0]} |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0}  |
                                        {2'b0,qt_rt_const_q1[29:0]}       |
                                        {3'b0,qt_rt_const_q1[29:1]};
//Quoit -2
assign sqrt_qt_r2_rem_add_op1[31:0] =   {1'b0,
                                         total_qt_rt_minus_30[29:0],1'b0} |
                                        {qt_rt_const_q1[29:0],2'b0}       |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0};
//Remainder Adder select logic
// &CombBeg; @607
always @( div_qt_2_rem_add_op1[31:0]
       or sqrt_qt_r2_rem_add_op1[31:0]
       or sqrt_qt_r1_rem_add_op1[31:0]
       or rem_sign
       or div_qt_r2_rem_add_op1[31:0]
       or div_qt_1_rem_add_op1[31:0]
       or sqrt_qt_2_rem_add_op1[31:0]
       or fdsu_ex2_sqrt
       or div_qt_r1_rem_add_op1[31:0]
       or sqrt_qt_1_rem_add_op1[31:0])
begin
case({rem_sign,fdsu_ex2_sqrt})
  2'b01:
  begin
        rem_add1_op1[31:0] = sqrt_qt_1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = sqrt_qt_2_rem_add_op1[31:0];
  end
  2'b00:
  begin
        rem_add1_op1[31:0] = div_qt_1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = div_qt_2_rem_add_op1[31:0];
  end
  2'b11:
  begin
        rem_add1_op1[31:0] = sqrt_qt_r1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = sqrt_qt_r2_rem_add_op1[31:0];
  end
  2'b10:
  begin
        rem_add1_op1[31:0] = div_qt_r1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = div_qt_r2_rem_add_op1[31:0];
  end
  default :
  begin
        rem_add1_op1[31:0] = 32'b0;
        rem_add2_op1[31:0] = 32'b0;
  end
  endcase
// &CombEnd; @635
end
assign srt_remainder_shift[31:0] = {srt_remainder[31],
                                    srt_remainder[28:0],2'b0};
//Remainder add
assign cur_doub_rem_1[31:0]      = srt_remainder_shift[31:0] +
                                   rem_add1_op1[31:0]    +
                                   {31'b0, ~rem_sign};
assign cur_doub_rem_2[31:0]      = srt_remainder_shift[31:0] +
                                   rem_add2_op1[31:0]    +
                                   {31'b0, ~rem_sign};
assign cur_rem_1[31:0]           = cur_doub_rem_1[31:0];
assign cur_rem_2[31:0]           = cur_doub_rem_2[31:0];
//Generate srt remainder update value
// &CombBeg; @648
always @( cur_rem_2[31:0]
       or bound1_cmp_sign
       or srt_remainder_shift[31:0]
       or bound2_cmp_sign
       or cur_rem_1[31:0])
begin
case({bound1_cmp_sign,bound2_cmp_sign})
  2'b00:   cur_rem[31:0]         = cur_rem_2[31:0];  //+-2
  2'b01:   cur_rem[31:0]         = cur_rem_1[31:0];  //+-1
  default: cur_rem[31:0]         = srt_remainder_shift[31:0]; //0
endcase
// &CombEnd; @654
end
assign srt_remainder_nxt[31:0]   = cur_rem[31:0];

//Remainder is zero signal in EX3
assign srt_remainder_zero        = ~|srt_remainder[31:0];
// &Force("output","srt_remainder_zero"); @659
assign srt_remainder_sign        =   srt_remainder[31];

// &Force("output", "ex2_uf"); @662
// &ModuleEnd; @663
endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module miv_rv32_pa_fdsu_top(
  cp0_fpu_icg_en,
  cp0_fpu_xx_dqnan,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_fdsu_ex1_sel,
  ctrl_xx_ex1_cmplt_dp,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  ctrl_xx_ex2_warm_up,
  ctrl_xx_ex3_warm_up,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_qnan,
  dp_xx_ex1_rm,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  fdsu_fpu_debug_info,
  fdsu_fpu_ex1_cmplt,
  fdsu_fpu_ex1_cmplt_dp,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign,
  fdsu_fpu_ex1_stall,
  fdsu_fpu_no_op,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_freg,
  fdsu_frbus_wb_vld,
  forever_cpuclk,
  frbus_fdsu_wb_grant,
  idu_fpu_ex1_dst_freg,
  idu_fpu_ex1_eu_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1,
  pad_yy_icg_scan_en,
  rtu_xx_ex1_cancel,
  rtu_xx_ex2_cancel,
  rtu_yy_xx_async_flush,
  rtu_yy_xx_flush
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_fpu_xx_dqnan;                    
input           cp0_yy_clk_en;                       
input           cpurst_b;                            
input           ctrl_fdsu_ex1_sel;                   
input           ctrl_xx_ex1_cmplt_dp;                
input           ctrl_xx_ex1_inst_vld;                
input           ctrl_xx_ex1_stall;                   
input           ctrl_xx_ex1_warm_up;                 
input           ctrl_xx_ex2_warm_up;                 
input           ctrl_xx_ex3_warm_up;                 
input   [2 :0]  dp_xx_ex1_cnan;                      
input   [2 :0]  dp_xx_ex1_id;                        
input   [2 :0]  dp_xx_ex1_inf;                       
input   [2 :0]  dp_xx_ex1_qnan;                      
input   [2 :0]  dp_xx_ex1_rm;                        
input   [2 :0]  dp_xx_ex1_snan;                      
input   [2 :0]  dp_xx_ex1_zero;                      
input           forever_cpuclk;                      
input           frbus_fdsu_wb_grant;                 
input   [4 :0]  idu_fpu_ex1_dst_freg;                
input   [2 :0]  idu_fpu_ex1_eu_sel;                  
input   [9 :0]  idu_fpu_ex1_func;                    
input   [31:0]  idu_fpu_ex1_srcf0;                   
input   [31:0]  idu_fpu_ex1_srcf1;                   
input           pad_yy_icg_scan_en;                  
input           rtu_xx_ex1_cancel;                   
input           rtu_xx_ex2_cancel;                   
input           rtu_yy_xx_async_flush;               
input           rtu_yy_xx_flush;                     
output  [4 :0]  fdsu_fpu_debug_info;                 
output          fdsu_fpu_ex1_cmplt;                  
output          fdsu_fpu_ex1_cmplt_dp;               
output  [4 :0]  fdsu_fpu_ex1_fflags;                 
output  [7 :0]  fdsu_fpu_ex1_special_sel;            
output  [3 :0]  fdsu_fpu_ex1_special_sign;           
output          fdsu_fpu_ex1_stall;                  
output          fdsu_fpu_no_op;                      
output  [31:0]  fdsu_frbus_data;                     
output  [4 :0]  fdsu_frbus_fflags;                   
output  [4 :0]  fdsu_frbus_freg;                     
output          fdsu_frbus_wb_vld;                   

// &Regs; @25

// &Wires; @26
wire            cp0_fpu_icg_en;                      
wire            cp0_fpu_xx_dqnan;                    
wire            cp0_yy_clk_en;                       
wire            cpurst_b;                            
wire            ctrl_fdsu_ex1_sel;                   
wire            ctrl_xx_ex1_cmplt_dp;                
wire            ctrl_xx_ex1_inst_vld;                
wire            ctrl_xx_ex1_stall;                   
wire            ctrl_xx_ex1_warm_up;                 
wire            ctrl_xx_ex2_warm_up;                 
wire            ctrl_xx_ex3_warm_up;                 
wire    [2 :0]  dp_xx_ex1_cnan;                      
wire    [2 :0]  dp_xx_ex1_id;                        
wire    [2 :0]  dp_xx_ex1_inf;                       
wire    [2 :0]  dp_xx_ex1_qnan;                      
wire    [2 :0]  dp_xx_ex1_rm;                        
wire    [2 :0]  dp_xx_ex1_snan;                      
wire    [2 :0]  dp_xx_ex1_zero;                      
wire            ex1_div;                             
wire    [23:0]  ex1_divisor;                         
wire    [12:0]  ex1_expnt_adder_op0;                 
wire    [12:0]  ex1_expnt_adder_op1;                 
wire            ex1_of_result_lfn;                   
wire            ex1_op0_id;                          
wire            ex1_op0_norm;                        
wire            ex1_op0_sign;                        
wire            ex1_op1_id;                          
wire            ex1_op1_id_vld;                      
wire            ex1_op1_norm;                        
wire            ex1_op1_sel;                         
wire    [12:0]  ex1_oper_id_expnt;                   
wire    [12:0]  ex1_oper_id_expnt_f;                 
wire    [51:0]  ex1_oper_id_frac;                    
wire    [51:0]  ex1_oper_id_frac_f;                  
wire            ex1_pipedown;                        
wire            ex1_pipedown_gate;                   
wire    [31:0]  ex1_remainder;                       
wire            ex1_result_sign;                     
wire    [2 :0]  ex1_rm;                              
wire            ex1_save_op0;                        
wire            ex1_save_op0_gate;                   
wire            ex1_sqrt;                            
wire            ex1_srt_skip;                        
wire    [9 :0]  ex2_expnt_adder_op0;                 
wire            ex2_of;                              
wire            ex2_pipe_clk;                        
wire            ex2_pipedown;                        
wire            ex2_potnt_of;                        
wire            ex2_potnt_uf;                        
wire            ex2_result_inf;                      
wire            ex2_result_lfn;                      
wire            ex2_rslt_denorm;                     
wire    [9 :0]  ex2_srt_expnt_rst;                   
wire            ex2_srt_first_round;                 
wire            ex2_uf;                              
wire            ex2_uf_srt_skip;                     
wire    [9 :0]  ex3_expnt_adjust_result;             
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_pipedown;                        
wire            ex3_rslt_denorm;                     
wire            fdsu_ex1_sel;                        
wire            fdsu_ex3_id_srt_skip;                
wire            fdsu_ex3_rem_sign;                   
wire            fdsu_ex3_rem_zero;                   
wire    [23:0]  fdsu_ex3_result_denorm_round_add_num; 
wire            fdsu_ex4_denorm_to_tiny_frac;        
wire    [25:0]  fdsu_ex4_frac;                       
wire            fdsu_ex4_nx;                         
wire    [1 :0]  fdsu_ex4_potnt_norm;                 
wire            fdsu_ex4_result_nor;                 
wire    [4 :0]  fdsu_fpu_debug_info;                 
wire            fdsu_fpu_ex1_cmplt;                  
wire            fdsu_fpu_ex1_cmplt_dp;               
wire    [4 :0]  fdsu_fpu_ex1_fflags;                 
wire    [7 :0]  fdsu_fpu_ex1_special_sel;            
wire    [3 :0]  fdsu_fpu_ex1_special_sign;           
wire            fdsu_fpu_ex1_stall;                  
wire            fdsu_fpu_no_op;                      
wire    [31:0]  fdsu_frbus_data;                     
wire    [4 :0]  fdsu_frbus_fflags;                   
wire    [4 :0]  fdsu_frbus_freg;                     
wire            fdsu_frbus_wb_vld;                   
wire            fdsu_yy_div;                         
wire    [9 :0]  fdsu_yy_expnt_rst;                   
wire            fdsu_yy_of;                          
wire            fdsu_yy_of_rm_lfn;                   
wire            fdsu_yy_op0_norm;                    
wire            fdsu_yy_op1_norm;                    
wire            fdsu_yy_potnt_of;                    
wire            fdsu_yy_potnt_uf;                    
wire            fdsu_yy_result_inf;                  
wire            fdsu_yy_result_lfn;                  
wire            fdsu_yy_result_sign;                 
wire    [2 :0]  fdsu_yy_rm;                          
wire            fdsu_yy_rslt_denorm;                 
wire            fdsu_yy_sqrt;                        
wire            fdsu_yy_uf;                          
wire    [4 :0]  fdsu_yy_wb_freg;                     
wire            forever_cpuclk;                      
wire            frbus_fdsu_wb_grant;                 
wire    [4 :0]  idu_fpu_ex1_dst_freg;                
wire    [2 :0]  idu_fpu_ex1_eu_sel;                  
wire    [9 :0]  idu_fpu_ex1_func;                    
wire    [31:0]  idu_fpu_ex1_srcf0;                   
wire    [31:0]  idu_fpu_ex1_srcf1;                   
wire            pad_yy_icg_scan_en;                  
wire            rtu_xx_ex1_cancel;                   
wire            rtu_xx_ex2_cancel;                   
wire            rtu_yy_xx_async_flush;               
wire            rtu_yy_xx_flush;                     
wire            srt_remainder_zero;                  
wire            srt_sm_on;                           
wire    [29:0]  total_qt_rt_30;                      



// &Instance("miv_rv32_pa_fdsu_special"); @29
miv_rv32_pa_fdsu_special  x_pa_fdsu_special (
  .cp0_fpu_xx_dqnan          (cp0_fpu_xx_dqnan         ),
  .dp_xx_ex1_cnan            (dp_xx_ex1_cnan           ),
  .dp_xx_ex1_id              (dp_xx_ex1_id             ),
  .dp_xx_ex1_inf             (dp_xx_ex1_inf            ),
  .dp_xx_ex1_qnan            (dp_xx_ex1_qnan           ),
  .dp_xx_ex1_snan            (dp_xx_ex1_snan           ),
  .dp_xx_ex1_zero            (dp_xx_ex1_zero           ),
  .ex1_div                   (ex1_div                  ),
  .ex1_op0_id                (ex1_op0_id               ),
  .ex1_op0_norm              (ex1_op0_norm             ),
  .ex1_op0_sign              (ex1_op0_sign             ),
  .ex1_op1_id                (ex1_op1_id               ),
  .ex1_op1_norm              (ex1_op1_norm             ),
  .ex1_result_sign           (ex1_result_sign          ),
  .ex1_sqrt                  (ex1_sqrt                 ),
  .ex1_srt_skip              (ex1_srt_skip             ),
  .fdsu_fpu_ex1_fflags       (fdsu_fpu_ex1_fflags      ),
  .fdsu_fpu_ex1_special_sel  (fdsu_fpu_ex1_special_sel ),
  .fdsu_fpu_ex1_special_sign (fdsu_fpu_ex1_special_sign)
);

// &Instance("miv_rv32_pa_fdsu_prepare"); @30
miv_rv32_pa_fdsu_prepare  x_pa_fdsu_prepare (
  .dp_xx_ex1_rm        (dp_xx_ex1_rm       ),
  .ex1_div             (ex1_div            ),
  .ex1_divisor         (ex1_divisor        ),
  .ex1_expnt_adder_op0 (ex1_expnt_adder_op0),
  .ex1_expnt_adder_op1 (ex1_expnt_adder_op1),
  .ex1_of_result_lfn   (ex1_of_result_lfn  ),
  .ex1_op0_id          (ex1_op0_id         ),
  .ex1_op0_sign        (ex1_op0_sign       ),
  .ex1_op1_id          (ex1_op1_id         ),
  .ex1_op1_id_vld      (ex1_op1_id_vld     ),
  .ex1_op1_sel         (ex1_op1_sel        ),
  .ex1_oper_id_expnt   (ex1_oper_id_expnt  ),
  .ex1_oper_id_expnt_f (ex1_oper_id_expnt_f),
  .ex1_oper_id_frac    (ex1_oper_id_frac   ),
  .ex1_oper_id_frac_f  (ex1_oper_id_frac_f ),
  .ex1_remainder       (ex1_remainder      ),
  .ex1_result_sign     (ex1_result_sign    ),
  .ex1_rm              (ex1_rm             ),
  .ex1_sqrt            (ex1_sqrt           ),
  .fdsu_ex1_sel        (fdsu_ex1_sel       ),
  .idu_fpu_ex1_func    (idu_fpu_ex1_func   ),
  .idu_fpu_ex1_srcf0   (idu_fpu_ex1_srcf0  ),
  .idu_fpu_ex1_srcf1   (idu_fpu_ex1_srcf1  )
);

// &Instance("pa_fdsu_srt"); @32
// &Instance("pa_fdsu_round"); @33
// &Instance("pa_fdsu_pack"); @34
// &Instance("miv_rv32_pa_fdsu_srt_single", "x_pa_fdsu_srt"); @36
miv_rv32_pa_fdsu_srt_single  x_pa_fdsu_srt (
  .cp0_fpu_icg_en                       (cp0_fpu_icg_en                      ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .ex1_divisor                          (ex1_divisor                         ),
  .ex1_expnt_adder_op1                  (ex1_expnt_adder_op1                 ),
  .ex1_oper_id_frac                     (ex1_oper_id_frac                    ),
  .ex1_oper_id_frac_f                   (ex1_oper_id_frac_f                  ),
  .ex1_pipedown                         (ex1_pipedown                        ),
  .ex1_pipedown_gate                    (ex1_pipedown_gate                   ),
  .ex1_remainder                        (ex1_remainder                       ),
  .ex1_save_op0                         (ex1_save_op0                        ),
  .ex1_save_op0_gate                    (ex1_save_op0_gate                   ),
  .ex2_expnt_adder_op0                  (ex2_expnt_adder_op0                 ),
  .ex2_of                               (ex2_of                              ),
  .ex2_pipe_clk                         (ex2_pipe_clk                        ),
  .ex2_pipedown                         (ex2_pipedown                        ),
  .ex2_potnt_of                         (ex2_potnt_of                        ),
  .ex2_potnt_uf                         (ex2_potnt_uf                        ),
  .ex2_result_inf                       (ex2_result_inf                      ),
  .ex2_result_lfn                       (ex2_result_lfn                      ),
  .ex2_rslt_denorm                      (ex2_rslt_denorm                     ),
  .ex2_srt_expnt_rst                    (ex2_srt_expnt_rst                   ),
  .ex2_srt_first_round                  (ex2_srt_first_round                 ),
  .ex2_uf                               (ex2_uf                              ),
  .ex2_uf_srt_skip                      (ex2_uf_srt_skip                     ),
  .ex3_frac_final_rst                   (ex3_frac_final_rst                  ),
  .ex3_pipedown                         (ex3_pipedown                        ),
  .fdsu_ex3_id_srt_skip                 (fdsu_ex3_id_srt_skip                ),
  .fdsu_ex3_rem_sign                    (fdsu_ex3_rem_sign                   ),
  .fdsu_ex3_rem_zero                    (fdsu_ex3_rem_zero                   ),
  .fdsu_ex3_result_denorm_round_add_num (fdsu_ex3_result_denorm_round_add_num),
  .fdsu_ex4_frac                        (fdsu_ex4_frac                       ),
  .fdsu_yy_div                          (fdsu_yy_div                         ),
  .fdsu_yy_of_rm_lfn                    (fdsu_yy_of_rm_lfn                   ),
  .fdsu_yy_op0_norm                     (fdsu_yy_op0_norm                    ),
  .fdsu_yy_op1_norm                     (fdsu_yy_op1_norm                    ),
  .fdsu_yy_sqrt                         (fdsu_yy_sqrt                        ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .pad_yy_icg_scan_en                   (pad_yy_icg_scan_en                  ),
  .srt_remainder_zero                   (srt_remainder_zero                  ),
  .srt_sm_on                            (srt_sm_on                           ),
  .total_qt_rt_30                       (total_qt_rt_30                      )
);

// &Instance("miv_rv32_pa_fdsu_round_single", "x_pa_fdsu_round"); @37
miv_rv32_pa_fdsu_round_single  x_pa_fdsu_round (
  .cp0_fpu_icg_en                       (cp0_fpu_icg_en                      ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .ex3_expnt_adjust_result              (ex3_expnt_adjust_result             ),
  .ex3_frac_final_rst                   (ex3_frac_final_rst                  ),
  .ex3_pipedown                         (ex3_pipedown                        ),
  .ex3_rslt_denorm                      (ex3_rslt_denorm                     ),
  .fdsu_ex3_id_srt_skip                 (fdsu_ex3_id_srt_skip                ),
  .fdsu_ex3_rem_sign                    (fdsu_ex3_rem_sign                   ),
  .fdsu_ex3_rem_zero                    (fdsu_ex3_rem_zero                   ),
  .fdsu_ex3_result_denorm_round_add_num (fdsu_ex3_result_denorm_round_add_num),
  .fdsu_ex4_denorm_to_tiny_frac         (fdsu_ex4_denorm_to_tiny_frac        ),
  .fdsu_ex4_nx                          (fdsu_ex4_nx                         ),
  .fdsu_ex4_potnt_norm                  (fdsu_ex4_potnt_norm                 ),
  .fdsu_ex4_result_nor                  (fdsu_ex4_result_nor                 ),
  .fdsu_yy_expnt_rst                    (fdsu_yy_expnt_rst                   ),
  .fdsu_yy_result_inf                   (fdsu_yy_result_inf                  ),
  .fdsu_yy_result_lfn                   (fdsu_yy_result_lfn                  ),
  .fdsu_yy_result_sign                  (fdsu_yy_result_sign                 ),
  .fdsu_yy_rm                           (fdsu_yy_rm                          ),
  .fdsu_yy_rslt_denorm                  (fdsu_yy_rslt_denorm                 ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .pad_yy_icg_scan_en                   (pad_yy_icg_scan_en                  ),
  .total_qt_rt_30                       (total_qt_rt_30                      )
);

// &Instance("miv_rv32_pa_fdsu_pack_single", "x_pa_fdsu_pack"); @38
miv_rv32_pa_fdsu_pack_single  x_pa_fdsu_pack (
  .fdsu_ex4_denorm_to_tiny_frac (fdsu_ex4_denorm_to_tiny_frac),
  .fdsu_ex4_frac                (fdsu_ex4_frac               ),
  .fdsu_ex4_nx                  (fdsu_ex4_nx                 ),
  .fdsu_ex4_potnt_norm          (fdsu_ex4_potnt_norm         ),
  .fdsu_ex4_result_nor          (fdsu_ex4_result_nor         ),
  .fdsu_frbus_data              (fdsu_frbus_data             ),
  .fdsu_frbus_fflags            (fdsu_frbus_fflags           ),
  .fdsu_frbus_freg              (fdsu_frbus_freg             ),
  .fdsu_yy_expnt_rst            (fdsu_yy_expnt_rst           ),
  .fdsu_yy_of                   (fdsu_yy_of                  ),
  .fdsu_yy_of_rm_lfn            (fdsu_yy_of_rm_lfn           ),
  .fdsu_yy_potnt_of             (fdsu_yy_potnt_of            ),
  .fdsu_yy_potnt_uf             (fdsu_yy_potnt_uf            ),
  .fdsu_yy_result_inf           (fdsu_yy_result_inf          ),
  .fdsu_yy_result_lfn           (fdsu_yy_result_lfn          ),
  .fdsu_yy_result_sign          (fdsu_yy_result_sign         ),
  .fdsu_yy_rslt_denorm          (fdsu_yy_rslt_denorm         ),
  .fdsu_yy_uf                   (fdsu_yy_uf                  ),
  .fdsu_yy_wb_freg              (fdsu_yy_wb_freg             )
);


// &Instance("miv_rv32_pa_fdsu_ctrl"); @41
miv_rv32_pa_fdsu_ctrl  x_pa_fdsu_ctrl (
  .cp0_fpu_icg_en          (cp0_fpu_icg_en         ),
  .cp0_yy_clk_en           (cp0_yy_clk_en          ),
  .cpurst_b                (cpurst_b               ),
  .ctrl_fdsu_ex1_sel       (ctrl_fdsu_ex1_sel      ),
  .ctrl_xx_ex1_cmplt_dp    (ctrl_xx_ex1_cmplt_dp   ),
  .ctrl_xx_ex1_inst_vld    (ctrl_xx_ex1_inst_vld   ),
  .ctrl_xx_ex1_stall       (ctrl_xx_ex1_stall      ),
  .ctrl_xx_ex1_warm_up     (ctrl_xx_ex1_warm_up    ),
  .ctrl_xx_ex2_warm_up     (ctrl_xx_ex2_warm_up    ),
  .ctrl_xx_ex3_warm_up     (ctrl_xx_ex3_warm_up    ),
  .ex1_div                 (ex1_div                ),
  .ex1_expnt_adder_op0     (ex1_expnt_adder_op0    ),
  .ex1_of_result_lfn       (ex1_of_result_lfn      ),
  .ex1_op0_id              (ex1_op0_id             ),
  .ex1_op0_norm            (ex1_op0_norm           ),
  .ex1_op1_id_vld          (ex1_op1_id_vld         ),
  .ex1_op1_norm            (ex1_op1_norm           ),
  .ex1_op1_sel             (ex1_op1_sel            ),
  .ex1_oper_id_expnt       (ex1_oper_id_expnt      ),
  .ex1_oper_id_expnt_f     (ex1_oper_id_expnt_f    ),
  .ex1_pipedown            (ex1_pipedown           ),
  .ex1_pipedown_gate       (ex1_pipedown_gate      ),
  .ex1_result_sign         (ex1_result_sign        ),
  .ex1_rm                  (ex1_rm                 ),
  .ex1_save_op0            (ex1_save_op0           ),
  .ex1_save_op0_gate       (ex1_save_op0_gate      ),
  .ex1_sqrt                (ex1_sqrt               ),
  .ex1_srt_skip            (ex1_srt_skip           ),
  .ex2_expnt_adder_op0     (ex2_expnt_adder_op0    ),
  .ex2_of                  (ex2_of                 ),
  .ex2_pipe_clk            (ex2_pipe_clk           ),
  .ex2_pipedown            (ex2_pipedown           ),
  .ex2_potnt_of            (ex2_potnt_of           ),
  .ex2_potnt_uf            (ex2_potnt_uf           ),
  .ex2_result_inf          (ex2_result_inf         ),
  .ex2_result_lfn          (ex2_result_lfn         ),
  .ex2_rslt_denorm         (ex2_rslt_denorm        ),
  .ex2_srt_expnt_rst       (ex2_srt_expnt_rst      ),
  .ex2_srt_first_round     (ex2_srt_first_round    ),
  .ex2_uf                  (ex2_uf                 ),
  .ex2_uf_srt_skip         (ex2_uf_srt_skip        ),
  .ex3_expnt_adjust_result (ex3_expnt_adjust_result),
  .ex3_pipedown            (ex3_pipedown           ),
  .ex3_rslt_denorm         (ex3_rslt_denorm        ),
  .fdsu_ex1_sel            (fdsu_ex1_sel           ),
  .fdsu_fpu_debug_info     (fdsu_fpu_debug_info    ),
  .fdsu_fpu_ex1_cmplt      (fdsu_fpu_ex1_cmplt     ),
  .fdsu_fpu_ex1_cmplt_dp   (fdsu_fpu_ex1_cmplt_dp  ),
  .fdsu_fpu_ex1_stall      (fdsu_fpu_ex1_stall     ),
  .fdsu_fpu_no_op          (fdsu_fpu_no_op         ),
  .fdsu_frbus_wb_vld       (fdsu_frbus_wb_vld      ),
  .fdsu_yy_div             (fdsu_yy_div            ),
  .fdsu_yy_expnt_rst       (fdsu_yy_expnt_rst      ),
  .fdsu_yy_of              (fdsu_yy_of             ),
  .fdsu_yy_of_rm_lfn       (fdsu_yy_of_rm_lfn      ),
  .fdsu_yy_op0_norm        (fdsu_yy_op0_norm       ),
  .fdsu_yy_op1_norm        (fdsu_yy_op1_norm       ),
  .fdsu_yy_potnt_of        (fdsu_yy_potnt_of       ),
  .fdsu_yy_potnt_uf        (fdsu_yy_potnt_uf       ),
  .fdsu_yy_result_inf      (fdsu_yy_result_inf     ),
  .fdsu_yy_result_lfn      (fdsu_yy_result_lfn     ),
  .fdsu_yy_result_sign     (fdsu_yy_result_sign    ),
  .fdsu_yy_rm              (fdsu_yy_rm             ),
  .fdsu_yy_rslt_denorm     (fdsu_yy_rslt_denorm    ),
  .fdsu_yy_sqrt            (fdsu_yy_sqrt           ),
  .fdsu_yy_uf              (fdsu_yy_uf             ),
  .fdsu_yy_wb_freg         (fdsu_yy_wb_freg        ),
  .forever_cpuclk          (forever_cpuclk         ),
  .frbus_fdsu_wb_grant     (frbus_fdsu_wb_grant    ),
  .idu_fpu_ex1_dst_freg    (idu_fpu_ex1_dst_freg   ),
  .idu_fpu_ex1_eu_sel      (idu_fpu_ex1_eu_sel     ),
  .pad_yy_icg_scan_en      (pad_yy_icg_scan_en     ),
  .rtu_xx_ex1_cancel       (rtu_xx_ex1_cancel      ),
  .rtu_xx_ex2_cancel       (rtu_xx_ex2_cancel      ),
  .rtu_yy_xx_async_flush   (rtu_yy_xx_async_flush  ),
  .rtu_yy_xx_flush         (rtu_yy_xx_flush        ),
  .srt_remainder_zero      (srt_remainder_zero     ),
  .srt_sm_on               (srt_sm_on              )
);



// &ModuleEnd; @44
endmodule



// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module miv_rv32_pa_fpu_dp(
  cp0_fpu_icg_en,
  cp0_fpu_xx_rm,
  cp0_yy_clk_en,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  dp_frbus_ex2_data,
  dp_frbus_ex2_fflags,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_norm,
  dp_xx_ex1_qnan,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  ex2_inst_wb,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign,
  forever_cpuclk,
  idu_fpu_ex1_eu_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_gateclk_vld,
  idu_fpu_ex1_rm,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1,
  idu_fpu_ex1_srcf2,
  pad_yy_icg_scan_en
);

input           cp0_fpu_icg_en;             
input   [2 :0]  cp0_fpu_xx_rm;              
input           cp0_yy_clk_en;              
input           ctrl_xx_ex1_inst_vld;       
input           ctrl_xx_ex1_stall;          
input           ctrl_xx_ex1_warm_up;
input   [4 :0]  fdsu_fpu_ex1_fflags;        
input   [7 :0]  fdsu_fpu_ex1_special_sel;   
input   [3 :0]  fdsu_fpu_ex1_special_sign;
input           forever_cpuclk;
input   [2 :0]  idu_fpu_ex1_eu_sel;         
input   [9 :0]  idu_fpu_ex1_func;           
input           idu_fpu_ex1_gateclk_vld;    
input   [2 :0]  idu_fpu_ex1_rm;             
input   [31:0]  idu_fpu_ex1_srcf0;          
input   [31:0]  idu_fpu_ex1_srcf1;          
input   [31:0]  idu_fpu_ex1_srcf2;          
input           pad_yy_icg_scan_en;         
output  [31:0]  dp_frbus_ex2_data;          
output  [4 :0]  dp_frbus_ex2_fflags;
output  [2 :0]  dp_xx_ex1_cnan;             
output  [2 :0]  dp_xx_ex1_id;               
output  [2 :0]  dp_xx_ex1_inf;              
output  [2 :0]  dp_xx_ex1_norm;             
output  [2 :0]  dp_xx_ex1_qnan;
output  [2 :0]  dp_xx_ex1_snan;
output  [2 :0]  dp_xx_ex1_zero;
output          ex2_inst_wb;                

reg     [4 :0]  ex1_fflags;                 
reg     [31:0]  ex1_special_data;           
reg     [8 :0]  ex1_special_sel;            
reg     [3 :0]  ex1_special_sign;           
reg     [4 :0]  ex2_fflags;
reg     [31:0]  ex2_result;
reg     [31:0]  ex2_special_data;           
reg     [6 :0]  ex2_special_sel;            
reg     [3 :0]  ex2_special_sign;

wire            cp0_fpu_icg_en;             
wire    [2 :0]  cp0_fpu_xx_rm;              
wire            cp0_yy_clk_en;              
wire            ctrl_xx_ex1_inst_vld;       
wire            ctrl_xx_ex1_stall;          
wire            ctrl_xx_ex1_warm_up;
wire    [31:0]  dp_frbus_ex2_data;          
wire    [4 :0]  dp_frbus_ex2_fflags;
wire    [2 :0]  dp_xx_ex1_cnan;             
wire    [2 :0]  dp_xx_ex1_id;               
wire    [2 :0]  dp_xx_ex1_inf;              
wire    [2 :0]  dp_xx_ex1_norm;             
wire    [2 :0]  dp_xx_ex1_qnan;
wire    [2 :0]  dp_xx_ex1_snan;
wire    [2 :0]  dp_xx_ex1_zero;
wire    [2 :0]  ex1_decode_rm;              
wire            ex1_double;                 
wire    [2 :0]  ex1_eu_sel;
wire    [9 :0]  ex1_func;                   
wire    [2 :0]  ex1_global_rm;              
wire    [2 :0]  ex1_rm;                     
wire            ex1_single;                 
wire    [31:0]  ex1_special_data_final;     
wire    [63:0]  ex1_src0;                   
wire    [63:0]  ex1_src1;                   
wire    [63:0]  ex1_src2;                   
wire            ex1_src2_vld;               
wire    [2 :0]  ex1_src_cnan;               
wire    [2 :0]  ex1_src_id;                 
wire    [2 :0]  ex1_src_inf;                
wire    [2 :0]  ex1_src_norm;               
wire    [2 :0]  ex1_src_qnan;               
wire    [2 :0]  ex1_src_snan;               
wire    [2 :0]  ex1_src_zero;               
wire            ex2_data_clk;               
wire            ex2_data_clk_en;            
wire            ex2_inst_wb;
wire    [4 :0]  fdsu_fpu_ex1_fflags;        
wire    [7 :0]  fdsu_fpu_ex1_special_sel;   
wire    [3 :0]  fdsu_fpu_ex1_special_sign;
wire            forever_cpuclk;
wire    [2 :0]  idu_fpu_ex1_eu_sel;         
wire    [9 :0]  idu_fpu_ex1_func;           
wire            idu_fpu_ex1_gateclk_vld;    
wire    [2 :0]  idu_fpu_ex1_rm;             
wire    [31:0]  idu_fpu_ex1_srcf0;          
wire    [31:0]  idu_fpu_ex1_srcf1;          
wire    [31:0]  idu_fpu_ex1_srcf2;          
wire            pad_yy_icg_scan_en;         


parameter DOUBLE_WIDTH =64;
parameter SINGLE_WIDTH =32;
parameter FUNC_WIDTH   =10;
//==========================================================
//                     EX1 special data path
//==========================================================
assign ex1_eu_sel[2:0]            = idu_fpu_ex1_eu_sel[2:0];  //3'h4
assign ex1_func[FUNC_WIDTH-1:0]   = idu_fpu_ex1_func[FUNC_WIDTH-1:0];
assign ex1_global_rm[2:0]         = cp0_fpu_xx_rm[2:0];
assign ex1_decode_rm[2:0]         = idu_fpu_ex1_rm[2:0];

assign ex1_rm[2:0]                = (ex1_decode_rm[2:0]==3'b111) 
                                  ?  ex1_global_rm[2:0] : ex1_decode_rm[2:0]; 

assign ex1_src2_vld               = idu_fpu_ex1_eu_sel[1] && ex1_func[0];

assign ex1_src0[DOUBLE_WIDTH-1:0] = { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf0[SINGLE_WIDTH-1:0]};
assign ex1_src1[DOUBLE_WIDTH-1:0] = { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf1[SINGLE_WIDTH-1:0]};
assign ex1_src2[DOUBLE_WIDTH-1:0] = ex1_src2_vld ? { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf2[SINGLE_WIDTH-1:0]}
                                                 : { {SINGLE_WIDTH{1'b1}},{SINGLE_WIDTH{1'b0}} };

assign ex1_double = 1'b0;
assign ex1_single = 1'b1;

//==========================================================
//                EX1 special src data judge
//==========================================================
miv_rv32_pa_fpu_src_type  x_pa_fpu_ex1_srcf0_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[0]),
  .src_id          (ex1_src_id[0]  ),
  .src_in          (ex1_src0       ),
  .src_inf         (ex1_src_inf[0] ),
  .src_norm        (ex1_src_norm[0]),
  .src_qnan        (ex1_src_qnan[0]),
  .src_snan        (ex1_src_snan[0]),
  .src_zero        (ex1_src_zero[0])
);

miv_rv32_pa_fpu_src_type  x_pa_fpu_ex1_srcf1_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[1]),
  .src_id          (ex1_src_id[1]  ),
  .src_in          (ex1_src1       ),
  .src_inf         (ex1_src_inf[1] ),
  .src_norm        (ex1_src_norm[1]),
  .src_qnan        (ex1_src_qnan[1]),
  .src_snan        (ex1_src_snan[1]),
  .src_zero        (ex1_src_zero[1])
);

miv_rv32_pa_fpu_src_type  x_pa_fpu_ex1_srcf2_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[2]),
  .src_id          (ex1_src_id[2]  ),
  .src_in          (ex1_src2       ),
  .src_inf         (ex1_src_inf[2] ),
  .src_norm        (ex1_src_norm[2]),
  .src_qnan        (ex1_src_qnan[2]),
  .src_snan        (ex1_src_snan[2]),
  .src_zero        (ex1_src_zero[2])
);

assign dp_xx_ex1_cnan[2:0] = ex1_src_cnan[2:0];
assign dp_xx_ex1_snan[2:0] = ex1_src_snan[2:0];
assign dp_xx_ex1_qnan[2:0] = ex1_src_qnan[2:0];
assign dp_xx_ex1_norm[2:0] = ex1_src_norm[2:0];
assign dp_xx_ex1_zero[2:0] = ex1_src_zero[2:0];
assign dp_xx_ex1_inf[2:0]  = ex1_src_inf[2:0];
assign dp_xx_ex1_id[2:0]   = ex1_src_id[2:0];

//==========================================================
//                EX1 special result judge
//==========================================================

always @( fdsu_fpu_ex1_special_sign[3:0]
       or fdsu_fpu_ex1_fflags[4:0]
       or ex1_eu_sel[2:0]
       or fdsu_fpu_ex1_special_sel[7:0])
begin
case(ex1_eu_sel[2:0])  //3'h4
   3'b100: begin//FDSU
         ex1_fflags[4:0]       = fdsu_fpu_ex1_fflags[4:0];
         ex1_special_sel[8:0]  ={1'b0,fdsu_fpu_ex1_special_sel[7:0]};
         ex1_special_sign[3:0] = fdsu_fpu_ex1_special_sign[3:0];
         end
default: begin//FDSU
         ex1_fflags[4:0]       = {5{1'b0}};
         ex1_special_sel[8:0]  = {9{1'b0}};
         ex1_special_sign[3:0] = {4{1'b0}};
         end
endcase
end

always @( ex1_special_sel[8:5]
       or ex1_src0[31:0]
       or ex1_src1[31:0]
       or ex1_src2[31:0])
begin
case(ex1_special_sel[8:5])
  4'b0001: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src0[SINGLE_WIDTH-1:0];
  4'b0010: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src1[SINGLE_WIDTH-1:0];
  4'b0100: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src2[SINGLE_WIDTH-1:0];
default  : ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src2[SINGLE_WIDTH-1:0];
endcase
end

assign ex1_special_data_final[SINGLE_WIDTH-1:0] = ex1_special_data[SINGLE_WIDTH-1:0];

//==========================================================
//                     EX1-EX2 data pipedown
//==========================================================
assign ex2_data_clk_en = idu_fpu_ex1_gateclk_vld || ctrl_xx_ex1_warm_up;

miv_rv32_gated_clk_cell  x_fpu_data_ex2_gated_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex2_data_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex2_data_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

always @(posedge ex2_data_clk)
begin
  if(ctrl_xx_ex1_inst_vld && !ctrl_xx_ex1_stall || ctrl_xx_ex1_warm_up)
  begin
    ex2_fflags[4:0]       <= ex1_fflags[4:0];
    ex2_special_sign[3:0] <= ex1_special_sign[3:0];
    ex2_special_sel[6:0]  <={ex1_special_sel[8],|ex1_special_sel[7:5],ex1_special_sel[4:0]};
    ex2_special_data[SINGLE_WIDTH-1:0] <= ex1_special_data_final[SINGLE_WIDTH-1:0];
  end
end

assign ex2_inst_wb = (|ex2_special_sel[6:0]);

always @( ex2_special_sel[6:0]
       or ex2_special_data[31:0]
       or ex2_special_sign[3:0])
begin
case(ex2_special_sel[6:0])
  7'b0000_001: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[0],ex2_special_data[SINGLE_WIDTH-2:0]};//src2
  7'b0000_010: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[1], {31{1'b0}} };//zero
  7'b0000_100: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[2], {8{1'b1}},{23{1'b0}} };//inf
  7'b0001_000: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[3], {7{1'b1}},1'b0,{23{1'b1}} };//lfn
  7'b0010_000: ex2_result[SINGLE_WIDTH-1:0]  = { 1'b0, {8{1'b1}},1'b1, {22{1'b0}} };//cnan
  7'b0100_000: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_data[31],{8{1'b1}}, 1'b1, ex2_special_data[21:0]};//propagate qnan
  7'b1000_000: ex2_result[SINGLE_WIDTH-1:0]  = ex2_special_data[SINGLE_WIDTH-1:0]; //ex1 falu special result
      default: ex2_result[SINGLE_WIDTH-1:0]  = {SINGLE_WIDTH{1'b0}};
endcase
end

assign dp_frbus_ex2_data[SINGLE_WIDTH-1:0]  = ex2_result[SINGLE_WIDTH-1:0];
assign dp_frbus_ex2_fflags[4:0] = ex2_fflags[4:0];

endmodule




// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module miv_rv32_pa_fpu_frbus(
  ctrl_frbus_ex2_wb_req,
  dp_frbus_ex2_data,
  dp_frbus_ex2_fflags,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_wb_vld,
  fpu_idu_fwd_data,
  fpu_idu_fwd_fflags,
  fpu_idu_fwd_vld
);

input           ctrl_frbus_ex2_wb_req;
input   [31:0]  dp_frbus_ex2_data;        
input   [4 :0]  dp_frbus_ex2_fflags;
input   [31:0]  fdsu_frbus_data;          
input   [4 :0]  fdsu_frbus_fflags;
input           fdsu_frbus_wb_vld;
output  [31:0]  fpu_idu_fwd_data;
output  [4 :0]  fpu_idu_fwd_fflags;
output          fpu_idu_fwd_vld;

reg     [31:0]  frbus_wb_data;            
reg     [4 :0]  frbus_wb_fflags;

wire            ctrl_frbus_ex2_wb_req;
wire    [31:0]  fdsu_frbus_data;          
wire    [4 :0]  fdsu_frbus_fflags;
wire            fdsu_frbus_wb_vld;
wire    [31:0]  fpu_idu_fwd_data;
wire    [4 :0]  fpu_idu_fwd_fflags;
wire            fpu_idu_fwd_vld;
wire            frbus_ex2_wb_vld;
wire            frbus_fdsu_wb_vld;
wire            frbus_wb_vld;
wire    [3 :0]  frbus_source_vld;


//==========================================================
//                   Input Signal Rename
//==========================================================
assign frbus_fdsu_wb_vld = fdsu_frbus_wb_vld;
assign frbus_ex2_wb_vld  = ctrl_frbus_ex2_wb_req;
assign frbus_source_vld[3:0]     = {1'b0, 1'b0, frbus_ex2_wb_vld, frbus_fdsu_wb_vld};
assign frbus_wb_vld = frbus_ex2_wb_vld | frbus_fdsu_wb_vld;

always @( frbus_source_vld[3:0]
       or fdsu_frbus_data[31:0]
       or dp_frbus_ex2_data[31:0]
       or fdsu_frbus_fflags[4:0]
       or dp_frbus_ex2_fflags[4:0])
begin
  case(frbus_source_vld[3:0])
    4'b0001: begin // DIV
      frbus_wb_data[31:0] = fdsu_frbus_data[31:0];
      frbus_wb_fflags[4:0]    = fdsu_frbus_fflags[4:0];
    end
    4'b0010: begin // EX2
      frbus_wb_data[31:0] = dp_frbus_ex2_data[31:0];
      frbus_wb_fflags[4:0]    = dp_frbus_ex2_fflags[4:0];
    end
    default: begin
      frbus_wb_data[31:0] = {31{1'b0}};
      frbus_wb_fflags[4:0]    = 5'b0;
    end
  endcase
end

assign fpu_idu_fwd_vld            = frbus_wb_vld;
assign fpu_idu_fwd_fflags[4:0]    = frbus_wb_fflags[4:0];
assign fpu_idu_fwd_data[31:0] = frbus_wb_data[31:0];

endmodule



// Copyright (c) 2023, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2023, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module miv_rv32_pa_fpu_src_type(
  inst_double,
  inst_single,
  src_cnan,
  src_id,
  src_in,
  src_inf,
  src_norm,
  src_qnan,
  src_snan,
  src_zero
);

// &Ports; @25
input           inst_double;  
input           inst_single;  
input   [63:0]  src_in;       
output          src_cnan;     
output          src_id;       
output          src_inf;      
output          src_norm;     
output          src_qnan;     
output          src_snan;     
output          src_zero;     

// &Regs; @26

// &Wires; @27
wire            inst_double;  
wire            inst_single;  
wire    [63:0]  src;          
wire            src_cnan;     
wire            src_expn_max; 
wire            src_expn_zero; 
wire            src_frac_msb; 
wire            src_frac_zero; 
wire            src_id;       
wire    [63:0]  src_in;       
wire            src_inf;      
wire            src_norm;     
wire            src_qnan;     
wire            src_snan;     
wire            src_zero;     


// &Depend("cpu_cfig.h"); @29
assign src[63:0] = src_in[63:0];

assign src_cnan  = !(&src[63:32]) && inst_single;

assign src_expn_zero = !(|src[62:52]) && inst_double ||
                       !(|src[30:23]) && inst_single;

assign src_expn_max  =  (&src[62:52]) && inst_double ||
                        (&src[30:23]) && inst_single;

assign src_frac_zero = !(|src[51:0]) && inst_double ||
                       !(|src[22:0]) && inst_single;

assign src_frac_msb  = src[51] && inst_double || src[22] && inst_single;

assign src_snan = src_expn_max  && !src_frac_msb && !src_frac_zero && !src_cnan;
assign src_qnan = src_expn_max  &&  src_frac_msb || src_cnan;
assign src_zero = src_expn_zero &&  src_frac_zero && !src_cnan;
assign src_id   = src_expn_zero && !src_frac_zero && !src_cnan;
assign src_inf  = src_expn_max  &&  src_frac_zero && !src_cnan;
assign src_norm =!(src_expn_zero && src_frac_zero) &&
                 ! src_expn_max  && !src_cnan;

// &Force("output","src_cnan"); @53

// &ModuleEnd; @55
endmodule




